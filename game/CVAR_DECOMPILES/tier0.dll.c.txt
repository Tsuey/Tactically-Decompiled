#include "tier0.dll.h"



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_10001040(void)

{
  _DAT_100481ec =
       LoggingSystem_RegisterLoggingChannel((byte *)"LOADING",(undefined *)0x0,0,0,DAT_100481e8);
  return;
}



void FUN_10001070(void)

{
  FUN_10007220((FARPROC *)&DAT_10048330);
  FUN_1002050a(FUN_10035100);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_10001090(void)

{
  undefined *puVar1;
  double in_XMM0_Qa;
  
  puVar1 = GetCPUInformation();
  _g_ClockSpeed = *(undefined4 *)(puVar1 + 8);
  _DAT_1004838c = *(uint *)(puVar1 + 0xc);
  _g_dwClockSpeed = _g_ClockSpeed;
  FUN_10001a1e(_g_ClockSpeed,_DAT_1004838c);
  _g_ClockSpeedSecondsMultiplier = 1.0 / in_XMM0_Qa;
  _g_ClockSpeedMicrosecondsMultiplier = _g_ClockSpeedSecondsMultiplier * 1000000.0;
  g_ClockSpeedMillisecondsMultiplier = _g_ClockSpeedSecondsMultiplier * 1000.0;
  return;
}



void FUN_100010f0(void)

{
  int iVar1;
  
  iVar1 = DAT_100483c0;
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  DAT_100483cc = FUN_100089e0(DAT_100483bc,(byte *)"Assert",(undefined *)0x0,0,0,iVar1);
  return;
}



void FUN_10001150(void)

{
  int iVar1;
  
  iVar1 = DAT_100483c0;
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  DAT_100483d8 = FUN_100089e0(DAT_100483bc,(byte *)"Console",FUN_10008be0,1,3,iVar1);
  return;
}



void FUN_100011c0(void)

{
  int iVar1;
  
  iVar1 = DAT_100483c0;
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  DAT_100483dc = FUN_100089e0(DAT_100483bc,(byte *)"Developer",FUN_10008c10,1,3,iVar1);
  return;
}



void FUN_10001230(void)

{
  int iVar1;
  
  iVar1 = DAT_100483c0;
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  DAT_100483d4 = FUN_100089e0(DAT_100483bc,(byte *)"DeveloperConsole",FUN_10008bf0,1,3,iVar1);
  return;
}



void FUN_100012a0(void)

{
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  DAT_100483d0 = FUN_100089e0(DAT_100483bc,(byte *)"DeveloperVerbose",FUN_10008c20,1,3,-0x3f7f40);
  return;
}



void FUN_10001310(void)

{
  int iVar1;
  
  iVar1 = DAT_100483c0;
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  DAT_100483c4 = FUN_100089e0(DAT_100483bc,(byte *)"General",(undefined *)0x0,0,0,iVar1);
  return;
}



void FUN_10001370(void)

{
  GenericThreadLocals::CThreadLocalBase::CThreadLocalBase((CThreadLocalBase *)&DAT_100483c8);
  FUN_1002050a(FUN_10035140);
  return;
}



void FUN_10001390(void)

{
  FUN_1000acf0((int)&DAT_102f2d88);
  FUN_1002050a(FUN_10035180);
  return;
}



void FUN_100013b0(void)

{
  FUN_1000acf0((int)&DAT_10052d60);
  FUN_1002050a(FUN_100351b0);
  return;
}



void FUN_100013d0(void)

{
  FUN_1000acf0((int)&DAT_10592db0);
  FUN_1002050a(FUN_100351e0);
  return;
}



void FUN_100013f0(void)

{
  if (DAT_10832dd8 == '\0') {
    DAT_10832ddc = FUN_1001d980(0,1);
  }
  else {
    DAT_10832ddc = (uint *)0x0;
  }
  if (DAT_10832dd8 != '\0') {
    DAT_10832de0 = (uint *)0x0;
    return;
  }
  DAT_10832de0 = FUN_1001d980(0x2000000,1);
  return;
}



void FUN_10001440(void)

{
  FUN_1000ac40(&DAT_10050148);
  FUN_1002050a(FUN_10035210);
  return;
}



void FUN_10001460(void)

{
  CThreadMutex::CThreadMutex((CThreadMutex *)&DAT_10052d30);
  FUN_1002050a(FUN_10035220);
  return;
}



void FUN_10001480(void)

{
  GenericThreadLocals::CThreadLocalBase::Set((CThreadLocalBase *)&DAT_10833b5c,&DAT_10833b60);
  FUN_1002050a(FUN_10035230);
  return;
}



void FUN_100014a0(void)

{
  GenericThreadLocals::CThreadLocalBase::CThreadLocalBase((CThreadLocalBase *)&DAT_10833b5c);
  FUN_1002050a(FUN_10035240);
  return;
}



void FUN_100014c0(void)

{
  CPerfStatsData::CPerfStatsData((CPerfStatsData *)&g_PerfStats);
  return;
}



void FUN_100014d0(void)

{
  InitializeCriticalSection((LPCRITICAL_SECTION)&DAT_10833c48);
  return;
}



void FUN_100014e0(void)

{
  FUN_1002050a(FUN_10035250);
  return;
}



void FUN_100014f0(void)

{
  FUN_1002050a(FUN_10035260);
  return;
}



void FUN_10001500(void)

{
  FUN_1002050a(FUN_10035270);
  return;
}



void FUN_10001510(void)

{
  GenericThreadLocals::CThreadLocalBase::CThreadLocalBase((CThreadLocalBase *)&DAT_10833d10);
  FUN_1002050a(FUN_10035280);
  return;
}



void FUN_10001530(void)

{
  FUN_1002050a(FUN_10035290);
  return;
}



void FUN_10001540(void)

{
  DAT_10833d70 = VoidFnPtrLookup_Tier0((byte *)"Kernel32.dll","TryEnterCriticalSection");
  return;
}



void FUN_10001560(void)

{
  InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)&DAT_10833d50,4000);
  DAT_10833d6c = 0;
  DAT_10833d68 = 0;
  DAT_10833d6e = 0;
  FUN_1002050a(FUN_10035310);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_10001590(void)

{
  ThreadSetDebugName((HANDLE)0x0,"MainThrd");
  _DAT_10833d74 = GetCurrentThreadId();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_100015b0(void)

{
  _g_nThreadID = TlsAlloc();
  if (_g_nThreadID == 0xffffffff) {
    Error((byte *)"Out of thread local storage!\n");
  }
  FUN_1002050a(FUN_10035320);
  return;
}



void FUN_100015e0(void)

{
  DAT_10833d3c = TlsAlloc();
  if (DAT_10833d3c == 0xffffffff) {
    Error((byte *)"Out of thread local storage!\n");
  }
  FUN_1002050a(FUN_10035340);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_10001610(void)

{
  code *pcVar1;
  
  if (false) {
    Error((byte *)"CTSListBase: Misaligned list\n");
    pcVar1 = (code *)swi(3);
    (*pcVar1)();
    return;
  }
  _DAT_10833e30 = 0;
  FUN_1002050a(FUN_10035360);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_10001640(void)

{
  code *pcVar1;
  
  if (false) {
    Error((byte *)"CTSListBase: Misaligned list\n");
    pcVar1 = (code *)swi(3);
    (*pcVar1)();
    return;
  }
  _DAT_10833e28 = 0;
  FUN_1002050a(FUN_10035370);
  return;
}



void FUN_10001670(void)

{
  FUN_10016380(&DAT_10833e48);
  FUN_1002050a(FUN_100353b0);
  return;
}



void FUN_10001690(void)

{
  FUN_1002050a(FUN_100353e0);
  return;
}



void FUN_100016a0(void)

{
  DAT_10833ee8 = FUN_1001b250();
  FUN_1002050a(FUN_10035440);
  return;
}



void FUN_100016c0(void)

{
  DAT_108358d0 = FUN_1001b1c0();
  FUN_1002050a(FUN_100354c0);
  return;
}



void FUN_100016e0(void)

{
  CVProfile::CVProfile((CVProfile *)&g_VProfCurrentProfile);
  FUN_1002050a(FUN_10035540);
  return;
}



void FUN_100016f6(void)

{
  FUN_10034e18(&DAT_10836a40);
  FUN_1002050a(FUN_10035554);
  return;
}



// Library Function - Single Match
//  __ftol3_except
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release, Visual Studio 2017 Debug, Visual
// Studio 2017 Release

void __fastcall __ftol3_except(undefined4 param_1,uint param_2)

{
  ushort in_FPUControlWord;
  undefined8 in_XMM0_Qa;
  
  if ((param_2 == 8) ||
     ((*(byte *)((int)&DAT_100363f8 + param_2 + 7) & (byte)in_FPUControlWord) == 0)) {
    __except1(param_2,0,in_XMM0_Qa,(double)in_XMM0_Qa,(uint)in_FPUControlWord);
  }
  return;
}



ulonglong FUN_100018f1(void)

{
  int extraout_ECX;
  int iVar1;
  undefined4 extraout_ECX_00;
  int extraout_ECX_01;
  undefined4 extraout_ECX_02;
  int extraout_ECX_03;
  undefined4 extraout_ECX_04;
  int extraout_ECX_05;
  int extraout_ECX_06;
  ushort in_FPUControlWord;
  double in_XMM0_Qa;
  undefined8 in_XMM0_Qb;
  int iVar2;
  ulonglong uVar3;
  undefined auVar4 [16];
  undefined auVar5 [16];
  double dVar6;
  longlong lVar7;
  double dVar8;
  ulonglong uVar9;
  
  iVar1 = 1;
  dVar8 = 9.223372036854776e+18;
  dVar6 = 9.223372036854776e+18;
  if (0x7fefffff < ((uint)((ulonglong)in_XMM0_Qa >> 0x20) & 0x7fffffff)) {
LAB_1000189b:
    __ftol3_except(iVar1,8);
    return 0x8000000000000000;
  }
  if (true) {
    if ((false) && (1.547425049106725e+26 < in_XMM0_Qa)) {
      dVar6 = 9.223372036854776e+18;
      __ftol3_except(1,0x10);
      iVar1 = extraout_ECX;
    }
    if ((dVar6 <= in_XMM0_Qa) || (in_XMM0_Qa < -9.223372036854776e+18)) goto LAB_1000189b;
    auVar4 = CONCAT88(in_XMM0_Qb,in_XMM0_Qa) & (undefined  [16])0xffffffffffffffff;
    if ((iVar1 != 1) &&
       ((((double)((ulonglong)in_XMM0_Qa & 0x7fffffffffffffff) <= 1.175494315789826e-38 &&
         ((double)((ulonglong)in_XMM0_Qa & 0x7fffffffffffffff) != 0.0)) &&
        ((in_FPUControlWord & 0x10) == 0)))) {
      __ftol3_except(iVar1,2);
      return 0x8000000000000000;
    }
  }
  else {
    auVar4 = CONCAT88(in_XMM0_Qb,in_XMM0_Qa) & (undefined  [16])0xffffffffffffffff;
    if (3.402823567797337e+38 < (double)((ulonglong)in_XMM0_Qa & 0x7fffffffffffffff)) {
      dVar8 = 9.223372036854776e+18;
      if (false) {
        __ftol3_except(1,0x10);
        __ftol3_except(extraout_ECX_02,1);
        iVar1 = extraout_ECX_03;
      }
      else {
        __ftol3_except(1,1);
        __ftol3_except(extraout_ECX_00,0x10);
        iVar1 = extraout_ECX_01;
      }
    }
    if (1.175494315789826e-38 <= SUB168(auVar4,0)) {
      dVar6 = in_XMM0_Qa;
      if ((iVar1 == 4) && (9.223372036854776e+18 <= in_XMM0_Qa)) {
        dVar6 = in_XMM0_Qa - 9.223372036854776e+18;
      }
      if ((int)((ulonglong)((longlong)dVar6 << 0x23) >> 0x20) != 0) {
        __ftol3_except(iVar1,0x10);
        iVar1 = extraout_ECX_06;
      }
      if ((dVar8 <= in_XMM0_Qa) || (in_XMM0_Qa < -9.223372036854776e+18)) goto LAB_1000189b;
    }
    else if (SUB168(auVar4,0) != 0.0) {
      __ftol3_except(iVar1,2);
      __ftol3_except(extraout_ECX_04,0x10);
      iVar1 = extraout_ECX_05;
    }
  }
  uVar3 = 0;
  dVar6 = SUB168(auVar4,0);
  if (dVar6 != 0.0) {
    auVar5 = auVar4 & ZEXT816(0xfffffffffffff) | ZEXT816(0x10000000000000);
    lVar7 = SUB168(ZEXT416(0x433),0) - ((ulonglong)dVar6 >> 0x34);
    uVar9 = SUB168(auVar5,0) >> lVar7;
    iVar2 = -(uint)(0x433 < SUB164(auVar4 >> 0x20,0) >> 0x14);
    uVar3 = CONCAT44(iVar2,iVar2);
    uVar3 = ~uVar3 & uVar9 |
            SUB168(auVar5,0) << ((ulonglong)dVar6 >> 0x34) - SUB168(ZEXT416(0x433),0) & uVar3;
    uVar3 = ~-(ulonglong)(in_XMM0_Qa == dVar6) & -uVar3 | uVar3 & -(ulonglong)(in_XMM0_Qa == dVar6);
    if ((0 < (int)lVar7) &&
       (auVar5 = auVar5 ^ CONCAT88((SUB168(auVar5 >> 0x40,0) >> lVar7) << -SUB168(auVar4 >> 0x74,0),
                                   uVar9 << lVar7),
       (SUB164(auVar5,0) | SUB164(auVar5 >> 0x20,0)) != 0)) {
      __ftol3_except(iVar1,0x10);
    }
  }
  return uVar3;
}



ulonglong FUN_10001900(void)

{
  int extraout_ECX;
  int iVar1;
  undefined4 extraout_ECX_00;
  int extraout_ECX_01;
  undefined4 extraout_ECX_02;
  int extraout_ECX_03;
  undefined4 extraout_ECX_04;
  int extraout_ECX_05;
  int extraout_ECX_06;
  ushort in_FPUControlWord;
  double in_XMM0_Qa;
  undefined8 in_XMM0_Qb;
  int iVar2;
  ulonglong uVar3;
  undefined auVar4 [16];
  undefined auVar5 [16];
  double dVar6;
  longlong lVar7;
  double dVar8;
  ulonglong uVar9;
  
  iVar1 = 4;
  dVar8 = 1.844674407370955e+19;
  dVar6 = 1.844674407370955e+19;
  if (0x7fefffff < ((uint)((ulonglong)in_XMM0_Qa >> 0x20) & 0x7fffffff)) {
LAB_1000189b:
    __ftol3_except(iVar1,8);
    return 0x8000000000000000;
  }
  if (false) {
    if ((false) && (1.547425049106725e+26 < in_XMM0_Qa)) {
      dVar6 = 1.844674407370955e+19;
      __ftol3_except(4,0x10);
      iVar1 = extraout_ECX;
    }
    if ((dVar6 <= in_XMM0_Qa) || (in_XMM0_Qa < -9.223372036854776e+18)) goto LAB_1000189b;
    auVar4 = CONCAT88(in_XMM0_Qb,in_XMM0_Qa) & (undefined  [16])0xffffffffffffffff;
    if ((iVar1 != 1) &&
       ((((double)((ulonglong)in_XMM0_Qa & 0x7fffffffffffffff) <= 1.175494315789826e-38 &&
         ((double)((ulonglong)in_XMM0_Qa & 0x7fffffffffffffff) != 0.0)) &&
        ((in_FPUControlWord & 0x10) == 0)))) {
      __ftol3_except(iVar1,2);
      return 0x8000000000000000;
    }
  }
  else {
    auVar4 = CONCAT88(in_XMM0_Qb,in_XMM0_Qa) & (undefined  [16])0xffffffffffffffff;
    if (3.402823567797337e+38 < (double)((ulonglong)in_XMM0_Qa & 0x7fffffffffffffff)) {
      dVar8 = 1.844674407370955e+19;
      if (true) {
        __ftol3_except(4,0x10);
        __ftol3_except(extraout_ECX_02,1);
        iVar1 = extraout_ECX_03;
      }
      else {
        __ftol3_except(4,1);
        __ftol3_except(extraout_ECX_00,0x10);
        iVar1 = extraout_ECX_01;
      }
    }
    if (1.175494315789826e-38 <= SUB168(auVar4,0)) {
      dVar6 = in_XMM0_Qa;
      if ((iVar1 == 4) && (9.223372036854776e+18 <= in_XMM0_Qa)) {
        dVar6 = in_XMM0_Qa - 9.223372036854776e+18;
      }
      if ((int)((ulonglong)((longlong)dVar6 << 0x23) >> 0x20) != 0) {
        __ftol3_except(iVar1,0x10);
        iVar1 = extraout_ECX_06;
      }
      if ((dVar8 <= in_XMM0_Qa) || (in_XMM0_Qa < -9.223372036854776e+18)) goto LAB_1000189b;
    }
    else if (SUB168(auVar4,0) != 0.0) {
      __ftol3_except(iVar1,2);
      __ftol3_except(extraout_ECX_04,0x10);
      iVar1 = extraout_ECX_05;
    }
  }
  uVar3 = 0;
  dVar6 = SUB168(auVar4,0);
  if (dVar6 != 0.0) {
    auVar5 = auVar4 & ZEXT816(0xfffffffffffff) | ZEXT816(0x10000000000000);
    lVar7 = SUB168(ZEXT416(0x433),0) - ((ulonglong)dVar6 >> 0x34);
    uVar9 = SUB168(auVar5,0) >> lVar7;
    iVar2 = -(uint)(0x433 < SUB164(auVar4 >> 0x20,0) >> 0x14);
    uVar3 = CONCAT44(iVar2,iVar2);
    uVar3 = ~uVar3 & uVar9 |
            SUB168(auVar5,0) << ((ulonglong)dVar6 >> 0x34) - SUB168(ZEXT416(0x433),0) & uVar3;
    uVar3 = ~-(ulonglong)(in_XMM0_Qa == dVar6) & -uVar3 | uVar3 & -(ulonglong)(in_XMM0_Qa == dVar6);
    if ((0 < (int)lVar7) &&
       (auVar5 = auVar5 ^ CONCAT88((SUB168(auVar5 >> 0x40,0) >> lVar7) << -SUB168(auVar4 >> 0x74,0),
                                   uVar9 << lVar7),
       (SUB164(auVar5,0) | SUB164(auVar5 >> 0x20,0)) != 0)) {
      __ftol3_except(iVar1,0x10);
    }
  }
  return uVar3;
}



int __fastcall FUN_10001a1e(undefined4 param_1,uint param_2)

{
  int iVar1;
  int in_EAX;
  
  if (param_2 == 0) {
    return in_EAX;
  }
  iVar1 = 0x1f;
  if (param_2 != 0) {
    for (; param_2 >> iVar1 == 0; iVar1 = iVar1 + -1) {
    }
  }
  return 0x20 - iVar1;
}



uint __fastcall FUN_10001aaf(int param_1,uint param_2)

{
  int iVar1;
  uint uVar2;
  
  uVar2 = param_1 >> 0x1f;
  if (uVar2 == param_2) {
    return uVar2;
  }
  if ((int)param_2 < 0) {
    uVar2 = FUN_10001a1e(-param_1,-(param_2 + (param_1 != 0)));
    return uVar2;
  }
  if (param_2 == 0) {
    return uVar2;
  }
  iVar1 = 0x1f;
  if (param_2 != 0) {
    for (; param_2 >> iVar1 == 0; iVar1 = iVar1 + -1) {
    }
  }
  return 0x20 - iVar1;
}



// public: __thiscall CCallStackStorage::CCallStackStorage(class CCallStackStorage const &)

CCallStackStorage * __thiscall
CCallStackStorage::CCallStackStorage(CCallStackStorage *this,CCallStackStorage *param_1)

{
                    // 0x1ae0  3  ??0CCallStackStorage@@QAE@ABV0@@Z
  *(undefined4 *)(this + 0x200) = *(undefined4 *)(param_1 + 0x200);
  FID_conflict__memcpy(this,param_1,*(int *)(param_1 + 0x200) << 2);
  return this;
}



// public: __thiscall CThreadRWLock::CThreadRWLock(void)

CThreadRWLock * __thiscall CThreadRWLock::CThreadRWLock(CThreadRWLock *this)

{
                    // 0x1b10  18  ??0CThreadRWLock@@QAE@XZ
  *(undefined4 *)this = 0;
  *(undefined4 *)(this + 4) = 0;
  CThreadEvent::CThreadEvent((CThreadEvent *)(this + 8),false);
  CThreadEvent::CThreadEvent((CThreadEvent *)(this + 0x10),true);
  *(undefined4 *)(this + 0x18) = 0;
  *(undefined4 *)(this + 0x1c) = 0;
  *(undefined4 *)(this + 0x20) = 0;
  return this;
}



// public: __thiscall CThreadSpinRWLock::CThreadSpinRWLock(void)

CThreadSpinRWLock * __thiscall CThreadSpinRWLock::CThreadSpinRWLock(CThreadSpinRWLock *this)

{
                    // 0x1b50  20  ??0CThreadSpinRWLock@@QAE@XZ
  *(undefined4 *)this = 0;
  *(undefined4 *)(this + 4) = 0;
  return this;
}



// public: __thiscall CValidatableThread::CValidatableThread(void)

CValidatableThread * __thiscall CValidatableThread::CValidatableThread(CValidatableThread *this)

{
                    // 0x1b60  24  ??0CValidatableThread@@QAE@XZ
  CThread::CThread((CThread *)this);
  *(undefined ***)this = _vftable_;
  *(undefined2 *)(this + 0x68) = 0;
  return this;
}



// public: __thiscall CThreadEvent::~CThreadEvent(void)

void __thiscall CThreadEvent::_CThreadEvent(CThreadEvent *this)

{
                    // 0x1b80  33  ??1CThreadEvent@@QAE@XZ
                    // 0x1b80  34  ??1CThreadFullMutex@@QAE@XZ
                    // 0x1b80  38  ??1CThreadSemaphore@@QAE@XZ
  if ((*(HANDLE *)this != (HANDLE)0x0) && (this[4] != (CThreadEvent)0x0)) {
    CloseHandle(*(HANDLE *)this);
  }
  return;
}



// public: __thiscall CThreadRWLock::~CThreadRWLock(void)

void __thiscall CThreadRWLock::_CThreadRWLock(CThreadRWLock *this)

{
                    // 0x1b90  37  ??1CThreadRWLock@@QAE@XZ
  CThreadSyncObject::_CThreadSyncObject((CThreadSyncObject *)(this + 0x10));
  CThreadSyncObject::_CThreadSyncObject((CThreadSyncObject *)(this + 8));
  return;
}



// public: virtual __thiscall CValidatableThread::~CValidatableThread(void)

void __thiscall CValidatableThread::_CValidatableThread(CValidatableThread *this)

{
  BOOL BVar1;
  CValidatableThread *pCVar2;
  CValidatableThread *pCStack8;
  
                    // 0x1bb0  42  ??1CValidatableThread@@UAE@XZ
  *(undefined ***)this = CThread::_vftable_;
  pCStack8 = this;
  if (*(HANDLE *)(this + 0x2c) != (HANDLE)0x0) {
    BVar1 = GetExitCodeThread(*(HANDLE *)(this + 0x2c),(LPDWORD)&pCStack8);
    if ((BVar1 != 0) && (pCStack8 == (CValidatableThread *)0x103)) {
      Msg((byte *)
          "Illegal termination of worker thread! Threads must negotiate an end to the thread before the CThread object is destroyed.\n"
         );
      DoNewAssertDialog((byte *)
                        "d:\\projects\\ti\\release\\ti_rel\\src\\public\\tier0\\threadtools.inl",
                        0x30,
                        "Illegal termination of worker thread! Threads must negotiate an end to the thread before the CThread object is destroyed.\n"
                       );
      if (DAT_10833d3c == 0xffffffff) {
        pCVar2 = (CValidatableThread *)0x0;
      }
      else {
        pCVar2 = (CValidatableThread *)TlsGetValue(DAT_10833d3c);
      }
      if (pCVar2 == this) {
        CThread::Stop((CThread *)this,0);
      }
    }
  }
  if ((*(HANDLE *)(this + 0x60) != (HANDLE)0x0) && (this[100] != (CValidatableThread)0x0)) {
    CloseHandle(*(HANDLE *)(this + 0x60));
  }
  if ((*(HANDLE *)(this + 0x24) != (HANDLE)0x0) && (this[0x28] != (CValidatableThread)0x0)) {
    CloseHandle(*(HANDLE *)(this + 0x24));
  }
  DeleteCriticalSection((LPCRITICAL_SECTION)(this + 4));
  return;
}



// public: virtual __thiscall CWorkerThread::~CWorkerThread(void)

void __thiscall CWorkerThread::_CWorkerThread(CWorkerThread *this)

{
                    // 0x1bc0  43  ??1CWorkerThread@@UAE@XZ
  CThreadSyncObject::_CThreadSyncObject((CThreadSyncObject *)(this + 0x70));
  CThreadSyncObject::_CThreadSyncObject((CThreadSyncObject *)(this + 0x68));
  CThread::_CThread((CThread *)this);
  return;
}



// public: class CCallStackStorage & __thiscall CCallStackStorage::operator=(class CCallStackStorage
// const &)

CCallStackStorage * __thiscall
CCallStackStorage::operator_(CCallStackStorage *this,CCallStackStorage *param_1)

{
  int iVar1;
  undefined4 *puVar2;
  
                    // 0x1be0  45  ??4CCallStackStorage@@QAEAAV0@ABV0@@Z
  puVar2 = (undefined4 *)this;
  for (iVar1 = 0x81; iVar1 != 0; iVar1 = iVar1 + -1) {
    *puVar2 = *(undefined4 *)param_1;
    param_1 = (CCallStackStorage *)((int)param_1 + 4);
    puVar2 = puVar2 + 1;
  }
  return this;
}



// public: class CStackTop_Base & __thiscall CStackTop_Base::operator=(class CStackTop_Base const &)

CStackTop_Base * __thiscall CStackTop_Base::operator_(CStackTop_Base *this,CStackTop_Base *param_1)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  
                    // 0x1c00  47  ??4CStackTop_Base@@QAEAAV0@ABV0@@Z
                    // 0x1c00  48  ??4CStackTop_CopyParentStack@@QAEAAV0@ABV0@@Z
                    // 0x1c00  49  ??4CStackTop_ReferenceParentStack@@QAEAAV0@ABV0@@Z
  uVar1 = *(undefined4 *)(param_1 + 4);
  uVar2 = *(undefined4 *)(param_1 + 8);
  uVar3 = *(undefined4 *)(param_1 + 0xc);
  *(undefined4 *)this = *(undefined4 *)param_1;
  *(undefined4 *)(this + 4) = uVar1;
  *(undefined4 *)(this + 8) = uVar2;
  *(undefined4 *)(this + 0xc) = uVar3;
  *(undefined4 *)(this + 0x10) = *(undefined4 *)(param_1 + 0x10);
  return this;
}



// public: class GenericThreadLocals::CThreadLocalBase & __thiscall
// GenericThreadLocals::CThreadLocalBase::operator=(class GenericThreadLocals::CThreadLocalBase
// const &)

CThreadLocalBase * __thiscall
GenericThreadLocals::CThreadLocalBase::operator_(CThreadLocalBase *this,CThreadLocalBase *param_1)

{
                    // 0x1c20  52  ??4CThreadLocalBase@GenericThreadLocals@@QAEAAV01@ABV01@@Z
  *(undefined4 *)this = *(undefined4 *)param_1;
  return this;
}



// public: class CThreadSpinRWLock & __thiscall CThreadSpinRWLock::operator=(class CThreadSpinRWLock
// const &)

CThreadSpinRWLock * __thiscall
CThreadSpinRWLock::operator_(CThreadSpinRWLock *this,CThreadSpinRWLock *param_1)

{
                    // 0x1c30  53  ??4CThreadSpinRWLock@@QAEAAV0@ABV0@@Z
  *(undefined4 *)this = *(undefined4 *)param_1;
  *(undefined4 *)(this + 4) = *(undefined4 *)(param_1 + 4);
  return this;
}



// public: __thiscall CThreadSyncObject::operator void *(void)

void * __thiscall CThreadSyncObject::operator_void_(CThreadSyncObject *this)

{
                    // 0x1c50  58  ??BCThreadSyncObject@@QAEPAXXZ
                    // 0x1c50  123  ?GetHandle@CThreadSyncObject@@QBEQAXXZ
                    // 0x1c50  128  ?GetName@CVProfNode@@QAEPBDXZ
  return *(void **)this;
}



CThread * __thiscall FUN_10001c60(void *this,uint param_1)

{
  int iVar1;
  CThread *this_00;
  
  if ((param_1 & 2) != 0) {
    iVar1 = *(int *)((int)this + -4);
    this_00 = (CThread *)(iVar1 * 0x6c + (int)this);
    while (iVar1 = iVar1 + -1, -1 < iVar1) {
      this_00 = this_00 + -0x6c;
      CThread::_CThread(this_00);
    }
    if ((param_1 & 1) != 0) {
      FID_conflict__free((int *)((int)this + -4));
    }
    return (CThread *)((int)this + -4);
  }
  CThread::_CThread((CThread *)this);
  if ((param_1 & 1) != 0) {
    FID_conflict__free(this);
  }
  return (CThread *)this;
}



// public: void __thiscall CCallStackStorage::`default constructor closure'(void)

void __thiscall CCallStackStorage::_default_constructor_closure_(CCallStackStorage *this)

{
                    // 0x1cd0  66  ??_FCCallStackStorage@@QAEXXZ
  CCallStackStorage(this,GetCallStack,0);
  return;
}



// public: void __thiscall CStackTop_ReferenceParentStack::`default constructor closure'(void)

void __thiscall
CStackTop_ReferenceParentStack::_default_constructor_closure_(CStackTop_ReferenceParentStack *this)

{
                    // 0x1ce0  67  ??_FCStackTop_ReferenceParentStack@@QAEXXZ
  CStackTop_ReferenceParentStack(this,(void **)0x0,0);
  return;
}



// public: void __thiscall CThreadEvent::`default constructor closure'(void)

void __thiscall CThreadEvent::_default_constructor_closure_(CThreadEvent *this)

{
                    // 0x1cf0  68  ??_FCThreadEvent@@QAEXXZ
  CThreadEvent(this,false);
  return;
}



// public: void __thiscall CThreadFullMutex::`default constructor closure'(void)

void __thiscall CThreadFullMutex::_default_constructor_closure_(CThreadFullMutex *this)

{
                    // 0x1d00  69  ??_FCThreadFullMutex@@QAEXXZ
  CThreadFullMutex(this,false,(char *)0x0);
  return;
}



uint FUN_10001d10(void)

{
  undefined (*pauVar1) [16];
  uint uVar2;
  
  if ((DAT_10048038 & 1) == 0) {
    DAT_10048038 = DAT_10048038 | 1;
    pauVar1 = (undefined (*) [16])Plat_GetCommandLine();
    uVar2 = FUN_1001fc56(pauVar1,(undefined (*) [16])"-assertonce");
    DAT_10048034 = uVar2 != 0;
    return uVar2 & 0xffffff00 | (uint)(uVar2 != 0);
  }
  return DAT_10048038 & 0xffffff00 | (uint)DAT_10048034;
}



undefined4 __cdecl FUN_10001d50(byte *param_1,int param_2)

{
  byte *pbVar1;
  byte **ppbVar2;
  byte **in_EAX;
  uint uVar3;
  byte *_Memory;
  byte **local_8;
  
  local_8 = &DAT_10048000;
  _Memory = DAT_10048000;
  if (DAT_10048000 != (byte *)0x0) {
    do {
      pbVar1 = *(byte **)(_Memory + 0x20c);
      in_EAX = (byte **)FUN_1001f9b6(param_1,_Memory);
      ppbVar2 = (byte **)(_Memory + 0x20c);
      if (in_EAX == (byte **)0x0) {
        in_EAX = (byte **)0x1;
        if ((*(int *)(_Memory + 0x200) == -1) &&
           (in_EAX = (byte **)0x1, *(int *)(_Memory + 0x204) == -1)) {
          in_EAX = (byte **)0x0;
        }
        if (((*(int *)(_Memory + 0x200) <= param_2) && (param_2 <= *(int *)(_Memory + 0x204))) ||
           ((char)in_EAX == '\0')) {
          uVar3 = *(uint *)(_Memory + 0x208);
          if ((int)uVar3 < 1) {
LAB_10001def:
            return uVar3 & 0xffffff00;
          }
          uVar3 = uVar3 - 1;
          *(uint *)(_Memory + 0x208) = uVar3;
          if (uVar3 != 0) goto LAB_10001def;
          *local_8 = pbVar1;
          in_EAX = local_8;
          FID_conflict__free(_Memory);
          ppbVar2 = local_8;
        }
      }
      local_8 = ppbVar2;
      _Memory = pbVar1;
    } while (pbVar1 != (byte *)0x0);
  }
  return CONCAT31((int3)((uint)in_EAX >> 8),1);
}



undefined4 FUN_10001e00(HWND param_1,int param_2,uint param_3)

{
  UINT UVar1;
  int iVar2;
  HWND hWnd;
  tagRECT *lpRect;
  tagRECT local_24;
  tagRECT local_14;
  
  if (param_2 != 0x100) {
    if (param_2 == 0x110) {
      SetDlgItemTextA(param_1,0x3f3,DAT_10048010);
      SetDlgItemTextA(param_1,1000,DAT_10048008);
      SetDlgItemInt(param_1,0x3e9,DAT_1004800c,0);
      SetDlgItemInt(param_1,0x3ec,DAT_10046004,0);
      SetDlgItemInt(param_1,0x3f2,DAT_10046008,0);
      GetWindowRect(param_1,&local_14);
      lpRect = &local_24;
      hWnd = GetDesktopWindow();
      GetWindowRect(hWnd,lpRect);
      SetWindowPos(param_1,(HWND)0x0,
                   (((local_14.left - local_14.right) - local_24.left) + local_24.right) / 2,
                   (((local_14.top - local_14.bottom) - local_24.top) + local_24.bottom) / 2,0,0,1);
      return 1;
    }
    if (param_2 != 0x111) {
      return 0;
    }
    if (true) {
      switch(param_3 & 0xffff) {
      case 0x3ea:
        FUN_10002080();
        break;
      case 0x3eb:
        param_2 = 0;
        UVar1 = GetDlgItemInt(param_1,0x3ec,&param_2,0);
        if (param_2 == 0) {
          return 1;
        }
        if (UVar1 == 0) {
          return 1;
        }
        FUN_100020f0(UVar1);
        EndDialog(param_1,0);
        return 1;
      default:
        goto switchD_10001e40_caseD_3ec;
      case 0x3ed:
        param_2 = 0;
        UVar1 = GetDlgItemInt(param_1,0x3f2,&param_2,0);
        if ((param_2 != 0) && (1 < UVar1)) {
          iVar2 = FUN_100020f0(0);
          DAT_10046008 = UVar1;
          *(UINT *)(iVar2 + 0x208) = UVar1 - 1;
        }
        break;
      case 0x3ee:
        DAT_1004801c = 1;
        break;
      case 0x3f0:
        DAT_10046000 = 0;
        break;
      case 0x3f1:
        FUN_100020f0(0);
      }
      goto LAB_10001fd7;
    }
  }
switchD_10001e40_caseD_3ec:
  if (param_3 != 2) {
    return 1;
  }
LAB_10001fd7:
  EndDialog(param_1,0);
  return 1;
}



// public: bool __thiscall CThreadMutex::AssertOwnedByCurrentThread(void)

bool __thiscall CThreadMutex::AssertOwnedByCurrentThread(CThreadMutex *this)

{
  DWORD DVar1;
  
                    // 0x2010  73  ?AssertOwnedByCurrentThread@CThreadMutex@@QAE_NXZ
  DVar1 = GetCurrentThreadId();
  return DVar1 == *(DWORD *)(this + 0x18);
}



uint FUN_10002030(void)

{
  undefined (*pauVar1) [16];
  uint uVar2;
  
  if ((DAT_10048028 & 1) == 0) {
    DAT_10048028 = DAT_10048028 | 1;
    pauVar1 = (undefined (*) [16])Plat_GetCommandLine();
    uVar2 = FUN_1001fc56(pauVar1,(undefined (*) [16])"-assertstack");
    DAT_10048024 = uVar2 != 0;
    return uVar2 & 0xffffff00 | (uint)(uVar2 != 0);
  }
  return DAT_10048028 & 0xffffff00 | (uint)DAT_10048024;
}



// public: unsigned int __thiscall CThread::CalcStackDepth(void *)

uint __thiscall CThread::CalcStackDepth(CThread *this,void *param_1)

{
                    // 0x2070  80  ?CalcStackDepth@CThread@@QAEIPAX@Z
  return *(int *)(this + 0x58) - (int)param_1;
}



uint * FUN_10002080(void)

{
  byte *pbVar1;
  uint *puVar2;
  
  puVar2 = (uint *)FUN_1001f8b3(0x210);
  pbVar1 = DAT_10048008;
  puVar2[0x83] = (uint)DAT_10048000;
  DAT_10048000 = puVar2;
  puVar2[0x81] = 0xffffffff;
  puVar2[0x80] = 0xffffffff;
  puVar2[0x82] = 0xffffffff;
  FUN_1001fb78(puVar2,pbVar1,0x1ff);
  *(undefined *)((int)puVar2 + 0x1ff) = 0;
  return puVar2;
}



// protected: unsigned int const __thiscall CThread::GetThreadID(void)const 

uint __thiscall CThread::GetThreadID(CThread *this)

{
                    // 0x20e0  149  ?GetThreadID@CThread@@IBE?BIXZ
  return *(uint *)(this + 0x30);
}



void __cdecl FUN_100020f0(int param_1)

{
  uint *puVar1;
  uint uVar2;
  
  puVar1 = FUN_10002080();
  uVar2 = DAT_1004800c - param_1;
  puVar1[0x80] = uVar2;
  puVar1[0x81] = uVar2;
  return;
}



// public: bool __thiscall CThreadSpinRWLock::IsLockedForRead(void)

bool __thiscall CThreadSpinRWLock::IsLockedForRead(CThreadSpinRWLock *this)

{
                    // 0x2120  163  ?IsLockedForRead@CThreadSpinRWLock@@QAE_NXZ
  return *(short *)this != 0;
}



// public: bool __thiscall CThreadSpinRWLock::IsLockedForWrite(void)

bool __thiscall CThreadSpinRWLock::IsLockedForWrite(CThreadSpinRWLock *this)

{
                    // 0x2130  164  ?IsLockedForWrite@CThreadSpinRWLock@@QAE_NXZ
  return *(short *)(this + 2) == 1;
}



// public: bool __thiscall CThreadMutex::IsOwnedByCurrentThread_DebugOnly(void)

bool __thiscall CThreadMutex::IsOwnedByCurrentThread_DebugOnly(CThreadMutex *this)

{
  DWORD DVar1;
  
                    // 0x2140  165  ?IsOwnedByCurrentThread_DebugOnly@CThreadMutex@@QAE_NXZ
  DVar1 = GetCurrentThreadId();
  return DVar1 == *(DWORD *)(this + 0x18);
}



// public: bool __thiscall CThread::IsSuspended(void)

bool __thiscall CThread::IsSuspended(CThread *this)

{
  bool bVar1;
  
                    // 0x2160  166  ?IsSuspended@CThread@@QAE_NXZ
  bVar1 = CThreadEvent::Check((CThreadEvent *)(this + 0x60));
  return !bVar1;
}



// public: void __thiscall CThreadFullMutex::Lock(unsigned int)

void __thiscall CThreadFullMutex::Lock(CThreadFullMutex *this,uint param_1)

{
                    // 0x2180  170  ?Lock@CThreadFullMutex@@QAEXI@Z
  CThreadEvent::Wait((CThreadEvent *)this,param_1);
  return;
}



// public: void __thiscall CThreadFullMutex::Lock(void)

void __thiscall CThreadFullMutex::Lock(CThreadFullMutex *this)

{
                    // 0x2190  171  ?Lock@CThreadFullMutex@@QAEXXZ
  CThreadEvent::Wait((CThreadEvent *)this,0xffffffff);
  return;
}



// public: void __thiscall CThreadMutex::Lock(void)

void __thiscall CThreadMutex::Lock(CThreadMutex *this)

{
  DWORD DVar1;
  
                    // 0x21a0  172  ?Lock@CThreadMutex@@QAEXXZ
  DVar1 = GetCurrentThreadId();
  if (((this[0x1e] != (CThreadMutex)0x0) && (*(DWORD *)(this + 0x18) != 0)) &&
     (*(DWORD *)(this + 0x18) != DVar1)) {
    GetCurrentThreadId();
    Msg((byte *)"Thread %u about to wait for lock %p owned by %u\n");
  }
  EnterCriticalSection((LPCRITICAL_SECTION)this);
  if ((*(short *)(this + 0x1c) == 0) &&
     (*(DWORD *)(this + 0x18) = DVar1, this[0x1e] != (CThreadMutex)0x0)) {
    Msg((byte *)"Thread %u now owns lock 0x%p\n");
  }
  *(short *)(this + 0x1c) = *(short *)(this + 0x1c) + 1;
  return;
}



// public: void __thiscall CThreadMutex::Lock(void)const 

void __thiscall CThreadMutex::Lock(CThreadMutex *this)

{
  DWORD DVar1;
  
  DVar1 = GetCurrentThreadId();
  if (((this[0x1e] != (CThreadMutex)0x0) && (*(DWORD *)(this + 0x18) != 0)) &&
     (*(DWORD *)(this + 0x18) != DVar1)) {
    GetCurrentThreadId();
    Msg((byte *)"Thread %u about to wait for lock %p owned by %u\n");
  }
  EnterCriticalSection((LPCRITICAL_SECTION)this);
  if ((*(short *)(this + 0x1c) == 0) &&
     (*(DWORD *)(this + 0x18) = DVar1, this[0x1e] != (CThreadMutex)0x0)) {
    Msg((byte *)"Thread %u now owns lock 0x%p\n");
  }
  *(short *)(this + 0x1c) = *(short *)(this + 0x1c) + 1;
  return;
}



// public: void __thiscall CThreadRWLock::LockForRead(void)

void __thiscall CThreadRWLock::LockForRead(CThreadRWLock *this)

{
  DWORD DVar1;
  int iVar2;
  
                    // 0x2210  174  ?LockForRead@CThreadRWLock@@QAEXXZ
                    // 0x2210  175  ?LockForRead@CThreadRWLock@@QBEXXZ
  DVar1 = GetCurrentThreadId();
  if (DVar1 != *(DWORD *)this) {
    iVar2 = 0;
    LOCK();
    if (*(int *)this == 0) {
      *(DWORD *)this = DVar1;
    }
    else {
      iVar2 = *(int *)this;
    }
    if (iVar2 != 0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)this,DVar1,0);
      goto LAB_1000223c;
    }
  }
  *(int *)(this + 4) = *(int *)(this + 4) + 1;
LAB_1000223c:
  if (*(int *)(this + 0x18) != 0) {
    WaitForRead(this);
  }
  *(int *)(this + 0x1c) = *(int *)(this + 0x1c) + 1;
  *(int *)(this + 4) = *(int *)(this + 4) + -1;
  if (*(int *)(this + 4) == 0) {
    *(undefined4 *)this = 0;
  }
  return;
}



// public: void __thiscall CThreadSpinRWLock::LockForRead(void)

void __thiscall CThreadSpinRWLock::LockForRead(CThreadSpinRWLock *this)

{
  uint uVar1;
  uint uVar2;
  
                    // 0x2260  176  ?LockForRead@CThreadSpinRWLock@@QAEXXZ
                    // 0x2260  177  ?LockForRead@CThreadSpinRWLock@@QBEXXZ
  if ((*(uint *)this & 0x10000) == 0) {
    uVar2 = *(uint *)this & 0xffff;
    LOCK();
    if (uVar2 == *(uint *)this) {
      *(uint *)this = uVar2 + 1;
      uVar1 = uVar2;
    }
    else {
      uVar1 = *(uint *)this;
    }
    if (uVar1 == uVar2) {
      return;
    }
  }
  SpinLockForRead(this);
  return;
}



// public: void __thiscall CThreadRWLock::LockForWrite(void)const 

void __thiscall CThreadRWLock::LockForWrite(CThreadRWLock *this)

{
  bool bVar1;
  DWORD DVar2;
  int iVar3;
  
                    // 0x2290  179  ?LockForWrite@CThreadRWLock@@QBEXXZ
  DVar2 = GetCurrentThreadId();
  if (DVar2 != *(DWORD *)this) {
    iVar3 = 0;
    LOCK();
    if (*(int *)this == 0) {
      *(DWORD *)this = DVar2;
    }
    else {
      iVar3 = *(int *)this;
    }
    if (iVar3 != 0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)this,DVar2,0);
      goto LAB_10014d2c;
    }
  }
  *(int *)(this + 4) = *(int *)(this + 4) + 1;
LAB_10014d2c:
  if ((*(int *)(this + 0x18) == 0) && (*(int *)(this + 0x1c) == 0)) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  *(int *)(this + 0x18) = *(int *)(this + 0x18) + 1;
  ResetEvent(*(HANDLE *)(this + 0x10));
  *(int *)(this + 4) = *(int *)(this + 4) + -1;
  if (*(int *)(this + 4) == 0) {
    *(undefined4 *)this = 0;
  }
  if (bVar1) {
    WaitForSingleObject(*(HANDLE *)(this + 8),0xffffffff);
  }
  return;
}



// public: void __thiscall CThreadSpinRWLock::LockForWrite(void)

void __thiscall CThreadSpinRWLock::LockForWrite(CThreadSpinRWLock *this)

{
  int iVar1;
  DWORD DVar2;
  
                    // 0x22a0  180  ?LockForWrite@CThreadSpinRWLock@@QAEXXZ
                    // 0x22a0  181  ?LockForWrite@CThreadSpinRWLock@@QBEXXZ
  if ((*(uint *)this & 0x10000) == 0) {
    iVar1 = 0;
    LOCK();
    if (*(int *)this == 0) {
      *(undefined4 *)this = 0x10000;
    }
    else {
      iVar1 = *(int *)this;
    }
    if (iVar1 == 0) {
      DVar2 = GetCurrentThreadId();
      *(DWORD *)(this + 4) = DVar2;
      return;
    }
  }
  SpinLockForWrite(this);
  return;
}



// public: void __thiscall CThreadMutex::LockSilent(void)

void __thiscall CThreadMutex::LockSilent(CThreadMutex *this)

{
                    // 0x22d0  182  ?LockSilent@CThreadMutex@@QAEXXZ
  EnterCriticalSection((LPCRITICAL_SECTION)this);
  return;
}



undefined4 FUN_100022e0(HWND param_1,HWND param_2)

{
  HWND hWnd;
  BOOL BVar1;
  
  hWnd = param_1;
  BVar1 = IsWindowVisible(param_1);
  if (BVar1 != 0) {
    GetWindowThreadProcessId(hWnd,(LPDWORD)&param_1);
    if (param_1 == param_2) {
      DAT_10048014 = hWnd;
      return 0;
    }
  }
  return 1;
}



// public: void __thiscall CThreadMutex::SetTrace(bool)

void __thiscall CThreadMutex::SetTrace(CThreadMutex *this,bool param_1)

{
                    // 0x2320  222  ?SetTrace@CThreadMutex@@QAEX_N@Z
  this[0x1e] = (CThreadMutex)param_1;
  return;
}



// public: bool __thiscall CThreadMutex::TryLock(void)const 

bool __thiscall CThreadMutex::TryLock(CThreadMutex *this)

{
  DWORD DVar1;
  int iVar2;
  
                    // 0x2330  240  ?TryLock@CThreadMutex@@QBE_NXZ
  DVar1 = GetCurrentThreadId();
  if (((this[0x1e] != (CThreadMutex)0x0) && (*(DWORD *)(this + 0x18) != 0)) &&
     (*(DWORD *)(this + 0x18) != DVar1)) {
    GetCurrentThreadId();
    Msg((byte *)"Thread %u about to try-wait for lock %p owned by %u\n");
  }
  if (DAT_10833d70 != (code *)0x0) {
    iVar2 = (*DAT_10833d70)(this);
    if (iVar2 != 0) {
      if ((*(short *)(this + 0x1c) == 0) &&
         (*(DWORD *)(this + 0x18) = DVar1, this[0x1e] != (CThreadMutex)0x0)) {
        Msg((byte *)"Thread %u now owns lock %p\n");
      }
      *(short *)(this + 0x1c) = *(short *)(this + 0x1c) + 1;
      return true;
    }
    return false;
  }
  Lock(this);
  return true;
}



// public: bool __thiscall CThreadSpinRWLock::TryLockForRead(void)

bool __thiscall CThreadSpinRWLock::TryLockForRead(CThreadSpinRWLock *this)

{
  uint uVar1;
  uint uVar2;
  
                    // 0x2340  241  ?TryLockForRead@CThreadSpinRWLock@@QAE_NXZ
                    // 0x2340  242  ?TryLockForRead@CThreadSpinRWLock@@QBE_NXZ
                    // 0x2340  243  ?TryLockForRead_UnforcedInline@CThreadSpinRWLock@@QAE_NXZ
  if ((*(uint *)this & 0x10000) == 0) {
    uVar2 = *(uint *)this & 0xffff;
    LOCK();
    if (uVar2 == *(uint *)this) {
      *(uint *)this = uVar2 + 1;
      uVar1 = uVar2;
    }
    else {
      uVar1 = *(uint *)this;
    }
    if (uVar1 == uVar2) {
      return true;
    }
  }
  return false;
}



// public: bool __thiscall CThreadSpinRWLock::TryLockForWrite(void)

bool __thiscall CThreadSpinRWLock::TryLockForWrite(CThreadSpinRWLock *this)

{
  int iVar1;
  DWORD DVar2;
  
                    // 0x2370  244  ?TryLockForWrite@CThreadSpinRWLock@@QAE_NXZ
                    // 0x2370  245  ?TryLockForWrite@CThreadSpinRWLock@@QBE_NXZ
                    // 0x2370  246  ?TryLockForWrite_UnforcedInline@CThreadSpinRWLock@@QAE_NXZ
  if ((*(uint *)this & 0x10000) == 0) {
    iVar1 = 0;
    LOCK();
    if (*(int *)this == 0) {
      *(undefined4 *)this = 0x10000;
    }
    else {
      iVar1 = *(int *)this;
    }
    if (iVar1 == 0) {
      DVar2 = GetCurrentThreadId();
      *(DWORD *)(this + 4) = DVar2;
      return true;
    }
  }
  return false;
}



// public: void __thiscall CThreadFullMutex::Unlock(void)

void __thiscall CThreadFullMutex::Unlock(CThreadFullMutex *this)

{
                    // 0x23a0  247  ?Unlock@CThreadFullMutex@@QAEXXZ
  ReleaseMutex(*(HANDLE *)this);
  return;
}



// public: void __thiscall CThreadMutex::Unlock(void)

void __thiscall CThreadMutex::Unlock(CThreadMutex *this)

{
  short *psVar1;
  
                    // 0x23b0  248  ?Unlock@CThreadMutex@@QAEXXZ
                    // 0x23b0  249  ?Unlock@CThreadMutex@@QBEXXZ
  psVar1 = (short *)(this + 0x1c);
  *psVar1 = *psVar1 + -1;
  if (*psVar1 == 0) {
    if (this[0x1e] != (CThreadMutex)0x0) {
      Msg((byte *)"Thread %u releasing lock 0x%p\n");
    }
    *(undefined4 *)(this + 0x18) = 0;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)this);
  return;
}



// public: void __thiscall CThreadRWLock::UnlockRead(void)

void __thiscall CThreadRWLock::UnlockRead(CThreadRWLock *this)

{
  int *piVar1;
  DWORD DVar2;
  int iVar3;
  
                    // 0x23f0  250  ?UnlockRead@CThreadRWLock@@QAEXXZ
                    // 0x23f0  251  ?UnlockRead@CThreadRWLock@@QBEXXZ
  DVar2 = GetCurrentThreadId();
  if (DVar2 != *(DWORD *)this) {
    iVar3 = 0;
    LOCK();
    if (*(int *)this == 0) {
      *(DWORD *)this = DVar2;
    }
    else {
      iVar3 = *(int *)this;
    }
    if (iVar3 != 0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)this,DVar2,0);
      goto LAB_1000241c;
    }
  }
  *(int *)(this + 4) = *(int *)(this + 4) + 1;
LAB_1000241c:
  piVar1 = (int *)(this + 0x1c);
  *piVar1 = *piVar1 + -1;
  if ((*piVar1 == 0) && (*(int *)(this + 0x18) != 0)) {
    CThreadEvent::Set((CThreadEvent *)(this + 8));
  }
  *(int *)(this + 4) = *(int *)(this + 4) + -1;
  if (*(int *)(this + 4) == 0) {
    *(undefined4 *)this = 0;
  }
  return;
}



// public: void __thiscall CThreadSpinRWLock::UnlockRead(void)

void __thiscall CThreadSpinRWLock::UnlockRead(CThreadSpinRWLock *this)

{
                    // 0x2440  252  ?UnlockRead@CThreadSpinRWLock@@QAEXXZ
                    // 0x2440  253  ?UnlockRead@CThreadSpinRWLock@@QBEXXZ
  LOCK();
  *(int *)this = *(int *)this + -1;
  return;
}



// public: void __thiscall CThreadMutex::UnlockSilent(void)

void __thiscall CThreadMutex::UnlockSilent(CThreadMutex *this)

{
                    // 0x2450  254  ?UnlockSilent@CThreadMutex@@QAEXXZ
  LeaveCriticalSection((LPCRITICAL_SECTION)this);
  return;
}



// public: void __thiscall CThreadRWLock::UnlockWrite(void)const 

void __thiscall CThreadRWLock::UnlockWrite(CThreadRWLock *this)

{
  int *piVar1;
  DWORD DVar2;
  int iVar3;
  HANDLE hEvent;
  
                    // 0x2460  256  ?UnlockWrite@CThreadRWLock@@QBEXXZ
  DVar2 = GetCurrentThreadId();
  if (DVar2 == *(DWORD *)this) {
LAB_10015939:
    *(int *)(this + 4) = *(int *)(this + 4) + 1;
  }
  else {
    iVar3 = 0;
    LOCK();
    if (*(int *)this == 0) {
      *(DWORD *)this = DVar2;
    }
    else {
      iVar3 = *(int *)this;
    }
    if (iVar3 == 0) goto LAB_10015939;
    CThreadFastMutex::Lock((CThreadFastMutex *)this,DVar2,0);
  }
  piVar1 = (int *)(this + 0x18);
  *piVar1 = *piVar1 + -1;
  if (*piVar1 == 0) {
    if (*(int *)(this + 0x20) == 0) goto LAB_10015955;
    hEvent = *(HANDLE *)(this + 0x10);
  }
  else {
    hEvent = *(HANDLE *)(this + 8);
  }
  SetEvent(hEvent);
LAB_10015955:
  *(int *)(this + 4) = *(int *)(this + 4) + -1;
  if (*(int *)(this + 4) == 0) {
    *(undefined4 *)this = 0;
  }
  return;
}



// public: void __thiscall CThreadSpinRWLock::UnlockWrite(void)

void __thiscall CThreadSpinRWLock::UnlockWrite(CThreadSpinRWLock *this)

{
                    // 0x2470  257  ?UnlockWrite@CThreadSpinRWLock@@QAEXXZ
                    // 0x2470  258  ?UnlockWrite@CThreadSpinRWLock@@QBEXXZ
  *(undefined4 *)(this + 4) = 0;
  *(undefined4 *)this = 0;
  return;
}



bool AreAllAssertsDisabled(void)

{
                    // 0x2480  280  AreAllAssertsDisabled
  return DAT_10046000 == '\0';
}



undefined4 FUN_10002490(undefined4 param_1)

{
  DAT_10048018 = param_1;
  return 1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint __cdecl DoNewAssertDialog(byte *param_1,int param_2,LPCSTR param_3)

{
  DWORD DVar1;
  DWORD DVar2;
  DWORD DVar3;
  undefined (*pauVar4) [16];
  uint uVar5;
  int iVar6;
  
                    // 0x24b0  298  DoNewAssertDialog
  if ((DAT_1004804c & 1) == 0) {
    DAT_1004804c = DAT_1004804c | 1;
    _DAT_10048048 = 0;
    DAT_10048044 = 0;
  }
  DVar2 = GetCurrentThreadId();
  if (DVar2 == DAT_10048044) {
LAB_1000250a:
    _DAT_10048048 = _DAT_10048048 + 1;
  }
  else {
    DVar3 = 0;
    LOCK();
    DVar1 = DVar2;
    if (DAT_10048044 != 0) {
      DVar3 = DAT_10048044;
      DVar1 = DAT_10048044;
    }
    DAT_10048044 = DVar1;
    if (DVar3 == 0) goto LAB_1000250a;
    CThreadFastMutex::Lock((CThreadFastMutex *)&DAT_10048044,DVar2,0);
  }
  if ((DAT_10048030 & 1) == 0) {
    DAT_10048030 = DAT_10048030 | 1;
    pauVar4 = (undefined (*) [16])Plat_GetCommandLine();
    uVar5 = FUN_1001fc56(pauVar4,(undefined (*) [16])"-noassert");
    DAT_1004802c = uVar5 != 0;
    uVar5 = uVar5 & 0xffffff00 | (uint)DAT_1004802c;
  }
  else {
    uVar5 = DAT_10048030 & 0xffffff00 | (uint)DAT_1004802c;
  }
  if (((char)uVar5 == '\0') && (DAT_1004801d == '\0')) {
    if ((DAT_10048020 & 1) == 0) {
      DAT_10048020 = DAT_10048020 | 1;
      pauVar4 = (undefined (*) [16])Plat_GetCommandLine();
      uVar5 = FUN_1001fc56(pauVar4,(undefined (*) [16])"-debugbreak");
      DAT_1004801e = uVar5 != 0;
      uVar5 = uVar5 & 0xffffff00 | (uint)DAT_1004801e;
    }
    else {
      uVar5 = DAT_10048020 & 0xffffff00 | (uint)DAT_1004801e;
    }
    if ((char)uVar5 != '\0') {
      uVar5 = CONCAT31((int3)(uVar5 >> 8),1);
      goto LAB_100025e9;
    }
    if ((DAT_10046000 != '\0') && (uVar5 = FUN_10001d50(param_1,param_2), (char)uVar5 != '\0')) {
      DAT_10048008 = param_1;
      DAT_1004800c = param_2;
      DAT_10048010 = param_3;
      uVar5 = FUN_10002030();
      if ((char)uVar5 == '\0') {
        uVar5 = FUN_10001d10();
        if ((char)uVar5 != '\0') {
          FUN_100020f0(0);
        }
        DAT_1004801c = 0;
        if ((DAT_10048018 == (HINSTANCE)0x0) || (uVar5 = ThreadInMainThread(), (char)uVar5 == '\0'))
        {
          iVar6 = MessageBoxA((HWND)0x0,param_3,"Assertion Failed",0x1006);
          if (iVar6 == 2) {
            uVar5 = FUN_100020f0(0);
            uVar5 = uVar5 & 0xffffff00 | (uint)DAT_1004801c;
          }
          else {
            uVar5 = (uint)DAT_1004801c;
            if (iVar6 == 0xb) {
              uVar5 = 1;
            }
            DAT_1004801c = (byte)uVar5;
          }
        }
        else {
          DAT_10048014 = (HWND)0x0;
          DVar2 = GetCurrentProcessId();
          EnumWindows(FUN_100022e0,DVar2);
          uVar5 = DialogBoxParamA(DAT_10048018,(LPCSTR)0x65,DAT_10048014,FUN_10001e00,0);
          uVar5 = uVar5 & 0xffffff00 | (uint)DAT_1004801c;
        }
        goto LAB_100025e9;
      }
      FUN_100020f0(0);
      uVar5 = Warning((byte *)
                      "%s (%d) : Assertion callstack...(NOT IMPLEMENTED IN NEW LOGGING SYSTEM.)\n");
    }
  }
  uVar5 = uVar5 & 0xffffff00;
LAB_100025e9:
  _DAT_10048048 = _DAT_10048048 + -1;
  if (_DAT_10048048 == 0) {
    DAT_10048044 = 0;
  }
  return uVar5;
}



bool IsAssertDialogDisabled(void)

{
                    // 0x26c0  349  IsAssertDialogDisabled
  return DAT_10046001 == '\0';
}



void __cdecl SetAllAssertsDisabled(char param_1)

{
                    // 0x26d0  441  SetAllAssertsDisabled
  DAT_10046000 = param_1 == '\0';
  return;
}



void __cdecl SetAssertDialogDisabled(char param_1)

{
                    // 0x26e0  442  SetAssertDialogDisabled
  DAT_10046001 = param_1 == '\0';
  return;
}



uint ShouldUseNewAssertDialog(void)

{
  undefined (*pauVar1) [16];
  uint uVar2;
  
                    // 0x26f0  453  ShouldUseNewAssertDialog
  if ((DAT_10048040 & 1) == 0) {
    DAT_10048040 = DAT_10048040 | 1;
    pauVar1 = (undefined (*) [16])Plat_GetCommandLine();
    uVar2 = FUN_1001fc56(pauVar1,(undefined (*) [16])"-mpi_worker");
    DAT_1004803c = uVar2 != 0;
    return uVar2 & 0xffffff00 | (uint)(uVar2 == 0);
  }
  return DAT_10048040 & 0xffffff00 | (uint)(DAT_1004803c == '\0');
}



void __fastcall FUN_10002730(undefined4 *param_1)

{
  void **ppvVar1;
  int iVar2;
  
  iVar2 = 0;
  *param_1 = CCommandLine::vftable;
  if (0 < (int)param_1[2]) {
    ppvVar1 = (void **)(param_1 + 3);
    do {
      FID_conflict__free(*ppvVar1);
      *ppvVar1 = (void *)0x0;
      ppvVar1 = ppvVar1 + 1;
      iVar2 = iVar2 + 1;
    } while (iVar2 < (int)param_1[2]);
  }
  param_1[2] = 0;
  FID_conflict__free((void *)param_1[1]);
  return;
}



undefined4 * __thiscall FUN_10002780(void *this,byte param_1)

{
  FUN_10002730((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    FID_conflict__free(this);
  }
  return (undefined4 *)this;
}



void __thiscall FUN_100027b0(void *this,void *param_1,void *param_2)

{
  undefined4 uVar1;
  size_t sVar2;
  
  if (param_2 != param_1) {
    if (0xff < *(int *)((int)this + 8)) {
      Error((byte *)"CCommandLine::AddArgument: exceeded %d parameters");
    }
    sVar2 = ((int)param_2 - (int)param_1) + 1;
    uVar1 = FUN_1001f8b3(sVar2);
    *(undefined4 *)((int)this + *(int *)((int)this + 8) * 4 + 0xc) = uVar1;
    FID_conflict__memcpy
              (*(void **)((int)this + *(int *)((int)this + 8) * 4 + 0xc),param_1,
               (int)param_2 - (int)param_1);
    *(undefined *)(*(int *)((int)this + *(int *)((int)this + 8) * 4 + 0xc) + -1 + sVar2) = 0;
    *(int *)((int)this + 8) = *(int *)((int)this + 8) + 1;
  }
  return;
}



void __thiscall FUN_10002820(void *this,undefined4 *param_1,undefined4 *param_2)

{
  char *pcVar1;
  char cVar2;
  uint *puVar3;
  uint uVar4;
  char *pcVar5;
  uint *puVar6;
  undefined4 *puVar7;
  undefined4 *puVar8;
  char *pcVar9;
  undefined2 *puVar10;
  undefined4 *puVar11;
  
  puVar8 = param_1;
  do {
    cVar2 = *(char *)puVar8;
    puVar8 = (undefined4 *)((int)puVar8 + 1);
  } while (cVar2 != '\0');
  pcVar9 = (char *)((int)puVar8 - ((int)param_1 + 1));
  if (param_2 != (undefined4 *)0x0) {
    puVar8 = param_2;
    do {
      cVar2 = *(char *)puVar8;
      puVar8 = (undefined4 *)((int)puVar8 + 1);
    } while (cVar2 != '\0');
    pcVar9 = (char *)((int)puVar8 + (int)(pcVar9 + (1 - ((int)param_2 + 1))));
  }
  if (*(int *)((int)this + 4) == 0) {
    pcVar9 = (char *)FUN_1001f8b3((size_t)(pcVar9 + 1));
    *(char **)((int)this + 4) = pcVar9;
    do {
      cVar2 = *(char *)param_1;
      param_1 = (undefined4 *)((int)param_1 + 1);
      *pcVar9 = cVar2;
      pcVar9 = pcVar9 + 1;
    } while (cVar2 != '\0');
    if (param_2 != (undefined4 *)0x0) {
      puVar10 = (undefined2 *)(*(int *)((int)this + 4) + -1);
      do {
        pcVar9 = (char *)((int)puVar10 + 1);
        puVar10 = (undefined2 *)((int)puVar10 + 1);
      } while (*pcVar9 != '\0');
      *puVar10 = 0x20;
      puVar8 = param_2;
      do {
        cVar2 = *(char *)puVar8;
        puVar8 = (undefined4 *)((int)puVar8 + 1);
      } while (cVar2 != '\0');
      puVar11 = (undefined4 *)(*(int *)((int)this + 4) + -1);
      do {
        pcVar9 = (char *)((int)puVar11 + 1);
        puVar11 = (undefined4 *)((int)puVar11 + 1);
      } while (*pcVar9 != '\0');
      puVar7 = param_2;
      for (uVar4 = (uint)((int)puVar8 - (int)param_2) >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
        *puVar11 = *puVar7;
        puVar7 = puVar7 + 1;
        puVar11 = puVar11 + 1;
      }
      for (uVar4 = (int)puVar8 - (int)param_2 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
        *(undefined *)puVar11 = *(undefined *)puVar7;
        puVar7 = (undefined4 *)((int)puVar7 + 1);
        puVar11 = (undefined4 *)((int)puVar11 + 1);
      }
    }
    FUN_10002ed0(this);
    return;
  }
                    // WARNING: Load size is inaccurate
  (**(code **)(*this + 0x14))(param_1);
  pcVar5 = *(char **)((int)this + 4);
  pcVar1 = pcVar5 + 1;
  do {
    cVar2 = *pcVar5;
    pcVar5 = pcVar5 + 1;
  } while (cVar2 != '\0');
  puVar3 = (uint *)FUN_1001f8b3((size_t)(pcVar5 + (int)(pcVar9 + 1 + (2 - (int)pcVar1))));
  FUN_10021290(puVar3,0,(uint)(pcVar5 + (int)(pcVar9 + 1 + (2 - (int)pcVar1))));
  pcVar9 = *(char **)((int)this + 4);
  puVar6 = puVar3;
  do {
    cVar2 = *pcVar9;
    pcVar9 = pcVar9 + 1;
    *(char *)puVar6 = cVar2;
    puVar6 = (uint *)((int)puVar6 + 1);
  } while (cVar2 != '\0');
  puVar10 = (undefined2 *)((int)puVar3 + -1);
  do {
    pcVar9 = (char *)((int)puVar10 + 1);
    puVar10 = (undefined2 *)((int)puVar10 + 1);
  } while (*pcVar9 != '\0');
  *puVar10 = 0x20;
  puVar8 = param_1;
  do {
    cVar2 = *(char *)puVar8;
    puVar8 = (undefined4 *)((int)puVar8 + 1);
  } while (cVar2 != '\0');
  puVar11 = (undefined4 *)((int)puVar3 + -1);
  do {
    pcVar9 = (char *)((int)puVar11 + 1);
    puVar11 = (undefined4 *)((int)puVar11 + 1);
  } while (*pcVar9 != '\0');
  puVar7 = param_1;
  for (uVar4 = (uint)((int)puVar8 - (int)param_1) >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
    *puVar11 = *puVar7;
    puVar7 = puVar7 + 1;
    puVar11 = puVar11 + 1;
  }
  for (uVar4 = (int)puVar8 - (int)param_1 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
    *(undefined *)puVar11 = *(undefined *)puVar7;
    puVar7 = (undefined4 *)((int)puVar7 + 1);
    puVar11 = (undefined4 *)((int)puVar11 + 1);
  }
  if (param_2 != (undefined4 *)0x0) {
    puVar10 = (undefined2 *)((int)puVar3 + -1);
    do {
      pcVar9 = (char *)((int)puVar10 + 1);
      puVar10 = (undefined2 *)((int)puVar10 + 1);
    } while (*pcVar9 != '\0');
    *puVar10 = 0x20;
    puVar8 = param_2;
    do {
      cVar2 = *(char *)puVar8;
      puVar8 = (undefined4 *)((int)puVar8 + 1);
    } while (cVar2 != '\0');
    puVar11 = (undefined4 *)((int)puVar3 + -1);
    do {
      pcVar9 = (char *)((int)puVar11 + 1);
      puVar11 = (undefined4 *)((int)puVar11 + 1);
    } while (*pcVar9 != '\0');
    puVar7 = param_2;
    for (uVar4 = (uint)((int)puVar8 - (int)param_2) >> 2; uVar4 != 0; uVar4 = uVar4 - 1) {
      *puVar11 = *puVar7;
      puVar7 = puVar7 + 1;
      puVar11 = puVar11 + 1;
    }
    for (uVar4 = (int)puVar8 - (int)param_2 & 3; uVar4 != 0; uVar4 = uVar4 - 1) {
      *(undefined *)puVar11 = *(undefined *)puVar7;
      puVar7 = (undefined4 *)((int)puVar7 + 1);
      puVar11 = (undefined4 *)((int)puVar11 + 1);
    }
  }
  FID_conflict__free(*(void **)((int)this + 4));
  *(uint **)((int)this + 4) = puVar3;
  FUN_10002ed0(this);
  return;
}



int __thiscall FUN_100029e0(void *this,undefined4 param_1,int *param_2)

{
  int iVar1;
  
  if (param_2 != (int *)0x0) {
    *param_2 = 0;
  }
                    // WARNING: Load size is inaccurate
  iVar1 = (**(code **)(*this + 0x2c))(param_1);
  if (iVar1 == 0) {
    return 0;
  }
  if (param_2 != (int *)0x0) {
    if (*(int *)((int)this + 8) <= iVar1 + 1) {
      *param_2 = 0;
      return *(int *)((int)this + iVar1 * 4 + 0xc);
    }
    *param_2 = *(int *)((int)this + iVar1 * 4 + 0x10);
  }
  return *(int *)((int)this + iVar1 * 4 + 0xc);
}



void __thiscall FUN_10002a40(void *this,int param_1,int param_2)

{
  int iVar1;
  char local_808 [2047];
  undefined local_9;
  int *local_8;
  
  iVar1 = 0;
  local_808[0] = '\0';
  local_9 = 0;
  local_8 = (int *)this;
  if (0 < param_1) {
    do {
      _strncat(local_808,"\"",0x7ff);
      _strncat(local_808,*(char **)(param_2 + iVar1 * 4),0x7ff);
      _strncat(local_808,"\"",0x7ff);
      _strncat(local_808,(char *)&DAT_100365d4,0x7ff);
      iVar1 = iVar1 + 1;
    } while (iVar1 < param_1);
  }
  (**(code **)(*local_8 + 4))(local_808);
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe

void __thiscall FUN_10002af0(void *this,byte *param_1)

{
  byte bVar1;
  char cVar2;
  uint uVar3;
  void *pvVar4;
  void *_Dst;
  uint uVar5;
  char *pcVar6;
  byte *pbVar7;
  bool bVar8;
  char local_1014 [4096];
  void *local_14;
  uint local_10;
  byte *local_c;
  char *local_8;
  
  local_8 = (char *)0x10002afd;
  local_14 = this;
  if (*(void **)((int)this + 4) != (void *)0x0) {
    FID_conflict__free(*(void **)((int)this + 4));
  }
  local_8 = local_1014;
  uVar5 = 0;
  local_10 = local_10 & 0xffffff00;
  pbVar7 = (byte *)0x0;
  bVar1 = *param_1;
  local_c = param_1;
  while (bVar1 != 0) {
    uVar3 = uVar5 & 0xffffff00;
    uVar5 = uVar3 | *local_c;
    if ((*local_c == 0x22) &&
       ((local_c == param_1 || ((local_c[-1] != 0x2f && (local_c[-1] != 0x5c)))))) {
      bVar8 = (char)(uVar3 >> 8) == '\0';
      pbVar7 = local_c + 1;
      uVar5 = (uint)CONCAT11(bVar8,0x22);
      local_10 = local_10 & 0xffffff00 | (uint)bVar8;
    }
    if ((char)uVar5 == '@') {
      if (local_c != param_1) {
        if ((char)(uVar5 >> 8) == '\0') {
          bVar1 = local_c[-1];
          if ((char)bVar1 < '\t') goto LAB_10002b9b;
          if ((char)bVar1 < '\x0e') goto LAB_10002b7a;
          bVar8 = bVar1 == 0x20;
        }
        else {
          bVar8 = local_c == pbVar7;
        }
        if (!bVar8) goto LAB_10002b9b;
      }
LAB_10002b7a:
      FUN_10002cb0((char **)&local_c,&local_8,(int)&local_14 - (int)local_8,(char)local_10);
    }
    else {
LAB_10002b9b:
      if (0xffe < (uint)((int)local_8 - (int)local_1014)) break;
      *local_8 = (char)uVar5;
      local_8 = local_8 + 1;
      local_c = local_c + 1;
    }
    bVar1 = *local_c;
  }
  pcVar6 = local_1014;
  *local_8 = '\0';
  do {
    cVar2 = *pcVar6;
    pcVar6 = pcVar6 + 1;
  } while (cVar2 != '\0');
  _Dst = (void *)FUN_1001f8b3((size_t)(pcVar6 + (1 - (int)(local_1014 + 1))));
  pvVar4 = local_14;
  *(void **)((int)local_14 + 4) = _Dst;
  FID_conflict__memcpy(_Dst,local_1014,(size_t)(pcVar6 + (1 - (int)(local_1014 + 1))));
  FUN_10002ed0(pvVar4);
  return;
}



int __thiscall FUN_10002c10(void *this,byte *param_1)

{
  uint uVar1;
  int iVar2;
  byte **ppbVar3;
  
  iVar2 = 1;
  if (1 < *(int *)((int)this + 8)) {
    ppbVar3 = (byte **)((int)this + 0x10);
    do {
      uVar1 = V_tier0_stricmp(param_1,*ppbVar3);
      if (uVar1 == 0) {
        return iVar2;
      }
      iVar2 = iVar2 + 1;
      ppbVar3 = ppbVar3 + 1;
    } while (iVar2 < *(int *)((int)this + 8));
  }
  return 0;
}



// public: virtual char const * __thiscall CTestCase::GetName(void)

char * __thiscall CTestCase::GetName(CTestCase *this)

{
                    // 0x2c60  125  ?GetName@CTestCase@@UAEPBDXZ
                    // 0x2c60  261  ?VTuneGroupID@CVProfile@@IAEHXZ
  return *(char **)(this + 4);
}



undefined1 * __thiscall FUN_10002c70(void *this,int param_1)

{
  if ((-1 < param_1) && (param_1 < *(int *)((int)this + 8))) {
    return *(undefined1 **)((int)this + param_1 * 4 + 0xc);
  }
  return &DAT_1003655d;
}



bool __thiscall FUN_10002c90(void *this,undefined4 param_1)

{
  int iVar1;
  
                    // WARNING: Load size is inaccurate
  iVar1 = (**(code **)(*this + 0x2c))(param_1);
  return iVar1 != 0;
}



void FUN_10002cb0(char **param_1,char **param_2,int param_3,char param_4)

{
  char *pcVar1;
  char cVar2;
  char *pcVar3;
  FILE *_File;
  uint uVar4;
  char *pcVar5;
  int iVar6;
  char local_108 [260];
  
  pcVar1 = *param_2;
  if (2 < param_3) {
    pcVar5 = local_108;
    cVar2 = ' ';
    *param_1 = *param_1 + 1;
    pcVar3 = *param_1;
    if (param_4 != '\0') {
      cVar2 = '\"';
    }
    if (*pcVar3 != '\0') {
      iVar6 = 0;
      while (*pcVar3 != cVar2) {
        *pcVar5 = *pcVar3;
        iVar6 = iVar6 + 1;
        pcVar3 = pcVar3 + 1;
        pcVar5 = pcVar5 + 1;
        *param_1 = pcVar3;
        if ((0x102 < iVar6) || (*pcVar3 == '\0')) break;
      }
    }
    pcVar3 = *param_1;
    *pcVar5 = '\0';
    if (*pcVar3 != '\0') {
      *param_1 = pcVar3 + 1;
    }
    _File = _fopen(local_108,"r");
    if (_File != (FILE *)0x0) {
      uVar4 = FUN_10020e54(_File);
      if ((char)uVar4 != -1) {
        do {
          cVar2 = (char)uVar4;
          if (cVar2 == '\n') {
            cVar2 = ' ';
          }
          **param_2 = cVar2;
          *param_2 = *param_2 + 1;
          if (param_3 + -2 <= (int)*param_2 - (int)pcVar1) break;
          uVar4 = FUN_10020e54(_File);
        } while ((char)uVar4 != -1);
      }
      **param_2 = ' ';
      *param_2 = *param_2 + 1;
      _fclose(_File);
      return;
    }
    FUN_1002103b((byte *)"Parameter file \'%s\' not found, skipping...");
  }
  return;
}



int __cdecl FUN_10002db0(char *param_1)

{
  char cVar1;
  int iVar2;
  int iVar3;
  char *pcVar4;
  
  if (param_1 != (char *)0x0) {
    pcVar4 = param_1;
    do {
      cVar1 = *pcVar4;
      pcVar4 = pcVar4 + 1;
    } while (cVar1 != '\0');
    iVar2 = (**(code **)(*(int *)g_pMemAlloc + 4))(pcVar4 + (1 - (int)(param_1 + 1)));
    if (iVar2 != 0) {
      iVar3 = iVar2 - (int)param_1;
      do {
        cVar1 = *param_1;
        param_1 = param_1 + 1;
        param_1[iVar3 + -1] = cVar1;
      } while (cVar1 != '\0');
      return iVar2;
    }
  }
  return 0;
}



undefined4 __fastcall FUN_10002e00(int param_1)

{
  return *(undefined4 *)(param_1 + 8);
}



undefined4 __thiscall FUN_10002e10(void *this,undefined4 param_1,undefined4 param_2)

{
  char cVar1;
  char *pcVar2;
  int iVar3;
  undefined4 uVar4;
  
                    // WARNING: Load size is inaccurate
  iVar3 = (**(code **)(*this + 0x2c))(param_1);
  if ((iVar3 != 0) && (iVar3 != *(int *)((int)this + 8) + -1)) {
    pcVar2 = *(char **)((int)this + iVar3 * 4 + 0x10);
    cVar1 = *pcVar2;
    if ((cVar1 != '-') && (cVar1 != '+')) {
      uVar4 = FUN_10020d54(pcVar2);
      return uVar4;
    }
  }
  return param_2;
}



float10 __thiscall FUN_10002e50(void *this,undefined4 param_1,float param_2)

{
  byte bVar1;
  byte *pbVar2;
  int iVar3;
  float10 fVar4;
  
                    // WARNING: Load size is inaccurate
  iVar3 = (**(code **)(*this + 0x2c))(param_1);
  if ((iVar3 != 0) && (iVar3 != *(int *)((int)this + 8) + -1)) {
    pbVar2 = *(byte **)((int)this + iVar3 * 4 + 0x10);
    bVar1 = *pbVar2;
    if ((bVar1 != 0x2d) && (bVar1 != 0x2b)) {
      fVar4 = (float10)FUN_10020d43(pbVar2);
      return fVar4;
    }
  }
  return (float10)param_2;
}



char * __thiscall FUN_10002e90(void *this,undefined4 param_1,char *param_2)

{
  char cVar1;
  char *pcVar2;
  int iVar3;
  
                    // WARNING: Load size is inaccurate
  iVar3 = (**(code **)(*this + 0x2c))(param_1);
  if ((iVar3 != 0) && (iVar3 != *(int *)((int)this + 8) + -1)) {
    pcVar2 = *(char **)((int)this + iVar3 * 4 + 0x10);
    cVar1 = *pcVar2;
    if ((cVar1 != '-') && (cVar1 != '+')) {
      return pcVar2;
    }
  }
  return param_2;
}



void __fastcall FUN_10002ed0(void *param_1)

{
  bool bVar1;
  bool bVar2;
  char cVar3;
  undefined4 uVar4;
  void **ppvVar5;
  char *pcVar6;
  size_t sVar7;
  int iVar8;
  char *pcVar9;
  
  iVar8 = 0;
  if (0 < *(int *)((int)param_1 + 8)) {
    ppvVar5 = (void **)((int)param_1 + 0xc);
    do {
      FID_conflict__free(*ppvVar5);
      *ppvVar5 = (void *)0x0;
      ppvVar5 = ppvVar5 + 1;
      iVar8 = iVar8 + 1;
    } while (iVar8 < *(int *)((int)param_1 + 8));
  }
  pcVar6 = *(char **)((int)param_1 + 4);
  *(undefined4 *)((int)param_1 + 8) = 0;
  if (pcVar6 != (char *)0x0) {
    cVar3 = *pcVar6;
    while (((cVar3 != '\0' && ('\b' < cVar3)) && ((cVar3 < '\x0e' || (cVar3 == ' '))))) {
      pcVar9 = pcVar6 + 1;
      pcVar6 = pcVar6 + 1;
      cVar3 = *pcVar9;
    }
    cVar3 = *pcVar6;
    bVar1 = false;
    pcVar9 = (char *)0x0;
    bVar2 = false;
    if (cVar3 != '\0') {
      do {
        if (bVar1) {
          if (cVar3 == '\"') {
            FUN_100027b0(param_1,pcVar9,pcVar6);
            bVar2 = false;
            pcVar9 = (char *)0x0;
            bVar1 = false;
          }
        }
        else if (pcVar9 == (char *)0x0) {
          if (cVar3 == '\"') {
            bVar2 = true;
            pcVar9 = pcVar6 + 1;
            bVar1 = true;
          }
          else if ((cVar3 < '\t') || (('\r' < cVar3 && (cVar3 != ' ')))) {
            pcVar9 = pcVar6;
          }
        }
        else if (('\b' < cVar3) && ((cVar3 < '\x0e' || (cVar3 == ' ')))) {
          FUN_100027b0(param_1,pcVar9,pcVar6);
          pcVar9 = (char *)0x0;
          bVar1 = bVar2;
        }
        cVar3 = pcVar6[1];
        pcVar6 = pcVar6 + 1;
      } while (cVar3 != '\0');
      if ((pcVar9 != (char *)0x0) && (pcVar6 != pcVar9)) {
        if (0xff < *(int *)((int)param_1 + 8)) {
          Error((byte *)"CCommandLine::AddArgument: exceeded %d parameters");
        }
        sVar7 = ((int)pcVar6 - (int)pcVar9) + 1;
        uVar4 = FUN_1001f8b3(sVar7);
        *(undefined4 *)((int)param_1 + *(int *)((int)param_1 + 8) * 4 + 0xc) = uVar4;
        FID_conflict__memcpy
                  (*(void **)((int)param_1 + *(int *)((int)param_1 + 8) * 4 + 0xc),pcVar9,
                   (int)pcVar6 - (int)pcVar9);
        *(undefined *)(*(int *)((int)param_1 + *(int *)((int)param_1 + 8) * 4 + 0xc) + -1 + sVar7) =
             0;
        *(int *)((int)param_1 + 8) = *(int *)((int)param_1 + 8) + 1;
      }
    }
  }
  return;
}



void __thiscall FUN_10003010(void *this,byte *param_1)

{
  byte *pbVar1;
  char cVar2;
  byte bVar3;
  char *pcVar4;
  byte *pbVar5;
  uint *_Dst;
  char *pcVar6;
  int iVar7;
  byte *pbVar8;
  byte *pbVar9;
  byte *pbVar10;
  bool bVar11;
  byte *local_8;
  
  pbVar9 = *(byte **)((int)this + 4);
  if (pbVar9 != (byte *)0x0) {
    bVar3 = *pbVar9;
    pbVar5 = pbVar9;
    while (bVar3 != 0) {
      pbVar1 = pbVar9 + 1;
      pbVar10 = pbVar9;
      do {
        bVar3 = *pbVar10;
        pbVar10 = pbVar10 + 1;
      } while (bVar3 != 0);
      _Dst = (uint *)FUN_10003190(pbVar9,param_1);
      if (_Dst == (uint *)0x0) break;
      local_8 = (byte *)((int)_Dst + 1);
      bVar11 = false;
      if (*(uint **)((int)this + 4) <= _Dst && _Dst != *(uint **)((int)this + 4)) {
        bVar11 = *(byte *)((int)_Dst + -1) == 0x22;
      }
      if (local_8 != (byte *)0x0) {
LAB_10003085:
        bVar3 = *local_8;
        if (((bVar3 != 0) && (bVar3 != 0x20)) && (bVar3 != 0x22)) goto code_r0x10003093;
        pbVar8 = param_1;
        do {
          bVar3 = *pbVar8;
          pbVar8 = pbVar8 + 1;
        } while (bVar3 != 0);
        pbVar9 = local_8;
        if ((uint)((int)pbVar8 - (int)(param_1 + 1)) < (uint)((int)local_8 - (int)_Dst))
        goto LAB_100030fd;
        while ((bVar3 = *local_8, pbVar9 = pbVar5, bVar3 != 0 && (bVar3 != 0x2d))) {
          if ((bVar3 == 0x2b) || (local_8 = local_8 + 1, local_8 == (byte *)0x0)) break;
        }
      }
LAB_100030cf:
      if (bVar11) {
        _Dst = (uint *)((int)_Dst + -1);
      }
      if ((local_8 == (byte *)0x0) || (*local_8 == 0)) {
        FUN_10021290(_Dst,0,(int)local_8 - (int)_Dst);
        local_8 = pbVar5;
      }
      else {
        FID_conflict__memcpy
                  (_Dst,local_8,(size_t)(pbVar9 + (int)(pbVar10 + (-(int)local_8 - (int)pbVar1))));
        (pbVar9 + (int)(pbVar10 + (-(int)local_8 - (int)pbVar1)))[(int)_Dst] = 0;
        local_8 = pbVar5;
      }
LAB_100030fd:
      pbVar5 = local_8;
      bVar3 = *pbVar9;
    }
    pcVar4 = *(char **)((int)this + 4);
    pcVar6 = pcVar4;
    do {
      cVar2 = *pcVar6;
      pcVar6 = pcVar6 + 1;
    } while (cVar2 != '\0');
    iVar7 = (int)pcVar6 - (int)(pcVar4 + 1);
    while ((iVar7 != 0 && (pcVar4[iVar7 + -1] == ' '))) {
      pcVar4[iVar7 + -1] = '\0';
      pcVar4 = *(char **)((int)this + 4);
      pcVar6 = pcVar4;
      do {
        cVar2 = *pcVar6;
        pcVar6 = pcVar6 + 1;
      } while (cVar2 != '\0');
      iVar7 = (int)pcVar6 - (int)(pcVar4 + 1);
    }
    FUN_10002ed0(this);
  }
  return;
code_r0x10003093:
  local_8 = local_8 + 1;
  if (local_8 == (byte *)0x0) goto LAB_100030cf;
  goto LAB_10003085;
}



void __thiscall FUN_10003150(void *this,int param_1,char *param_2)

{
  void *_Memory;
  int iVar1;
  
  if (((param_2 != (char *)0x0) && (-1 < param_1)) && (param_1 < *(int *)((int)this + 8))) {
    _Memory = *(void **)((int)this + param_1 * 4 + 0xc);
    if (_Memory != (void *)0x0) {
      FID_conflict__free(_Memory);
    }
    iVar1 = FUN_10002db0(param_2);
    *(int *)((int)this + param_1 * 4 + 0xc) = iVar1;
  }
  return;
}



byte * __cdecl FUN_10003190(byte *param_1,byte *param_2)

{
  int iVar1;
  int iVar2;
  int iVar3;
  byte bVar4;
  byte *pbVar5;
  
  if ((param_1 != (byte *)0x0) && (param_2 != (byte *)0x0)) {
    bVar4 = *param_1;
    do {
      if (bVar4 == 0) {
        return (byte *)0x0;
      }
      iVar1 = _tolower((uint)*param_1);
      iVar2 = _tolower((uint)*param_2);
      if (iVar1 == iVar2) {
        bVar4 = param_2[1];
        pbVar5 = param_2 + 1;
        if (bVar4 == 0) {
          return param_1;
        }
        iVar1 = 1 - (int)pbVar5;
        while( true ) {
          if (pbVar5[(int)(param_1 + iVar1)] == 0) {
            return (byte *)0x0;
          }
          iVar2 = _tolower((uint)bVar4);
          iVar3 = _tolower((uint)pbVar5[(int)(param_1 + iVar1)]);
          if (iVar3 != iVar2) break;
          bVar4 = pbVar5[1];
          pbVar5 = pbVar5 + 1;
          if (bVar4 == 0) {
            return param_1;
          }
        }
        if (*pbVar5 == 0) {
          return param_1;
        }
      }
      param_1 = param_1 + 1;
      bVar4 = *param_1;
    } while( true );
  }
  return (byte *)0x0;
}



undefined ** CommandLine(void)

{
                    // 0x3240  290  CommandLine
  return &PTR_vftable_10046010;
}



undefined8 FUN_10003250(void)

{
  undefined8 uVar1;
  undefined8 uVar2;
  int iVar3;
  uint uVar4;
  uint local_1c;
  int local_18;
  uint local_14;
  int local_10;
  uint local_c;
  int local_8;
  
  QueryPerformanceFrequency((LARGE_INTEGER *)&local_c);
  local_c = local_c >> 5 | local_8 << 0x1b;
  local_8 = local_8 >> 5;
  QueryPerformanceCounter((LARGE_INTEGER *)&local_1c);
  uVar1 = rdtsc();
  do {
    do {
      QueryPerformanceCounter((LARGE_INTEGER *)&local_14);
      iVar3 = (local_10 - local_18) - (uint)(local_14 < local_1c);
    } while (iVar3 < local_8);
  } while ((iVar3 <= local_8) && (local_14 - local_1c < local_c));
  uVar2 = rdtsc();
  uVar4 = (uint)uVar2 - (uint)uVar1;
  return CONCAT44((((int)((ulonglong)uVar2 >> 0x20) - (int)((ulonglong)uVar1 >> 0x20)) -
                  (uint)((uint)uVar2 < (uint)uVar1)) * 0x20 | uVar4 >> 0x1b,uVar4 * 0x20);
}



uint __fastcall FUN_100032c0(undefined4 param_1,undefined4 param_2)

{
  undefined4 extraout_ECX;
  ulonglong uVar1;
  uint local_14 [4];
  
  uVar1 = FUN_10003780(param_1,param_2,-0x80000000,local_14);
  if (((char)uVar1 != '\0') && (0x80000000 < local_14[0])) {
    uVar1 = FUN_10003780(extraout_ECX,(int)(uVar1 >> 0x20),-0x7fffffff,local_14);
    if ((char)uVar1 == '\0') {
      local_14[0] = 0;
    }
    return local_14[0] >> 0x1f | (uint)(uint3)(uVar1 >> 8) << 8;
  }
  return (uint)(uint3)(uVar1 >> 8) << 8;
}



uint __fastcall FUN_10003310(undefined4 param_1,undefined4 param_2)

{
  byte *pbVar1;
  uint uVar2;
  undefined4 extraout_ECX;
  undefined4 extraout_EDX;
  ulonglong uVar3;
  undefined4 local_14 [2];
  uint local_c;
  
  pbVar1 = FUN_10003500(param_1,param_2);
  uVar2 = V_tier0_stricmp(pbVar1,(byte *)"GenuineIntel");
  if (uVar2 != 0) {
    return uVar2 & 0xffffff00;
  }
  uVar3 = FUN_10003780(extraout_ECX,extraout_EDX,1,local_14);
  if ((char)uVar3 == '\0') {
    local_c = 0;
  }
  return local_c >> 0x14 & 1 | (uint)(uint3)(uVar3 >> 8) << 8;
}



uint __fastcall FUN_10003360(undefined4 param_1,undefined4 param_2)

{
  byte *pbVar1;
  uint uVar2;
  undefined4 extraout_ECX;
  undefined4 extraout_EDX;
  ulonglong uVar3;
  undefined4 local_14 [2];
  uint local_c;
  
  pbVar1 = FUN_10003500(param_1,param_2);
  uVar2 = V_tier0_stricmp(pbVar1,(byte *)"AuthenticAMD");
  if (uVar2 != 0) {
    return uVar2 & 0xffffff00;
  }
  uVar3 = FUN_10003780(extraout_ECX,extraout_EDX,1,local_14);
  if ((char)uVar3 == '\0') {
    local_c = 0;
  }
  return local_c >> 6 & 1 | (uint)(uint3)(uVar3 >> 8) << 8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined * FUN_100033b0(void)

{
  byte *pbVar1;
  uint uVar2;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  undefined4 extraout_ECX_01;
  undefined4 extraout_ECX_02;
  undefined4 extraout_ECX_03;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  ulonglong uVar3;
  uint local_20;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 uStack20;
  
  if (DAT_100480d0 == '\0') {
    DAT_100480d0 = '\x01';
    FUN_10021290((uint *)&DAT_10048058,0,0x34);
    pbVar1 = FUN_10003500(extraout_ECX,extraout_EDX);
    uVar2 = V_tier0_stricmp(pbVar1,(byte *)"GenuineIntel");
    if (uVar2 == 0) {
      uVar3 = FUN_10003780(extraout_ECX_00,extraout_EDX_00,-0x80000000,&local_20);
      if (((char)uVar3 != '\0') && (0x80000003 < local_20)) {
        uVar3 = FUN_10003780(extraout_ECX_01,(int)(uVar3 >> 0x20),-0x7ffffffe,&local_20);
        if ((char)uVar3 == '\0') {
          uStack20 = 0;
          uStack24 = 0;
          uStack28 = 0;
          local_20 = 0;
        }
        _DAT_10048058 = local_20;
        uRam1004805c = uStack28;
        uRam10048060 = uStack24;
        uRam10048064 = uStack20;
        uVar3 = FUN_10003780(extraout_ECX_02,(int)(uVar3 >> 0x20),-0x7ffffffd,&local_20);
        if ((char)uVar3 == '\0') {
          uStack20 = 0;
          uStack24 = 0;
          uStack28 = 0;
          local_20 = 0;
        }
        _DAT_10048068 = local_20;
        uRam1004806c = uStack28;
        uRam10048070 = uStack24;
        uRam10048074 = uStack20;
        uVar3 = FUN_10003780(extraout_ECX_03,(int)(uVar3 >> 0x20),-0x7ffffffc,&local_20);
        if ((char)uVar3 == '\0') {
          uStack20 = 0;
          uStack24 = 0;
          uStack28 = 0;
          local_20 = 0;
        }
        _DAT_10048078 = local_20;
        uRam1004807c = uStack28;
        uRam10048080 = uStack24;
        uRam10048084 = uStack20;
      }
    }
  }
  return &DAT_10048058;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined * __fastcall FUN_10003500(undefined4 param_1,undefined4 param_2)

{
  ulonglong uVar1;
  int local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  if (DAT_10048054 == '\0') {
    DAT_10048054 = '\x01';
    uVar1 = FUN_10003780(param_1,param_2,0,&local_14);
    if ((char)uVar1 == '\0') {
      local_8 = 0;
      local_c = 0;
      local_10 = 0;
      local_14 = 0;
    }
    DAT_10046428 = 0;
    if (local_14 == 0) {
      s_unknown_1004641c = 0x5f636972656e6547;
      _DAT_10046424 = 0x363878;
      DAT_10046428 = 0;
      return s_unknown_1004641c;
    }
    s_unknown_1004641c = CONCAT44(local_8,local_10);
    _DAT_10046424 = local_c;
  }
  return s_unknown_1004641c;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_100035b0(uint param_1)

{
  char cVar1;
  int iVar2;
  int iVar3;
  
  if (-1 < (int)param_1) {
    iVar3 = 4;
    do {
      iVar2 = 0;
      do {
        cVar1 = (char)param_1;
        if (DAT_1004642c == cVar1) {
          _DAT_100480b8 = (uint)DAT_1004642e;
          _DAT_100480bc = param_1 & 0xff;
          break;
        }
        iVar2 = iVar2 + 1;
      } while (iVar2 < 9);
      iVar2 = 0;
      do {
        if (DAT_10046450 == cVar1) {
          _DAT_100480c0 = (uint)DAT_10046452;
          _DAT_100480c4 = param_1 & 0xff;
          break;
        }
        iVar2 = iVar2 + 1;
      } while (iVar2 < 0x1b);
      iVar2 = 0;
      do {
        if (DAT_100464c0 == cVar1) {
          _DAT_100480c8 = (uint)DAT_100464c2;
          _DAT_100480cc = param_1 & 0xff;
          break;
        }
        iVar2 = iVar2 + 1;
      } while (iVar2 < 0x19);
      param_1 = param_1 >> 8;
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
  }
  return;
}



uint FUN_10003660(void)

{
  BOOL BVar1;
  uint uVar2;
  _OSVERSIONINFOA local_a0;
  
  FUN_10021290(&local_a0.dwOSVersionInfoSize,0,0x9c);
  local_a0.dwOSVersionInfoSize = 0x9c;
  BVar1 = GetVersionExA(&local_a0);
  if (BVar1 == 0) {
    local_a0.dwOSVersionInfoSize = 0x94;
    BVar1 = GetVersionExA(&local_a0);
    if (BVar1 == 0) {
      Error((byte *)"IsWin98OrOlder:  Unable to get OS version information");
    }
  }
  if ((local_a0.dwPlatformId == 0) ||
     (uVar2 = local_a0.dwPlatformId - 1, local_a0.dwPlatformId = uVar2 & 0xffffff00, uVar2 == 0)) {
    local_a0.dwPlatformId = CONCAT31((int3)(local_a0.dwPlatformId >> 8),1);
  }
  return local_a0.dwPlatformId;
}



uint __fastcall FUN_100036e0(undefined4 param_1,undefined4 param_2)

{
  uint uVar1;
  ulonglong uVar2;
  undefined4 local_14;
  uint local_10;
  uint local_8;
  
  uVar2 = FUN_10003780(param_1,param_2,1,&local_14);
  uVar1 = local_10;
  if ((char)uVar2 == '\0') {
    local_8 = 0;
    uVar1 = 0;
  }
  if (((local_8 & 0x10000000) != 0) && (uVar1 = uVar1 & 0xff0000, 0x10000 < uVar1)) {
    uVar2 = FUN_10003780(local_8,(int)(uVar2 >> 0x20),1,&local_14);
    if ((char)uVar2 == '\0') {
      local_10 = 0;
    }
    return local_10 >> 0x10 & 0xff | (uint)(uint3)(uVar2 >> 8) << 8;
  }
  return CONCAT31((int3)(uVar1 >> 8),1);
}



ulonglong __fastcall
FUN_10003740(undefined4 param_1,undefined4 param_2,undefined4 *param_3,int param_4)

{
  ulonglong uVar1;
  
  uVar1 = FUN_10003780(param_1,param_2,param_4,param_3);
  if ((char)uVar1 == '\0') {
    param_3[3] = 0;
    param_3[2] = 0;
    param_3[1] = 0;
    *param_3 = 0;
  }
  return uVar1 & 0xffffffff00000000 | ZEXT48(param_3);
}



// WARNING: Restarted to delay deadcode elimination for space: stack

ulonglong __fastcall
FUN_10003780(undefined4 param_1,undefined4 param_2,int param_3,undefined4 *param_4)

{
  undefined4 uVar1;
  undefined4 *puVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 *in_FS_OFFSET;
  undefined auStack20 [16];
  
  uVar1 = *in_FS_OFFSET;
  *in_FS_OFFSET = auStack20;
  if (param_3 == 0) {
    puVar2 = (undefined4 *)cpuid_basic_info(0);
  }
  else if (param_3 == 1) {
    puVar2 = (undefined4 *)cpuid_Version_info(1);
  }
  else if (param_3 == 2) {
    puVar2 = (undefined4 *)cpuid_cache_tlb_info(2);
  }
  else if (param_3 == 3) {
    puVar2 = (undefined4 *)cpuid_serial_info(3);
  }
  else if (param_3 == 4) {
    puVar2 = (undefined4 *)cpuid_Deterministic_Cache_Parameters_info(4);
  }
  else if (param_3 == 5) {
    puVar2 = (undefined4 *)cpuid_MONITOR_MWAIT_Features_info(5);
  }
  else if (param_3 == 6) {
    puVar2 = (undefined4 *)cpuid_Thermal_Power_Management_info(6);
  }
  else if (param_3 == 7) {
    puVar2 = (undefined4 *)cpuid_Extended_Feature_Enumeration_info(7);
  }
  else if (param_3 == 9) {
    puVar2 = (undefined4 *)cpuid_Direct_Cache_Access_info(9);
  }
  else if (param_3 == 10) {
    puVar2 = (undefined4 *)cpuid_Architectural_Performance_Monitoring_info(10);
  }
  else if (param_3 == 0xb) {
    puVar2 = (undefined4 *)cpuid_Extended_Topology_info(0xb);
  }
  else if (param_3 == 0xd) {
    puVar2 = (undefined4 *)cpuid_Processor_Extended_States_info(0xd);
  }
  else if (param_3 == 0xf) {
    puVar2 = (undefined4 *)cpuid_Quality_of_Service_info(0xf);
  }
  else if (param_3 == -0x7ffffffe) {
    puVar2 = (undefined4 *)cpuid_brand_part1_info(0x80000002);
  }
  else if (param_3 == -0x7ffffffd) {
    puVar2 = (undefined4 *)cpuid_brand_part2_info(0x80000003);
  }
  else if (param_3 == -0x7ffffffc) {
    puVar2 = (undefined4 *)cpuid_brand_part3_info(0x80000004);
  }
  else {
    puVar2 = (undefined4 *)cpuid(param_3);
  }
  uVar5 = puVar2[1];
  uVar4 = puVar2[2];
  uVar3 = puVar2[3];
  *param_4 = *puVar2;
  param_4[1] = uVar5;
  param_4[2] = uVar3;
  param_4[3] = uVar4;
  *in_FS_OFFSET = uVar1;
  return CONCAT44(param_2,uVar1) & 0xffffffffffffff00 | 1;
}



// WARNING: Restarted to delay deadcode elimination for space: stack

ulonglong __fastcall
FUN_10003830(undefined4 param_1,undefined4 param_2,int param_3,undefined4 param_4,
            undefined4 *param_5)

{
  undefined4 uVar1;
  undefined4 *puVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 *in_FS_OFFSET;
  undefined auStack20 [16];
  
  uVar1 = *in_FS_OFFSET;
  *in_FS_OFFSET = auStack20;
  if (param_3 == 0) {
    puVar2 = (undefined4 *)cpuid_basic_info(0);
  }
  else if (param_3 == 1) {
    puVar2 = (undefined4 *)cpuid_Version_info(1);
  }
  else if (param_3 == 2) {
    puVar2 = (undefined4 *)cpuid_cache_tlb_info(2);
  }
  else if (param_3 == 3) {
    puVar2 = (undefined4 *)cpuid_serial_info(3);
  }
  else if (param_3 == 4) {
    puVar2 = (undefined4 *)cpuid_Deterministic_Cache_Parameters_info(4);
  }
  else if (param_3 == 5) {
    puVar2 = (undefined4 *)cpuid_MONITOR_MWAIT_Features_info(5);
  }
  else if (param_3 == 6) {
    puVar2 = (undefined4 *)cpuid_Thermal_Power_Management_info(6);
  }
  else if (param_3 == 7) {
    puVar2 = (undefined4 *)cpuid_Extended_Feature_Enumeration_info(7);
  }
  else if (param_3 == 9) {
    puVar2 = (undefined4 *)cpuid_Direct_Cache_Access_info(9);
  }
  else if (param_3 == 10) {
    puVar2 = (undefined4 *)cpuid_Architectural_Performance_Monitoring_info(10);
  }
  else if (param_3 == 0xb) {
    puVar2 = (undefined4 *)cpuid_Extended_Topology_info(0xb);
  }
  else if (param_3 == 0xd) {
    puVar2 = (undefined4 *)cpuid_Processor_Extended_States_info(0xd);
  }
  else if (param_3 == 0xf) {
    puVar2 = (undefined4 *)cpuid_Quality_of_Service_info(0xf);
  }
  else if (param_3 == -0x7ffffffe) {
    puVar2 = (undefined4 *)cpuid_brand_part1_info(0x80000002);
  }
  else if (param_3 == -0x7ffffffd) {
    puVar2 = (undefined4 *)cpuid_brand_part2_info(0x80000003);
  }
  else if (param_3 == -0x7ffffffc) {
    puVar2 = (undefined4 *)cpuid_brand_part3_info(0x80000004);
  }
  else {
    puVar2 = (undefined4 *)cpuid(param_3);
  }
  uVar5 = puVar2[1];
  uVar4 = puVar2[2];
  uVar3 = puVar2[3];
  *param_5 = *puVar2;
  param_5[1] = uVar5;
  param_5[2] = uVar3;
  param_5[3] = uVar4;
  *in_FS_OFFSET = uVar1;
  return CONCAT44(param_2,uVar1) & 0xffffffffffffff00 | 1;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined * GetCPUInformation(void)

{
  uint uVar1;
  byte *pbVar2;
  undefined4 uVar3;
  uint uVar4;
  byte bVar5;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  undefined4 extraout_ECX_01;
  uint extraout_ECX_02;
  uint extraout_ECX_03;
  uint extraout_ECX_04;
  uint extraout_ECX_05;
  uint uVar6;
  int *piVar7;
  uint extraout_ECX_06;
  uint extraout_ECX_07;
  uint extraout_ECX_08;
  uint uVar8;
  uint extraout_ECX_09;
  undefined4 extraout_ECX_10;
  uint extraout_ECX_11;
  char cVar9;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 extraout_EDX_03;
  undefined4 extraout_EDX_04;
  undefined4 extraout_EDX_05;
  undefined4 extraout_EDX_06;
  uint extraout_EDX_07;
  uint uVar10;
  undefined4 extraout_EDX_08;
  undefined in_XMM0 [16];
  ulonglong uVar11;
  char *pcVar12;
  undefined local_80 [16];
  undefined local_70 [16];
  undefined4 local_60;
  uint local_50 [2];
  int *piStack72;
  uint uStack68;
  undefined local_40 [8];
  uint uStack56;
  uint uStack52;
  uint local_24;
  uint local_20;
  uint local_1c;
  int *local_18;
  char local_12;
  char local_11;
  
                    // 0x38e0  332  GetCPUInformation
  if (_DAT_10048090 == 0x40) goto LAB_10003e86;
  FUN_10021290((uint *)&DAT_10048090,0,0x40);
  _DAT_10048090 = 0x40;
  _DAT_10048098 = FUN_10003250();
  uVar1 = FUN_100036e0(extraout_ECX,(int)((ulonglong)_DAT_10048098 >> 0x20));
  pcVar12 = "AuthenticAMD";
  _DAT_10048094 = _DAT_10048094 & 0xff00 | (ushort)(byte)uVar1;
  pbVar2 = FUN_10003500(extraout_ECX_00,extraout_EDX);
  uVar1 = V_tier0_stricmp(pbVar2,(byte *)pcVar12);
  local_12 = uVar1 == 0;
  if ((bool)local_12) {
LAB_10003977:
    local_11 = '\0';
  }
  else {
    pcVar12 = "GenuineIntel";
    pbVar2 = FUN_10003500(extraout_ECX_01,extraout_EDX_00);
    uVar1 = V_tier0_stricmp(pbVar2,(byte *)pcVar12);
    local_11 = '\x01';
    if (uVar1 != 0) goto LAB_10003977;
  }
  local_80 = in_XMM0 & (undefined  [16])0x0;
  local_60 = 0;
  local_70 = local_80;
  GetSystemInfo((LPSYSTEM_INFO)local_80);
  DAT_10048094 = SUB161(local_70 >> 0x20,0);
  _DAT_10048094 = _DAT_10048094 & 0xff00 | (ushort)DAT_10048094;
  if (local_12 == '\0') {
    FUN_10004770(&local_18,0);
    bVar5 = FUN_100050a0(&local_18);
    _DAT_10048094 = _DAT_10048094 & 0xff | (ushort)bVar5 << 8;
    FUN_10004b70((int *)&local_18);
    uVar1 = extraout_ECX_03 & 0xffffff00 | (uint)DAT_10048095;
    uVar3 = extraout_EDX_02;
  }
  else {
    uVar1 = extraout_ECX_02 & 0xffffff00 | local_70._4_4_ & 0xff;
    _DAT_10048094 = CONCAT11((char)(local_70._4_4_ & 0xff),DAT_10048094);
    uVar3 = extraout_EDX_01;
  }
  if (((char)uVar1 == '\0') && (DAT_10048094 == 0)) {
    _DAT_10048094 = 0x101;
  }
  uVar11 = FUN_10003780(uVar1,uVar3,0,local_50);
  uVar1 = local_50[0];
  uVar6 = (uint)(uVar11 >> 0x20);
  local_40._4_4_ = extraout_ECX_04;
  if (((char)uVar11 != '\0') && (local_50[0] != 0)) {
    uVar11 = FUN_10003780(extraout_ECX_04,uVar6,1,local_50);
    if ((char)uVar11 == '\0') {
      local_18 = (int *)0x0;
      local_24 = 0;
      local_20 = 0;
      uVar4 = 0;
    }
    else {
      local_18 = piStack72;
      local_24 = local_50[1];
      local_20 = local_50[0];
      uVar4 = uStack68;
    }
    bVar5 = ((byte)(uVar4 >> 4) ^ DAT_10048096) & 1 ^ DAT_10048096;
    bVar5 = bVar5 ^ ((char)(uVar4 >> 0xf) * '\x02' ^ bVar5) & 2;
    if (((bVar5 & 2) == 0) || ((uVar4 & 1) == 0)) {
      cVar9 = '\0';
    }
    else {
      cVar9 = '\x01';
    }
    bVar5 = (cVar9 << 2 ^ bVar5) & 4 ^ bVar5;
    DAT_10048096 = ((char)(uVar4 >> 0x17) << 6 ^ bVar5) & 0x40 ^ bVar5;
    local_1c = uVar4;
    uVar3 = FUN_10003660();
    if ((char)uVar3 == '\0') {
      uVar11 = FUN_10003780(extraout_ECX_05,extraout_EDX_03,1,local_50);
      uVar3 = 0;
      uVar6 = uStack68;
      if ((char)uVar11 == '\0') {
        uVar6 = 0;
      }
      uVar6 = (uint)((byte)(uVar6 >> 0x19) & 1);
    }
    else {
      uVar6 = extraout_ECX_05 & 0xffffff00;
      uVar3 = extraout_EDX_03;
    }
    uVar8 = (byte)((char)uVar6 << 3 ^ DAT_10048096) & 0xffffff08;
    DAT_10048096 = DAT_10048096 ^ (byte)uVar8;
    uVar11 = FUN_10003780(uVar6 & 0xffffff00 | uVar8,uVar3,1,local_50);
    uVar6 = uStack68;
    if ((char)uVar11 == '\0') {
      uVar6 = 0;
    }
    bVar5 = ((byte)(uVar6 >> 0x1a) << 4 ^ DAT_10048096) & 0x10;
    DAT_10048096 = DAT_10048096 ^ bVar5;
    uVar11 = FUN_10003780((uint)bVar5,0,1,local_50);
    piVar7 = piStack72;
    if ((char)uVar11 == '\0') {
      piVar7 = (int *)0x0;
    }
    uVar6 = (byte)((byte)piVar7 ^ DAT_10048097) & 0xffffff01;
    DAT_10048097 = DAT_10048097 ^ (byte)uVar6;
    uVar11 = FUN_10003780((uint)piVar7 & 0xffffff00 | uVar6,0,1,local_50);
    piVar7 = piStack72;
    if ((char)uVar11 == '\0') {
      piVar7 = (int *)0x0;
    }
    uVar6 = CONCAT31((uint3)((uint)piVar7 >> 0x11),(char)((uint)piVar7 >> 9) * '\x02' ^ DAT_10048097
                    ) & 0xffffff02;
    DAT_10048097 = DAT_10048097 ^ (byte)uVar6;
    uVar6 = FUN_10003360(uVar6,0);
    DAT_10048097 = DAT_10048097 ^ ((char)uVar6 << 2 ^ DAT_10048097) & 4;
    uVar11 = FUN_10003780(extraout_ECX_06 & 0xffffff00 | (uint)DAT_10048097,extraout_EDX_04,1,
                          local_50);
    piVar7 = piStack72;
    if ((char)uVar11 == '\0') {
      piVar7 = (int *)0x0;
    }
    uVar6 = CONCAT31((uint3)((uint)piVar7 >> 0x1b),(char)((uint)piVar7 >> 0x13) << 3 ^ DAT_10048097)
            & 0xffffff08;
    DAT_10048097 = DAT_10048097 ^ (byte)uVar6;
    uVar6 = FUN_10003310(uVar6,0);
    DAT_10048097 = DAT_10048097 ^ ((char)uVar6 << 4 ^ DAT_10048097) & 0x10;
    uVar6 = FUN_100032c0(extraout_ECX_07 & 0xffffff00 | (uint)DAT_10048097,extraout_EDX_05);
    DAT_10048096 = DAT_10048096 ^ ((char)uVar6 << 5 ^ DAT_10048096) & 0x20;
    uVar6 = (byte)((byte)((uint)local_18 >> 0x1c) << 5 ^ DAT_10048097) & 0xffffff20;
    DAT_10048097 = DAT_10048097 ^ (byte)uVar6;
    _DAT_100480a0 = FUN_10003500(uVar6,extraout_EDX_06);
    _DAT_100480a4 = FUN_100033b0();
    DAT_10048096 = (DAT_10048095 < DAT_10048094) << 7 | DAT_10048096 & 0x7f;
    local_40._4_4_ = extraout_ECX_08 & 0xffffff00 | (uint)DAT_10048096;
    _DAT_100480a8 = local_20;
    _DAT_100480b0 = local_18;
    _DAT_100480b4 = local_24;
    uVar6 = extraout_EDX_07;
    _DAT_100480ac = uVar4;
    if (local_11 != '\0') {
      if (uVar1 < 4) {
        if (1 < uVar1) {
          uVar11 = FUN_10003740(local_40._4_4_,extraout_EDX_07,local_50,2);
          uVar6 = (uint)(uVar11 >> 0x20);
          _local_40 = *(undefined (*) [16])uVar11;
          uVar4 = SUB164(_local_40,0) & 0xff;
          uVar1 = SUB164(_local_40,0);
          local_40._4_4_ = extraout_ECX_09;
          if ((_local_40 & (undefined  [16])0xff) != (undefined  [16])0x0) {
            do {
              uVar4 = uVar4 - 1;
              FUN_100035b0(uVar1 & 0xffffff00);
              FUN_100035b0(local_40._4_4_);
              FUN_100035b0(uStack56);
              FUN_100035b0(uStack52);
              uVar11 = FUN_10003780(extraout_ECX_10,extraout_EDX_08,2,local_50);
              uVar6 = (uint)(uVar11 >> 0x20);
              if ((char)uVar11 == '\0') {
                uStack68 = 0;
                piStack72 = (int *)0x0;
                local_50[1] = 0;
                local_50[0] = 0;
              }
              local_40 = CONCAT44(local_50[1],local_50[0]);
              _local_40 = CONCAT48(piStack72,local_40);
              _local_40 = CONCAT412(uStack68,_local_40);
              uVar1 = local_50[0];
              local_40._4_4_ = extraout_ECX_11;
            } while (0 < (int)uVar4);
          }
        }
      }
      else {
        local_50[1] = 0;
        uVar1 = 0;
        piStack72 = (int *)0x0;
        uStack68 = 0;
        do {
          uVar11 = FUN_10003830(local_40._4_4_,uVar6,4,uVar1,(undefined4 *)local_40);
          if ((char)uVar11 == '\0') {
            uStack56 = 0;
            local_40._4_4_ = 0;
            local_40._0_4_ = 0;
            _local_40 = ZEXT812(local_40);
            _local_40 = _local_40 & (undefined  [16])0xffffffff00000000;
          }
          else {
          }
          uVar6 = local_40._0_4_ & 0x1f;
          if (uVar6 == 0) break;
          if (((local_40._0_4_ & 1) != 0) && (uVar4 = local_40._0_4_ >> 5 & 7, uVar4 < 4)) {
            uVar6 = local_40._4_4_ >> 0xc;
            uVar10 = local_40._4_4_ >> 0x16;
            uVar8 = local_40._4_4_ & 0xff;
            local_40._4_4_ = uStack56 + 1;
            uVar6 = ((uVar10 & 0x3f) + 1) * ((uVar6 & 0x3f) + 1) * (uVar8 + 1) * local_40._4_4_ >>
                    10;
            local_50[uVar4] = uVar6;
          }
          uVar1 = uVar1 + 1;
        } while (uVar1 < 0x400);
        _DAT_100480b8 = local_50[1];
        _DAT_100480c0 = piStack72;
        _DAT_100480c8 = uStack68;
      }
    }
  }
  uVar11 = FUN_10003780(local_40._4_4_,uVar6,-0x80000000,local_50);
  uVar3 = (undefined4)(uVar11 >> 0x20);
  uVar6 = 0;
  uVar1 = local_50[0];
  if ((char)uVar11 == '\0') {
    uVar1 = 0;
  }
  if (local_12 == '\0') {
    if ((local_11 != '\0') && (0x80000005 < uVar1)) {
      uVar11 = FUN_10003780(0,uVar3,-0x7ffffffa,local_50);
      if ((char)uVar11 == '\0') {
        piStack72 = (int *)0x0;
      }
      _DAT_100480c0 = (int *)((uint)piStack72 >> 0x10);
    }
  }
  else {
    if (0x80000004 < uVar1) {
      uVar11 = FUN_10003780(0,uVar3,-0x7ffffffb,local_50);
      uVar3 = 0;
      piVar7 = piStack72;
      if ((char)uVar11 == '\0') {
        piVar7 = (int *)0x0;
      }
      _DAT_100480b8 = (uint)piVar7 >> 0x18;
      uVar6 = (uint)piVar7 & 0xffffff;
      _DAT_100480bc = uVar6;
    }
    if (0x80000005 < uVar1) {
      uVar11 = FUN_10003780(uVar6,uVar3,-0x7ffffffa,local_50);
      if ((char)uVar11 == '\0') {
        uStack68 = 0;
        piStack72 = (int *)0x0;
      }
      _DAT_100480c0 = (int *)((uint)piStack72 >> 0x10);
      _DAT_100480c4 = (uint)piStack72 & 0xffff;
      _DAT_100480c8 = (uStack68 >> 0x12) << 9;
      _DAT_100480cc = uStack68 & 0xffff;
      return &DAT_10048090;
    }
  }
LAB_10003e86:
  _DAT_1004809c = (undefined4)((ulonglong)_DAT_10048098 >> 0x20);
  return &DAT_10048090;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_10003ea0(void)

{
  DWORD DVar1;
  undefined4 **ppuVar2;
  undefined4 **ppuVar3;
  undefined4 **ppuVar4;
  undefined4 **ppuVar5;
  undefined4 **ppuVar6;
  code *pcVar7;
  uint uVar8;
  int iVar9;
  code *pcVar10;
  undefined4 *puVar11;
  float10 fVar12;
  uint local_320;
  undefined4 *local_31c;
  undefined4 *local_318;
  undefined4 *local_314;
  undefined4 *local_20;
  undefined4 *local_1c;
  undefined4 *local_18;
  uint local_14;
  undefined4 *local_10;
  undefined4 *local_c;
  undefined4 *local_8;
  
  ThreadSetDebugName((HANDLE)0x0,"CPUMonitoringHeartbeatThread");
  pcVar10 = Sleep_exref;
  Sleep(500);
  pcVar7 = GetCurrentThreadId_exref;
  do {
    while( true ) {
      DVar1 = (*pcVar7)();
      if (((DAT_100480fe != '\0') && (DAT_100480f8 != 0)) && (DAT_100480f8 != DVar1)) {
        (*pcVar7)(&DAT_100480e0,DAT_100480f8);
        Msg((byte *)"Thread %u about to wait for lock %p owned by %u\n");
      }
      EnterCriticalSection((LPCRITICAL_SECTION)&DAT_100480e0);
      if ((DAT_100480fc == 0) && (DAT_100480f8 = DVar1, DAT_100480fe != '\0')) {
        Msg((byte *)"Thread %u now owns lock 0x%p\n");
      }
      DVar1 = DAT_10048118;
      if (DAT_100480fc == 0) {
        if (DAT_100480fe != '\0') {
          Msg((byte *)"Thread %u releasing lock 0x%p\n");
        }
        DAT_100480f8 = 0;
      }
      LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_100480e0);
      if (DVar1 != 0) break;
      (*pcVar10)(300);
    }
    FUN_10021290(&local_320,0,0x300);
    CallNtPowerInformation(0xb,0,0,&local_320,DAT_10048134 * 0x18);
    local_1c = local_314;
    local_20 = local_314;
    local_8 = local_31c;
    local_10 = local_318;
    local_c = local_318;
    puVar11 = local_318;
    if (DAT_10048134 != 0) {
      ppuVar6 = &local_318;
      local_14 = DAT_10048134;
      local_18 = local_318;
      do {
        ppuVar5 = &local_10;
        if (*ppuVar6 < local_18) {
          ppuVar5 = ppuVar6;
        }
        local_18 = *ppuVar5;
        ppuVar5 = &local_c;
        if (puVar11 < *ppuVar6) {
          ppuVar5 = ppuVar6;
        }
        local_10 = local_18;
        puVar11 = *ppuVar5;
        ppuVar5 = &local_8;
        if (local_8 < ppuVar6[-1]) {
          ppuVar5 = ppuVar6 + -1;
        }
        local_c = puVar11;
        local_8 = *ppuVar5;
        ppuVar5 = &local_20;
        if (local_1c < ppuVar6[1]) {
          ppuVar5 = ppuVar6 + 1;
        }
        ppuVar6 = ppuVar6 + 6;
        local_14 = local_14 - 1;
        local_1c = *ppuVar5;
        local_20 = *ppuVar5;
      } while (local_14 != 0);
    }
    local_20 = local_1c;
    local_c = puVar11;
    ReleaseSemaphore(DAT_1004811c,DAT_10048134,(LPLONG)0x0);
    Sleep(5);
    uVar8 = 0;
    if (DAT_10048134 != 0) {
      do {
        WaitForSingleObject(DAT_10048130,0xffffffff);
        uVar8 = uVar8 + 1;
      } while (uVar8 < DAT_10048134);
    }
    pcVar7 = GetCurrentThreadId_exref;
    uVar8 = 1;
    local_8 = DAT_10048138;
    local_10 = DAT_10048138;
    local_c = DAT_10048138;
    if (1 < DAT_10048134) {
      if (3 < DAT_10048134 - 1) {
        local_18 = &DAT_10048144;
        iVar9 = (DAT_10048134 - 5 >> 2) + 1;
        uVar8 = iVar9 * 4 + 1;
        local_14 = uVar8;
        ppuVar6 = (undefined4 **)&DAT_10048144;
        do {
          ppuVar5 = &local_8;
          if ((float)ppuVar6[-2] < (float)local_8) {
            ppuVar5 = ppuVar6 + -2;
          }
          ppuVar2 = &local_c;
          if ((float)local_c < (float)ppuVar6[-2]) {
            ppuVar2 = ppuVar6 + -2;
          }
          local_8 = *ppuVar5;
          local_c = *ppuVar2;
          ppuVar4 = &local_8;
          if ((float)ppuVar6[-1] < (float)*ppuVar5) {
            ppuVar4 = ppuVar6 + -1;
          }
          ppuVar5 = &local_c;
          if ((float)*ppuVar2 < (float)ppuVar6[-1]) {
            ppuVar5 = ppuVar6 + -1;
          }
          local_8 = *ppuVar4;
          ppuVar2 = ppuVar6 + 1;
          local_c = *ppuVar5;
          ppuVar3 = &local_8;
          if ((float)*ppuVar6 < (float)*ppuVar4) {
            ppuVar3 = ppuVar6;
          }
          ppuVar4 = &local_c;
          if ((float)*ppuVar5 < (float)*ppuVar6) {
            ppuVar4 = ppuVar6;
          }
          local_8 = *ppuVar3;
          local_c = *ppuVar4;
          ppuVar5 = &local_8;
          if ((float)*ppuVar2 < (float)*ppuVar3) {
            ppuVar5 = ppuVar2;
          }
          local_8 = *ppuVar5;
          ppuVar5 = &local_c;
          if ((float)*ppuVar4 < (float)*ppuVar2) {
            ppuVar5 = ppuVar2;
          }
          ppuVar6 = ppuVar6 + 4;
          local_c = *ppuVar5;
          iVar9 = iVar9 + -1;
        } while (iVar9 != 0);
        local_10 = local_c;
      }
      if (uVar8 < DAT_10048134) {
        ppuVar6 = &DAT_10048138 + uVar8;
        iVar9 = DAT_10048134 - uVar8;
        do {
          ppuVar5 = &local_8;
          if ((float)*ppuVar6 < (float)local_8) {
            ppuVar5 = ppuVar6;
          }
          local_8 = *ppuVar5;
          ppuVar5 = &local_c;
          if ((float)local_c < (float)*ppuVar6) {
            ppuVar5 = ppuVar6;
          }
          ppuVar6 = ppuVar6 + 1;
          local_c = *ppuVar5;
          iVar9 = iVar9 + -1;
        } while (iVar9 != 0);
      }
    }
    local_10 = local_c;
    DVar1 = GetCurrentThreadId();
    if (((DAT_100480fe != '\0') && (DAT_100480f8 != 0)) && (DAT_100480f8 != DVar1)) {
      GetCurrentThreadId();
      Msg((byte *)"Thread %u about to wait for lock %p owned by %u\n");
    }
    EnterCriticalSection((LPCRITICAL_SECTION)&DAT_100480e0);
    if ((DAT_100480fc == 0) && (DAT_100480f8 = DVar1, DAT_100480fe != '\0')) {
      Msg((byte *)"Thread %u now owns lock 0x%p\n");
    }
    DAT_100480fc = DAT_100480fc + 1;
    fVar12 = Plat_FloatTime();
    DVar1 = DAT_10048118;
    _DAT_10048108 = (float)local_10 * 1.03;
    _DAT_10048100 = (double)fVar12;
    _DAT_1004810c =
         ((float)local_10 /
         ((float)((double)(int)puVar11 + (double)(&DAT_100366d0)[-((int)puVar11 >> 0x1f)]) * 1e-05))
         * 1.03;
    if (((float)DAT_10048110 == 0.0) || (_DAT_1004810c < (float)DAT_10048110)) {
      DAT_10048110._0_4_ = _DAT_1004810c;
    }
    DAT_100480fc = DAT_100480fc + -1;
    if (DAT_100480fc == 0) {
      if (DAT_100480fe != '\0') {
        Msg((byte *)"Thread %u releasing lock 0x%p\n");
      }
      DAT_100480f8 = 0;
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_100480e0);
    pcVar10 = Sleep_exref;
    Sleep(DVar1);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_10004350(float param_1)

{
  HANDLE hSemaphore;
  float fVar1;
  int iVar2;
  int iVar3;
  double dVar4;
  double dVar5;
  float fVar6;
  uint local_1c;
  int local_18;
  uint local_14;
  int local_10;
  double local_c;
  
  fVar1 = param_1;
  ThreadSetDebugName((HANDLE)0x0,"CPUMonitoringMeasureThread");
  do {
    WaitForSingleObject(DAT_1004811c,0xffffffff);
    dVar4 = 0.0;
    iVar3 = 7;
    param_1 = 0.0;
    do {
      QueryPerformanceCounter((LARGE_INTEGER *)&local_14);
      FUN_10001aaf(local_14 - _DAT_10048128,
                   (local_10 - _DAT_1004812c) - (uint)(local_14 < _DAT_10048128));
      local_c = dVar4;
      FUN_10001aaf(DAT_10048120,DAT_10048124);
      local_c = local_c / dVar4;
      iVar2 = 10000;
      do {
        iVar2 = iVar2 + -1;
      } while (iVar2 != 0);
      QueryPerformanceCounter((LARGE_INTEGER *)&local_1c);
      FUN_10001aaf(local_1c - _DAT_10048128,
                   (local_18 - _DAT_1004812c) - (uint)(local_1c < _DAT_10048128));
      dVar5 = dVar4;
      FUN_10001aaf(DAT_10048120,DAT_10048124);
      hSemaphore = DAT_10048130;
      fVar6 = (float)((500000.0 / (dVar4 / dVar5 - local_c)) * 1e-09);
      if (param_1 < fVar6) {
        param_1 = fVar6;
      }
      dVar4 = (double)(ulonglong)(uint)param_1;
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
    (&DAT_10048138)[(int)fVar1] = param_1;
    ReleaseSemaphore(hSemaphore,1,(LPLONG)0x0);
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl GetCPUFrequencyResults(undefined (*param_1) [16],char param_2)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined8 uVar5;
  undefined in_XMM0 [16];
  
                    // 0x44f0  331  GetCPUFrequencyResults
  CThreadMutex::Lock((CThreadMutex *)&DAT_100480e0);
  uVar5 = DAT_10048110;
  uVar4 = _DAT_1004810c;
  uVar3 = _DAT_10048108;
  uVar2 = uRam10048104;
  uVar1 = _DAT_10048100;
  if ((DAT_100481b8 == '\0') && (param_2 == '\0')) {
    DAT_100480fc = DAT_100480fc + -1;
    if (DAT_100480fc == 0) {
      if (DAT_100480fe != '\0') {
        Msg((byte *)"Thread %u releasing lock 0x%p\n");
      }
      DAT_100480f8 = 0;
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_100480e0);
    *param_1 = in_XMM0 & (undefined  [16])0x0;
    *(undefined8 *)param_1[1] = 0;
    return;
  }
  DAT_100480fc = DAT_100480fc + -1;
  if (DAT_100480fc == 0) {
    if (DAT_100480fe != '\0') {
      Msg((byte *)"Thread %u releasing lock 0x%p\n");
    }
    DAT_100480f8 = 0;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_100480e0);
  *(undefined4 *)*param_1 = uVar1;
  *(undefined4 *)(*param_1 + 4) = uVar2;
  *(undefined4 *)(*param_1 + 8) = uVar3;
  *(undefined4 *)(*param_1 + 0xc) = uVar4;
  *(undefined8 *)param_1[1] = uVar5;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl SetCPUMonitoringInterval(uint param_1)

{
  HANDLE hThread;
  LPVOID lpParameter;
  _SYSTEM_INFO local_28;
  
                    // 0x45e0  444  SetCPUMonitoringInterval
  if ((param_1 != 0) && (param_1 < 0x12d)) {
    param_1 = 300;
  }
  if (DAT_100481b9 == '\0') {
    DAT_100481b9 = '\x01';
    QueryPerformanceFrequency((LARGE_INTEGER *)&DAT_10048120);
    QueryPerformanceCounter((LARGE_INTEGER *)&DAT_10048128);
    DAT_1004811c = CreateSemaphoreA((LPSECURITY_ATTRIBUTES)0x0,0,1000,(LPCSTR)0x0);
    if (DAT_1004811c == (HANDLE)0x0) {
      return;
    }
    DAT_10048130 = CreateSemaphoreA((LPSECURITY_ATTRIBUTES)0x0,0,1000,(LPCSTR)0x0);
    if (DAT_10048130 == (HANDLE)0x0) {
      return;
    }
    GetSystemInfo(&local_28);
    if ((LPVOID)0x20 < local_28.dwNumberOfProcessors) {
      local_28.dwNumberOfProcessors = 0x20;
    }
    lpParameter = (LPVOID)0x0;
    DAT_10048134 = (LPVOID)local_28.dwNumberOfProcessors;
    if ((LPVOID)local_28.dwNumberOfProcessors != (LPVOID)0x0) {
      do {
        hThread = CreateThread((LPSECURITY_ATTRIBUTES)0x0,0x10000,FUN_10004350,lpParameter,0,
                               (LPDWORD)0x0);
        SetThreadAffinityMask(hThread,1 << ((byte)lpParameter & 0x1f));
        SetThreadPriority(hThread,2);
        lpParameter = (LPVOID)((int)lpParameter + 1);
      } while (lpParameter < DAT_10048134);
    }
    CreateThread((LPSECURITY_ATTRIBUTES)0x0,0x10000,FUN_10003ea0,(LPVOID)0x0,0,(LPDWORD)0x0);
  }
  CThreadMutex::Lock((CThreadMutex *)&DAT_100480e0);
  if ((param_1 != 0) && (DAT_10048118 == 0)) {
    _DAT_10048100 = ZEXT816(0);
    DAT_10048110 = 0;
  }
  DAT_100481b8 = param_1 != 0;
  DAT_10048118 = 5000;
  if ((bool)DAT_100481b8) {
    DAT_10048118 = param_1;
  }
  DAT_100480fc = DAT_100480fc + -1;
  if (DAT_100480fc == 0) {
    if (DAT_100480fe != '\0') {
      Msg((byte *)"Thread %u releasing lock 0x%p\n");
    }
    DAT_100480f8 = 0;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_100480e0);
  return;
}



undefined4 * __thiscall FUN_10004770(void *this,int param_1)

{
  *(undefined4 *)this = 0;
  FUN_10004dc0(this,param_1);
  return (undefined4 *)this;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 * __fastcall FUN_10004790(undefined4 *param_1)

{
  HANDLE hProcess;
  code *pcVar1;
  uint uVar2;
  byte bVar3;
  DWORD_PTR dwThreadAffinityMask;
  byte bVar4;
  uint uVar5;
  uint local_44 [4];
  uint local_34 [4];
  undefined4 local_24;
  undefined4 local_20;
  uint local_1c;
  uint local_18;
  HANDLE local_14;
  DWORD_PTR local_10;
  HANDLE local_c;
  DWORD_PTR local_8;
  
  *param_1 = `anonymous_namespace'::CpuidImpl::vftable;
  *(undefined *)(param_1 + 9) = 0;
  FUN_10005160((void *)((int)param_1 + 0x25),1,1);
  bVar3 = 1;
  local_24 = 0;
  bVar4 = 1;
  local_20 = 0;
  local_1c = 0;
  local_18 = 0;
  if ((DAT_100481e0 & 1) == 0) {
    DAT_100481e0 = DAT_100481e0 | 1;
    FUN_100051f0(local_34,0,0);
    _DAT_100481dc = local_34[0];
  }
  if ((DAT_100481e0 & 2) == 0) {
    DAT_100481e0 = DAT_100481e0 | 2;
    FUN_100051f0(local_44,0x80000000,0);
    _DAT_100481e4 = local_44[0];
  }
  if (_DAT_100481dc != 0) {
    FUN_100051f0(&local_24,0,1);
  }
  if ((local_18 & 0x10000000) == 0) goto LAB_100049aa;
  bVar3 = (byte)((uint)local_20 >> 0x10);
  if ((DAT_100481d8 & 1) == 0) {
    DAT_100481d8 = DAT_100481d8 | 1;
    FUN_100051f0(&DAT_100481c8,0,0);
  }
  if (((DAT_100481cc == 0x756e6547) && (DAT_100481d0 == 0x6c65746e)) && (DAT_100481d4 == 0x49656e69)
     ) {
    if ((DAT_100481e0 & 1) == 0) {
      DAT_100481e0 = DAT_100481e0 | 1;
      FUN_100051f0(local_44,0,0);
      _DAT_100481dc = local_44[0];
    }
    if ((DAT_100481e0 & 2) == 0) {
      DAT_100481e0 = DAT_100481e0 | 2;
      FUN_100051f0(local_34,0x80000000,0);
      _DAT_100481e4 = local_34[0];
    }
    if (_DAT_100481dc < 4) goto LAB_100049aa;
    FUN_100051f0(&local_24,0,4);
    bVar4 = (byte)((uint)local_24 >> 0x1a);
  }
  else {
    if ((DAT_100481e0 & 1) == 0) {
      DAT_100481e0 = DAT_100481e0 | 1;
      FUN_100051f0(local_44,0,0);
      _DAT_100481dc = local_44[0];
    }
    if ((DAT_100481e0 & 2) == 0) {
      DAT_100481e0 = DAT_100481e0 | 2;
      FUN_100051f0(local_34,0x80000000,0);
      _DAT_100481e4 = local_34[0];
    }
    if (_DAT_100481e4 < 8) goto LAB_100049aa;
    FUN_100051f0(&local_24,0x80000000,8);
    if ((local_1c & 0xf000) != 0) {
      bVar4 = (byte)(1 << (sbyte)((local_1c & 0xf000) >> 0xc));
      goto LAB_100049aa;
    }
    bVar4 = (byte)local_1c;
  }
  bVar4 = bVar4 + 1;
LAB_100049aa:
  FUN_10005160((void *)((int)param_1 + 0x25),bVar3,bVar4);
  hProcess = GetCurrentProcess();
  local_14 = hProcess;
  local_c = GetCurrentThread();
  GetProcessAffinityMask(hProcess,&local_10,&local_8);
  if (local_8 == 1) {
    *(undefined *)(*(byte *)(param_1 + 9) + 4 + (int)param_1) = 0;
    *(char *)(param_1 + 9) = *(char *)(param_1 + 9) + '\x01';
    return param_1;
  }
  if (local_10 != local_8) {
    SetProcessAffinityMask(hProcess,local_8);
  }
  dwThreadAffinityMask = 0;
  uVar5 = 1;
  pcVar1 = SetThreadAffinityMask_exref;
  uVar2 = local_8;
  do {
    if (uVar2 < uVar5) break;
    if ((uVar2 & uVar5) != 0) {
      if (dwThreadAffinityMask == 0) {
        dwThreadAffinityMask = (*pcVar1)(local_c,uVar5);
      }
      else {
        (*pcVar1)(local_c,uVar5);
      }
      Sleep(0);
      if ((DAT_100481e0 & 1) == 0) {
        DAT_100481e0 = DAT_100481e0 | 1;
        FUN_100051f0(local_44,0,0);
        _DAT_100481dc = local_44[0];
      }
      if ((DAT_100481e0 & 2) == 0) {
        DAT_100481e0 = DAT_100481e0 | 2;
        FUN_100051f0(local_34,0x80000000,0);
        _DAT_100481e4 = local_34[0];
      }
      if (_DAT_100481dc != 0) {
        FUN_100051f0(&local_24,0,1);
      }
      *(char *)(*(byte *)(param_1 + 9) + 4 + (int)param_1) = (char)((uint)local_20 >> 0x18);
      *(char *)(param_1 + 9) = *(char *)(param_1 + 9) + '\x01';
      pcVar1 = SetThreadAffinityMask_exref;
      uVar2 = local_8;
    }
    uVar5 = uVar5 * 2;
  } while (uVar5 != 0);
  SetProcessAffinityMask(local_14,local_10);
  SetThreadAffinityMask(local_c,dwThreadAffinityMask);
  Sleep(0);
  return param_1;
}



undefined4 * __fastcall FUN_10004af0(undefined4 *param_1)

{
  FARPROC pFVar1;
  void *pvVar2;
  undefined4 *local_8;
  
  *param_1 = `anonymous_namespace'::GlpiImpl::vftable;
  param_1[1] = 0;
  param_1[2] = 0;
  if ((DAT_100481c4 & 1) == 0) {
    DAT_100481c4 = DAT_100481c4 | 1;
    local_8 = param_1;
    DAT_100481c0 = FUN_10005220();
  }
  pFVar1 = DAT_100481c0;
  local_8 = (undefined4 *)0x0;
  (*DAT_100481c0)(0,&local_8);
  pvVar2 = _malloc((size_t)local_8);
  param_1[1] = pvVar2;
  (*pFVar1)(pvVar2,&local_8);
  param_1[2] = (uint)local_8 / 0x18;
  return param_1;
}



void __fastcall FUN_10004b70(int *param_1)

{
  if ((undefined4 *)*param_1 != (undefined4 *)0x0) {
    (***(code ***)(undefined4 *)*param_1)(1);
  }
  *param_1 = 0;
  return;
}



undefined4 * __thiscall FUN_10004b90(void *this,byte param_1)

{
  *(undefined ***)this = ICpuTopology::vftable;
  if ((param_1 & 1) != 0) {
    FID_conflict__free(this);
  }
  return (undefined4 *)this;
}



undefined4 * __thiscall FUN_10004bc0(void *this,byte param_1)

{
  *(undefined ***)this = `anonymous_namespace'::GlpiImpl::vftable;
  FID_conflict__free(*(void **)((int)this + 4));
  *(undefined4 *)((int)this + 4) = 0;
  *(undefined4 *)((int)this + 8) = 0;
  *(undefined ***)this = ICpuTopology::vftable;
  if ((param_1 & 1) != 0) {
    FID_conflict__free(this);
  }
  return (undefined4 *)this;
}



uint __thiscall FUN_10004c10(void *this,uint param_1)

{
  uint uVar1;
  HANDLE hProcess;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint *lpProcessAffinityMask;
  ULONG_PTR *lpSystemAffinityMask;
  byte local_34;
  undefined local_33 [16];
  undefined8 local_23;
  undefined4 local_1b;
  undefined2 local_17;
  undefined local_15;
  uint local_14;
  ULONG_PTR local_10;
  uint local_c;
  
  local_34 = 0;
  local_1b = 0;
  uVar3 = 0;
  uVar4 = 0;
  local_23 = 0;
  local_17 = 0;
  local_15 = 0;
  local_c = (uint)*(byte *)((int)this + 0x24);
  local_33 = ZEXT816(0);
  if (*(byte *)((int)this + 0x24) != 0) {
    do {
      uVar1 = 0;
      if (uVar3 != 0) {
        do {
          if (local_33[uVar1 - 1] ==
              (byte)(((*(byte *)((int)this + 0x2c) | *(byte *)((int)this + 0x2a)) &
                     *(byte *)((int)this + uVar4 + 4)) >> (*(byte *)((int)this + 0x27) & 0x1f)))
          break;
          uVar1 = uVar1 + 1;
        } while (uVar1 < uVar3);
      }
      if (uVar1 == uVar3) {
        uVar3 = uVar3 + 1;
        local_33[uVar1 - 1] =
             ((*(byte *)((int)this + 0x2c) | *(byte *)((int)this + 0x2a)) &
             *(byte *)((int)this + uVar4 + 4)) >> (*(byte *)((int)this + 0x27) & 0x1f);
      }
      uVar4 = uVar4 + 1;
    } while (uVar4 < local_c);
  }
  lpSystemAffinityMask = &local_10;
  lpProcessAffinityMask = &local_14;
  hProcess = GetCurrentProcess();
  GetProcessAffinityMask(hProcess,lpProcessAffinityMask,lpSystemAffinityMask);
  uVar4 = 0;
  if (param_1 < uVar3) {
    local_c = (uint)*(byte *)((int)this + 0x24);
    uVar3 = 0;
    if (local_c != 0) {
      uVar1 = 1;
      uVar2 = (uint)CONCAT11(*(byte *)((int)this + 0x2c) | *(byte *)((int)this + 0x2a),
                             *(byte *)((int)this + 0x27));
      do {
        if ((byte)((*(byte *)((int)this + uVar3 + 4) & (byte)(uVar2 >> 8)) >> ((byte)uVar2 & 0x1f))
            == local_33[param_1 - 1]) {
          uVar4 = uVar4 | uVar1 & local_14;
        }
        uVar2 = uVar2 & 0xffffff00 | (uint)*(byte *)((int)this + 0x27);
        uVar3 = uVar3 + 1;
        uVar1 = uVar1 << 1 | (uint)((int)uVar1 < 0);
      } while (uVar3 < local_c);
    }
  }
  return uVar4;
}



ULONG_PTR FUN_10004d10(ULONG_PTR param_1)

{
  HANDLE hProcess;
  ULONG_PTR *lpProcessAffinityMask;
  ULONG_PTR *lpSystemAffinityMask;
  ULONG_PTR local_8;
  
  local_8 = 0;
  if (param_1 == 1) {
    lpSystemAffinityMask = &param_1;
    lpProcessAffinityMask = &local_8;
    hProcess = GetCurrentProcess();
    GetProcessAffinityMask(hProcess,lpProcessAffinityMask,lpSystemAffinityMask);
    return local_8;
  }
  return 0;
}



uint __thiscall FUN_10004d50(void *this,int param_1)

{
  HANDLE hProcess;
  int *piVar1;
  uint uVar2;
  int iVar3;
  uint *lpProcessAffinityMask;
  ULONG_PTR *lpSystemAffinityMask;
  ULONG_PTR local_c;
  uint local_8;
  
  lpSystemAffinityMask = &local_c;
  lpProcessAffinityMask = &local_8;
  hProcess = GetCurrentProcess();
  GetProcessAffinityMask(hProcess,lpProcessAffinityMask,lpSystemAffinityMask);
  uVar2 = 0;
  if (*(uint *)((int)this + 8) != 0) {
    piVar1 = (int *)(*(int *)((int)this + 4) + 4);
    do {
      iVar3 = param_1;
      if ((*piVar1 == 0) && (iVar3 = param_1 + -1, param_1 == 0)) {
        return *(uint *)(*(int *)((int)this + 4) + uVar2 * 0x18) & local_8;
      }
      uVar2 = uVar2 + 1;
      piVar1 = piVar1 + 6;
      param_1 = iVar3;
    } while (uVar2 < *(uint *)((int)this + 8));
  }
  return 0;
}



void __thiscall FUN_10004dc0(void *this,int param_1)

{
  undefined4 *puVar1;
  uint uVar2;
  
                    // WARNING: Load size is inaccurate
  if (*this != (undefined4 *)0x0) {
    (**(code **)**this)(1);
  }
  *(undefined4 *)this = 0;
  if (param_1 == 0) {
    if ((DAT_100481c4 & 1) == 0) {
      DAT_100481c4 = DAT_100481c4 | 1;
      DAT_100481c0 = FUN_10005220();
    }
    if (DAT_100481c0 != (FARPROC)0x0) {
      puVar1 = (undefined4 *)FUN_1001f8b3(0xc);
      if (puVar1 != (undefined4 *)0x0) {
        puVar1 = FUN_10004af0(puVar1);
        *(undefined4 **)this = puVar1;
        return;
      }
      goto LAB_10004e60;
    }
  }
  uVar2 = FUN_10004e70();
  if (uVar2 == 0) {
    puVar1 = (undefined4 *)FUN_1001f8b3(4);
    if (puVar1 != (undefined4 *)0x0) {
      *puVar1 = `anonymous_namespace'::DefaultImpl::vftable;
      *(undefined4 **)this = puVar1;
      return;
    }
  }
  else {
    puVar1 = (undefined4 *)FUN_1001f8b3(0x30);
    if (puVar1 != (undefined4 *)0x0) {
      puVar1 = FUN_10004790(puVar1);
      *(undefined4 **)this = puVar1;
      return;
    }
  }
LAB_10004e60:
  *(undefined4 *)this = 0;
  return;
}



uint FUN_10004e70(void)

{
  HANDLE pvVar1;
  uint uVar2;
  BOOL BVar3;
  DWORD_PTR DVar4;
  uint local_c;
  DWORD_PTR local_8;
  
  if ((DAT_100481d8 & 1) == 0) {
    DAT_100481d8 = DAT_100481d8 | 1;
    FUN_100051f0(&DAT_100481c8,0,0);
  }
  if (((DAT_100481cc != 0x756e6547) || (DAT_100481d0 != 0x6c65746e)) || (DAT_100481d4 != 0x49656e69)
     ) {
    if ((DAT_100481d8 & 1) == 0) {
      DAT_100481d8 = DAT_100481d8 | 1;
      FUN_100051f0(&DAT_100481c8,0,0);
    }
    if (DAT_100481cc != 0x68747541) {
      return 0;
    }
    if (DAT_100481d0 != 0x444d4163) {
      return 0;
    }
    if (DAT_100481d4 != 0x69746e65) {
      return 0;
    }
  }
  pvVar1 = GetCurrentProcess();
  uVar2 = GetProcessAffinityMask(pvVar1,&local_8,&local_c);
  if (uVar2 == 0) {
    return 0;
  }
  if (local_8 != local_c) {
    BVar3 = SetProcessAffinityMask(pvVar1,local_c);
    if (BVar3 == 0) {
      return 0;
    }
    uVar2 = SetProcessAffinityMask(pvVar1,local_8);
  }
  if (uVar2 == 0) {
    return 0;
  }
  if (local_c < 2) {
    return uVar2;
  }
  pvVar1 = GetCurrentThread();
  DVar4 = SetThreadAffinityMask(pvVar1,local_8);
  if (DVar4 == 0) {
    return 0;
  }
  DVar4 = SetThreadAffinityMask(pvVar1,DVar4);
  return (uint)(DVar4 != 0);
}



uint FUN_10004f80(void)

{
  HANDLE hProcess;
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  uint *lpProcessAffinityMask;
  uint *lpSystemAffinityMask;
  byte local_30;
  undefined local_2f [16];
  undefined8 local_1f;
  undefined4 local_17;
  undefined2 local_13;
  undefined local_11;
  uint local_10;
  int local_c;
  uint local_8;
  
  lpSystemAffinityMask = &local_10;
  lpProcessAffinityMask = &local_8;
  hProcess = GetCurrentProcess();
  GetProcessAffinityMask(hProcess,lpProcessAffinityMask,lpSystemAffinityMask);
  uVar4 = 0;
  local_30 = 0;
  uVar3 = 0;
  local_1f = 0;
  local_2f = ZEXT816(0);
  local_17 = 0;
  local_13 = 0;
  local_11 = 0;
  local_10 = (uint)*(byte *)(local_c + 0x24);
  if (*(byte *)(local_c + 0x24) != 0) {
    uVar5 = 1;
    uVar2 = local_8;
    do {
      if ((uVar2 & uVar5) != 0) {
        uVar1 = 0;
        if (uVar4 != 0) {
          do {
            if (local_2f[uVar1 - 1] ==
                (byte)(((*(byte *)(local_c + 0x2c) | *(byte *)(local_c + 0x2a)) &
                       *(byte *)(local_c + 4 + uVar3)) >> (*(byte *)(local_c + 0x27) & 0x1f)))
            break;
            uVar1 = uVar1 + 1;
          } while (uVar1 < uVar4);
        }
        uVar2 = local_8;
        if (uVar1 == uVar4) {
          uVar4 = uVar4 + 1;
          local_2f[uVar1 - 1] =
               ((*(byte *)(local_c + 0x2c) | *(byte *)(local_c + 0x2a)) &
               *(byte *)(local_c + 4 + uVar3)) >> (*(byte *)(local_c + 0x27) & 0x1f);
          uVar2 = local_8;
        }
      }
      uVar3 = uVar3 + 1;
      uVar5 = uVar5 << 1 | (uint)((int)uVar5 < 0);
    } while (uVar3 < local_10);
  }
  return uVar4;
}



undefined4 FUN_10005040(void)

{
  return 1;
}



int __fastcall FUN_10005050(int param_1)

{
  HANDLE hProcess;
  int iVar1;
  int iVar2;
  int iVar3;
  uint *lpProcessAffinityMask;
  ULONG_PTR *lpSystemAffinityMask;
  ULONG_PTR local_c;
  uint local_8;
  
  lpSystemAffinityMask = &local_c;
  lpProcessAffinityMask = &local_8;
  hProcess = GetCurrentProcess();
  GetProcessAffinityMask(hProcess,lpProcessAffinityMask,lpSystemAffinityMask);
  iVar3 = *(int *)(param_1 + 8);
  iVar1 = 0;
  if (iVar3 != 0) {
    iVar2 = 0;
    do {
      if ((*(int *)(iVar2 + 4 + *(int *)(param_1 + 4)) == 0) &&
         ((*(uint *)(iVar2 + *(int *)(param_1 + 4)) & local_8) != 0)) {
        iVar1 = iVar1 + 1;
      }
      iVar2 = iVar2 + 0x18;
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
  }
  return iVar1;
}



void __fastcall FUN_100050a0(int **param_1)

{
                    // WARNING: Could not recover jumptable at 0x100050a4. Too many branches
                    // WARNING: Treating indirect jump as call
  (**(code **)(**param_1 + 0xc))();
  return;
}



void __fastcall FUN_100050b0(int param_1)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  byte local_28;
  undefined local_27 [16];
  undefined8 local_17;
  undefined4 local_f;
  undefined2 local_b;
  undefined local_9;
  uint local_8;
  
  local_28 = 0;
  local_f = 0;
  uVar2 = 0;
  local_17 = 0;
  uVar5 = 0;
  local_b = 0;
  uVar3 = (uint)*(byte *)(param_1 + 0x24);
  local_9 = 0;
  local_8 = uVar3;
  local_27 = ZEXT816(0);
  if (uVar3 != 0) {
    do {
      uVar1 = local_8;
      uVar4 = 0;
      if (uVar2 != 0) {
        do {
          uVar3 = local_8;
          if (local_27[uVar4 - 1] ==
              (byte)(((*(byte *)(param_1 + 0x2c) | *(byte *)(param_1 + 0x2a)) &
                     *(byte *)(param_1 + 4 + uVar5)) >> (*(byte *)(param_1 + 0x27) & 0x1f))) break;
          uVar4 = uVar4 + 1;
        } while (uVar4 < uVar2);
      }
      if (uVar4 == uVar2) {
        uVar2 = uVar2 + 1;
        local_27[uVar4 - 1] =
             ((*(byte *)(param_1 + 0x2c) | *(byte *)(param_1 + 0x2a)) &
             *(byte *)(param_1 + 4 + uVar5)) >> (*(byte *)(param_1 + 0x27) & 0x1f);
        uVar3 = uVar1;
      }
      uVar5 = uVar5 + 1;
    } while (uVar5 < uVar3);
  }
  return;
}



int __fastcall FUN_10005140(int param_1)

{
  int iVar1;
  int *piVar2;
  int iVar3;
  
  iVar3 = *(int *)(param_1 + 8);
  iVar1 = 0;
  if (iVar3 != 0) {
    piVar2 = (int *)(*(int *)(param_1 + 4) + 4);
    do {
      if (*piVar2 == 0) {
        iVar1 = iVar1 + 1;
      }
      piVar2 = piVar2 + 6;
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
  }
  return iVar1;
}



void __thiscall FUN_10005160(void *this,byte param_1,byte param_2)

{
  byte bVar1;
  char cVar2;
  byte bVar3;
  
  *(byte *)this = param_1;
  *(byte *)((int)this + 1) = param_2;
  if (param_1 < param_2) {
    *(byte *)((int)this + 1) = param_1;
  }
  bVar3 = 8;
  bVar1 = 0x80;
  do {
    if (((char)((ulonglong)param_1 / (ulonglong)(longlong)(int)(uint)*(byte *)((int)this + 1)) - 1U
        & bVar1) != 0) break;
    bVar3 = bVar3 - 1;
    bVar1 = bVar1 >> 1;
  } while (bVar1 != 0);
  *(byte *)((int)this + 2) = bVar3;
  cVar2 = '\b';
  bVar1 = 0x80;
  do {
    if ((*(byte *)((int)this + 1) - 1 & bVar1) != 0) break;
    cVar2 = cVar2 + -1;
    bVar1 = bVar1 >> 1;
  } while (bVar1 != 0);
  *(char *)((int)this + 4) = cVar2;
  *(byte *)((int)this + 6) = ('\b' - cVar2) - bVar3;
  bVar1 = -1 << (cVar2 + bVar3 & 0x1f);
  bVar3 = -1 << (bVar3 & 0x1f);
  *(byte *)((int)this + 7) = bVar1;
  *(byte *)((int)this + 3) = ~bVar3;
  *(byte *)((int)this + 5) = bVar3 ^ bVar1;
  return;
}



void __thiscall FUN_100051f0(void *this,uint param_1,uint param_2)

{
  undefined4 *puVar1;
  uint uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  
  uVar2 = param_2 | param_1;
  if (uVar2 == 0) {
    puVar1 = (undefined4 *)cpuid_basic_info(0);
  }
  else if (uVar2 == 1) {
    puVar1 = (undefined4 *)cpuid_Version_info(1);
  }
  else if (uVar2 == 2) {
    puVar1 = (undefined4 *)cpuid_cache_tlb_info(2);
  }
  else if (uVar2 == 3) {
    puVar1 = (undefined4 *)cpuid_serial_info(3);
  }
  else if (uVar2 == 4) {
    puVar1 = (undefined4 *)cpuid_Deterministic_Cache_Parameters_info(4);
  }
  else if (uVar2 == 5) {
    puVar1 = (undefined4 *)cpuid_MONITOR_MWAIT_Features_info(5);
  }
  else if (uVar2 == 6) {
    puVar1 = (undefined4 *)cpuid_Thermal_Power_Management_info(6);
  }
  else if (uVar2 == 7) {
    puVar1 = (undefined4 *)cpuid_Extended_Feature_Enumeration_info(7);
  }
  else if (uVar2 == 9) {
    puVar1 = (undefined4 *)cpuid_Direct_Cache_Access_info(9);
  }
  else if (uVar2 == 10) {
    puVar1 = (undefined4 *)cpuid_Architectural_Performance_Monitoring_info(10);
  }
  else if (uVar2 == 0xb) {
    puVar1 = (undefined4 *)cpuid_Extended_Topology_info(0xb);
  }
  else if (uVar2 == 0xd) {
    puVar1 = (undefined4 *)cpuid_Processor_Extended_States_info(0xd);
  }
  else if (uVar2 == 0xf) {
    puVar1 = (undefined4 *)cpuid_Quality_of_Service_info(0xf);
  }
  else if (uVar2 == 0x80000002) {
    puVar1 = (undefined4 *)cpuid_brand_part1_info(0x80000002);
  }
  else if (uVar2 == 0x80000003) {
    puVar1 = (undefined4 *)cpuid_brand_part2_info(0x80000003);
  }
  else if (uVar2 == 0x80000004) {
    puVar1 = (undefined4 *)cpuid_brand_part3_info(0x80000004);
  }
  else {
    puVar1 = (undefined4 *)cpuid(uVar2);
  }
  uVar5 = puVar1[1];
  uVar4 = puVar1[2];
  uVar3 = puVar1[3];
  *(undefined4 *)this = *puVar1;
  *(undefined4 *)((int)this + 4) = uVar5;
  *(undefined4 *)((int)this + 8) = uVar3;
  *(undefined4 *)((int)this + 0xc) = uVar4;
  return;
}



FARPROC FUN_10005220(void)

{
  HMODULE hModule;
  FARPROC pFVar1;
  int iVar2;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 local_a4;
  uint local_a0;
  undefined4 local_9c;
  undefined4 local_10;
  FARPROC local_8;
  
  hModule = GetModuleHandleA("kernel32");
  local_8 = GetProcAddress(hModule,"VerifyVersionInfoA");
  if (local_8 != (FARPROC)0x0) {
    pFVar1 = GetProcAddress(hModule,"VerSetConditionMask");
    local_a4 = 0x9c;
    FUN_10021290(&local_a0,0,0x98);
    local_a0 = 6;
    local_9c = 0;
    local_10 = 0;
    iVar2 = (*pFVar1)(0,0,2,3);
    iVar2 = (*pFVar1)(iVar2,extraout_EDX,1,3);
    iVar2 = (*pFVar1)(iVar2,extraout_EDX_00,0x20,3);
    iVar2 = (*pFVar1)(iVar2,extraout_EDX_01,0x10,3);
    iVar2 = (*local_8)(&local_a4,0x33,iVar2,extraout_EDX_02);
    if (iVar2 != 0) {
      pFVar1 = GetProcAddress(hModule,"GetLogicalProcessorInformation");
      return pFVar1;
    }
  }
  return (FARPROC)0x0;
}



// public: __thiscall CVProfNode::CVProfNode(char const *,int,class CVProfNode *,char const *,int)

CVProfNode * __thiscall
CVProfNode::CVProfNode
          (CVProfNode *this,char *param_1,int param_2,CVProfNode *param_3,char *param_4,int param_5)

{
  int iVar1;
  
                    // 0x52e0  22  ??0CVProfNode@@QAE@PBDHPAV0@0H@Z
  *(char **)this = param_1;
  *(undefined4 *)(this + 8) = 0;
  *(undefined4 *)(this + 0xc) = 0;
  FUN_10011270((int *)(this + 0x20));
  *(undefined4 *)(this + 0x40) = 0;
  *(undefined4 *)(this + 0x44) = 0;
  *(undefined4 *)(this + 0x48) = 0;
  *(undefined4 *)(this + 0x4c) = 0;
  *(undefined4 *)(this + 0x50) = 0;
  *(undefined4 *)(this + 0x58) = 0;
  *(undefined4 *)(this + 0x5c) = 0;
  *(undefined4 *)(this + 0x68) = 0;
  *(undefined4 *)(this + 0x6c) = 0;
  *(undefined4 *)(this + 0x70) = 0;
  *(undefined4 *)(this + 0x74) = 0;
  *(CVProfNode **)(this + 0x78) = param_3;
  *(undefined4 *)(this + 0x7c) = 0;
  *(undefined4 *)(this + 0x80) = 0;
  *(undefined4 *)(this + 0x88) = 0xffffffff;
  *(int *)(this + 0x8c) = s_iCurrentUniqueNodeID;
  s_iCurrentUniqueNodeID = s_iCurrentUniqueNodeID + 1;
  if (*(int *)(this + 0x8c) < 1) {
    *(undefined4 *)(this + 0x84) = 0;
  }
  else {
    iVar1 = CVProfile::BudgetGroupNameToBudgetGroupID
                      ((CVProfile *)&g_VProfCurrentProfile,param_4,param_5);
    *(int *)(this + 0x84) = iVar1;
  }
  Reset(this);
  if ((*(int *)(this + 0x78) != 0) && (*(int *)(this + 0x84) == 0)) {
    *(undefined4 *)(this + 0x84) = *(undefined4 *)(*(int *)(this + 0x78) + 0x84);
  }
  return this;
}



// public: class CVProfNode & __thiscall CVProfNode::operator=(class CVProfNode const &)

CVProfNode * __thiscall CVProfNode::operator_(CVProfNode *this,CVProfNode *param_1)

{
  int iVar1;
  undefined4 *puVar2;
  
                    // 0x53e0  54  ??4CVProfNode@@QAEAAV0@ABV0@@Z
  puVar2 = (undefined4 *)this;
  for (iVar1 = 0x24; iVar1 != 0; iVar1 = iVar1 + -1) {
    *puVar2 = *(undefined4 *)param_1;
    param_1 = (CVProfNode *)((int)param_1 + 4);
    puVar2 = puVar2 + 1;
  }
  return this;
}



// public: class CVProfile & __thiscall CVProfile::operator=(class CVProfile const &)

CVProfile * __thiscall CVProfile::operator_(CVProfile *this,CVProfile *param_1)

{
                    // 0x5400  55  ??4CVProfile@@QAEAAV0@ABV0@@Z
  FID_conflict__memcpy(this,param_1,0x19d0);
  return this;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Unable to track spacebase fully for stack

void __cdecl FUN_10005420(char *param_1,uint param_2,int param_3)

{
  char cVar1;
  int iVar2;
  char *pcVar3;
  int aiStackY80 [3];
  char *pcStackY68;
  undefined local_34 [8];
  undefined4 local_2c;
  undefined *local_28;
  int local_24;
  char *local_20;
  undefined *local_1c;
  int local_18;
  char *local_14;
  char *local_10;
  int local_c;
  char local_5;
  
  if (0 < param_3) {
    local_10 = param_1;
    local_20 = param_1 + 1;
    do {
      local_5 = *local_10;
      local_10 = local_10 + 1;
    } while (local_5 != '\0');
    local_24 = (int)local_10 - (int)local_20;
    param_1 = param_1 + local_24;
    param_2 = param_2 - local_24;
    if (0x20 < (int)param_2) {
      if ((0 < local_24) && (param_1[-1] == '\n')) {
        param_1 = param_1 + -1;
        param_2 = param_2 + 1;
      }
      pcStackY68 = (char *)0x100054bb;
      local_18 = local_24;
      local_c = FUN_1002169d(param_1,param_2,(byte *)"\nCall Stack:\n\t");
      iVar2 = -(param_3 * 4 + 0xfU & 0xfffffff0);
      local_28 = local_34 + iVar2;
      local_1c = local_34 + iVar2;
      *(undefined4 *)(&stack0xffffffc8 + iVar2) = 2;
      *(int *)(&stack0xffffffc4 + iVar2) = param_3;
      *(undefined **)(&stack0xffffffc0 + iVar2) = local_1c;
      *(undefined4 *)((int)&pcStackY68 + iVar2) = 0x100054eb;
      local_2c = GetCallStack(*(int *)(&stack0xffffffc0 + iVar2),*(int *)(&stack0xffffffc4 + iVar2),
                              *(int *)(&stack0xffffffc8 + iVar2));
      *(undefined4 *)(&stack0xffffffc8 + iVar2) = 0x27;
      *(undefined **)(&stack0xffffffc4 + iVar2) = &DAT_100367fc;
      *(uint *)(&stack0xffffffc0 + iVar2) = param_2 - local_c;
      *(char **)((int)&pcStackY68 + iVar2) = param_1 + local_c;
      *(undefined4 *)((int)aiStackY80 + iVar2 + 8) = local_2c;
      *(undefined **)((int)aiStackY80 + iVar2 + 4) = local_1c;
      *(undefined4 *)((int)aiStackY80 + iVar2) = 0x10005513;
      iVar2 = TranslateStackInfo(*(int *)((int)aiStackY80 + iVar2 + 4),
                                 *(int *)((int)aiStackY80 + iVar2 + 8),
                                 *(undefined2 **)((int)&pcStackY68 + iVar2),
                                 *(size_t *)(&stack0xffffffc0 + iVar2),
                                 *(char **)(&stack0xffffffc4 + iVar2),
                                 *(uint *)(&stack0xffffffc8 + iVar2));
      if (iVar2 == 0) {
        *param_1 = '\0';
      }
      else {
        local_14 = param_1 + local_c;
        pcVar3 = local_14 + 1;
        do {
          cVar1 = *local_14;
          local_14 = local_14 + 1;
        } while (cVar1 != '\0');
        local_14 = local_14 + (local_c - (int)pcVar3);
        if ((int)local_14 < (int)param_2) {
          param_1[(int)local_14] = '\n';
          param_1[(int)(local_14 + 1)] = '\0';
        }
      }
    }
  }
  return;
}



// public: bool __thiscall CVProfile::AtRoot(void)const 

bool __thiscall CVProfile::AtRoot(CVProfile *this)

{
                    // 0x5590  75  ?AtRoot@CVProfile@@QBE_NXZ
  return (bool)this[0x1010];
}



// public: int __thiscall CVProfile::BudgetGroupNameToBudgetGroupIDNoCreate(char const *)

int __thiscall CVProfile::BudgetGroupNameToBudgetGroupIDNoCreate(CVProfile *this,char *param_1)

{
  int iVar1;
  
                    // 0x55a0  79  ?BudgetGroupNameToBudgetGroupIDNoCreate@CVProfile@@QAEHPBD@Z
  iVar1 = FindBudgetGroupName(this,param_1);
  return iVar1;
}



// public: void __thiscall CVProfNode::ClearPrevTime(void)

void __thiscall CVProfNode::ClearPrevTime(CVProfNode *this)

{
                    // 0x55b0  86  ?ClearPrevTime@CVProfNode@@QAEXXZ
  *(undefined4 *)(this + 0x58) = 0;
  *(undefined4 *)(this + 0x5c) = 0;
  return;
}



// void __cdecl ConColorMsg(class Color const &,char const *,...)

void __cdecl ConColorMsg(Color *param_1,char *param_2,...)

{
  uint uVar1;
  char local_80c [2048];
  int **local_c;
  undefined4 *local_8;
  
  do {
    local_8 = FUN_10008430();
    uVar1 = FUN_10005df0(local_8,DAT_100483d8,0);
    if ((uVar1 & 0xff) != 0) {
      local_c = (int **)&stack0x0000000c;
      FUN_10021749(local_80c,0x800,(byte *)param_2,local_c);
      local_c = (int **)0x0;
      FUN_10005420(local_80c,0x800,0);
      FUN_100084c0(local_8,DAT_100483d8,0,*(int *)param_1,local_80c);
    }
  } while (false);
  return;
}



// void __cdecl ConMsg(char const *,...)

void __cdecl ConMsg(char *param_1,...)

{
  uint uVar1;
  int *piVar2;
  char *pcVar3;
  char local_810 [2048];
  undefined4 local_10;
  int **local_c;
  undefined4 *local_8;
  
  do {
    local_8 = FUN_10008430();
    uVar1 = FUN_10005df0(local_8,DAT_100483d8,0);
    if ((uVar1 & 0xff) != 0) {
      local_c = (int **)&stack0x00000008;
      FUN_10021749(local_810,0x800,(byte *)param_1,local_c);
      local_c = (int **)0x0;
      FUN_10005420(local_810,0x800,0);
      pcVar3 = local_810;
      piVar2 = (int *)FUN_100059e0(local_8,&local_10,DAT_100483d8);
      FUN_100084c0(local_8,DAT_100483d8,0,*piVar2,pcVar3);
    }
  } while (false);
  return;
}



// void __cdecl DevMsg(char const *,...)

void __cdecl DevMsg(char *param_1,...)

{
  uint uVar1;
  int *piVar2;
  char *pcVar3;
  char local_810 [2048];
  undefined4 local_10;
  int **local_c;
  undefined4 *local_8;
  
  do {
    local_8 = FUN_10008430();
    uVar1 = FUN_10005df0(local_8,DAT_100483dc,0);
    if ((uVar1 & 0xff) != 0) {
      local_c = (int **)&stack0x00000008;
      FUN_10021749(local_810,0x800,(byte *)param_1,local_c);
      local_c = (int **)0x0;
      FUN_10005420(local_810,0x800,0);
      pcVar3 = local_810;
      piVar2 = (int *)FUN_100059e0(local_8,&local_10,DAT_100483dc);
      FUN_100084c0(local_8,DAT_100483dc,0,*piVar2,pcVar3);
    }
  } while (false);
  return;
}



// void __cdecl DevWarning(char const *,...)

void __cdecl DevWarning(char *param_1,...)

{
  uint uVar1;
  int *piVar2;
  char *pcVar3;
  char local_810 [2048];
  undefined4 local_10;
  int **local_c;
  undefined4 *local_8;
  
  do {
    local_8 = FUN_10008430();
    uVar1 = FUN_10005df0(local_8,DAT_100483dc,1);
    if ((uVar1 & 0xff) != 0) {
      local_c = (int **)&stack0x00000008;
      FUN_10021749(local_810,0x800,(byte *)param_1,local_c);
      local_c = (int **)0x0;
      FUN_10005420(local_810,0x800,0);
      pcVar3 = local_810;
      piVar2 = (int *)FUN_100059e0(local_8,&local_10,DAT_100483dc);
      FUN_100084c0(local_8,DAT_100483dc,1,*piVar2,pcVar3);
    }
  } while (false);
  return;
}



// public: void __thiscall CVProfile::DisableVTuneGroup(void)

void __thiscall CVProfile::DisableVTuneGroup(CVProfile *this)

{
                    // 0x5860  92  ?DisableVTuneGroup@CVProfile@@QAEXXZ
  *this = (CVProfile)0x0;
  return;
}



// public: void __thiscall CVProfile::EnableVTuneGroup(char const *)

void __thiscall CVProfile::EnableVTuneGroup(CVProfile *this,char *param_1)

{
  int iVar1;
  
                    // 0x5870  94  ?EnableVTuneGroup@CVProfile@@QAEXPBD@Z
  iVar1 = BudgetGroupNameToBudgetGroupID(this,param_1);
  *(int *)(this + 4) = iVar1;
  *this = (CVProfile)0x1;
  return;
}



// public: void __thiscall CVProfile::EnterScope(char const *,int,char const *,bool)

void __thiscall
CVProfile::EnterScope(CVProfile *this,char *param_1,int param_2,char *param_3,bool param_4)

{
                    // 0x5890  96  ?EnterScope@CVProfile@@QAEXPBDH0_N@Z
  EnterScope(this,param_1,param_2,param_3,param_4,4);
  return;
}



// public: void __thiscall CVProfile::EnterScope(char const *,int,char const *,bool,int)

void __thiscall
CVProfile::EnterScope
          (CVProfile *this,char *param_1,int param_2,char *param_3,bool param_4,int param_5)

{
  uint *puVar1;
  DWORD DVar2;
  CVProfNode *pCVar3;
  
                    // 0x58b0  97  ?EnterScope@CVProfile@@QAEXPBDH0_NH@Z
  if ((*(int *)(this + 0x100c) != 0) || (this[0x1010] == (CVProfile)0x0)) {
    DVar2 = GetCurrentThreadId();
    if (*(DWORD *)(this + 0x19cc) == DVar2) {
      if (param_1 != **(char ***)(this + 0x1014)) {
        pCVar3 = CVProfNode::GetSubNode
                           ((CVProfNode *)*(char ***)(this + 0x1014),param_1,param_2,param_3,param_5
                           );
        *(CVProfNode **)(this + 0x1014) = pCVar3;
      }
      puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + *(int *)(*(int *)(this + 0x1014) + 0x84) * 8);
      *puVar1 = *puVar1 | param_5;
      CVProfNode::EnterScope(*(CVProfNode **)(this + 0x1014));
      this[0x1010] = (CVProfile)0x0;
    }
  }
  return;
}



// public: void __thiscall CVProfile::ExitScope(void)

void __thiscall CVProfile::ExitScope(CVProfile *this)

{
  bool bVar1;
  DWORD DVar2;
  
                    // 0x5930  99  ?ExitScope@CVProfile@@QAEXXZ
  if ((this[0x1010] == (CVProfile)0x0) || (*(int *)(this + 0x100c) != 0)) {
    DVar2 = GetCurrentThreadId();
    if (*(DWORD *)(this + 0x19cc) == DVar2) {
      bVar1 = CVProfNode::ExitScope(*(CVProfNode **)(this + 0x1014));
      if (bVar1) {
        *(undefined4 *)(this + 0x1014) = *(undefined4 *)(*(int *)(this + 0x1014) + 0x78);
      }
      this[0x1010] = (CVProfile)(*(CVProfile **)(this + 0x1014) == this + 0x1018);
    }
  }
  return;
}



// public: int __thiscall CVProfile::GetBudgetGroupFlags(int)const 

int __thiscall CVProfile::GetBudgetGroupFlags(CVProfile *this,int param_1)

{
                    // 0x5990  106  ?GetBudgetGroupFlags@CVProfile@@QBEHH@Z
  return *(int *)(*(int *)(this + 0x10b4) + 4 + param_1 * 8);
}



// public: int __thiscall CVProfNode::GetBudgetGroupID(void)

int __thiscall CVProfNode::GetBudgetGroupID(CVProfNode *this)

{
                    // 0x59b0  107  ?GetBudgetGroupID@CVProfNode@@QAEHXZ
  return *(int *)(this + 0x84);
}



// public: char const * __thiscall CVProfile::GetBudgetGroupName(int)

char * __thiscall CVProfile::GetBudgetGroupName(CVProfile *this,int param_1)

{
                    // 0x59c0  108  ?GetBudgetGroupName@CVProfile@@QAEPBDH@Z
  return *(char **)(*(int *)(this + 0x10b4) + param_1 * 8);
}



void __thiscall FUN_100059e0(void *this,undefined4 *param_1,int param_2)

{
  int iVar1;
  
  iVar1 = FUN_10008420(this,param_2);
  *param_1 = *(undefined4 *)(iVar1 + 0xc);
  return;
}



// public: class CVProfNode * __thiscall CVProfNode::GetChild(void)

CVProfNode * __thiscall CVProfNode::GetChild(CVProfNode *this)

{
                    // 0x5a00  111  ?GetChild@CVProfNode@@QAEPAV1@XZ
  return *(CVProfNode **)(this + 0x7c);
}



// public: int __thiscall CVProfNode::GetClientData(void)const 

int __thiscall CVProfNode::GetClientData(CVProfNode *this)

{
                    // 0x5a10  112  ?GetClientData@CVProfNode@@QBEHXZ
  return *(int *)(this + 0x88);
}



// public: unsigned int __thiscall CVProfNode::GetCurCalls(void)

uint __thiscall CVProfNode::GetCurCalls(CVProfNode *this)

{
                    // 0x5a20  117  ?GetCurCalls@CVProfNode@@QAEIXZ
  return *(uint *)(this + 0x44);
}



// public: double __thiscall CVProfNode::GetCurTime(void)

double __thiscall CVProfNode::GetCurTime(CVProfNode *this)

{
  double in_XMM0_Qa;
  
                    // 0x5a30  118  ?GetCurTime@CVProfNode@@QAENXZ
  FUN_10001a1e(*(undefined4 *)(this + 0x48),*(uint *)(this + 0x4c));
  return in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
}



// public: double __thiscall CVProfNode::GetCurTimeLessChildren(void)

double __thiscall CVProfNode::GetCurTimeLessChildren(CVProfNode *this)

{
  int iVar1;
  double in_XMM0_Qa;
  double dVar2;
  
                    // 0x5a60  119  ?GetCurTimeLessChildren@CVProfNode@@QAENXZ
  FUN_10001a1e(*(undefined4 *)(this + 0x48),*(uint *)(this + 0x4c));
  in_XMM0_Qa = in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
  dVar2 = in_XMM0_Qa;
  for (iVar1 = *(int *)(this + 0x7c); iVar1 != 0; iVar1 = *(int *)(iVar1 + 0x80)) {
    FUN_10001a1e(*(undefined4 *)(iVar1 + 0x48),*(uint *)(iVar1 + 0x4c));
    in_XMM0_Qa = in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
    dVar2 = dVar2 - in_XMM0_Qa;
  }
  return dVar2;
}



// public: class CVProfNode * __thiscall CVProfile::GetCurrentNode(void)

CVProfNode * __thiscall CVProfile::GetCurrentNode(CVProfile *this)

{
                    // 0x5ad0  121  ?GetCurrentNode@CVProfile@@QAEPAVCVProfNode@@XZ
  return *(CVProfNode **)(this + 0x1014);
}



// public: int __thiscall CVProfile::GetDetailLevel(void)const 

int __thiscall CVProfile::GetDetailLevel(CVProfile *this)

{
                    // 0x5ae0  122  ?GetDetailLevel@CVProfile@@QBEHXZ
  return *(int *)(this + 0x10ac);
}



// public: int __thiscall CVProfNode::GetL2CacheMisses(void)

int __thiscall CVProfNode::GetL2CacheMisses(CVProfNode *this)

{
                    // 0x5af0  124  ?GetL2CacheMisses@CVProfNode@@QAEHXZ
  return *(int *)(this + 0x38);
}



// public: double __thiscall CVProfile::GetPeakFrameTime(void)

double __thiscall CVProfile::GetPeakFrameTime(CVProfile *this)

{
  double in_XMM0_Qa;
  
                    // 0x5b00  132  ?GetPeakFrameTime@CVProfile@@QAENXZ
  FUN_10001a1e(*(undefined4 *)(this + 0x1088),*(uint *)(this + 0x108c));
  return in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
}



// public: double __thiscall CVProfNode::GetPeakTime(void)

double __thiscall CVProfNode::GetPeakTime(CVProfNode *this)

{
  double in_XMM0_Qa;
  
                    // 0x5b30  133  ?GetPeakTime@CVProfNode@@QAENXZ
  FUN_10001a1e(*(undefined4 *)(this + 0x70),*(uint *)(this + 0x74));
  return in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
}



// public: unsigned int __thiscall CVProfNode::GetPrevCalls(void)

uint __thiscall CVProfNode::GetPrevCalls(CVProfNode *this)

{
                    // 0x5b60  134  ?GetPrevCalls@CVProfNode@@QAEIXZ
  return *(uint *)(this + 0x50);
}



// public: int __thiscall CVProfNode::GetPrevL2CacheMissLessChildren(void)

int __thiscall CVProfNode::GetPrevL2CacheMissLessChildren(CVProfNode *this)

{
  int iVar1;
  int iVar2;
  
                    // 0x5b70  135  ?GetPrevL2CacheMissLessChildren@CVProfNode@@QAEHXZ
  iVar2 = *(int *)(this + 0x10);
  for (iVar1 = *(int *)(this + 0x7c); iVar1 != 0; iVar1 = *(int *)(iVar1 + 0x80)) {
    iVar2 = iVar2 - *(int *)(iVar1 + 0x10);
  }
  return iVar2;
}



// public: class CVProfNode * __thiscall CVProfNode::GetPrevSibling(void)

CVProfNode * __thiscall CVProfNode::GetPrevSibling(CVProfNode *this)

{
  CVProfNode *pCVar1;
  CVProfNode *pCVar2;
  
                    // 0x5b90  137  ?GetPrevSibling@CVProfNode@@QAEPAV1@XZ
  pCVar1 = *(CVProfNode **)(this + 0x78);
  if (pCVar1 == (CVProfNode *)0x0) {
    return pCVar1;
  }
  pCVar1 = *(CVProfNode **)(pCVar1 + 0x7c);
  do {
    pCVar2 = pCVar1;
    if (pCVar2 == (CVProfNode *)0x0) {
      return (CVProfNode *)0x0;
    }
    pCVar1 = *(CVProfNode **)(pCVar2 + 0x80);
  } while (*(CVProfNode **)(pCVar2 + 0x80) != this);
  return pCVar2;
}



// public: double __thiscall CVProfNode::GetPrevTime(void)

double __thiscall CVProfNode::GetPrevTime(CVProfNode *this)

{
  double in_XMM0_Qa;
  
                    // 0x5bc0  138  ?GetPrevTime@CVProfNode@@QAENXZ
  FUN_10001a1e(*(undefined4 *)(this + 0x58),*(uint *)(this + 0x5c));
  return in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
}



// public: double __thiscall CVProfNode::GetPrevTimeLessChildren(void)

double __thiscall CVProfNode::GetPrevTimeLessChildren(CVProfNode *this)

{
  int iVar1;
  double in_XMM0_Qa;
  double dVar2;
  
                    // 0x5bf0  139  ?GetPrevTimeLessChildren@CVProfNode@@QAENXZ
  FUN_10001a1e(*(undefined4 *)(this + 0x58),*(uint *)(this + 0x5c));
  in_XMM0_Qa = in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
  dVar2 = in_XMM0_Qa;
  for (iVar1 = *(int *)(this + 0x7c); iVar1 != 0; iVar1 = *(int *)(iVar1 + 0x80)) {
    FUN_10001a1e(*(undefined4 *)(iVar1 + 0x58),*(uint *)(iVar1 + 0x5c));
    in_XMM0_Qa = in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
    dVar2 = dVar2 - in_XMM0_Qa;
  }
  return dVar2;
}



// public: class CVProfNode * __thiscall CVProfile::GetRoot(void)

CVProfNode * __thiscall CVProfile::GetRoot(CVProfile *this)

{
                    // 0x5c60  142  ?GetRoot@CVProfile@@QAEPAVCVProfNode@@XZ
  return (CVProfNode *)(this + 0x1018);
}



// public: class CVProfNode * __thiscall CVProfNode::GetSibling(void)

CVProfNode * __thiscall CVProfNode::GetSibling(CVProfNode *this)

{
                    // 0x5c70  143  ?GetSibling@CVProfNode@@QAEPAV1@XZ
  return *(CVProfNode **)(this + 0x80);
}



// public: unsigned int __thiscall CVProfile::GetTargetThreadId(void)

uint __thiscall CVProfile::GetTargetThreadId(CVProfile *this)

{
                    // 0x5c80  146  ?GetTargetThreadId@CVProfile@@QAEIXZ
  return *(uint *)(this + 0x19cc);
}



// public: double __thiscall CVProfile::GetTimeLastFrame(void)

double __thiscall CVProfile::GetTimeLastFrame(CVProfile *this)

{
  double in_XMM0_Qa;
  
                    // 0x5c90  151  ?GetTimeLastFrame@CVProfile@@QAENXZ
  FUN_10001a1e(*(undefined4 *)(this + 0x1060),*(uint *)(this + 0x1064));
  return in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
}



// public: unsigned int __thiscall CVProfNode::GetTotalCalls(void)

uint __thiscall CVProfNode::GetTotalCalls(CVProfNode *this)

{
                    // 0x5cc0  152  ?GetTotalCalls@CVProfNode@@QAEIXZ
  return *(uint *)(this + 0x60);
}



// public: double __thiscall CVProfNode::GetTotalTime(void)

double __thiscall CVProfNode::GetTotalTime(CVProfNode *this)

{
  double in_XMM0_Qa;
  
                    // 0x5cd0  153  ?GetTotalTime@CVProfNode@@QAENXZ
  FUN_10001a1e(*(undefined4 *)(this + 0x68),*(uint *)(this + 0x6c));
  return in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
}



// public: double __thiscall CVProfNode::GetTotalTimeLessChildren(void)

double __thiscall CVProfNode::GetTotalTimeLessChildren(CVProfNode *this)

{
  int iVar1;
  double in_XMM0_Qa;
  double dVar2;
  
                    // 0x5d00  154  ?GetTotalTimeLessChildren@CVProfNode@@QAENXZ
  FUN_10001a1e(*(undefined4 *)(this + 0x68),*(uint *)(this + 0x6c));
  in_XMM0_Qa = in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
  dVar2 = in_XMM0_Qa;
  for (iVar1 = *(int *)(this + 0x7c); iVar1 != 0; iVar1 = *(int *)(iVar1 + 0x80)) {
    FUN_10001a1e(*(undefined4 *)(iVar1 + 0x68),*(uint *)(iVar1 + 0x6c));
    in_XMM0_Qa = in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
    dVar2 = dVar2 - in_XMM0_Qa;
  }
  return dVar2;
}



// public: double __thiscall CVProfile::GetTotalTimeSampled(void)

double __thiscall CVProfile::GetTotalTimeSampled(CVProfile *this)

{
  double in_XMM0_Qa;
  
                    // 0x5d70  155  ?GetTotalTimeSampled@CVProfile@@QAENXZ
  FUN_10001a1e(*(undefined4 *)(this + 0x1080),*(uint *)(this + 0x1084));
  return in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
}



// private: int __thiscall CVProfNode::GetUniqueNodeID(void)const 

int __thiscall CVProfNode::GetUniqueNodeID(CVProfNode *this)

{
                    // 0x5da0  156  ?GetUniqueNodeID@CVProfNode@@ABEHXZ
  return *(int *)(this + 0x8c);
}



// public: void __thiscall CVProfile::HideBudgetGroup(char const *,bool)

void __thiscall CVProfile::HideBudgetGroup(CVProfile *this,char *param_1,bool param_2)

{
  int iVar1;
  
                    // 0x5db0  158  ?HideBudgetGroup@CVProfile@@QAEXPBD_N@Z
  iVar1 = BudgetGroupNameToBudgetGroupID(this,param_1);
  HideBudgetGroup(this,iVar1,param_2);
  return;
}



// public: bool __thiscall CVProfile::InTargetThread(void)

bool __thiscall CVProfile::InTargetThread(CVProfile *this)

{
  DWORD DVar1;
  
                    // 0x5dd0  159  ?InTargetThread@CVProfile@@QAE_NXZ
  DVar1 = GetCurrentThreadId();
  return *(DWORD *)(this + 0x19cc) == DVar1;
}



undefined4 __thiscall FUN_10005df0(void *this,int param_1,int param_2)

{
                    // WARNING: Load size is inaccurate
  if ((-1 < param_1) && (param_1 < *this)) {
    param_1 = FUN_10008420(this,param_1);
    if (*(int *)(param_1 + 8) <= param_2) {
      return CONCAT31((int3)((uint)param_1 >> 8),1);
    }
  }
  return param_1 & 0xffffff00;
}



// public: bool __thiscall CVProfile::IsEnabled(void)const 

bool __thiscall CVProfile::IsEnabled(CVProfile *this)

{
                    // 0x5e20  162  ?IsEnabled@CVProfile@@QBE_NXZ
  return *(int *)(this + 0x100c) != 0;
}



// public: void __thiscall CVProfile::MarkFrame(char const *)

void __thiscall CVProfile::MarkFrame(CVProfile *this,char *param_1)

{
  CVProfNode *this_00;
  
                    // 0x5e30  185  ?MarkFrame@CVProfile@@QAEXPBD@Z
  if (*(int *)(this + 0x100c) != 0) {
    *(int *)(this + 0x10a8) = *(int *)(this + 0x10a8) + 1;
    this_00 = (CVProfNode *)(this + 0x1018);
    CVProfNode::ExitScope(this_00);
    CVProfNode::MarkFrame(this_00);
    CVProfNode::EnterScope(this_00);
  }
  return;
}



// public: void __thiscall CVProfile::MarkFrame(void)

void __thiscall CVProfile::MarkFrame(CVProfile *this)

{
  CVProfNode *this_00;
  
                    // 0x5e60  186  ?MarkFrame@CVProfile@@QAEXXZ
  if (*(int *)(this + 0x100c) != 0) {
    *(int *)(this + 0x10a8) = *(int *)(this + 0x10a8) + 1;
    this_00 = (CVProfNode *)(this + 0x1018);
    CVProfNode::ExitScope(this_00);
    CVProfNode::MarkFrame(this_00);
    CVProfNode::EnterScope(this_00);
    return;
  }
  return;
}



// public: int __thiscall CVProfile::NumFramesSampled(void)

int __thiscall CVProfile::NumFramesSampled(CVProfile *this)

{
                    // 0x5e90  187  ?NumFramesSampled@CVProfile@@QAEHXZ
  return *(int *)(this + 0x10a8);
}



// public: void __thiscall CVProfile::PMEEnable(bool)

void __thiscall CVProfile::PMEEnable(CVProfile *this,bool param_1)

{
                    // 0x5ea0  190  ?PMEEnable@CVProfile@@QAEX_N@Z
  this[0x10c5] = (CVProfile)param_1;
  return;
}



// public: void __thiscall CVProfile::PMEInitialized(bool)

void __thiscall CVProfile::PMEInitialized(CVProfile *this,bool param_1)

{
                    // 0x5eb0  191  ?PMEInitialized@CVProfile@@QAEX_N@Z
  this[0x10c4] = (CVProfile)param_1;
  return;
}



// public: void __thiscall CVProfile::Pause(void)

void __thiscall CVProfile::Pause(CVProfile *this)

{
                    // 0x5ec0  193  ?Pause@CVProfile@@QAEXXZ
  *(undefined4 *)(this + 0x10b0) = *(undefined4 *)(this + 0x100c);
  *(undefined4 *)(this + 0x100c) = 0;
  if (this[0x1010] == (CVProfile)0x0) {
    CVProfNode::Pause((CVProfNode *)(this + 0x1018));
    return;
  }
  return;
}



// public: void __thiscall CVProfile::PopGroup(void)

void __thiscall CVProfile::PopGroup(CVProfile *this)

{
                    // 0x5ef0  195  ?PopGroup@CVProfile@@QAEXXZ
  *(int *)(this + 0x1008) = *(int *)(this + 0x1008) + -1;
  if (((*(int *)(this + *(int *)(this + 0x1008) * 4 + 8) !=
        *(int *)(this + *(int *)(this + 0x1008) * 4 + 0xc)) && (*this != (CVProfile)0x0)) &&
     (*(int *)(this + *(int *)(this + 0x1008) * 4 + 0xc) == *(int *)(this + 4))) {
    vtune('\0');
  }
  return;
}



// public: void __thiscall CVProfile::PushGroup(int)

void __thiscall CVProfile::PushGroup(CVProfile *this,int param_1)

{
                    // 0x5f20  196  ?PushGroup@CVProfile@@QAEXH@Z
  *(int *)(this + *(int *)(this + 0x1008) * 4 + 8) = param_1;
  *(int *)(this + 0x1008) = *(int *)(this + 0x1008) + 1;
  if (((*(int *)(this + *(int *)(this + 0x1008) * 4) != param_1) && (*this != (CVProfile)0x0)) &&
     (param_1 == *(int *)(this + 4))) {
    vtune('\x01');
  }
  return;
}



// public: void __thiscall CVProfile::Reset(void)

void __thiscall CVProfile::Reset(CVProfile *this)

{
                    // 0x5f60  205  ?Reset@CVProfile@@QAEXXZ
  CVProfNode::Reset((CVProfNode *)(this + 0x1018));
  *(undefined4 *)(this + 0x10a8) = 0;
  return;
}



// public: void __thiscall CVProfile::ResetPeaks(void)

void __thiscall CVProfile::ResetPeaks(CVProfile *this)

{
                    // 0x5f80  208  ?ResetPeaks@CVProfile@@QAEXXZ
  CVProfNode::ResetPeak((CVProfNode *)(this + 0x1018));
  return;
}



// public: void __thiscall CVProfile::Resume(void)

void __thiscall CVProfile::Resume(CVProfile *this)

{
                    // 0x5f90  211  ?Resume@CVProfile@@QAEXXZ
  *(undefined4 *)(this + 0x100c) = *(undefined4 *)(this + 0x10b0);
  if (this[0x1010] == (CVProfile)0x0) {
    CVProfNode::Resume((CVProfNode *)(this + 0x1018));
    return;
  }
  return;
}



void __cdecl FUN_10005fc0(uint *param_1,byte param_2,byte param_3,int param_4)

{
  *param_1 = ~((1 << (param_3 & 0x1f)) + -1 << (param_2 & 0x1f)) & *param_1 |
             param_4 << (param_2 & 0x1f);
  return;
}



// public: void __thiscall CVProfNode::SetBudgetGroupID(int)

void __thiscall CVProfNode::SetBudgetGroupID(CVProfNode *this,int param_1)

{
                    // 0x6000  215  ?SetBudgetGroupID@CVProfNode@@QAEXH@Z
  *(int *)(this + 0x84) = param_1;
  return;
}



// public: void __thiscall CVProfNode::SetClientData(int)

void __thiscall CVProfNode::SetClientData(CVProfNode *this,int param_1)

{
                    // 0x6010  216  ?SetClientData@CVProfNode@@QAEXH@Z
  *(int *)(this + 0x88) = param_1;
  return;
}



// public: void __thiscall CVProfile::SetTargetThreadId(unsigned int)

void __thiscall CVProfile::SetTargetThreadId(CVProfile *this,uint param_1)

{
                    // 0x6020  220  ?SetTargetThreadId@CVProfile@@QAEXI@Z
  *(uint *)(this + 0x19cc) = param_1;
  return;
}



// private: void __thiscall CVProfNode::SetUniqueNodeID(int)

void __thiscall CVProfNode::SetUniqueNodeID(CVProfNode *this,int param_1)

{
                    // 0x6030  223  ?SetUniqueNodeID@CVProfNode@@AAEXH@Z
  *(int *)(this + 0x8c) = param_1;
  return;
}



// public: void __thiscall CVProfile::Start(void)

void __thiscall CVProfile::Start(CVProfile *this)

{
                    // 0x6040  228  ?Start@CVProfile@@QAEXXZ
  *(int *)(this + 0x100c) = *(int *)(this + 0x100c) + 1;
  if (*(int *)(this + 0x100c) == 1) {
    CVProfNode::EnterScope((CVProfNode *)(this + 0x1018));
    return;
  }
  return;
}



// public: void __thiscall CVProfile::Stop(void)

void __thiscall CVProfile::Stop(CVProfile *this)

{
  int *piVar1;
  
                    // 0x6060  230  ?Stop@CVProfile@@QAEXXZ
  piVar1 = (int *)(this + 0x100c);
  *piVar1 = *piVar1 + -1;
  if (*piVar1 == 0) {
    CVProfNode::ExitScope((CVProfNode *)(this + 0x1018));
    return;
  }
  return;
}



undefined4 FUN_10006080(DWORD *param_1)

{
  CONTEXT local_2e4;
  int local_18;
  uint local_14;
  undefined4 local_10;
  undefined local_c;
  undefined local_b;
  undefined local_a;
  undefined local_9;
  DWORD *local_8;
  
  local_8 = param_1;
  SuspendThread((HANDLE)param_1[1]);
  local_2e4.ContextFlags = 0;
  FUN_10021290(&local_2e4.Dr0,0,0x2c8);
  local_2e4.ContextFlags = 0x10010;
  GetThreadContext((HANDLE)local_8[1],&local_2e4);
  local_10 = 0;
  local_9 = (local_2e4.Dr7 & 1) != 0;
  local_c = (local_2e4.Dr7 & 4) != 0;
  local_b = (local_2e4.Dr7 & 0x10) != 0;
  local_a = (local_2e4.Dr7 & 0x40) != 0;
  if (local_8[6] == 1) {
    if (local_8[5] == 0) {
      local_2e4.Dr0 = 0;
    }
    local_9 = local_8[5] != 0 && (bool)local_9;
    local_10 = 0;
    if (local_8[5] == 1) {
      local_10 = 2;
      local_2e4.Dr1 = 0;
    }
    local_c = local_8[5] != 1 && (bool)local_c;
    if (local_8[5] == 2) {
      local_10 = 4;
      local_2e4.Dr2 = 0;
    }
    local_b = local_8[5] != 2 && (bool)local_b;
    if (local_8[5] == 3) {
      local_10 = 6;
      local_2e4.Dr3 = 0;
    }
    local_a = local_8[5] != 3 && (bool)local_a;
    local_2e4.Dr7 = ~(1 << (sbyte)local_10) & local_2e4.Dr7;
  }
  else {
    if ((bool)local_9) {
      if ((bool)local_c) {
        if ((bool)local_b) {
          if ((bool)local_a) {
            *(undefined *)(local_8 + 7) = 0;
            ResumeThread((HANDLE)local_8[1]);
            SetEvent((HANDLE)local_8[4]);
            return 0;
          }
          local_8[5] = 3;
          local_2e4.Dr3 = *local_8;
          local_a = true;
        }
        else {
          local_8[5] = 2;
          local_2e4.Dr2 = *local_8;
          local_b = true;
        }
      }
      else {
        local_8[5] = 1;
        local_2e4.Dr1 = *local_8;
        local_c = true;
      }
    }
    else {
      local_8[5] = 0;
      local_2e4.Dr0 = *local_8;
      local_9 = true;
    }
    local_2e4.Dr6 = 0;
    local_18 = 0;
    if (local_8[2] == 2) {
      local_18 = 3;
    }
    if (local_8[2] == 1) {
      local_18 = 1;
    }
    local_14 = (uint)(local_8[3] == 2);
    if (local_8[3] == 4) {
      local_14 = 3;
    }
    if (local_8[3] == 8) {
      local_14 = 2;
    }
    FUN_10005fc0(&local_2e4.Dr7,(char)local_8[5] * '\x04' + 0x10,2,local_18);
    FUN_10005fc0(&local_2e4.Dr7,(char)local_8[5] * '\x04' + 0x12,2,local_14);
    FUN_10005fc0(&local_2e4.Dr7,(byte)(local_8[5] << 1),1,1);
  }
  local_2e4.ContextFlags = 0x10010;
  SetThreadContext((HANDLE)local_8[1],&local_2e4);
  ResumeThread((HANDLE)local_8[1]);
  *(undefined *)(local_8 + 7) = 1;
  SetEvent((HANDLE)local_8[4]);
  return 0;
}



// public: bool __thiscall CVProfile::UsePME(void)

bool __thiscall CVProfile::UsePME(CVProfile *this)

{
                    // 0x63c0  259  ?UsePME@CVProfile@@QAE_NXZ
  if ((this[0x10c4] != (CVProfile)0x0) && (this[0x10c5] != (CVProfile)0x0)) {
    return true;
  }
  return false;
}



// protected: bool __thiscall CVProfile::VTuneGroupEnabled(void)

bool __thiscall CVProfile::VTuneGroupEnabled(CVProfile *this)

{
                    // 0x63e0  260  ?VTuneGroupEnabled@CVProfile@@IAE_NXZ
  return (bool)*this;
}



float10 __cdecl FUN_100063f0(uint param_1)

{
  return (float10)(float)(param_1 & 0x7fffffff);
}



void AssertValidWStringPtr(void)

{
                    // 0x6410  281  AssertValidWStringPtr
                    // 0x6410  486  _AssertValidReadPtr
                    // 0x6410  487  _AssertValidReadWritePtr
                    // 0x6410  488  _AssertValidStringPtr
                    // 0x6410  489  _AssertValidWritePtr
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl COM_TimestampedLog(byte *param_1)

{
  int iVar1;
  float10 fVar2;
  char local_424 [1024];
  float local_24;
  undefined **local_20;
  undefined **local_1c;
  FILE *local_18;
  int **local_14;
  undefined **local_10;
  float local_c;
  undefined local_7;
  undefined local_6;
  undefined local_5;
  
                    // 0x6420  282  COM_TimestampedLog
  if (DAT_100481fb == '\0') {
    local_20 = CommandLine();
    iVar1 = (**(code **)(*local_20 + 0xc))();
    DAT_100481f8 = iVar1 != 0;
    local_7 = DAT_100481f8;
    local_10 = CommandLine();
    fVar2 = (float10)(**(code **)(*local_10 + 0x1c))();
    local_24 = (float)fVar2;
    DAT_100481f9 = local_24 != 0.0;
    local_5 = DAT_100481f9;
    local_1c = CommandLine();
    iVar1 = (**(code **)(*local_1c + 0xc))("-etwprofile");
    DAT_100481fa = iVar1 != 0;
    if ((bool)DAT_100481fa) {
      DAT_100481f8 = '\x01';
    }
    DAT_100481fb = '\x01';
    local_6 = DAT_100481fa;
  }
  if (DAT_100481f8 != '\0') {
    local_14 = (int **)&stack0x00000008;
    FUN_10021749(local_424,0x400,param_1,local_14);
    local_14 = (int **)0x0;
    fVar2 = Plat_FloatTime();
    local_c = (float)fVar2;
    if (true) {
      if (DAT_100481fa == '\0') {
        if (DAT_100481fc == '\0') {
          FUN_10034f18("timestamped.log");
          DAT_100481fc = '\x01';
        }
        local_18 = _fopen("timestamped.log","at+");
        FUN_1002158b(local_18,(byte *)"%8.4f / %8.4f:  %s\n");
        _fclose(local_18);
        if (DAT_100481f9 != '\0') {
          Msg((byte *)"%8.4f / %8.4f:  %s\n");
        }
      }
      else {
        ETWMark(local_424);
      }
    }
    _DAT_100481f4 = local_c;
  }
  return;
}



void __cdecl CallAssertFailedNotifyFunc(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
                    // 0x6650  283  CallAssertFailedNotifyFunc
  if (DAT_10048200 != (code *)0x0) {
    (*DAT_10048200)(param_1,param_2,param_3);
  }
  return;
}



undefined4 __cdecl ClearHardwareBreakpoint(void *param_1)

{
  undefined4 uVar1;
  HANDLE pvVar2;
  DWORD dwThreadId;
  void *pvVar3;
  bool bVar4;
  
                    // 0x6680  289  ClearHardwareBreakpoint
  if (param_1 == (void *)0x0) {
    uVar1 = 0;
  }
  else {
    pvVar2 = GetCurrentThread();
    bVar4 = *(HANDLE *)((int)param_1 + 4) == pvVar2;
    if (bVar4) {
      dwThreadId = GetCurrentThreadId();
      pvVar2 = OpenThread(0x1fffff,0,dwThreadId);
      *(HANDLE *)((int)param_1 + 4) = pvVar2;
    }
    pvVar2 = CreateEventA((LPSECURITY_ATTRIBUTES)0x0,0,0,(LPCSTR)0x0);
    *(HANDLE *)((int)param_1 + 0x10) = pvVar2;
    *(undefined4 *)((int)param_1 + 0x18) = 1;
    CreateThread((LPSECURITY_ATTRIBUTES)0x0,0,FUN_10006080,param_1,0,(LPDWORD)0x0);
    WaitForSingleObject(*(HANDLE *)((int)param_1 + 0x10),0xffffffff);
    CloseHandle(*(HANDLE *)((int)param_1 + 0x10));
    *(undefined4 *)((int)param_1 + 0x10) = 0;
    pvVar3 = param_1;
    if (bVar4) {
      pvVar3 = (void *)CloseHandle(*(HANDLE *)((int)param_1 + 4));
    }
    FID_conflict__free(param_1);
    uVar1 = CONCAT31((int3)((uint)pvVar3 >> 8),1);
  }
  return uVar1;
}



void __cdecl ConDMsg(byte *param_1)

{
  uint uVar1;
  int *piVar2;
  char *pcVar3;
  char local_810 [2048];
  undefined4 local_10;
  int **local_c;
  undefined4 *local_8;
  
  do {
    local_8 = FUN_10008430();
    uVar1 = FUN_10005df0(local_8,DAT_100483d4,0);
    if ((uVar1 & 0xff) != 0) {
      local_c = (int **)&stack0x00000008;
      FUN_10021749(local_810,0x800,param_1,local_c);
      local_c = (int **)0x0;
      FUN_10005420(local_810,0x800,0);
      pcVar3 = local_810;
      piVar2 = (int *)FUN_100059e0(local_8,&local_10,DAT_100483d4);
      FUN_100084c0(local_8,DAT_100483d4,0,*piVar2,pcVar3);
    }
  } while (false);
  return;
}



void __cdecl CrackSmokingCompiler(uint param_1)

{
                    // 0x6810  292  CrackSmokingCompiler
  FUN_100063f0(param_1);
  return;
}



void __cdecl DevMsg(int param_1,byte *param_2)

{
  uint uVar1;
  int *piVar2;
  char *pcVar3;
  char local_818 [2048];
  undefined4 local_18;
  int **local_14;
  int local_10;
  undefined4 *local_c;
  int local_8;
  
                    // 0x6830  296  DevMsg
  if (param_1 < 2) {
    local_10 = DAT_100483dc;
  }
  else {
    local_10 = DAT_100483d0;
  }
  local_8 = local_10;
  do {
    local_c = FUN_10008430();
    uVar1 = FUN_10005df0(local_c,local_8,0);
    if ((uVar1 & 0xff) != 0) {
      local_14 = (int **)&stack0x0000000c;
      FUN_10021749(local_818,0x800,param_2,local_14);
      local_14 = (int **)0x0;
      FUN_10005420(local_818,0x800,0);
      pcVar3 = local_818;
      piVar2 = (int *)FUN_100059e0(local_c,&local_18,local_8);
      FUN_100084c0(local_c,local_8,0,*piVar2,pcVar3);
    }
  } while (false);
  return;
}



void __cdecl DevWarning(int param_1,byte *param_2)

{
  uint uVar1;
  int *piVar2;
  char *pcVar3;
  char local_818 [2048];
  undefined4 local_18;
  int **local_14;
  int local_10;
  undefined4 *local_c;
  int local_8;
  
                    // 0x68f0  297  DevWarning
  if (param_1 < 2) {
    local_10 = DAT_100483dc;
  }
  else {
    local_10 = DAT_100483d0;
  }
  local_8 = local_10;
  do {
    local_c = FUN_10008430();
    uVar1 = FUN_10005df0(local_c,local_8,1);
    if ((uVar1 & 0xff) != 0) {
      local_14 = (int **)&stack0x0000000c;
      FUN_10021749(local_818,0x800,param_2,local_14);
      local_14 = (int **)0x0;
      FUN_10005420(local_818,0x800,0);
      pcVar3 = local_818;
      piVar2 = (int *)FUN_100059e0(local_c,&local_18,local_8);
      FUN_100084c0(local_c,local_8,1,*piVar2,pcVar3);
    }
  } while (false);
  return;
}



void __cdecl Error(byte *param_1)

{
  uint uVar1;
  int *piVar2;
  char *pcVar3;
  char local_814 [2048];
  undefined4 local_14;
  int **local_10;
  int local_c;
  undefined4 *local_8;
  
  do {
    local_8 = FUN_10008430();
    uVar1 = FUN_10005df0(local_8,DAT_100483c4,3);
    if ((uVar1 & 0xff) != 0) {
      local_10 = (int **)&stack0x00000008;
      FUN_10021749(local_814,0x800,param_1,local_10);
      local_10 = (int **)0x0;
      if (DAT_100481f1 == '\0') {
        local_c = 0;
      }
      else {
        local_c = DAT_10046528;
      }
      FUN_10005420(local_814,0x800,local_c);
      pcVar3 = local_814;
      piVar2 = (int *)FUN_100059e0(local_8,&local_14,DAT_100483c4);
      FUN_100084c0(local_8,DAT_100483c4,3,*piVar2,pcVar3);
    }
  } while (false);
  Plat_ExitProcess(100);
  return;
}



void __cdecl Error_SpewCallStack(int param_1,byte *param_2)

{
  uint uVar1;
  int *piVar2;
  char *pcVar3;
  char local_810 [2048];
  undefined4 local_10;
  int **local_c;
  undefined4 *local_8;
  
  do {
    local_8 = FUN_10008430();
    uVar1 = FUN_10005df0(local_8,DAT_100483c4,3);
    if ((uVar1 & 0xff) != 0) {
      local_c = (int **)&stack0x0000000c;
      FUN_10021749(local_810,0x800,param_2,local_c);
      local_c = (int **)0x0;
      FUN_10005420(local_810,0x800,param_1);
      pcVar3 = local_810;
      piVar2 = (int *)FUN_100059e0(local_8,&local_10,DAT_100483c4);
      FUN_100084c0(local_8,DAT_100483c4,3,*piVar2,pcVar3);
    }
  } while (false);
  Plat_ExitProcess(100);
  return;
}



void __cdecl Msg(byte *param_1)

{
  uint uVar1;
  int *piVar2;
  char *pcVar3;
  char local_810 [2048];
  undefined4 local_10;
  int **local_c;
  undefined4 *local_8;
  
  do {
    local_8 = FUN_10008430();
    uVar1 = FUN_10005df0(local_8,DAT_100483c4,0);
    if ((uVar1 & 0xff) != 0) {
      local_c = (int **)&stack0x00000008;
      FUN_10021749(local_810,0x800,param_1,local_c);
      local_c = (int **)0x0;
      FUN_10005420(local_810,0x800,0);
      pcVar3 = local_810;
      piVar2 = (int *)FUN_100059e0(local_8,&local_10,DAT_100483c4);
      FUN_100084c0(local_8,DAT_100483c4,0,*piVar2,pcVar3);
    }
  } while (false);
  return;
}



undefined4 Plat_SimpleLog(undefined4 param_1,undefined4 param_2)

{
  FILE *_File;
  
                    // 0x6be0  416  Plat_SimpleLog
  _File = _fopen("simple.log","at+");
  FUN_1002158b(_File,(byte *)"%s:%i\n");
  _fclose(_File);
  return 0;
}



void __cdecl SetAssertFailedNotifyFunc(undefined4 param_1)

{
  DAT_10048200 = param_1;
                    // 0x6c30  443  SetAssertFailedNotifyFunc
  return;
}



undefined4 * __cdecl SetHardwareBreakpoint(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  HANDLE pvVar1;
  HANDLE pvVar2;
  DWORD dwThreadId;
  undefined4 *local_14;
  
                    // 0x6c40  445  SetHardwareBreakpoint
  local_14 = (undefined4 *)FUN_1001f8b3(0x20);
  if (local_14 == (undefined4 *)0x0) {
    local_14 = (undefined4 *)0x0;
  }
  else {
    local_14[6] = 0;
    *local_14 = 0;
    local_14[1] = 0;
    local_14[4] = 0;
    local_14[5] = 0;
    *(undefined *)(local_14 + 7) = 0;
  }
  *local_14 = param_3;
  local_14[3] = param_2;
  local_14[2] = param_1;
  pvVar1 = GetCurrentThread();
  local_14[1] = pvVar1;
  pvVar2 = GetCurrentThread();
  if (pvVar1 == pvVar2) {
    dwThreadId = GetCurrentThreadId();
    pvVar2 = OpenThread(0x1fffff,0,dwThreadId);
    local_14[1] = pvVar2;
  }
  pvVar2 = CreateEventA((LPSECURITY_ATTRIBUTES)0x0,0,0,(LPCSTR)0x0);
  local_14[4] = pvVar2;
  local_14[6] = 0;
  CreateThread((LPSECURITY_ATTRIBUTES)0x0,0,FUN_10006080,local_14,0,(LPDWORD)0x0);
  WaitForSingleObject((HANDLE)local_14[4],0xffffffff);
  CloseHandle((HANDLE)local_14[4]);
  local_14[4] = 0;
  pvVar2 = GetCurrentThread();
  if (pvVar1 == pvVar2) {
    CloseHandle((HANDLE)local_14[1]);
  }
  local_14[1] = pvVar1;
  if (*(char *)(local_14 + 7) == '\0') {
    FID_conflict__free(local_14);
    local_14 = (undefined4 *)0x0;
  }
  return local_14;
}



void __cdecl Warning(byte *param_1)

{
  uint uVar1;
  int *piVar2;
  char *pcVar3;
  char local_814 [2048];
  undefined4 local_14;
  int **local_10;
  int local_c;
  undefined4 *local_8;
  
  do {
    local_8 = FUN_10008430();
    uVar1 = FUN_10005df0(local_8,DAT_100483c4,1);
    if ((uVar1 & 0xff) != 0) {
      local_10 = (int **)&stack0x00000008;
      FUN_10021749(local_814,0x800,param_1,local_10);
      local_10 = (int **)0x0;
      if (DAT_100481f0 == '\0') {
        local_c = 0;
      }
      else {
        local_c = DAT_10046524;
      }
      FUN_10005420(local_814,0x800,local_c);
      pcVar3 = local_814;
      piVar2 = (int *)FUN_100059e0(local_8,&local_14,DAT_100483c4);
      FUN_100084c0(local_8,DAT_100483c4,1,*piVar2,pcVar3);
    }
  } while (false);
  return;
}



void __cdecl Warning_SpewCallStack(int param_1,byte *param_2)

{
  uint uVar1;
  int *piVar2;
  char *pcVar3;
  char local_810 [2048];
  undefined4 local_10;
  int **local_c;
  undefined4 *local_8;
  
  do {
    local_8 = FUN_10008430();
    uVar1 = FUN_10005df0(local_8,DAT_100483c4,1);
    if ((uVar1 & 0xff) != 0) {
      local_c = (int **)&stack0x0000000c;
      FUN_10021749(local_810,0x800,param_2,local_c);
      local_c = (int **)0x0;
      FUN_10005420(local_810,0x800,param_1);
      pcVar3 = local_810;
      piVar2 = (int *)FUN_100059e0(local_8,&local_10,DAT_100483c4);
      FUN_100084c0(local_8,DAT_100483c4,1,*piVar2,pcVar3);
    }
  } while (false);
  return;
}



void __cdecl _Error_AlwaysSpewCallStack_Enable(undefined param_1)

{
  DAT_100481f1 = param_1;
                    // 0x6f30  492  _Error_AlwaysSpewCallStack_Enable
  return;
}



void __cdecl _Error_AlwaysSpewCallStack_Length(undefined4 param_1)

{
  DAT_10046528 = param_1;
                    // 0x6f40  493  _Error_AlwaysSpewCallStack_Length
  return;
}



void _ExitOnFatalAssert(undefined4 param_1,undefined4 param_2)

{
  bool bVar1;
  uint uVar2;
  
  do {
    uVar2 = LoggingSystem_IsChannelEnabled(DAT_100483cc,0);
    if ((uVar2 & 0xff) != 0) {
      LoggingSystem_Log(DAT_100483cc,0,
                        (byte *)"Fatal assert failed: %s, line %d.  Application exiting.\n");
    }
  } while (false);
  bVar1 = Plat_IsInDebugSession();
  if (!bVar1) {
    WriteMiniDump();
  }
  do {
    uVar2 = LoggingSystem_IsChannelEnabled(DAT_100483dc,0);
    if ((uVar2 & 0xff) != 0) {
      LoggingSystem_Log(DAT_100483dc,0,(byte *)"_ExitOnFatalAssert\n");
    }
  } while (false);
  Plat_ExitProcess(1);
  return;
}



void __cdecl _Warning_AlwaysSpewCallStack_Enable(undefined param_1)

{
  DAT_100481f0 = param_1;
                    // 0x6fe0  495  _Warning_AlwaysSpewCallStack_Enable
  return;
}



void __cdecl _Warning_AlwaysSpewCallStack_Length(undefined4 param_1)

{
  DAT_10046524 = param_1;
                    // 0x6ff0  496  _Warning_AlwaysSpewCallStack_Length
  return;
}



char ** __thiscall FUN_10007000(void *this,char *param_1,char *param_2)

{
  char cVar1;
  char *pcVar2;
  
  *(char **)((int)this + 8) = param_1;
  pcVar2 = param_2;
  do {
    cVar1 = *pcVar2;
    pcVar2 = pcVar2 + 1;
  } while (cVar1 != '\0');
  pcVar2 = (char *)FUN_1001f8b3((size_t)(pcVar2 + (1 - (int)(param_2 + 1))));
  *(char **)this = pcVar2;
  *(undefined4 *)((int)this + 4) = 0;
  do {
    cVar1 = *param_2;
    param_2 = param_2 + 1;
    *pcVar2 = cVar1;
    pcVar2 = pcVar2 + 1;
  } while (cVar1 != '\0');
  return (char **)this;
}



void ** __thiscall FUN_10007050(void *this,byte param_1)

{
  CThreadSyncObject::AssertUseable((CThreadSyncObject *)this);
  FreeLibrary(*(HMODULE *)((int)this + 8));
                    // WARNING: Load size is inaccurate
  FID_conflict__free(*this);
  if (*(void **)((int)this + 4) != (void *)0x0) {
    FUN_10007050(*(void **)((int)this + 4),1);
  }
  if ((param_1 & 1) != 0) {
    FID_conflict__free(this);
  }
  return (void **)this;
}



byte ** __thiscall FUN_100070a0(void *this,byte *param_1)

{
  byte bVar1;
  byte **ppbVar2;
  byte **ppbVar3;
  byte *pbVar4;
  uint uVar5;
  byte *pbVar6;
  bool bVar7;
  
                    // WARNING: Load size is inaccurate
  ppbVar2 = (byte **)0x0;
  ppbVar3 = *this;
  do {
    if (ppbVar3 == (byte **)0x0) {
      return (byte **)0x0;
    }
    pbVar6 = *ppbVar3;
    pbVar4 = param_1;
    do {
      bVar1 = *pbVar6;
      bVar7 = bVar1 < *pbVar4;
      if (bVar1 != *pbVar4) {
LAB_100070e0:
        uVar5 = -(uint)bVar7 | 1;
        goto LAB_100070e5;
      }
      if (bVar1 == 0) break;
      bVar1 = pbVar6[1];
      bVar7 = bVar1 < pbVar4[1];
      if (bVar1 != pbVar4[1]) goto LAB_100070e0;
      pbVar6 = pbVar6 + 2;
      pbVar4 = pbVar4 + 2;
    } while (bVar1 != 0);
    uVar5 = 0;
LAB_100070e5:
    if (uVar5 == 0) {
      if (ppbVar2 != (byte **)0x0) {
        ppbVar2[1] = ppbVar3[1];
                    // WARNING: Load size is inaccurate
        ppbVar3[1] = *this;
        *(byte ***)this = ppbVar3;
      }
      return ppbVar3;
    }
    ppbVar2 = ppbVar3;
    ppbVar3 = (byte **)ppbVar3[1];
  } while( true );
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

HMODULE __thiscall FUN_10007120(void *this,byte *param_1)

{
  byte **ppbVar1;
  HMODULE pHVar2;
  HMODULE pHVar3;
  void *this_00;
  char **ppcVar4;
  CThreadSyncObject *this_01;
  
  ppbVar1 = FUN_100070a0(this,param_1);
  if (ppbVar1 == (byte **)0x0) {
    pHVar2 = LoadLibraryA((LPCSTR)param_1);
    pHVar3 = pHVar2;
    CThreadSyncObject::AssertUseable(this_01);
    if (pHVar2 == (HMODULE)0x0) {
      return pHVar3;
    }
    this_00 = (void *)FUN_1001f8b3(0xc);
    if (this_00 != (void *)0x0) {
      ppcVar4 = FUN_10007000(this_00,(char *)pHVar2,(char *)param_1);
                    // WARNING: Load size is inaccurate
      ppcVar4[1] = *this;
      *(char ***)this = ppcVar4;
      return (HMODULE)ppcVar4[2];
    }
                    // WARNING: Load size is inaccurate
    _DAT_00000004 = *this;
    ppbVar1 = (byte **)0x0;
    *(undefined4 *)this = 0;
  }
  return (HMODULE)ppbVar1[2];
}



// protected: void __thiscall CThreadSyncObject::AssertUseable(void)

void __thiscall CThreadSyncObject::AssertUseable(CThreadSyncObject *this)

{
                    // 0x71a0  74  ?AssertUseable@CThreadSyncObject@@IAEXXZ
                    // 0x71a0  188  ?OnExit@CThread@@MAEXXZ
                    // 0x71a0  279  AppendMiniProfilerToList
                    // 0x71a0  430  PreloadStackInformation
                    // 0x71a0  431  PublishAll
                    // 0x71a0  432  PublishAllMiniProfilers
                    // 0x71a0  436  RemoveMiniProfilerFromList
  return;
}



void __cdecl VoidFnPtrLookup_Tier0(byte *param_1,LPCSTR param_2)

{
  HMODULE hModule;
  CThreadSyncObject *this;
  
                    // 0x71b0  481  VoidFnPtrLookup_Tier0
  if ((DAT_1004820c & 1) == 0) {
    DAT_1004820c = DAT_1004820c | 1;
    DAT_10048208 = 0;
    FUN_1002050a(FUN_100350b0);
  }
  hModule = FUN_10007120(&DAT_10048208,param_1);
  if (hModule != (HMODULE)0x0) {
    GetProcAddress(hModule,param_2);
    CThreadSyncObject::AssertUseable(this);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

FARPROC * __fastcall FUN_10007220(FARPROC *param_1)

{
  HMODULE hModule;
  FARPROC pFVar1;
  DWORD DVar2;
  char *pcVar3;
  
  QueryPerformanceFrequency((LARGE_INTEGER *)(param_1 + 4));
  hModule = LoadLibraryW(L"Advapi32.dll");
  if (hModule != (HMODULE)0x0) {
    pFVar1 = GetProcAddress(hModule,"EventRegister");
    *param_1 = pFVar1;
    pFVar1 = GetProcAddress(hModule,"EventWrite");
    param_1[1] = pFVar1;
    pFVar1 = GetProcAddress(hModule,"EventUnregister");
    param_1[2] = pFVar1;
    FUN_10007bf0(0xf0,0x80,0x50,&DAT_10048248);
    FUN_10007bf0(0x20,0x80,0x88,&DAT_10048280);
    FUN_10007bf0(0,0x80,0x18,&DAT_10048210);
    FUN_10007bf0(0x50,0x80,0xc0,&DAT_100482b8);
    FUN_10007bf0(0xb0,0x80,0xf8,&DAT_100482f0);
    if ((_DAT_1004823c != 0) && ((3 < DAT_10048240 || (DAT_10048240 == 0)))) {
      pcVar3 = "Main thread";
      DVar2 = GetCurrentThreadId();
      FUN_10007d80(DAT_10048210,DAT_10048214,&DAT_100369e0,DVar2,pcVar3);
    }
    if (_DAT_100482e4 != 0) {
      FUN_100080c0(DAT_100482b8,DAT_100482bc,&DAT_10036a80,"Valve input provider initialized.");
    }
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 __cdecl ETWBegin(char *param_1)

{
  int iVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  int in_FS_OFFSET;
  undefined8 local_c;
  
                    // 0x7360  300  ETWBegin
  if (_DAT_1004823c == 0) {
    return 0;
  }
  QueryPerformanceCounter(&local_c);
  uVar3 = DAT_10048214;
  uVar2 = DAT_10048210;
  if (_DAT_1004823c != 0) {
    iVar1 = *(int *)(*(int *)(in_FS_OFFSET + 0x2c) + DAT_10835af4 * 4);
    *(int *)(iVar1 + 4) = *(int *)(iVar1 + 4) + 1;
    FUN_10007e80(uVar2,uVar3,&DAT_10036910,param_1);
  }
  return local_c;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 __cdecl ETWEnd(char *param_1,uint param_2,int param_3)

{
  int *piVar1;
  int in_FS_OFFSET;
  uint local_c;
  int local_8;
  
                    // 0x73d0  301  ETWEnd
  if (_DAT_1004823c == 0) {
    return 0;
  }
  QueryPerformanceCounter((LARGE_INTEGER *)&local_c);
  if (_DAT_1004823c != 0) {
    piVar1 = (int *)(*(int *)(*(int *)(in_FS_OFFSET + 0x2c) + DAT_10835af4 * 4) + 4);
    *piVar1 = *piVar1 + -1;
    FUN_10001aaf(local_c - param_2,(local_8 - param_3) - (uint)(local_c < param_2));
    FUN_10001aaf(DAT_10048340,DAT_10048344);
    FUN_100080c0(DAT_10048210,DAT_10048214,&DAT_10036920,param_1);
  }
  return CONCAT44(local_8,local_c);
}



undefined4 ETWGetRenderFrameNumber(void)

{
                    // 0x7480  302  ETWGetRenderFrameNumber
  return DAT_10048348;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

bool ETWIsTracingEnabled(void)

{
                    // 0x7490  303  ETWIsTracingEnabled
  return _DAT_1004823c != 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl ETWKeyDown(undefined4 param_1,undefined4 param_2,char *param_3)

{
                    // 0x74a0  304  ETWKeyDown
  if (_DAT_100482e4 != 0) {
    FUN_100080c0(DAT_100482b8,DAT_100482bc,&DAT_10036a80,param_3);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 __cdecl ETWMark(char *param_1)

{
  undefined8 local_c;
  
                    // 0x74d0  305  ETWMark
  QueryPerformanceCounter(&local_c);
  if (_DAT_1004823c != 0) {
    FUN_10007e10(DAT_10048210,DAT_10048214,&DAT_10036930,param_1);
  }
  return local_c;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl ETWMark1F(char *param_1)

{
                    // 0x7510  306  ETWMark1F
  if (_DAT_1004823c != 0) {
    FUN_10007e80(DAT_10048210,DAT_10048214,&DAT_10036940,param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl ETWMark1I(char *param_1)

{
                    // 0x7550  307  ETWMark1I
  if (_DAT_1004823c != 0) {
    FUN_10007e80(DAT_10048210,DAT_10048214,&DAT_10036980,param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl ETWMark1S(char *param_1,char *param_2)

{
                    // 0x7580  308  ETWMark1S
  if (_DAT_1004823c != 0) {
    FUN_10008160(DAT_10048210,DAT_10048214,&DAT_100369c0,param_1,param_2);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl ETWMark2F(char *param_1)

{
                    // 0x75b0  309  ETWMark2F
  if (_DAT_1004823c != 0) {
    FUN_100080c0(DAT_10048210,DAT_10048214,&DAT_10036950,param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl ETWMark2I(char *param_1)

{
                    // 0x7600  310  ETWMark2I
  if (_DAT_1004823c != 0) {
    FUN_100080c0(DAT_10048210,DAT_10048214,&DAT_10036990,param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl ETWMark2S(char *param_1,char *param_2,char *param_3)

{
                    // 0x7630  311  ETWMark2S
  if (_DAT_1004823c != 0) {
    FUN_10008210(DAT_10048210,DAT_10048214,&DAT_100369d0,param_1,param_2,param_3);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl ETWMark3F(char *param_1)

{
                    // 0x7660  312  ETWMark3F
  if (_DAT_1004823c != 0) {
    FUN_10007f10(DAT_10048210,DAT_10048214,&DAT_10036960,param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl ETWMark3I(char *param_1)

{
                    // 0x76b0  313  ETWMark3I
  if (_DAT_1004823c != 0) {
    FUN_10007f10(DAT_10048210,DAT_10048214,&DAT_100369a0,param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl ETWMark4F(char *param_1)

{
                    // 0x76f0  314  ETWMark4F
  if (_DAT_1004823c != 0) {
    FUN_10007fe0(DAT_10048210,DAT_10048214,&DAT_10036970,param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl ETWMark4I(char *param_1)

{
                    // 0x7750  315  ETWMark4I
  if (_DAT_1004823c != 0) {
    FUN_10007fe0(DAT_10048210,DAT_10048214,&DAT_100369b0,param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl ETWMarkPrintf(char *param_1)

{
  char local_3ec [1000];
  
                    // 0x7790  316  ETWMarkPrintf
  if (_DAT_1004823c != 0) {
    _vsprintf_s(local_3ec,1000,param_1,&stack0x00000008);
    if (_DAT_1004823c != 0) {
      FUN_10007e10(DAT_10048210,DAT_10048214,&DAT_10036930,local_3ec);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ETWMouseDown(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
                    // 0x77f0  317  ETWMouseDown
  if (_DAT_100482e4 != 0) {
    FUN_10007ca0(DAT_100482b8,DAT_100482bc,&DAT_10036a60,(undefined1)param_2,(undefined1)param_3,
                 (undefined1)param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl ETWMouseMove(int param_1,int param_2)

{
                    // 0x7820  318  ETWMouseMove
  if ((_DAT_10048378 != param_1) || (_DAT_1004837c != param_2)) {
    _DAT_10048378 = param_1;
    _DAT_1004837c = param_2;
    if (_DAT_100482e4 != 0) {
      FUN_10007d20(DAT_100482b8,DAT_100482bc,&DAT_10036a90,(char)param_1,(char)param_2);
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ETWMouseUp(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
                    // 0x7870  319  ETWMouseUp
  if (_DAT_100482e4 != 0) {
    FUN_10007ca0(DAT_100482b8,DAT_100482bc,&DAT_10036a70,(undefined1)param_2,(undefined1)param_3,
                 (undefined1)param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ETWMouseWheel(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
                    // 0x78a0  320  ETWMouseWheel
  if (_DAT_100482e4 != 0) {
    FUN_10007ca0(DAT_100482b8,DAT_100482bc,&DAT_10036aa0,(undefined1)param_2,(undefined1)param_3,
                 (undefined1)param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl ETWReadPacket(char *param_1,int param_2)

{
                    // 0x78d0  321  ETWReadPacket
  DAT_10048384 = DAT_10048384 + param_2;
  if (_DAT_1004831c != 0) {
    FUN_10007fe0(DAT_100482f0,DAT_100482f4,&DAT_10036ae0,param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl ETWRenderFrameMark(byte param_1)

{
  double dVar1;
  uint uVar2;
  float fVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined *puVar6;
  undefined4 uVar7;
  uint local_c;
  int local_8;
  
                    // 0x7920  322  ETWRenderFrameMark
  QueryPerformanceCounter((LARGE_INTEGER *)&local_c);
  fVar3 = 0.0;
  uVar4 = 0;
  uVar2 = (uint)param_1;
  if ((&DAT_10048348)[uVar2] != 0) {
    FUN_10001aaf(local_c - *(uint *)(&DAT_10048350 + uVar2 * 8),
                 (local_8 - *(int *)(&DAT_10048354 + uVar2 * 8)) -
                 (uint)(local_c < *(uint *)(&DAT_10048350 + uVar2 * 8)));
    dVar1 = (double)CONCAT44(uVar4,fVar3);
    FUN_10001aaf(DAT_10048340,DAT_10048344);
    fVar3 = (float)(dVar1 / (double)CONCAT44(uVar4,fVar3)) * 1000.0;
  }
  if (param_1 == 0) {
    if (_DAT_10048274 == 0) goto LAB_100079e4;
    puVar6 = &DAT_10036a00;
    uVar4 = DAT_10048248;
    uVar5 = DAT_1004824c;
    uVar7 = DAT_10048348;
  }
  else {
    if (_DAT_100482ac == 0) goto LAB_100079e4;
    puVar6 = &DAT_10036a30;
    uVar4 = DAT_10048280;
    uVar5 = DAT_10048284;
    uVar7 = (&DAT_10048348)[uVar2];
  }
  FUN_10007d20(uVar4,uVar5,puVar6,(char)uVar7,SUB41(fVar3,0));
LAB_100079e4:
  (&DAT_10048348)[uVar2] = (&DAT_10048348)[uVar2] + 1;
  *(uint *)(&DAT_10048350 + uVar2 * 8) = local_c;
  *(int *)(&DAT_10048354 + uVar2 * 8) = local_8;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl ETWSendPacket(char *param_1,int param_2)

{
                    // 0x7a10  323  ETWSendPacket
  DAT_10048380 = DAT_10048380 + param_2;
  if (_DAT_1004831c != 0) {
    FUN_10007fe0(DAT_100482f0,DAT_100482f4,&DAT_10036ac0,param_1);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl ETWSimFrameMark(byte param_1)

{
  double dVar1;
  uint uVar2;
  float fVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined *puVar6;
  undefined4 uVar7;
  uint local_c;
  int local_8;
  
                    // 0x7a60  324  ETWSimFrameMark
  QueryPerformanceCounter((LARGE_INTEGER *)&local_c);
  fVar3 = 0.0;
  uVar4 = 0;
  uVar2 = (uint)param_1;
  if ((&DAT_10048360)[uVar2] != 0) {
    FUN_10001aaf(local_c - *(uint *)(&DAT_10048368 + uVar2 * 8),
                 (local_8 - *(int *)(&DAT_1004836c + uVar2 * 8)) -
                 (uint)(local_c < *(uint *)(&DAT_10048368 + uVar2 * 8)));
    dVar1 = (double)CONCAT44(uVar4,fVar3);
    FUN_10001aaf(DAT_10048340,DAT_10048344);
    fVar3 = (float)(dVar1 / (double)CONCAT44(uVar4,fVar3)) * 1000.0;
  }
  if (param_1 == 0) {
    if (_DAT_10048274 == 0) goto LAB_10007b24;
    puVar6 = &DAT_10036a10;
    uVar4 = DAT_10048248;
    uVar5 = DAT_1004824c;
    uVar7 = DAT_10048360;
  }
  else {
    if (_DAT_100482ac == 0) goto LAB_10007b24;
    puVar6 = &DAT_10036a40;
    uVar4 = DAT_10048280;
    uVar5 = DAT_10048284;
    uVar7 = (&DAT_10048360)[uVar2];
  }
  FUN_10007d20(uVar4,uVar5,puVar6,(char)uVar7,SUB41(fVar3,0));
LAB_10007b24:
  (&DAT_10048360)[uVar2] = (&DAT_10048360)[uVar2] + 1;
  *(uint *)(&DAT_10048368 + uVar2 * 8) = local_c;
  *(int *)(&DAT_1004836c + uVar2 * 8) = local_8;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void ETWThrottled(void)

{
                    // 0x7b50  325  ETWThrottled
  if (_DAT_1004831c != 0) {
    FUN_10007c70(DAT_100482f0,DAT_100482f4,&DAT_10036ad0);
  }
  return;
}



void FUN_10007b80(undefined4 param_1,int param_2,undefined param_3,undefined4 param_4,
                 undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,
                 int param_9)

{
  if (param_9 != 0) {
    if (param_2 == 0) {
      *(undefined4 *)(param_9 + 0x24) = 0;
      *(undefined *)(param_9 + 0x28) = 0;
      *(undefined4 *)(param_9 + 0x10) = 0;
      *(undefined4 *)(param_9 + 0x14) = 0;
      *(undefined4 *)(param_9 + 0x18) = 0;
      *(undefined4 *)(param_9 + 0x1c) = 0;
    }
    else if (param_2 == 1) {
      *(undefined *)(param_9 + 0x28) = param_3;
      *(undefined4 *)(param_9 + 0x10) = param_4;
      *(undefined4 *)(param_9 + 0x14) = param_5;
      *(undefined4 *)(param_9 + 0x18) = param_6;
      *(undefined4 *)(param_9 + 0x1c) = param_7;
      *(undefined4 *)(param_9 + 0x24) = 1;
      return;
    }
  }
  return;
}



undefined4 FUN_10007bf0(undefined param_1,undefined param_2,undefined param_3,uint *param_4)

{
  undefined4 uVar1;
  
  if ((*param_4 | param_4[1]) == 0) {
    if (DAT_10048330 != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x10007c0a. Too many branches
                    // WARNING: Treating indirect jump as call
      uVar1 = (*DAT_10048330)();
      return uVar1;
    }
    *param_4 = 0;
    param_4[1] = 0;
  }
  return 0;
}



void FUN_10007c20(uint *param_1)

{
  if ((*param_1 | param_1[1]) == 0) {
    return;
  }
  if (DAT_10048338 != (code *)0x0) {
    (*DAT_10048338)(*param_1,param_1[1]);
    *param_1 = 0;
    param_1[1] = 0;
    return;
  }
  *param_1 = 0;
  param_1[1] = 0;
  return;
}



undefined4 __cdecl FUN_10007c70(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  undefined4 uVar1;
  
  if (DAT_10048334 != (code *)0x0) {
    uVar1 = (*DAT_10048334)(param_1,param_2,param_3,0,0);
    return uVar1;
  }
  return 0;
}



undefined4 __cdecl
FUN_10007ca0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined param_4,
            undefined param_5,undefined param_6)

{
  undefined4 uVar1;
  undefined1 *local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined1 *local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined1 *local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  local_34 = &param_4;
  local_30 = 0;
  local_24 = &param_5;
  local_14 = &param_6;
  local_2c = 4;
  local_28 = 0;
  local_20 = 0;
  local_1c = 4;
  local_18 = 0;
  local_10 = 0;
  local_c = 4;
  local_8 = 0;
  if (DAT_10048334 != (code *)0x0) {
    uVar1 = (*DAT_10048334)(param_1,param_2,param_3,3,&local_34);
    return uVar1;
  }
  return 0;
}



undefined4 __cdecl
FUN_10007d20(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined param_4,
            undefined param_5)

{
  undefined4 uVar1;
  undefined1 *local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined1 *local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  local_24 = &param_4;
  local_20 = 0;
  local_14 = &param_5;
  local_1c = 4;
  local_18 = 0;
  local_10 = 0;
  local_c = 4;
  local_8 = 0;
  if (DAT_10048334 != (code *)0x0) {
    uVar1 = (*DAT_10048334)(param_1,param_2,param_3,2,&local_24);
    return uVar1;
  }
  return 0;
}



undefined4 __cdecl
FUN_10007d80(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,
            char *param_5)

{
  char cVar1;
  undefined4 uVar2;
  undefined4 *local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  char *local_14;
  undefined4 local_10;
  char *local_c;
  undefined4 local_8;
  
  local_24 = &param_4;
  local_20 = 0;
  local_1c = 4;
  local_18 = 0;
  if (param_5 == (char *)0x0) {
    local_c = (char *)0x5;
  }
  else {
    local_c = param_5;
    do {
      cVar1 = *local_c;
      local_c = local_c + 1;
    } while (cVar1 != '\0');
    local_c = local_c + (1 - (int)(param_5 + 1));
  }
  local_10 = 0;
  local_14 = "NULL";
  if (param_5 != (char *)0x0) {
    local_14 = param_5;
  }
  local_8 = 0;
  if (DAT_10048334 != (code *)0x0) {
    uVar2 = (*DAT_10048334)(param_1,param_2,param_3,2,&local_24);
    return uVar2;
  }
  return 0;
}



undefined4 __cdecl
FUN_10007e10(undefined4 param_1,undefined4 param_2,undefined4 param_3,char *param_4)

{
  char cVar1;
  undefined4 uVar2;
  char *local_14;
  undefined4 local_10;
  char *local_c;
  undefined4 local_8;
  
  if (param_4 == (char *)0x0) {
    local_c = (char *)0x5;
  }
  else {
    local_c = param_4;
    do {
      cVar1 = *local_c;
      local_c = local_c + 1;
    } while (cVar1 != '\0');
    local_c = local_c + (1 - (int)(param_4 + 1));
  }
  local_10 = 0;
  local_14 = "NULL";
  if (param_4 != (char *)0x0) {
    local_14 = param_4;
  }
  local_8 = 0;
  if (DAT_10048334 != (code *)0x0) {
    uVar2 = (*DAT_10048334)(param_1,param_2,param_3,1,&local_14);
    return uVar2;
  }
  return 0;
}



undefined4 __cdecl
FUN_10007e80(undefined4 param_1,undefined4 param_2,undefined4 param_3,char *param_4)

{
  char cVar1;
  undefined4 uVar2;
  char *local_24;
  undefined4 local_20;
  char *local_1c;
  undefined4 local_18;
  undefined *local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  if (param_4 == (char *)0x0) {
    local_1c = (char *)0x5;
  }
  else {
    local_1c = param_4;
    do {
      cVar1 = *local_1c;
      local_1c = local_1c + 1;
    } while (cVar1 != '\0');
    local_1c = local_1c + (1 - (int)(param_4 + 1));
  }
  local_20 = 0;
  local_24 = "NULL";
  if (param_4 != (char *)0x0) {
    local_24 = param_4;
  }
  local_18 = 0;
  local_14 = &stack0x00000014;
  local_10 = 0;
  local_c = 4;
  local_8 = 0;
  if (DAT_10048334 != (code *)0x0) {
    uVar2 = (*DAT_10048334)(param_1,param_2,param_3,2,&local_24);
    return uVar2;
  }
  return 0;
}



undefined4 __cdecl
FUN_10007f10(undefined4 param_1,undefined4 param_2,undefined4 param_3,char *param_4)

{
  char cVar1;
  undefined4 uVar2;
  char *local_44;
  undefined4 local_40;
  char *local_3c;
  undefined4 local_38;
  undefined *local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined *local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined *local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  if (param_4 == (char *)0x0) {
    local_3c = (char *)0x5;
  }
  else {
    local_3c = param_4;
    do {
      cVar1 = *local_3c;
      local_3c = local_3c + 1;
    } while (cVar1 != '\0');
    local_3c = local_3c + (1 - (int)(param_4 + 1));
  }
  local_40 = 0;
  local_44 = "NULL";
  if (param_4 != (char *)0x0) {
    local_44 = param_4;
  }
  local_38 = 0;
  local_34 = &stack0x00000014;
  local_24 = &stack0x00000018;
  local_14 = &stack0x0000001c;
  local_30 = 0;
  local_2c = 4;
  local_28 = 0;
  local_20 = 0;
  local_1c = 4;
  local_18 = 0;
  local_10 = 0;
  local_c = 4;
  local_8 = 0;
  if (DAT_10048334 != (code *)0x0) {
    uVar2 = (*DAT_10048334)(param_1,param_2,param_3,4,&local_44);
    return uVar2;
  }
  return 0;
}



undefined4 __cdecl
FUN_10007fe0(undefined4 param_1,undefined4 param_2,undefined4 param_3,char *param_4)

{
  char cVar1;
  undefined4 uVar2;
  char *local_54;
  undefined4 local_50;
  char *local_4c;
  undefined4 local_48;
  undefined *local_44;
  undefined4 local_40;
  undefined4 local_3c;
  undefined4 local_38;
  undefined *local_34;
  undefined4 local_30;
  undefined4 local_2c;
  undefined4 local_28;
  undefined *local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined *local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  if (param_4 == (char *)0x0) {
    local_4c = (char *)0x5;
  }
  else {
    local_4c = param_4;
    do {
      cVar1 = *local_4c;
      local_4c = local_4c + 1;
    } while (cVar1 != '\0');
    local_4c = local_4c + (1 - (int)(param_4 + 1));
  }
  local_50 = 0;
  local_54 = "NULL";
  if (param_4 != (char *)0x0) {
    local_54 = param_4;
  }
  local_48 = 0;
  local_44 = &stack0x00000014;
  local_34 = &stack0x00000018;
  local_24 = &stack0x0000001c;
  local_14 = &stack0x00000020;
  local_40 = 0;
  local_3c = 4;
  local_38 = 0;
  local_30 = 0;
  local_2c = 4;
  local_28 = 0;
  local_20 = 0;
  local_1c = 4;
  local_18 = 0;
  local_10 = 0;
  local_c = 4;
  local_8 = 0;
  if (DAT_10048334 != (code *)0x0) {
    uVar2 = (*DAT_10048334)(param_1,param_2,param_3,5,&local_54);
    return uVar2;
  }
  return 0;
}



undefined4 __cdecl
FUN_100080c0(undefined4 param_1,undefined4 param_2,undefined4 param_3,char *param_4)

{
  char cVar1;
  undefined4 uVar2;
  char *local_34;
  undefined4 local_30;
  char *local_2c;
  undefined4 local_28;
  undefined *local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  undefined *local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  if (param_4 == (char *)0x0) {
    local_2c = (char *)0x5;
  }
  else {
    local_2c = param_4;
    do {
      cVar1 = *local_2c;
      local_2c = local_2c + 1;
    } while (cVar1 != '\0');
    local_2c = local_2c + (1 - (int)(param_4 + 1));
  }
  local_30 = 0;
  local_34 = "NULL";
  if (param_4 != (char *)0x0) {
    local_34 = param_4;
  }
  local_28 = 0;
  local_24 = &stack0x00000014;
  local_14 = &stack0x00000018;
  local_20 = 0;
  local_1c = 4;
  local_18 = 0;
  local_10 = 0;
  local_c = 4;
  local_8 = 0;
  if (DAT_10048334 != (code *)0x0) {
    uVar2 = (*DAT_10048334)(param_1,param_2,param_3,3,&local_34);
    return uVar2;
  }
  return 0;
}



undefined4 __cdecl
FUN_10008160(undefined4 param_1,undefined4 param_2,undefined4 param_3,char *param_4,char *param_5)

{
  char cVar1;
  undefined4 uVar2;
  char *local_24;
  undefined4 local_20;
  char *local_1c;
  undefined4 local_18;
  char *local_14;
  undefined4 local_10;
  char *local_c;
  undefined4 local_8;
  
  if (param_4 == (char *)0x0) {
    local_1c = (char *)0x5;
  }
  else {
    local_1c = param_4;
    do {
      cVar1 = *local_1c;
      local_1c = local_1c + 1;
    } while (cVar1 != '\0');
    local_1c = local_1c + (1 - (int)(param_4 + 1));
  }
  local_20 = 0;
  local_18 = 0;
  local_24 = "NULL";
  if (param_4 != (char *)0x0) {
    local_24 = param_4;
  }
  if (param_5 == (char *)0x0) {
    local_c = (char *)0x5;
  }
  else {
    local_c = param_5;
    do {
      cVar1 = *local_c;
      local_c = local_c + 1;
    } while (cVar1 != '\0');
    local_c = local_c + (1 - (int)(param_5 + 1));
  }
  local_10 = 0;
  local_14 = "NULL";
  if (param_5 != (char *)0x0) {
    local_14 = param_5;
  }
  local_8 = 0;
  if (DAT_10048334 != (code *)0x0) {
    uVar2 = (*DAT_10048334)(param_1,param_2,param_3,2,&local_24);
    return uVar2;
  }
  return 0;
}



undefined4 __cdecl
FUN_10008210(undefined4 param_1,undefined4 param_2,undefined4 param_3,char *param_4,char *param_5,
            char *param_6)

{
  char cVar1;
  undefined4 uVar2;
  char *local_34;
  undefined4 local_30;
  char *local_2c;
  undefined4 local_28;
  char *local_24;
  undefined4 local_20;
  char *local_1c;
  undefined4 local_18;
  char *local_14;
  undefined4 local_10;
  char *local_c;
  undefined4 local_8;
  
  if (param_4 == (char *)0x0) {
    local_2c = (char *)0x5;
  }
  else {
    local_2c = param_4;
    do {
      cVar1 = *local_2c;
      local_2c = local_2c + 1;
    } while (cVar1 != '\0');
    local_2c = local_2c + (1 - (int)(param_4 + 1));
  }
  local_30 = 0;
  local_28 = 0;
  local_34 = "NULL";
  if (param_4 != (char *)0x0) {
    local_34 = param_4;
  }
  if (param_5 == (char *)0x0) {
    local_1c = (char *)0x5;
  }
  else {
    local_1c = param_5;
    do {
      cVar1 = *local_1c;
      local_1c = local_1c + 1;
    } while (cVar1 != '\0');
    local_1c = local_1c + (1 - (int)(param_5 + 1));
  }
  local_20 = 0;
  local_24 = "NULL";
  if (param_5 != (char *)0x0) {
    local_24 = param_5;
  }
  local_18 = 0;
  if (param_6 == (char *)0x0) {
    local_c = (char *)0x5;
  }
  else {
    local_c = param_6;
    do {
      cVar1 = *local_c;
      local_c = local_c + 1;
    } while (cVar1 != '\0');
    local_c = local_c + (1 - (int)(param_6 + 1));
  }
  local_14 = "NULL";
  if (param_6 != (char *)0x0) {
    local_14 = param_6;
  }
  local_10 = 0;
  local_8 = 0;
  if (DAT_10048334 != (code *)0x0) {
    uVar2 = (*DAT_10048334)(param_1,param_2,param_3,3,&local_34);
    return uVar2;
  }
  return 0;
}



undefined4 * __fastcall FUN_100082f0(undefined4 *param_1)

{
  undefined4 *puVar1;
  int iVar2;
  
  iVar2 = 0xff;
  *param_1 = 0;
  puVar1 = param_1 + 4;
  do {
    iVar2 = iVar2 + -1;
    *puVar1 = 0;
    puVar1 = puVar1 + 0xd;
  } while (-1 < iVar2);
  param_1[0xd01] = 0;
  param_1[0x1502] = 0;
  param_1[0x1d04] = 0;
  param_1[0x1e35] = CDefaultLoggingResponsePolicy::vftable;
  param_1[0x1e36] = CSimpleLoggingListener::vftable;
  *(undefined2 *)(param_1 + 0x1e37) = 0;
  DAT_100483b8 = 1;
  param_1[0x1d05] = 0xffffffff;
  param_1[0x1d06] = 1;
  param_1[0x1d07] = param_1 + 0x1e36;
  puVar1 = param_1 + 0x1d19;
  param_1[0x1d17] = param_1 + 0x1e35;
  iVar2 = 0xf;
  do {
    *puVar1 = 0xffffffff;
    puVar1 = puVar1 + 0x13;
    iVar2 = iVar2 + -1;
  } while (iVar2 != 0);
  param_1[0x1d03] = 0;
  return param_1;
}



int * __thiscall FUN_100083a0(void *this,char *param_1)

{
  char *pcVar1;
  int *piVar2;
  char cVar3;
  char *pcVar4;
  char *pcVar5;
  
  piVar2 = (int *)((int)this + *(int *)((int)this + 0x3404) * 8 + 0x3408);
  *(int *)((int)this + 0x3404) = *(int *)((int)this + 0x3404) + 1;
  piVar2[1] = 0;
  *piVar2 = *(int *)((int)this + 0x5408) + 0x540c + (int)this;
  pcVar1 = param_1 + 1;
  pcVar5 = param_1;
  do {
    cVar3 = *pcVar5;
    pcVar5 = pcVar5 + 1;
  } while (cVar3 != '\0');
  pcVar4 = (char *)((int)this + *(int *)((int)this + 0x5408) + 0x540c);
  do {
    cVar3 = *param_1;
    param_1 = param_1 + 1;
    *pcVar4 = cVar3;
    pcVar4 = pcVar4 + 1;
  } while (cVar3 != '\0');
  *(char **)((int)this + 0x5408) =
       pcVar5 + (int)(*(char **)((int)this + 0x5408) + (1 - (int)pcVar1));
  return piVar2;
}



int __thiscall FUN_10008420(void *this,int param_1)

{
  return param_1 * 0x34 + 4 + (int)this;
}



undefined4 * FUN_10008430(void)

{
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  return DAT_100483bc;
}



void __thiscall FUN_10008480(void *this,undefined4 param_1,LPCSTR param_2)

{
  bool bVar1;
  
  if (*(char *)((int)this + 4) == '\0') {
    FUN_1002103b(&DAT_10036b98);
  }
  if (*(char *)((int)this + 5) == '\0') {
    bVar1 = Plat_IsInDebugSession();
    if (bVar1) {
      Plat_DebugString(param_2);
    }
  }
  return;
}



int __thiscall FUN_100084c0(void *this,int param_1,int param_2,int param_3,undefined4 param_4)

{
  DWORD *this_00;
  code *pcVar1;
  bool bVar2;
  int *piVar3;
  undefined4 *puVar4;
  DWORD DVar5;
  DWORD DVar6;
  void *pvVar7;
  int iVar8;
  int iVar9;
  int local_18;
  undefined4 local_14;
  int local_10;
  int local_c;
  void *local_8;
  
                    // WARNING: Load size is inaccurate
  if ((param_1 < 0) || (*this <= param_1)) {
    return 0;
  }
  local_18 = param_1;
  local_14 = *(undefined4 *)(param_1 * 0x34 + 8 + (int)this);
  local_10 = param_2;
  if (param_3 == DAT_100483c0) {
    piVar3 = (int *)((int)this + param_1 * 0x34 + 0x10);
  }
  else {
    piVar3 = &param_3;
  }
  local_c = *piVar3;
  local_8 = this;
  if (*(int *)((int)this + 0x740c) == 0) {
    puVar4 = (undefined4 *)FUN_1001f8b3(8);
    if (puVar4 == (undefined4 *)0x0) {
      puVar4 = (undefined4 *)0x0;
    }
    else {
      *puVar4 = 0;
      puVar4[1] = 0;
    }
    *(undefined4 **)((int)this + 0x740c) = puVar4;
  }
  this_00 = *(DWORD **)((int)this + 0x740c);
  DVar5 = GetCurrentThreadId();
  if (DVar5 != *this_00) {
    DVar6 = 0;
    LOCK();
    if (*this_00 == 0) {
      *this_00 = DVar5;
    }
    else {
      DVar6 = *this_00;
    }
    if (DVar6 != 0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)this_00,DVar5,0);
      goto LAB_1000856b;
    }
  }
  this_00[1] = this_00[1] + 1;
LAB_1000856b:
  pvVar7 = GenericThreadLocals::CThreadLocalBase::Get((CThreadLocalBase *)&DAT_100483c8);
  if (pvVar7 == (void *)0x0) {
    pvVar7 = *(void **)((int)this + 0x7410);
  }
  iVar8 = (int)pvVar7 + 0x187;
  iVar9 = 0;
  pvVar7 = this;
  if (0 < *(int *)((int)this + iVar8 * 0x4c + 4)) {
    puVar4 = (undefined4 *)((int)this + iVar8 * 0x4c + 8);
    do {
      (***(code ***)*puVar4)(&local_18,param_4);
      iVar9 = iVar9 + 1;
      puVar4 = puVar4 + 1;
      pvVar7 = local_8;
    } while (iVar9 < *(int *)((int)this + iVar8 * 0x4c + 4));
  }
  iVar8 = (**(code **)**(undefined4 **)((int)this + iVar8 * 0x4c + 0x48))(&local_18);
  puVar4 = *(undefined4 **)((int)pvVar7 + 0x740c);
  puVar4[1] = puVar4[1] + -1;
  if (puVar4[1] == 0) {
    *puVar4 = 0;
  }
  iVar9 = DAT_100483d0;
  if (iVar8 == 1) {
    if ((param_2 != 2) && (bVar2 = Plat_IsInDebugSession(), bVar2)) {
      pcVar1 = (code *)swi(3);
      iVar8 = (*pcVar1)();
      return iVar8;
    }
  }
  else if (iVar8 == 2) {
    if (DAT_100483bc == (int *)0x0) {
      if ((DAT_1004fcc0 & 1) == 0) {
        DAT_1004fcc0 = DAT_1004fcc0 | 1;
        FUN_100082f0(&DAT_100483e0);
        FUN_1002050a(FUN_10035150);
      }
      DAT_100483bc = &DAT_100483e0;
    }
    if (((-1 < iVar9) && (iVar9 < *DAT_100483bc)) && (DAT_100483bc[iVar9 * 0xd + 3] < 1)) {
      LoggingSystem_Log(DAT_100483d0,0,(byte *)"Exiting due to logging LR_ABORT request.\n");
    }
    Plat_ExitProcess(1);
    return 2;
  }
  return iVar8;
}



// enum LoggingResponse_t __cdecl LoggingSystem_Log(int,enum LoggingSeverity_t,class Color,char
// const *,...)

LoggingResponse_t __cdecl
LoggingSystem_Log(int param_1,LoggingSeverity_t param_2,Color param_3,char *param_4,...)

{
  LoggingResponse_t LVar1;
  char local_804 [2048];
  
                    // 0x8690  183
                    // ?LoggingSystem_Log@@YA?AW4LoggingResponse_t@@HW4LoggingSeverity_t@@VColor@@PBDZZ
  if (DAT_100483bc == (int *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  if (((-1 < param_1) && (param_1 < *DAT_100483bc)) &&
     (DAT_100483bc[param_1 * 0xd + 3] <= (int)param_2)) {
    FUN_10021749(local_804,0x800,(byte *)param_4,(int **)&stack0x00000014);
    if (DAT_100483bc == (int *)0x0) {
      if ((DAT_1004fcc0 & 1) == 0) {
        DAT_1004fcc0 = DAT_1004fcc0 | 1;
        FUN_100082f0(&DAT_100483e0);
        FUN_1002050a(FUN_10035150);
      }
      DAT_100483bc = &DAT_100483e0;
    }
    LVar1 = FUN_100084c0(DAT_100483bc,param_1,param_2,_param_3,local_804);
    return LVar1;
  }
  return 0;
}



undefined4 FUN_10008780(int param_1)

{
  undefined **ppuVar1;
  int iVar2;
  undefined4 uVar3;
  
  if (*(int *)(param_1 + 8) == 2) {
    ppuVar1 = CommandLine();
    iVar2 = (**(code **)(*ppuVar1 + 0x2c))("-noassert");
    if (iVar2 == 0) {
      return 1;
    }
  }
  uVar3 = 0;
  if (*(int *)(param_1 + 8) == 3) {
    uVar3 = 2;
  }
  return uVar3;
}



void __thiscall FUN_100087c0(void *this,char param_1)

{
  DWORD *this_00;
  undefined4 *puVar1;
  DWORD DVar2;
  DWORD DVar3;
  void *pvVar4;
  
  if (*(int *)((int)this + 0x740c) == 0) {
    puVar1 = (undefined4 *)FUN_1001f8b3(8);
    if (puVar1 == (undefined4 *)0x0) {
      puVar1 = (undefined4 *)0x0;
    }
    else {
      *puVar1 = 0;
      puVar1[1] = 0;
    }
    *(undefined4 **)((int)this + 0x740c) = puVar1;
  }
  this_00 = *(DWORD **)((int)this + 0x740c);
  DVar2 = GetCurrentThreadId();
  if (DVar2 != *this_00) {
    DVar3 = 0;
    LOCK();
    if (*this_00 == 0) {
      *this_00 = DVar2;
    }
    else {
      DVar3 = *this_00;
    }
    if (DVar3 != 0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)this_00,DVar2,0);
      goto LAB_10008825;
    }
  }
  this_00[1] = this_00[1] + 1;
LAB_10008825:
  if (param_1 == '\0') {
    pvVar4 = *(void **)((int)this + 0x7410);
  }
  else {
    pvVar4 = GenericThreadLocals::CThreadLocalBase::Get((CThreadLocalBase *)&DAT_100483c8);
  }
  *(undefined4 *)((int)pvVar4 * 0x4c + 0x7418 + (int)this) = 0xffffffff;
  if (param_1 == '\0') {
    *(undefined4 *)((int)this + 0x7410) = *(undefined4 *)(((int)pvVar4 + 0x187) * 0x4c + (int)this);
  }
  else {
    GenericThreadLocals::CThreadLocalBase::Set
              ((CThreadLocalBase *)&DAT_100483c8,
               *(void **)(((int)pvVar4 + 0x187) * 0x4c + (int)this));
  }
  puVar1 = *(undefined4 **)((int)this + 0x740c);
  puVar1[1] = puVar1[1] + -1;
  if (puVar1[1] == 0) {
    *puVar1 = 0;
  }
  return;
}



void __thiscall FUN_10008890(void *this,char param_1,char param_2)

{
  DWORD *this_00;
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 *puVar4;
  DWORD DVar5;
  DWORD DVar6;
  int *piVar7;
  void *pvVar8;
  undefined4 *puVar9;
  void *pvVar10;
  
  if (*(int *)((int)this + 0x740c) == 0) {
    puVar4 = (undefined4 *)FUN_1001f8b3(8);
    if (puVar4 == (undefined4 *)0x0) {
      puVar4 = (undefined4 *)0x0;
    }
    else {
      *puVar4 = 0;
      puVar4[1] = 0;
    }
    *(undefined4 **)((int)this + 0x740c) = puVar4;
  }
  this_00 = *(DWORD **)((int)this + 0x740c);
  DVar5 = GetCurrentThreadId();
  if (DVar5 != *this_00) {
    DVar6 = 0;
    LOCK();
    if (*this_00 == 0) {
      *this_00 = DVar5;
    }
    else {
      DVar6 = *this_00;
    }
    if (DVar6 != 0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)this_00,DVar5,0);
      goto LAB_100088f4;
    }
  }
  this_00[1] = this_00[1] + 1;
LAB_100088f4:
  pvVar10 = (void *)0x0;
  piVar7 = (int *)((int)this + 0x7418);
  do {
    if (*piVar7 < 0) goto LAB_10008911;
    pvVar10 = (void *)((int)pvVar10 + 1);
    piVar7 = piVar7 + 0x13;
  } while ((int)pvVar10 < 0x10);
  pvVar10 = (void *)0xffffffff;
LAB_10008911:
  if (param_1 == '\0') {
    pvVar8 = *(void **)((int)this + 0x7410);
  }
  else {
    pvVar8 = GenericThreadLocals::CThreadLocalBase::Get((CThreadLocalBase *)&DAT_100483c8);
  }
  if (param_2 == '\0') {
    puVar9 = (undefined4 *)(((int)pvVar8 + 0x187) * 0x4c + (int)this);
    puVar4 = (undefined4 *)(((int)pvVar10 + 0x187) * 0x4c + (int)this);
    uVar1 = puVar9[1];
    uVar2 = puVar9[2];
    uVar3 = puVar9[3];
    *puVar4 = *puVar9;
    puVar4[1] = uVar1;
    puVar4[2] = uVar2;
    puVar4[3] = uVar3;
    uVar1 = puVar9[5];
    uVar2 = puVar9[6];
    uVar3 = puVar9[7];
    puVar4[4] = puVar9[4];
    puVar4[5] = uVar1;
    puVar4[6] = uVar2;
    puVar4[7] = uVar3;
    uVar1 = puVar9[9];
    uVar2 = puVar9[10];
    uVar3 = puVar9[0xb];
    puVar4[8] = puVar9[8];
    puVar4[9] = uVar1;
    puVar4[10] = uVar2;
    puVar4[0xb] = uVar3;
    uVar1 = puVar9[0xd];
    uVar2 = puVar9[0xe];
    uVar3 = puVar9[0xf];
    puVar4[0xc] = puVar9[0xc];
    puVar4[0xd] = uVar1;
    puVar4[0xe] = uVar2;
    puVar4[0xf] = uVar3;
    *(undefined8 *)(puVar4 + 0x10) = *(undefined8 *)(puVar9 + 0x10);
    puVar4[0x12] = puVar9[0x12];
  }
  else {
    *(undefined4 *)((int)pvVar10 * 0x4c + 0x7418 + (int)this) = 0;
    *(int *)((int)pvVar10 * 0x4c + 0x745c + (int)this) = (int)this + 0x78d4;
  }
  *(void **)(((int)pvVar10 + 0x187) * 0x4c + (int)this) = pvVar8;
  if (param_1 == '\0') {
    *(void **)((int)this + 0x7410) = pvVar10;
  }
  else {
    GenericThreadLocals::CThreadLocalBase::Set((CThreadLocalBase *)&DAT_100483c8,pvVar10);
  }
  puVar4 = *(undefined4 **)((int)this + 0x740c);
  puVar4[1] = puVar4[1] + -1;
  if (puVar4[1] == 0) {
    *puVar4 = 0;
  }
  return;
}



int __thiscall
FUN_100089e0(void *this,byte *param_1,undefined *param_2,int param_3,int param_4,int param_5)

{
  uint uVar1;
  int iVar2;
  byte *pbVar3;
  
  iVar2 = DAT_100483c4;
                    // WARNING: Load size is inaccurate
  if (0xff < *this) {
    if (DAT_100483bc == (int *)0x0) {
      if ((DAT_1004fcc0 & 1) == 0) {
        DAT_1004fcc0 = DAT_1004fcc0 | 1;
        FUN_100082f0(&DAT_100483e0);
        FUN_1002050a(FUN_10035150);
      }
      DAT_100483bc = &DAT_100483e0;
    }
    if (((-1 < iVar2) && (iVar2 < *DAT_100483bc)) && (DAT_100483bc[iVar2 * 0xd + 3] < 4)) {
      LoggingSystem_Log(DAT_100483c4,3,(byte *)"Out of logging channels.\n");
    }
    return -1;
  }
  iVar2 = 0;
  if (0 < *this) {
    pbVar3 = (byte *)((int)this + 0x14);
    do {
      uVar1 = V_tier0_stricmp(pbVar3,param_1);
      if (uVar1 == 0) {
        if (param_2 != (undefined *)0x0) {
          (*(code *)param_2)();
        }
        if (((*(int *)((int)this + iVar2 * 0x34 + 8) == 0) &&
            (*(int *)((int)this + iVar2 * 0x34 + 0xc) == 0)) &&
           (*(int *)((int)this + iVar2 * 0x34 + 0x10) == DAT_100483c0)) {
          *(int *)((int)this + iVar2 * 0x34 + 8) = param_3;
          *(int *)((int)this + iVar2 * 0x34 + 0xc) = param_4;
          *(int *)((int)this + iVar2 * 0x34 + 0x10) = param_5;
        }
        return *(int *)((int)this + iVar2 * 0x34 + 4);
      }
      iVar2 = iVar2 + 1;
      pbVar3 = pbVar3 + 0x34;
                    // WARNING: Load size is inaccurate
    } while (iVar2 < *this);
  }
                    // WARNING: Load size is inaccurate
  *(int *)(*this * 0x34 + 4 + (int)this) = *this;
                    // WARNING: Load size is inaccurate
  *(int *)(*this * 0x34 + 8 + (int)this) = param_3;
                    // WARNING: Load size is inaccurate
  *(int *)(*this * 0x34 + 0xc + (int)this) = param_4;
                    // WARNING: Load size is inaccurate
  *(int *)(*this * 0x34 + 0x10 + (int)this) = param_5;
                    // WARNING: Load size is inaccurate
  _strncpy((char *)(*this * 0x34 + 0x14 + (int)this),(char *)param_1,0x20);
  if (param_2 != (undefined *)0x0) {
    (*(code *)param_2)();
  }
                    // WARNING: Load size is inaccurate
  iVar2 = *this;
  *(int *)this = iVar2 + 1;
  return iVar2;
}



int __thiscall FUN_10008b30(void *this,int param_1)

{
  int *piVar1;
  DWORD *this_00;
  uint uVar2;
  undefined4 *puVar3;
  DWORD DVar4;
  DWORD DVar5;
  void *pvVar6;
  int iVar7;
  
  if (*(int *)((int)this + 0x740c) == 0) {
    puVar3 = (undefined4 *)FUN_1001f8b3(8);
    if (puVar3 == (undefined4 *)0x0) {
      puVar3 = (undefined4 *)0x0;
    }
    else {
      *puVar3 = 0;
      puVar3[1] = 0;
    }
    *(undefined4 **)((int)this + 0x740c) = puVar3;
  }
  this_00 = *(DWORD **)((int)this + 0x740c);
  DVar4 = GetCurrentThreadId();
  if (DVar4 != *this_00) {
    DVar5 = 0;
    LOCK();
    if (*this_00 == 0) {
      *this_00 = DVar4;
    }
    else {
      DVar5 = *this_00;
    }
    if (DVar5 != 0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)this_00,DVar4,0);
      goto LAB_10008b94;
    }
  }
  this_00[1] = this_00[1] + 1;
LAB_10008b94:
  pvVar6 = GenericThreadLocals::CThreadLocalBase::Get((CThreadLocalBase *)&DAT_100483c8);
  if (pvVar6 == (void *)0x0) {
    pvVar6 = *(void **)((int)this + 0x7410);
  }
  iVar7 = (int)pvVar6 + 0x187;
  uVar2 = *(uint *)((int)this + iVar7 * 0x4c + 4);
  if (uVar2 < 0x10) {
    *(int *)((int)this + uVar2 * 4 + iVar7 * 0x4c + 8) = param_1;
    piVar1 = (int *)((int)this + iVar7 * 0x4c + 4);
    *piVar1 = *piVar1 + 1;
    iVar7 = param_1;
  }
  piVar1 = *(int **)((int)this + 0x740c);
  piVar1[1] = piVar1[1] + -1;
  if (piVar1[1] == 0) {
    iVar7 = *piVar1;
    *piVar1 = 0;
  }
  return iVar7;
}



void FUN_10008be0(void)

{
  LoggingSystem_AddTagToCurrentChannel((byte *)"Console");
  return;
}



void FUN_10008bf0(void)

{
  LoggingSystem_AddTagToCurrentChannel((byte *)"DeveloperVerbose");
  LoggingSystem_AddTagToCurrentChannel((byte *)"Console");
  return;
}



void FUN_10008c10(void)

{
  LoggingSystem_AddTagToCurrentChannel((byte *)"Developer");
  return;
}



void FUN_10008c20(void)

{
  LoggingSystem_AddTagToCurrentChannel((byte *)"DeveloperVerbose");
  return;
}



void __thiscall FUN_10008ce0(void *this,byte *param_1,int param_2)

{
  byte **ppbVar1;
  uint uVar2;
  int iVar3;
  int *piVar4;
  
  iVar3 = 0;
                    // WARNING: Load size is inaccurate
  if (0 < *this) {
    piVar4 = (int *)((int)this + 0xc);
    do {
      for (ppbVar1 = (byte **)piVar4[10]; ppbVar1 != (byte **)0x0; ppbVar1 = (byte **)ppbVar1[1]) {
        uVar2 = V_tier0_stricmp(*ppbVar1,param_1);
        if (uVar2 == 0) {
          *piVar4 = param_2;
          break;
        }
      }
      iVar3 = iVar3 + 1;
      piVar4 = piVar4 + 0xd;
                    // WARNING: Load size is inaccurate
    } while (iVar3 < *this);
  }
  return;
}



int __thiscall FUN_10008d40(void *this,int param_1)

{
  DWORD *this_00;
  int *piVar1;
  undefined4 *puVar2;
  DWORD DVar3;
  DWORD DVar4;
  void *pvVar5;
  
  if (*(int *)((int)this + 0x740c) == 0) {
    puVar2 = (undefined4 *)FUN_1001f8b3(8);
    if (puVar2 == (undefined4 *)0x0) {
      puVar2 = (undefined4 *)0x0;
    }
    else {
      *puVar2 = 0;
      puVar2[1] = 0;
    }
    *(undefined4 **)((int)this + 0x740c) = puVar2;
  }
  this_00 = *(DWORD **)((int)this + 0x740c);
  DVar3 = GetCurrentThreadId();
  if (DVar3 != *this_00) {
    DVar4 = 0;
    LOCK();
    if (*this_00 == 0) {
      *this_00 = DVar3;
    }
    else {
      DVar4 = *this_00;
    }
    if (DVar4 != 0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)this_00,DVar3,0);
      goto LAB_10008da4;
    }
  }
  this_00[1] = this_00[1] + 1;
LAB_10008da4:
  pvVar5 = GenericThreadLocals::CThreadLocalBase::Get((CThreadLocalBase *)&DAT_100483c8);
  if (pvVar5 == (void *)0x0) {
    pvVar5 = *(void **)((int)this + 0x7410);
  }
  if (param_1 == 0) {
    param_1 = (int)this + 0x78d4;
  }
  *(int *)((int)this + ((int)pvVar5 + 0x187) * 0x4c + 0x48) = param_1;
  piVar1 = *(int **)((int)this + 0x740c);
  piVar1[1] = piVar1[1] + -1;
  if (piVar1[1] == 0) {
    param_1 = *piVar1;
    *piVar1 = 0;
  }
  return param_1;
}



void __cdecl LoggingSystem_AddTagToCurrentChannel(byte *param_1)

{
  int iVar1;
  byte **ppbVar2;
  int *this;
  uint uVar3;
  int *piVar4;
  
                    // 0x8df0  350  LoggingSystem_AddTagToCurrentChannel
  if (DAT_100483bc == (int *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  this = DAT_100483bc;
  iVar1 = *DAT_100483bc;
  ppbVar2 = (byte **)DAT_100483bc[iVar1 * 0xd + 0xd];
  while( true ) {
    if (ppbVar2 == (byte **)0x0) {
      piVar4 = FUN_100083a0(this,(char *)param_1);
      piVar4[1] = this[iVar1 * 0xd + 0xd];
      this[iVar1 * 0xd + 0xd] = (int)piVar4;
      return;
    }
    uVar3 = V_tier0_stricmp(*ppbVar2,param_1);
    if (uVar3 == 0) break;
    ppbVar2 = (byte **)ppbVar2[1];
  }
  return;
}



int __cdecl LoggingSystem_FindChannel(byte *param_1)

{
  int *piVar1;
  uint uVar2;
  int iVar3;
  int *piVar4;
  
                    // 0x8e90  351  LoggingSystem_FindChannel
  if (DAT_100483bc == (int *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  piVar1 = DAT_100483bc;
  iVar3 = 0;
  if (0 < *DAT_100483bc) {
    piVar4 = DAT_100483bc + 5;
    do {
      uVar2 = V_tier0_stricmp((byte *)piVar4,param_1);
      if (uVar2 == 0) {
        return iVar3;
      }
      iVar3 = iVar3 + 1;
      piVar4 = piVar4 + 0xd;
    } while (iVar3 < *piVar1);
  }
  return -1;
}



undefined4 * __cdecl LoggingSystem_GetChannel(int param_1)

{
                    // 0x8f10  352  LoggingSystem_GetChannel
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  return DAT_100483bc + param_1 * 0xd + 1;
}



undefined4 __cdecl LoggingSystem_GetChannelColor(int param_1)

{
                    // 0x8f60  353  LoggingSystem_GetChannelColor
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  return DAT_100483bc[param_1 * 0xd + 4];
}



undefined4 LoggingSystem_GetChannelCount(void)

{
                    // 0x8fb0  354  LoggingSystem_GetChannelCount
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
    return DAT_100483e0;
  }
  return *DAT_100483bc;
}



undefined4 __cdecl LoggingSystem_GetChannelFlags(int param_1)

{
                    // 0x9000  355  LoggingSystem_GetChannelFlags
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  return DAT_100483bc[param_1 * 0xd + 2];
}



int LoggingSystem_GetFirstChannelID(void)

{
                    // 0x9050  356  LoggingSystem_GetFirstChannelID
  if (DAT_100483bc == (int *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  return (0 < *DAT_100483bc) - 1;
}



int __cdecl LoggingSystem_GetNextChannelID(int param_1)

{
  int iVar1;
  
                    // 0x90a0  357  LoggingSystem_GetNextChannelID
  if (DAT_100483bc == (int *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  iVar1 = -1;
  if (param_1 + 1 < *DAT_100483bc) {
    iVar1 = param_1 + 1;
  }
  return iVar1;
}



uint __cdecl LoggingSystem_HasTag(int param_1,byte *param_2)

{
  byte **ppbVar1;
  uint uVar2;
  
                    // 0x9100  358  LoggingSystem_HasTag
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  uVar2 = (param_1 + 1) * 0x34;
  ppbVar1 = (byte **)DAT_100483bc[(param_1 + 1) * 0xd];
  while( true ) {
    if (ppbVar1 == (byte **)0x0) {
      return uVar2 & 0xffffff00;
    }
    uVar2 = V_tier0_stricmp(*ppbVar1,param_2);
    if (uVar2 == 0) break;
    ppbVar1 = (byte **)ppbVar1[1];
  }
  return 1;
}



undefined4 __cdecl LoggingSystem_IsChannelEnabled(int param_1,int param_2)

{
  int iVar1;
  
                    // 0x9180  359  LoggingSystem_IsChannelEnabled
  if (DAT_100483bc == (int *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  if (((-1 < param_1) && (param_1 < *DAT_100483bc)) &&
     (iVar1 = param_1 * 0xd, param_1 = param_2, DAT_100483bc[iVar1 + 3] <= param_2)) {
    return CONCAT31((int3)((uint)param_2 >> 8),1);
  }
  return param_1 & 0xffffff00;
}



int __cdecl LoggingSystem_Log(int param_1,int param_2,byte *param_3)

{
  int iVar1;
  char local_804 [2048];
  
                    // 0x91f0  360  LoggingSystem_Log
  if (DAT_100483bc == (int *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  if (((-1 < param_1) && (param_1 < *DAT_100483bc)) && (DAT_100483bc[param_1 * 0xd + 3] <= param_2))
  {
    FUN_10021749(local_804,0x800,param_3,(int **)&stack0x00000010);
    if (DAT_100483bc == (int *)0x0) {
      if ((DAT_1004fcc0 & 1) == 0) {
        DAT_1004fcc0 = DAT_1004fcc0 | 1;
        FUN_100082f0(&DAT_100483e0);
        FUN_1002050a(FUN_10035150);
      }
      DAT_100483bc = &DAT_100483e0;
    }
    iVar1 = FUN_100084c0(DAT_100483bc,param_1,param_2,DAT_100483c0,local_804);
    return iVar1;
  }
  return 0;
}



int __cdecl LoggingSystem_LogAssert(byte *param_1)

{
  int iVar1;
  char local_804 [2048];
  
                    // 0x92e0  361  LoggingSystem_LogAssert
  if (DAT_100483bc == (int *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  if (((-1 < DAT_100483cc) && (DAT_100483cc < *DAT_100483bc)) &&
     (DAT_100483bc[DAT_100483cc * 0xd + 3] < 3)) {
    FUN_10021749(local_804,0x800,param_1,(int **)&stack0x00000008);
    if (DAT_100483bc == (int *)0x0) {
      if ((DAT_1004fcc0 & 1) == 0) {
        DAT_1004fcc0 = DAT_1004fcc0 | 1;
        FUN_100082f0(&DAT_100483e0);
        FUN_1002050a(FUN_10035150);
      }
      DAT_100483bc = &DAT_100483e0;
    }
    iVar1 = FUN_100084c0(DAT_100483bc,DAT_100483cc,2,DAT_100483c0,local_804);
    return iVar1;
  }
  return 0;
}



int __cdecl LoggingSystem_LogDirect(int param_1,int param_2,int param_3,undefined4 param_4)

{
  int iVar1;
  
                    // 0x93d0  362  LoggingSystem_LogDirect
  if (DAT_100483bc == (int *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  if (((-1 < param_1) && (param_1 < *DAT_100483bc)) && (DAT_100483bc[param_1 * 0xd + 3] <= param_2))
  {
    if (DAT_100483bc == (int *)0x0) {
      if ((DAT_1004fcc0 & 1) == 0) {
        DAT_1004fcc0 = DAT_1004fcc0 | 1;
        FUN_100082f0(&DAT_100483e0);
        FUN_1002050a(FUN_10035150);
      }
      DAT_100483bc = &DAT_100483e0;
    }
    iVar1 = FUN_100084c0(DAT_100483bc,param_1,param_2,param_3,param_4);
    return iVar1;
  }
  return 0;
}



void __cdecl LoggingSystem_PopLoggingState(char param_1)

{
                    // 0x9490  363  LoggingSystem_PopLoggingState
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  FUN_100087c0(DAT_100483bc,param_1);
  return;
}



void __cdecl LoggingSystem_PushLoggingState(char param_1,char param_2)

{
                    // 0x94e0  364  LoggingSystem_PushLoggingState
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  FUN_10008890(DAT_100483bc,param_1,param_2);
  return;
}



void __cdecl
LoggingSystem_RegisterLoggingChannel
          (byte *param_1,undefined *param_2,int param_3,int param_4,int param_5)

{
                    // 0x9540  365  LoggingSystem_RegisterLoggingChannel
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  FUN_100089e0(DAT_100483bc,param_1,param_2,param_3,param_4,param_5);
  return;
}



void __cdecl LoggingSystem_RegisterLoggingListener(int param_1)

{
                    // 0x95a0  366  LoggingSystem_RegisterLoggingListener
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  FUN_10008b30(DAT_100483bc,param_1);
  return;
}



undefined4 * LoggingSystem_ResetCurrentLoggingState(void)

{
  DWORD *this;
  undefined4 *puVar1;
  undefined4 *puVar2;
  DWORD DVar3;
  DWORD DVar4;
  void *pvVar5;
  
                    // 0x95f0  367  LoggingSystem_ResetCurrentLoggingState
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  puVar1 = DAT_100483bc;
  if (DAT_100483bc[0x1d03] == 0) {
    puVar2 = (undefined4 *)FUN_1001f8b3(8);
    if (puVar2 == (undefined4 *)0x0) {
      puVar2 = (undefined4 *)0x0;
    }
    else {
      *puVar2 = 0;
      puVar2[1] = 0;
    }
    puVar1[0x1d03] = puVar2;
  }
  this = (DWORD *)puVar1[0x1d03];
  DVar3 = GetCurrentThreadId();
  if (DVar3 != *this) {
    DVar4 = 0;
    LOCK();
    if (*this == 0) {
      *this = DVar3;
    }
    else {
      DVar4 = *this;
    }
    if (DVar4 != 0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)this,DVar3,0);
      goto LAB_10008c91;
    }
  }
  this[1] = this[1] + 1;
LAB_10008c91:
  pvVar5 = GenericThreadLocals::CThreadLocalBase::Get((CThreadLocalBase *)&DAT_100483c8);
  if (pvVar5 == (void *)0x0) {
    pvVar5 = (void *)puVar1[0x1d04];
  }
  puVar2 = puVar1 + 0x1e35;
  puVar1[((int)pvVar5 + 0x187) * 0x13 + 1] = 0;
  puVar1[((int)pvVar5 + 0x187) * 0x13 + 0x12] = puVar2;
  puVar1 = (undefined4 *)puVar1[0x1d03];
  puVar1[1] = puVar1[1] + -1;
  if (puVar1[1] == 0) {
    puVar2 = (undefined4 *)*puVar1;
    *puVar1 = 0;
  }
  return puVar2;
}



void __cdecl LoggingSystem_SetChannelColor(int param_1,undefined4 param_2)

{
                    // 0x9640  368  LoggingSystem_SetChannelColor
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  DAT_100483bc[param_1 * 0xd + 4] = param_2;
  return;
}



void __cdecl LoggingSystem_SetChannelFlags(int param_1,undefined4 param_2)

{
                    // 0x96a0  369  LoggingSystem_SetChannelFlags
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  DAT_100483bc[param_1 * 0xd + 2] = param_2;
  return;
}



void __cdecl LoggingSystem_SetChannelSpewLevel(int param_1,undefined4 param_2)

{
                    // 0x9700  370  LoggingSystem_SetChannelSpewLevel
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  DAT_100483bc[param_1 * 0xd + 3] = param_2;
  return;
}



void __cdecl LoggingSystem_SetChannelSpewLevelByName(byte *param_1,int param_2)

{
  int *piVar1;
  uint uVar2;
  int *piVar3;
  int iVar4;
  
                    // 0x9760  371  LoggingSystem_SetChannelSpewLevelByName
  if (DAT_100483bc == (int *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  piVar1 = DAT_100483bc;
  iVar4 = 0;
  if (0 < *DAT_100483bc) {
    piVar3 = DAT_100483bc + 3;
    do {
      uVar2 = V_tier0_stricmp((byte *)(piVar3 + 2),param_1);
      if (uVar2 == 0) {
        *piVar3 = param_2;
      }
      iVar4 = iVar4 + 1;
      piVar3 = piVar3 + 0xd;
    } while (iVar4 < *piVar1);
  }
  return;
}



void __cdecl LoggingSystem_SetChannelSpewLevelByTag(byte *param_1,int param_2)

{
                    // 0x97e0  372  LoggingSystem_SetChannelSpewLevelByTag
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  FUN_10008ce0(DAT_100483bc,param_1,param_2);
  return;
}



void __cdecl LoggingSystem_SetGlobalSpewLevel(int param_1)

{
  int *piVar1;
  int iVar2;
  int *piVar3;
  
                    // 0x9840  373  LoggingSystem_SetGlobalSpewLevel
  if (DAT_100483bc == (int *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  piVar1 = DAT_100483bc;
  iVar2 = 0;
  if (0 < *DAT_100483bc) {
    piVar3 = DAT_100483bc + 3;
    do {
      *piVar3 = param_1;
      piVar3 = piVar3 + 0xd;
      iVar2 = iVar2 + 1;
    } while (iVar2 < *piVar1);
  }
  return;
}



void __cdecl LoggingSystem_SetLoggingResponsePolicy(int param_1)

{
                    // 0x98a0  374  LoggingSystem_SetLoggingResponsePolicy
  if (DAT_100483bc == (undefined4 *)0x0) {
    if ((DAT_1004fcc0 & 1) == 0) {
      DAT_1004fcc0 = DAT_1004fcc0 | 1;
      FUN_100082f0(&DAT_100483e0);
      FUN_1002050a(FUN_10035150);
    }
    DAT_100483bc = &DAT_100483e0;
  }
  FUN_10008d40(DAT_100483bc,param_1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __cdecl MemAllocScratch(int param_1)

{
  int iVar1;
  int iVar2;
  
                    // 0x98f0  375  MemAllocScratch
  iVar2 = DAT_1004fd54 + param_1;
  iVar1 = DAT_1004fd54;
  if (_DAT_1004fd58 < iVar2) {
    if (iVar2 < 0x800) {
      iVar2 = 0x800;
    }
    _DAT_1004fd58 = iVar2;
    if (DAT_1004fd50 == 0) {
      DAT_1004fd50 = (**(code **)(*(int *)g_pMemAlloc + 4))(iVar2);
      iVar1 = DAT_1004fd54;
    }
    else {
      DAT_1004fd50 = (**(code **)(*(int *)g_pMemAlloc + 0xc))(DAT_1004fd50);
      iVar1 = DAT_1004fd54;
    }
  }
  iVar2 = DAT_1004fd50;
  DAT_1004fd54 = iVar1 + param_1;
  DAT_1004652c = DAT_1004652c + 1;
  (&DAT_1004fcd0)[DAT_1004652c] = param_1;
  return iVar2 + iVar1;
}



void MemFreeScratch(void)

{
                    // 0x9980  376  MemFreeScratch
  DAT_1004fd54 = DAT_1004fd54 - (&DAT_1004fcd0)[DAT_1004652c];
  DAT_1004652c = DAT_1004652c + -1;
  return;
}



void MemOutOfMemory(void)

{
  code *pcVar1;
  bool bVar2;
  
                    // 0x99a0  377  MemOutOfMemory
  bVar2 = Plat_IsInDebugSession();
  if (bVar2) {
    pcVar1 = (code *)swi(3);
    (*pcVar1)();
    return;
  }
  WriteMiniDump();
  Plat_ExitProcess(1);
  return;
}



int FUN_100099c0(void)

{
  int iVar1;
  int iVar2;
  LPCVOID local_10;
  int local_c;
  int local_8;
  
  iVar2 = 0;
  local_10 = (LPCVOID)0x0;
  iVar1 = FUN_10021f55(&local_10);
  while (iVar1 == -2) {
    iVar1 = 0;
    if (local_8 == 1) {
      iVar1 = local_c;
    }
    iVar2 = iVar2 + iVar1;
    iVar1 = FUN_10021f55(&local_10);
  }
  if ((iVar1 != -5) && (iVar1 != -1)) {
    iVar2 = -1;
  }
  return iVar2;
}



void __cdecl FUN_10009a20(undefined4 *param_1,uint param_2)

{
  LPSTR _Source;
  undefined (*pauVar1) [16];
  undefined4 extraout_ECX;
  uint uVar2;
  undefined4 extraout_EDX;
  char local_204 [511];
  undefined local_5;
  
  if (param_1 != (undefined4 *)0x0) {
    if ((DAT_1004fd68 & 1) == 0) {
      DAT_1004fd68 = DAT_1004fd68 | 1;
      DAT_1004fd64 = Plat_IsInDebugSession();
    }
    if (DAT_1004fd6c == '\0') {
      DAT_1004fd6c = '\x01';
      _Source = Plat_GetCommandLine();
      if (_Source != (LPSTR)0x0) {
        _strncpy(local_204,_Source,0x1ff);
        local_5 = 0;
        __strupr(local_204);
        pauVar1 = FUN_10021ad0(extraout_ECX,extraout_EDX,(undefined (*) [16])local_204,
                               (undefined (*) [16])"-RANDOMIZEMEMORY");
        uVar2 = (uint)DAT_1004fd6d;
        if (pauVar1 != (undefined (*) [16])0x0) {
          uVar2 = 1;
        }
        DAT_1004fd6d = (byte)uVar2;
        pauVar1 = FUN_10021ad0(uVar2,1,(undefined (*) [16])local_204,
                               (undefined (*) [16])"-NOINITMEMORY");
        if (pauVar1 != (undefined (*) [16])0x0) {
          DAT_10046638 = 0;
        }
      }
    }
    if (DAT_1004fd6d != 0) {
      FUN_10009b60((int)param_1,param_2);
      return;
    }
    if (DAT_1004fd64 != '\0') {
      FUN_10009b20(param_1,param_2);
    }
  }
  return;
}



void __cdecl FUN_10009b20(undefined4 *param_1,uint param_2)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  uint uVar3;
  
  uVar3 = param_2 >> 2;
  puVar1 = param_1;
  if (uVar3 != 0) {
    puVar1 = (undefined4 *)((int)param_1 + (param_2 & 0xfffffffc));
    for (; uVar3 != 0; uVar3 = uVar3 - 1) {
      *param_1 = 0xffeeffee;
      param_1 = param_1 + 1;
    }
  }
  uVar3 = param_2 & 3;
  if (uVar3 != 0) {
    puVar2 = puVar1;
    do {
      *(undefined *)puVar2 = *(undefined *)(((int)&DAT_10046530 - (int)puVar1) + (int)puVar2);
      uVar3 = uVar3 - 1;
      puVar2 = (undefined4 *)((int)puVar2 + 1);
    } while (uVar3 != 0);
  }
  return;
}



void __cdecl FUN_10009b60(int param_1,uint param_2)

{
  uint uVar1;
  
  uVar1 = 0;
  if (param_2 != 0) {
    do {
      *(undefined *)(uVar1 + param_1) = (&DAT_10046538)[DAT_1004fd5c & 0xff];
      uVar1 = uVar1 + 1;
      DAT_1004fd5c = DAT_1004fd5c + 1;
    } while (uVar1 < param_2);
  }
  return;
}



// public: __thiscall BasicStatStructFieldDesc::BasicStatStructFieldDesc(class
// BasicStatStructFieldDesc const &)

BasicStatStructFieldDesc * __thiscall
BasicStatStructFieldDesc::BasicStatStructFieldDesc
          (BasicStatStructFieldDesc *this,BasicStatStructFieldDesc *param_1)

{
                    // 0x9ba0  1  ??0BasicStatStructFieldDesc@@QAE@ABV0@@Z
  *(undefined ***)this = CallStackStatStructDescFuncs::_vftable_;
  *(undefined4 *)(this + 4) = *(undefined4 *)(param_1 + 4);
  *(undefined4 *)(this + 8) = *(undefined4 *)(param_1 + 8);
  *(undefined4 *)(this + 0xc) = *(undefined4 *)(param_1 + 0xc);
  *(undefined ***)this = _vftable_;
  *(undefined4 *)(this + 0x10) = *(undefined4 *)(param_1 + 0x10);
  *(undefined4 *)(this + 0x14) = *(undefined4 *)(param_1 + 0x14);
  return this;
}



// public: __thiscall BasicStatStructFieldDesc::BasicStatStructFieldDesc(enum
// BasicStatStructFieldTypes_t,enum BasicStatStructFieldCombineMethods_t)

BasicStatStructFieldDesc * __thiscall
BasicStatStructFieldDesc::BasicStatStructFieldDesc
          (BasicStatStructFieldDesc *this,BasicStatStructFieldTypes_t param_1,
          BasicStatStructFieldCombineMethods_t param_2)

{
                    // 0x9be0  2
                    // ??0BasicStatStructFieldDesc@@QAE@W4BasicStatStructFieldTypes_t@@W4BasicStatStructFieldCombineMethods_t@@@Z
  *(BasicStatStructFieldTypes_t *)(this + 0x10) = param_1;
  *(BasicStatStructFieldCombineMethods_t *)(this + 0x14) = param_2;
  *(undefined ***)this = _vftable_;
  return this;
}



// public: __thiscall CallStackStatStructDescFuncs::CallStackStatStructDescFuncs(class
// CallStackStatStructDescFuncs const &)

CallStackStatStructDescFuncs * __thiscall
CallStackStatStructDescFuncs::CallStackStatStructDescFuncs
          (CallStackStatStructDescFuncs *this,CallStackStatStructDescFuncs *param_1)

{
                    // 0x9c00  26  ??0CallStackStatStructDescFuncs@@QAE@ABV0@@Z
  *(undefined ***)this = _vftable_;
  *(undefined4 *)(this + 4) = *(undefined4 *)(param_1 + 4);
  *(undefined4 *)(this + 8) = *(undefined4 *)(param_1 + 8);
  *(undefined4 *)(this + 0xc) = *(undefined4 *)(param_1 + 0xc);
  return this;
}



// public: __thiscall CallStackStatStructDescFuncs::CallStackStatStructDescFuncs(void)

CallStackStatStructDescFuncs * __thiscall
CallStackStatStructDescFuncs::CallStackStatStructDescFuncs(CallStackStatStructDescFuncs *this)

{
                    // 0x9c30  27  ??0CallStackStatStructDescFuncs@@QAE@XZ
  *(undefined ***)this = _vftable_;
  return this;
}



// public: class BasicStatStructFieldDesc & __thiscall BasicStatStructFieldDesc::operator=(class
// BasicStatStructFieldDesc const &)

BasicStatStructFieldDesc * __thiscall
BasicStatStructFieldDesc::operator_
          (BasicStatStructFieldDesc *this,BasicStatStructFieldDesc *param_1)

{
                    // 0x9c40  44  ??4BasicStatStructFieldDesc@@QAEAAV0@ABV0@@Z
  *(undefined4 *)(this + 4) = *(undefined4 *)(param_1 + 4);
  *(undefined4 *)(this + 8) = *(undefined4 *)(param_1 + 8);
  *(undefined4 *)(this + 0xc) = *(undefined4 *)(param_1 + 0xc);
  *(undefined4 *)(this + 0x10) = *(undefined4 *)(param_1 + 0x10);
  *(undefined4 *)(this + 0x14) = *(undefined4 *)(param_1 + 0x14);
  return this;
}



// public: class CTestSuite & __thiscall CTestSuite::operator=(class CTestSuite const &)

CTestSuite * __thiscall CTestSuite::operator_(CTestSuite *this,CTestSuite *param_1)

{
                    // 0x9c70  51  ??4CTestSuite@@QAEAAV0@ABV0@@Z
                    // 0x9c70  56  ??4CallStackStatStructDescFuncs@@QAEAAV0@ABV0@@Z
  *(undefined4 *)(this + 4) = *(undefined4 *)(param_1 + 4);
  *(undefined4 *)(this + 8) = *(undefined4 *)(param_1 + 8);
  *(undefined4 *)(this + 0xc) = *(undefined4 *)(param_1 + 0xc);
  return this;
}



undefined4 * __thiscall FUN_10009c90(void *this,byte param_1)

{
  *(undefined ***)this = IMemAlloc::vftable;
  if ((param_1 & 1) != 0) {
    FID_conflict__free(this);
  }
  return (undefined4 *)this;
}



void __thiscall FUN_10009cc0(void *this,undefined4 param_1)

{
                    // WARNING: Load size is inaccurate
  (**(code **)(*this + 4))(param_1);
  return;
}



void __thiscall FUN_10009cd0(void *this,int param_1)

{
  LPVOID pvVar1;
  byte bVar2;
  
  if (param_1 == 0) {
    param_1 = 1;
  }
  pvVar1 = FUN_10009d00(this,param_1);
  bVar2 = 0x10 - ((byte)pvVar1 & 0xf);
  *(byte *)((int)pvVar1 + (bVar2 - 1)) = bVar2;
  return;
}



LPVOID __thiscall FUN_10009d00(void *this,int param_1)

{
  code *pcVar1;
  LPVOID pvVar2;
  
  if (*(HANDLE *)((int)this + 4) == (HANDLE)0x0) {
    pcVar1 = (code *)swi(3);
    pvVar2 = (LPVOID)(*pcVar1)();
    return pvVar2;
  }
  pvVar2 = HeapAlloc(*(HANDLE *)((int)this + 4),*(DWORD *)((int)this + 8),param_1 + 0x10);
  if (pvVar2 == (LPVOID)0x0) {
                    // WARNING: Load size is inaccurate
    (**(code **)(*this + 0x90))(param_1);
  }
  InterlockedExchangeAdd((LONG *)((int)this + 0xc),param_1);
  InterlockedExchangeAdd((LONG *)((int)this + 0x10),param_1 + 0x100fU & 0xfffff000);
  InterlockedIncrement((LONG *)((int)this + 0x14));
  InterlockedIncrement((LONG *)((int)this + 0x1c));
  return pvVar2;
}



uint __cdecl FUN_10009d70(undefined (*param_1) [16])

{
  uint uVar1;
  undefined (*pauVar2) [16];
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  undefined4 extraout_ECX_01;
  undefined4 extraout_ECX_02;
  undefined4 uVar3;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 extraout_EDX_02;
  undefined4 uVar4;
  bool bVar5;
  bool bVar6;
  char local_5;
  
  local_5 = '\0';
  uVar1 = FUN_1000a110((HKEY)&local_5);
  DAT_1004fd7e = (char)uVar1;
  FUN_10021ad0(extraout_ECX,extraout_EDX,param_1,(undefined (*) [16])"-RESERVELOWMEM");
  VirtualAlloc((LPVOID)0xffeeffee,1,0x2000,1);
  HeapSetInformation((HANDLE)0x0,HeapEnableTerminationOnCorruption,(PVOID)0x0,0);
  bVar6 = false;
  pauVar2 = FUN_10021ad0(extraout_ECX_00,extraout_EDX_00,param_1,(undefined (*) [16])"-PROCESSHEAP")
  ;
  bVar5 = pauVar2 != (undefined (*) [16])0x0;
  uVar3 = extraout_ECX_01;
  uVar4 = extraout_EDX_01;
  if (bVar5) {
    pauVar2 = FUN_10021ad0(extraout_ECX_01,extraout_EDX_01,param_1,
                           (undefined (*) [16])"-PROCESSHEAPZEROMEM");
    bVar6 = pauVar2 != (undefined (*) [16])0x0;
    uVar3 = extraout_ECX_02;
    uVar4 = extraout_EDX_02;
  }
  pauVar2 = FUN_10021ad0(uVar3,uVar4,param_1,(undefined (*) [16])"-NOPROCESSHEAP");
  if ((pauVar2 == (undefined (*) [16])0x0) && ((DAT_1004fd7e != '\0' || (local_5 != '\0')))) {
    uVar1 = FUN_10009f10(bVar6);
    return uVar1 & 0xffffff00 | 1;
  }
  if (bVar5) {
    pauVar2 = (undefined (*) [16])FUN_10009f10(bVar6);
  }
  return (uint)pauVar2 & 0xffffff00 | (uint)bVar5;
}



bool __fastcall FUN_10009e40(int param_1)

{
  BOOL BVar1;
  
  BVar1 = HeapValidate(*(HANDLE *)(param_1 + 4),0,(LPCVOID)0x0);
  return BVar1 != 0;
}



void __fastcall FUN_10009e60(int param_1)

{
  uint uVar1;
  
  Msg((byte *)"Sorry -- no stats saved to file memstats.txt when the heap allocator is enabled.\n");
  Msg((byte *)"%u MB allocated.\n");
  Msg((byte *)"%u MB memory used assuming maximum PageHeap overhead.\n");
  uVar1 = *(uint *)(param_1 + 0x14);
  __alldiv(*(uint *)(param_1 + 0x10) + uVar1 * 0x1000,
           (((int)uVar1 >> 0x1f) << 0xc | uVar1 >> 0x14) +
           (uint)CARRY4(*(uint *)(param_1 + 0x10),uVar1 * 0x1000),0x100000,0);
  Msg((byte *)"%u MB address space used assuming maximum PageHeap overhead.\n");
  Msg((byte *)"%u outstanding allocations (%d delta).\n");
  Msg((byte *)"%u lifetime allocations (%u delta).\n");
  *(undefined4 *)(param_1 + 0x18) = *(undefined4 *)(param_1 + 0x14);
  *(undefined4 *)(param_1 + 0x20) = *(undefined4 *)(param_1 + 0x1c);
  return;
}



void __fastcall FUN_10009f00(int *param_1)

{
  (**(code **)(*param_1 + 0x48))();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_10009f10(char param_1)

{
  char *lpOutputString;
  
  if ((DAT_1004fda4 & 1) == 0) {
    DAT_1004fda4 = DAT_1004fda4 | 1;
    _DAT_1004fd80 = CHeapMemAlloc::vftable;
    _DAT_1004fd84 = GetProcessHeap();
    FUN_1002050a(FUN_10035170);
  }
  if (DAT_1004fda8 == '\0') {
    _DAT_1004fd88 = 0;
    if (param_1 != '\0') {
      _DAT_1004fd88 = 8;
    }
    if (DAT_1004fd7e == '\0') {
      lpOutputString = "PageHeap is off. Memory use will be normal.\n";
    }
    else {
      lpOutputString = "PageHeap is on. Memory use will be larger than normal.\n";
    }
    OutputDebugStringA(lpOutputString);
    if (param_1 != '\0') {
      OutputDebugStringA("  HEAP_ZERO_MEMORY is specified.\n");
    }
    FUN_1000ebe0(&DAT_1004fd80);
    DAT_1004fda8 = '\x01';
  }
  return;
}



void __thiscall FUN_10009fb0(void *this,undefined4 param_1)

{
                    // WARNING: Load size is inaccurate
  (**(code **)(*this + 0x14))(param_1);
  return;
}



void __thiscall FUN_10009fc0(void *this,uint param_1)

{
  byte bVar1;
  code *pcVar2;
  bool bVar3;
  
  if (param_1 != 0) {
    bVar1 = *(byte *)(param_1 - 1);
    if ((param_1 & 0xf) != 0) {
      bVar3 = Plat_IsInDebugSession();
      if (bVar3) {
        pcVar2 = (code *)swi(3);
        (*pcVar2)();
        return;
      }
    }
    if ((bVar1 == 0) || (0x10 < bVar1)) {
      bVar3 = Plat_IsInDebugSession();
      if (bVar3) {
        pcVar2 = (code *)swi(3);
        (*pcVar2)();
        return;
      }
    }
    FUN_1000a010(this,(LPCVOID)(param_1 - bVar1));
  }
  return;
}



void __thiscall FUN_1000a010(void *this,LPCVOID param_1)

{
  SIZE_T SVar1;
  
  SVar1 = HeapSize(*(HANDLE *)((int)this + 4),0,param_1);
  InterlockedExchangeAdd((LONG *)((int)this + 0xc),-(SVar1 - 0x10));
  InterlockedExchangeAdd((LONG *)((int)this + 0x10),-(SVar1 + 0xfff & 0xfffff000));
  InterlockedDecrement((LONG *)((int)this + 0x14));
  HeapFree(*(HANDLE *)((int)this + 4),0,param_1);
  return;
}



void FUN_1000a080(undefined4 *param_1,undefined4 *param_2)

{
  *param_1 = &DAT_1003655d;
  *param_2 = 0;
  return;
}



int __thiscall FUN_1000a0a0(void *this,uint param_1)

{
  byte bVar1;
  code *pcVar2;
  bool bVar3;
  int iVar4;
  SIZE_T SVar5;
  
  if (param_1 == 0) {
    return 0;
  }
  bVar1 = *(byte *)(param_1 - 1);
  if ((param_1 & 0xf) != 0) {
    bVar3 = Plat_IsInDebugSession();
    if (bVar3) {
      pcVar2 = (code *)swi(3);
      iVar4 = (*pcVar2)();
      return iVar4;
    }
  }
  if ((bVar1 == 0) || (0x10 < bVar1)) {
    bVar3 = Plat_IsInDebugSession();
    if (bVar3) {
      pcVar2 = (code *)swi(3);
      iVar4 = (*pcVar2)();
      return iVar4;
    }
  }
  SVar5 = HeapSize(*(HANDLE *)((int)this + 4),0,(LPCVOID)(param_1 - bVar1));
  return SVar5 - 0x10;
}



undefined FUN_1000a100(void)

{
  return 0;
}



uint __cdecl FUN_1000a110(HKEY param_1)

{
  char cVar1;
  code *pcVar2;
  HKEY pHVar3;
  bool bVar4;
  HMODULE hModule;
  char *pcVar5;
  uint uVar6;
  LSTATUS LVar7;
  char *pcVar8;
  byte bVar9;
  char local_20c [259];
  undefined local_109;
  CHAR local_108 [259];
  undefined local_5;
  
  pHVar3 = param_1;
  bVar9 = 0;
  *(undefined *)&param_1->unused = 0;
  hModule = GetModuleHandleA((LPCSTR)0x0);
  if (hModule != (HMODULE)0x0) {
    hModule = (HMODULE)GetModuleFileNameA(hModule,local_108,0x104);
    if (hModule != (HMODULE)0x0) {
      local_5 = 0;
      pcVar5 = _strrchr(local_108,0x5c);
      if (pcVar5 != (char *)0x0) {
        pcVar8 = pcVar5 + 1;
        do {
          cVar1 = *pcVar8;
          pcVar8 = pcVar8 + 1;
        } while (cVar1 != '\0');
        if (((int)pcVar8 - (int)(pcVar5 + 2) != 0) &&
           ((pcVar5 + 1)[((int)pcVar8 - (int)(pcVar5 + 2)) + -1] == ' ')) {
          OutputDebugStringA(
                            "Trailing space on executable name! This will cause Application Verifier and ETW Heap tracing to fail!\n"
                            );
          bVar4 = Plat_IsInDebugSession();
          if (bVar4) {
            pcVar2 = (code *)swi(3);
            uVar6 = (*pcVar2)();
            return uVar6;
          }
        }
        FUN_1002169d(local_20c,0x104,
                     (byte *)
                     "Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\%s"
                    );
        local_109 = 0;
        pcVar5 = (char *)RegOpenKeyA((HKEY)0x80000002,local_20c,&param_1);
        if (pcVar5 == (char *)0x0) {
          LVar7 = RegQueryValueExA(param_1,"StackTraceDatabaseSizeInMB",(LPDWORD)0x0,(LPDWORD)0x0,
                                   (LPBYTE)0x0,(LPDWORD)0x0);
          bVar9 = 0;
          if (LVar7 == 0) {
            LVar7 = RegQueryValueExA(param_1,"PageHeapFlags",(LPDWORD)0x0,(LPDWORD)0x0,(LPBYTE)0x0,
                                     (LPDWORD)0x0);
            if (LVar7 == 0) {
              bVar9 = 1;
            }
          }
          LVar7 = RegQueryValueExA(param_1,"TracingFlags",(LPDWORD)0x0,(LPDWORD)0x0,(LPBYTE)0x0,
                                   (LPDWORD)0x0);
          if (LVar7 == 0) {
            *(undefined *)&pHVar3->unused = 1;
          }
          pcVar5 = (char *)RegCloseKey(param_1);
        }
      }
      return (uint)pcVar5 & 0xffffff00 | (uint)bVar9;
    }
  }
  return (uint)hModule & 0xffffff00;
}



void __fastcall FUN_1000a240(int *param_1,undefined param_2,undefined4 param_3)

{
  code *pcVar1;
  bool bVar2;
  char local_104 [255];
  undefined local_5;
  
  bVar2 = Plat_IsInDebugSession();
  if (bVar2) {
    pcVar1 = (code *)swi(3);
    (*pcVar1)();
    return;
  }
  (**(code **)(*param_1 + 0x48))();
  FUN_1002169d(local_104,0x100,
               (byte *)
               "d:\\projects\\ti\\release\\ti_rel\\src\\tier0\\memprocessheap.cpp(323):***** OUT OF MEMORY! attempted allocation size: %I64d ****\n"
              );
  local_5 = 0;
  Plat_DebugString(local_104);
  if (DAT_1004fd7e == '\0') {
    bVar2 = Plat_IsInDebugSession();
    if (bVar2) {
      pcVar1 = (code *)swi(3);
      (*pcVar1)();
      return;
    }
  }
  Plat_ExitProcess(1);
  return;
}



void __thiscall FUN_1000a2b0(void *this,undefined4 param_1,undefined4 param_2)

{
                    // WARNING: Load size is inaccurate
  (**(code **)(*this + 0xc))(param_1,param_2);
  return;
}



void * __thiscall FUN_1000a2d0(void *this,void *param_1,uint param_2)

{
  byte bVar1;
  code *pcVar2;
  bool bVar3;
  void *pvVar4;
  SIZE_T SVar5;
  LPVOID pvVar6;
  byte bVar7;
  uint _Size;
  
  if (param_1 == (void *)0x0) {
                    // WARNING: Load size is inaccurate
    pvVar4 = (void *)(**(code **)(*this + 4))(param_2);
    return pvVar4;
  }
  if (param_2 == 0) {
                    // WARNING: Load size is inaccurate
    (**(code **)(*this + 0x14))(param_1);
    return (void *)0x0;
  }
  bVar1 = *(byte *)((int)param_1 + -1);
  if (((uint)param_1 & 0xf) != 0) {
    bVar3 = Plat_IsInDebugSession();
    if (bVar3) {
      pcVar2 = (code *)swi(3);
      pvVar4 = (void *)(*pcVar2)();
      return pvVar4;
    }
  }
  if ((bVar1 == 0) || (0x10 < bVar1)) {
    bVar3 = Plat_IsInDebugSession();
    if (bVar3) {
      pcVar2 = (code *)swi(3);
      pvVar4 = (void *)(*pcVar2)();
      return pvVar4;
    }
  }
  SVar5 = HeapSize(*(HANDLE *)((int)this + 4),0,(LPCVOID)((int)param_1 - (uint)bVar1));
  pvVar6 = FUN_10009d00(this,param_2);
  bVar7 = 0x10 - ((byte)pvVar6 & 0xf);
  pvVar4 = (void *)((uint)bVar7 + (int)pvVar6);
  _Size = SVar5 - 0x10;
  if (param_2 < SVar5 - 0x10) {
    _Size = param_2;
  }
  *(byte *)((int)pvVar4 + -1) = bVar7;
  FID_conflict__memcpy(pvVar4,param_1,_Size);
  FUN_1000a010(this,(LPCVOID)((int)param_1 - (uint)bVar1));
  return pvVar4;
}



undefined4 FUN_1000a3a0(void)

{
  return 0;
}



void FUN_1000a3b0(void)

{
  return;
}



undefined4 FUN_1000a3c0(void)

{
  return 0xfffffffe;
}



int __fastcall FUN_1000a3d0(int param_1)

{
  code *pcVar1;
  uint uVar2;
  uint uVar3;
  undefined4 *this;
  undefined4 *puVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  undefined4 *puVar8;
  undefined4 *puVar9;
  undefined4 *local_14;
  undefined4 *local_10;
  int local_8;
  
  local_10 = (undefined4 *)(param_1 + 0x800);
  iVar6 = 0x29;
  puVar9 = local_10;
  do {
    if (((uint)puVar9 & 7) != 0) {
      Error((byte *)"CTSListBase: Misaligned list\n");
      pcVar1 = (code *)swi(3);
      iVar6 = (*pcVar1)();
      return iVar6;
    }
    *puVar9 = 0;
    puVar9[1] = 0;
    puVar9[2] = 0;
    puVar9[6] = 0;
    puVar9[7] = 0;
    puVar9[8] = 0;
    puVar9[4] = 0;
    puVar9[5] = 0;
    puVar9[3] = 0;
    puVar9 = puVar9 + 10;
    iVar6 = iVar6 + -1;
  } while (-1 < iVar6);
  uVar5 = 0;
  puVar9 = (undefined4 *)0x0;
  iVar6 = 0;
  local_8 = 0;
  *(undefined **)(param_1 + 0xe90) = &DAT_102f2d88;
  uVar7 = 0;
  do {
    uVar3 = uVar7;
    uVar7 = uVar3 + 1;
    uVar2 = uVar7 & 0x80000001;
    if ((int)uVar2 < 0) {
      uVar2 = (uVar2 - 1 | 0xfffffffe) + 1;
    }
    if (uVar2 == 1) {
      uVar5 = uVar5 + 8;
      FUN_1000d540(local_10,uVar5);
      iVar6 = local_8 + 1;
      puVar9 = local_10;
      local_10 = local_10 + 10;
      local_8 = iVar6;
    }
    *(undefined4 **)(param_1 + uVar3 * 4) = puVar9;
  } while ((int)uVar7 < 0x20);
  if ((int)uVar7 < 0x40) {
    uVar3 = uVar3 + 2;
    local_10 = (undefined4 *)(param_1 + iVar6 * 0x28 + 0x800);
    do {
      uVar2 = uVar3 & 0x80000003;
      if ((int)uVar2 < 0) {
        uVar2 = (uVar2 - 1 | 0xfffffffc) + 1;
      }
      if (uVar2 == 1) {
        uVar5 = uVar5 + 0x10;
        FUN_1000d540(local_10,uVar5);
        iVar6 = local_8 + 1;
        puVar9 = local_10;
        local_10 = local_10 + 10;
        local_8 = iVar6;
      }
      uVar3 = uVar3 + 1;
      *(undefined4 **)(param_1 + uVar7 * 4) = puVar9;
      uVar7 = uVar7 + 1;
    } while ((int)uVar3 < 0x41);
  }
  if ((int)uVar7 < 0x80) {
    uVar3 = uVar7 + 1;
    local_14 = (undefined4 *)(param_1 + iVar6 * 0x28 + 0x800);
    do {
      uVar2 = uVar3 & 0x80000007;
      if ((int)uVar2 < 0) {
        uVar2 = (uVar2 - 1 | 0xfffffff8) + 1;
      }
      if (uVar2 == 1) {
        uVar5 = uVar5 + 0x20;
        FUN_1000d540(local_14,uVar5);
        iVar6 = local_8 + 1;
        puVar9 = local_14;
        local_14 = local_14 + 10;
        local_8 = iVar6;
      }
      uVar3 = uVar3 + 1;
      *(undefined4 **)(param_1 + uVar7 * 4) = puVar9;
      uVar7 = uVar7 + 1;
    } while ((int)uVar3 < 0x81);
  }
  if ((int)uVar7 < 0xc0) {
    uVar3 = uVar7 + 1;
    local_14 = (undefined4 *)(param_1 + iVar6 * 0x28 + 0x800);
    do {
      uVar2 = uVar3 & 0x8000000f;
      if ((int)uVar2 < 0) {
        uVar2 = (uVar2 - 1 | 0xfffffff0) + 1;
      }
      if (uVar2 == 1) {
        uVar5 = uVar5 + 0x40;
        FUN_1000d540(local_14,uVar5);
        iVar6 = local_8 + 1;
        puVar9 = local_14;
        local_14 = local_14 + 10;
        local_8 = iVar6;
      }
      uVar3 = uVar3 + 1;
      *(undefined4 **)(param_1 + uVar7 * 4) = puVar9;
      uVar7 = uVar7 + 1;
    } while ((int)uVar3 < 0xc1);
  }
  if ((int)uVar7 < 0x100) {
    uVar3 = uVar7 + 1;
    local_14 = (undefined4 *)(param_1 + iVar6 * 0x28 + 0x800);
    do {
      uVar2 = uVar3 & 0x8000001f;
      if ((int)uVar2 < 0) {
        uVar2 = (uVar2 - 1 | 0xffffffe0) + 1;
      }
      if (uVar2 == 1) {
        uVar5 = uVar5 + 0x80;
        FUN_1000d540(local_14,uVar5);
        iVar6 = local_8 + 1;
        puVar9 = local_14;
        local_14 = local_14 + 10;
        local_8 = iVar6;
      }
      uVar3 = uVar3 + 1;
      *(undefined4 **)(param_1 + uVar7 * 4) = puVar9;
      uVar7 = uVar7 + 1;
    } while ((int)uVar3 < 0x101);
  }
  if ((int)uVar7 < 0x200) {
    uVar3 = uVar7 + 1;
    puVar8 = (undefined4 *)(param_1 + uVar7 * 4);
    local_10 = (undefined4 *)(param_1 + iVar6 * 0x28 + 0x800);
    this = local_10;
    do {
      uVar7 = uVar3 & 0x8000003f;
      if ((int)uVar7 < 0) {
        uVar7 = (uVar7 - 1 | 0xffffffc0) + 1;
      }
      puVar4 = this;
      if (uVar7 == 1) {
        uVar5 = uVar5 + 0x100;
        FUN_1000d540(this,uVar5);
        iVar6 = local_8 + 1;
        puVar4 = local_10 + 10;
        puVar9 = this;
        local_10 = puVar4;
        local_8 = iVar6;
      }
      uVar3 = uVar3 + 1;
      *puVar8 = puVar9;
      puVar8 = puVar8 + 1;
      this = puVar4;
    } while ((int)uVar3 < 0x201);
  }
  if (iVar6 != 0x2a) {
    Error((byte *)"SBH configuration error: %d/%d pools initialized\n");
  }
  return param_1;
}



int __fastcall FUN_1000a6a0(int param_1)

{
  code *pcVar1;
  uint uVar2;
  uint uVar3;
  undefined4 *this;
  undefined4 *puVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  undefined4 *puVar8;
  undefined4 *puVar9;
  undefined4 *local_14;
  undefined4 *local_10;
  int local_8;
  
  local_10 = (undefined4 *)(param_1 + 0x800);
  iVar6 = 0x29;
  puVar9 = local_10;
  do {
    if (((uint)puVar9 & 7) != 0) {
      Error((byte *)"CTSListBase: Misaligned list\n");
      pcVar1 = (code *)swi(3);
      iVar6 = (*pcVar1)();
      return iVar6;
    }
    *puVar9 = 0;
    puVar9[1] = 0;
    puVar9[2] = 0;
    puVar9[6] = 0;
    puVar9[7] = 0;
    puVar9[8] = 0;
    puVar9[4] = 0;
    puVar9[5] = 0;
    puVar9[3] = 0;
    puVar9 = puVar9 + 10;
    iVar6 = iVar6 + -1;
  } while (-1 < iVar6);
  uVar5 = 0;
  puVar9 = (undefined4 *)0x0;
  iVar6 = 0;
  local_8 = 0;
  *(undefined **)(param_1 + 0xe90) = &DAT_10052d60;
  uVar7 = 0;
  do {
    uVar3 = uVar7;
    uVar7 = uVar3 + 1;
    uVar2 = uVar7 & 0x80000001;
    if ((int)uVar2 < 0) {
      uVar2 = (uVar2 - 1 | 0xfffffffe) + 1;
    }
    if (uVar2 == 1) {
      uVar5 = uVar5 + 8;
      FUN_1000d650(local_10,uVar5);
      iVar6 = local_8 + 1;
      puVar9 = local_10;
      local_10 = local_10 + 10;
      local_8 = iVar6;
    }
    *(undefined4 **)(param_1 + uVar3 * 4) = puVar9;
  } while ((int)uVar7 < 0x20);
  if ((int)uVar7 < 0x40) {
    uVar3 = uVar3 + 2;
    local_10 = (undefined4 *)(param_1 + iVar6 * 0x28 + 0x800);
    do {
      uVar2 = uVar3 & 0x80000003;
      if ((int)uVar2 < 0) {
        uVar2 = (uVar2 - 1 | 0xfffffffc) + 1;
      }
      if (uVar2 == 1) {
        uVar5 = uVar5 + 0x10;
        FUN_1000d650(local_10,uVar5);
        iVar6 = local_8 + 1;
        puVar9 = local_10;
        local_10 = local_10 + 10;
        local_8 = iVar6;
      }
      uVar3 = uVar3 + 1;
      *(undefined4 **)(param_1 + uVar7 * 4) = puVar9;
      uVar7 = uVar7 + 1;
    } while ((int)uVar3 < 0x41);
  }
  if ((int)uVar7 < 0x80) {
    uVar3 = uVar7 + 1;
    local_14 = (undefined4 *)(param_1 + iVar6 * 0x28 + 0x800);
    do {
      uVar2 = uVar3 & 0x80000007;
      if ((int)uVar2 < 0) {
        uVar2 = (uVar2 - 1 | 0xfffffff8) + 1;
      }
      if (uVar2 == 1) {
        uVar5 = uVar5 + 0x20;
        FUN_1000d650(local_14,uVar5);
        iVar6 = local_8 + 1;
        puVar9 = local_14;
        local_14 = local_14 + 10;
        local_8 = iVar6;
      }
      uVar3 = uVar3 + 1;
      *(undefined4 **)(param_1 + uVar7 * 4) = puVar9;
      uVar7 = uVar7 + 1;
    } while ((int)uVar3 < 0x81);
  }
  if ((int)uVar7 < 0xc0) {
    uVar3 = uVar7 + 1;
    local_14 = (undefined4 *)(param_1 + iVar6 * 0x28 + 0x800);
    do {
      uVar2 = uVar3 & 0x8000000f;
      if ((int)uVar2 < 0) {
        uVar2 = (uVar2 - 1 | 0xfffffff0) + 1;
      }
      if (uVar2 == 1) {
        uVar5 = uVar5 + 0x40;
        FUN_1000d650(local_14,uVar5);
        iVar6 = local_8 + 1;
        puVar9 = local_14;
        local_14 = local_14 + 10;
        local_8 = iVar6;
      }
      uVar3 = uVar3 + 1;
      *(undefined4 **)(param_1 + uVar7 * 4) = puVar9;
      uVar7 = uVar7 + 1;
    } while ((int)uVar3 < 0xc1);
  }
  if ((int)uVar7 < 0x100) {
    uVar3 = uVar7 + 1;
    local_14 = (undefined4 *)(param_1 + iVar6 * 0x28 + 0x800);
    do {
      uVar2 = uVar3 & 0x8000001f;
      if ((int)uVar2 < 0) {
        uVar2 = (uVar2 - 1 | 0xffffffe0) + 1;
      }
      if (uVar2 == 1) {
        uVar5 = uVar5 + 0x80;
        FUN_1000d650(local_14,uVar5);
        iVar6 = local_8 + 1;
        puVar9 = local_14;
        local_14 = local_14 + 10;
        local_8 = iVar6;
      }
      uVar3 = uVar3 + 1;
      *(undefined4 **)(param_1 + uVar7 * 4) = puVar9;
      uVar7 = uVar7 + 1;
    } while ((int)uVar3 < 0x101);
  }
  if ((int)uVar7 < 0x200) {
    uVar3 = uVar7 + 1;
    puVar8 = (undefined4 *)(param_1 + uVar7 * 4);
    local_10 = (undefined4 *)(param_1 + iVar6 * 0x28 + 0x800);
    this = local_10;
    do {
      uVar7 = uVar3 & 0x8000003f;
      if ((int)uVar7 < 0) {
        uVar7 = (uVar7 - 1 | 0xffffffc0) + 1;
      }
      puVar4 = this;
      if (uVar7 == 1) {
        uVar5 = uVar5 + 0x100;
        FUN_1000d650(this,uVar5);
        iVar6 = local_8 + 1;
        puVar4 = local_10 + 10;
        puVar9 = this;
        local_10 = puVar4;
        local_8 = iVar6;
      }
      uVar3 = uVar3 + 1;
      *puVar8 = puVar9;
      puVar8 = puVar8 + 1;
      this = puVar4;
    } while ((int)uVar3 < 0x201);
  }
  if (iVar6 != 0x2a) {
    Error((byte *)"SBH configuration error: %d/%d pools initialized\n");
  }
  return param_1;
}



int __fastcall FUN_1000a970(int param_1)

{
  code *pcVar1;
  uint uVar2;
  uint uVar3;
  undefined4 *this;
  undefined4 *puVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  undefined4 *puVar8;
  undefined4 *puVar9;
  undefined4 *local_14;
  undefined4 *local_10;
  int local_8;
  
  local_10 = (undefined4 *)(param_1 + 0x800);
  iVar6 = 0x29;
  puVar9 = local_10;
  do {
    if (((uint)puVar9 & 7) != 0) {
      Error((byte *)"CTSListBase: Misaligned list\n");
      pcVar1 = (code *)swi(3);
      iVar6 = (*pcVar1)();
      return iVar6;
    }
    *puVar9 = 0;
    puVar9[1] = 0;
    puVar9[2] = 0;
    puVar9[6] = 0;
    puVar9[7] = 0;
    puVar9[8] = 0;
    puVar9[4] = 0;
    puVar9[5] = 0;
    puVar9[3] = 0;
    puVar9 = puVar9 + 10;
    iVar6 = iVar6 + -1;
  } while (-1 < iVar6);
  uVar5 = 0;
  puVar9 = (undefined4 *)0x0;
  iVar6 = 0;
  local_8 = 0;
  *(undefined **)(param_1 + 0xe90) = &DAT_10592db0;
  uVar7 = 0;
  do {
    uVar3 = uVar7;
    uVar7 = uVar3 + 1;
    uVar2 = uVar7 & 0x80000001;
    if ((int)uVar2 < 0) {
      uVar2 = (uVar2 - 1 | 0xfffffffe) + 1;
    }
    if (uVar2 == 1) {
      uVar5 = uVar5 + 8;
      FUN_1000d790(local_10,uVar5);
      iVar6 = local_8 + 1;
      puVar9 = local_10;
      local_10 = local_10 + 10;
      local_8 = iVar6;
    }
    *(undefined4 **)(param_1 + uVar3 * 4) = puVar9;
  } while ((int)uVar7 < 0x20);
  if ((int)uVar7 < 0x40) {
    uVar3 = uVar3 + 2;
    local_10 = (undefined4 *)(param_1 + iVar6 * 0x28 + 0x800);
    do {
      uVar2 = uVar3 & 0x80000003;
      if ((int)uVar2 < 0) {
        uVar2 = (uVar2 - 1 | 0xfffffffc) + 1;
      }
      if (uVar2 == 1) {
        uVar5 = uVar5 + 0x10;
        FUN_1000d790(local_10,uVar5);
        iVar6 = local_8 + 1;
        puVar9 = local_10;
        local_10 = local_10 + 10;
        local_8 = iVar6;
      }
      uVar3 = uVar3 + 1;
      *(undefined4 **)(param_1 + uVar7 * 4) = puVar9;
      uVar7 = uVar7 + 1;
    } while ((int)uVar3 < 0x41);
  }
  if ((int)uVar7 < 0x80) {
    uVar3 = uVar7 + 1;
    local_14 = (undefined4 *)(param_1 + iVar6 * 0x28 + 0x800);
    do {
      uVar2 = uVar3 & 0x80000007;
      if ((int)uVar2 < 0) {
        uVar2 = (uVar2 - 1 | 0xfffffff8) + 1;
      }
      if (uVar2 == 1) {
        uVar5 = uVar5 + 0x20;
        FUN_1000d790(local_14,uVar5);
        iVar6 = local_8 + 1;
        puVar9 = local_14;
        local_14 = local_14 + 10;
        local_8 = iVar6;
      }
      uVar3 = uVar3 + 1;
      *(undefined4 **)(param_1 + uVar7 * 4) = puVar9;
      uVar7 = uVar7 + 1;
    } while ((int)uVar3 < 0x81);
  }
  if ((int)uVar7 < 0xc0) {
    uVar3 = uVar7 + 1;
    local_14 = (undefined4 *)(param_1 + iVar6 * 0x28 + 0x800);
    do {
      uVar2 = uVar3 & 0x8000000f;
      if ((int)uVar2 < 0) {
        uVar2 = (uVar2 - 1 | 0xfffffff0) + 1;
      }
      if (uVar2 == 1) {
        uVar5 = uVar5 + 0x40;
        FUN_1000d790(local_14,uVar5);
        iVar6 = local_8 + 1;
        puVar9 = local_14;
        local_14 = local_14 + 10;
        local_8 = iVar6;
      }
      uVar3 = uVar3 + 1;
      *(undefined4 **)(param_1 + uVar7 * 4) = puVar9;
      uVar7 = uVar7 + 1;
    } while ((int)uVar3 < 0xc1);
  }
  if ((int)uVar7 < 0x100) {
    uVar3 = uVar7 + 1;
    local_14 = (undefined4 *)(param_1 + iVar6 * 0x28 + 0x800);
    do {
      uVar2 = uVar3 & 0x8000001f;
      if ((int)uVar2 < 0) {
        uVar2 = (uVar2 - 1 | 0xffffffe0) + 1;
      }
      if (uVar2 == 1) {
        uVar5 = uVar5 + 0x80;
        FUN_1000d790(local_14,uVar5);
        iVar6 = local_8 + 1;
        puVar9 = local_14;
        local_14 = local_14 + 10;
        local_8 = iVar6;
      }
      uVar3 = uVar3 + 1;
      *(undefined4 **)(param_1 + uVar7 * 4) = puVar9;
      uVar7 = uVar7 + 1;
    } while ((int)uVar3 < 0x101);
  }
  if ((int)uVar7 < 0x200) {
    uVar3 = uVar7 + 1;
    puVar8 = (undefined4 *)(param_1 + uVar7 * 4);
    local_10 = (undefined4 *)(param_1 + iVar6 * 0x28 + 0x800);
    this = local_10;
    do {
      uVar7 = uVar3 & 0x8000003f;
      if ((int)uVar7 < 0) {
        uVar7 = (uVar7 - 1 | 0xffffffc0) + 1;
      }
      puVar4 = this;
      if (uVar7 == 1) {
        uVar5 = uVar5 + 0x100;
        FUN_1000d790(this,uVar5);
        iVar6 = local_8 + 1;
        puVar4 = local_10 + 10;
        puVar9 = this;
        local_10 = puVar4;
        local_8 = iVar6;
      }
      uVar3 = uVar3 + 1;
      *puVar8 = puVar9;
      puVar8 = puVar8 + 1;
      this = puVar4;
    } while ((int)uVar3 < 0x201);
  }
  if (iVar6 != 0x2a) {
    Error((byte *)"SBH configuration error: %d/%d pools initialized\n");
  }
  return param_1;
}



undefined4 * __fastcall FUN_1000ac40(undefined4 *param_1)

{
  LPSTR _Source;
  uint uVar1;
  char local_204 [511];
  undefined local_5;
  
  *param_1 = CStdMemAlloc::vftable;
  FUN_1000a6a0((int)(param_1 + 2));
  FUN_1000a3d0((int)(param_1 + 0x3a8));
  FUN_1000a970((int)(param_1 + 0x74e));
  param_1[0xaf4] = CVProfNode::GetPrevLoadHitStoreLessChildren;
  param_1[0xaf5] = 0;
  param_1[0xaf6] = 0;
  param_1[0xaf7] = 0;
  *(undefined *)(param_1 + 0xaf8) = 0;
  _Source = Plat_GetCommandLine();
  if (_Source != (LPSTR)0x0) {
    _strncpy(local_204,_Source,0x1ff);
    local_5 = 0;
    __strupr(local_204);
    uVar1 = FUN_10009d70((undefined (*) [16])local_204);
    DAT_10832dd8 = (undefined)uVar1;
  }
  return param_1;
}



int __fastcall FUN_1000acf0(int param_1)

{
  code *pcVar1;
  int iVar2;
  undefined4 *puVar3;
  
  if (((uint)(undefined4 *)(param_1 + 8) & 7) != 0) {
    Error((byte *)"CTSListBase: Misaligned list\n");
    pcVar1 = (code *)swi(3);
    iVar2 = (*pcVar1)();
    return iVar2;
  }
  *(undefined4 *)(param_1 + 8) = 0;
  puVar3 = (undefined4 *)(param_1 + 0x34);
  *(undefined4 *)(param_1 + 0xc) = 0;
  iVar2 = 0x1bfff;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *(undefined4 *)(param_1 + 0x14) = 0;
  do {
    *puVar3 = 0;
    if (((uint)(puVar3 + 1) & 7) != 0) {
      Error((byte *)"CTSListBase: Misaligned list\n");
      pcVar1 = (code *)swi(3);
      iVar2 = (*pcVar1)();
      return iVar2;
    }
    puVar3[1] = 0;
    puVar3[2] = 0;
    puVar3[-2] = 0;
    *puVar3 = 0xffffffff;
    puVar3[-1] = 0;
    puVar3 = puVar3 + 6;
    iVar2 = iVar2 + -1;
  } while (-1 < iVar2);
  return param_1;
}



undefined4 __fastcall FUN_1000ad90(undefined4 *param_1,uint param_2)

{
  longlong *plVar1;
  int iVar2;
  ulonglong uVar3;
  
  iVar2 = 0x29;
  plVar1 = (longlong *)(param_1 + 0xaf2);
  do {
    plVar1 = plVar1 + -5;
    uVar3 = FUN_1000c560(plVar1,param_2);
    param_2 = (uint)(uVar3 >> 0x20);
    iVar2 = iVar2 + -1;
  } while (-1 < iVar2);
  plVar1 = (longlong *)(param_1 + 0x74c);
  iVar2 = 0x29;
  do {
    plVar1 = plVar1 + -5;
    uVar3 = FUN_1000c560(plVar1,param_2);
    param_2 = (uint)(uVar3 >> 0x20);
    iVar2 = iVar2 + -1;
  } while (-1 < iVar2);
  plVar1 = (longlong *)(param_1 + 0x3a6);
  iVar2 = 0x29;
  do {
    plVar1 = plVar1 + -5;
    uVar3 = FUN_1000c560(plVar1,param_2);
    param_2 = (uint)(uVar3 >> 0x20);
    iVar2 = iVar2 + -1;
  } while (-1 < iVar2);
  *param_1 = IMemAlloc::vftable;
  return (int)uVar3;
}



undefined4 * __fastcall FUN_1000ae00(undefined4 *param_1,uint param_2,byte param_3)

{
  FUN_1000ad90(param_1,param_2);
  if ((param_3 & 1) != 0) {
    FID_conflict__free(param_1);
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 * __fastcall FUN_1000ae50(longlong *param_1)

{
  longlong *plVar1;
  uint uVar2;
  undefined4 *puVar3;
  DWORD DVar4;
  DWORD DVar5;
  int iVar6;
  uint uVar7;
  uint uVar8;
  undefined4 *puVar9;
  undefined8 uVar10;
  int local_14;
  longlong *local_10;
  int local_c;
  
  if ((DAT_102f2d98 & 0x10000) == 0) {
    uVar8 = DAT_102f2d98 & 0xffff;
    LOCK();
    uVar7 = uVar8;
    uVar2 = uVar8 + 1;
    if (uVar8 != DAT_102f2d98) {
      uVar7 = DAT_102f2d98;
      uVar2 = DAT_102f2d98;
    }
    DAT_102f2d98 = uVar2;
    if (uVar7 == uVar8) goto LAB_1000aeb5;
  }
  if ((DAT_102f2d98 & 0x10000) == 0) {
    uVar8 = DAT_102f2d98 & 0xffff;
    LOCK();
    uVar7 = uVar8;
    uVar2 = uVar8 + 1;
    if (uVar8 != DAT_102f2d98) {
      uVar7 = DAT_102f2d98;
      uVar2 = DAT_102f2d98;
    }
    DAT_102f2d98 = uVar2;
    if (uVar7 == uVar8) goto LAB_1000aeb5;
  }
  CThreadSpinRWLock::SpinLockForRead((CThreadSpinRWLock *)&DAT_102f2d98);
LAB_1000aeb5:
  local_14 = 0x7fffffff;
  puVar9 = *(undefined4 **)param_1;
  iVar6 = *(int *)((int)param_1 + 4);
  if (puVar9 == (undefined4 *)0x0) {
LAB_1000af00:
    local_c = *(int *)(param_1 + 2);
  }
  else {
    do {
      uVar10 = ThreadInterlockedAssignIf64(param_1,CONCAT44(iVar6 + -1,*puVar9),puVar9,iVar6);
      if ((char)uVar10 != '\0') {
        if (puVar9 == (undefined4 *)0x0) goto LAB_1000af00;
        goto LAB_1000af44;
      }
      puVar9 = *(undefined4 **)param_1;
      iVar6 = *(int *)((int)param_1 + 4);
    } while (puVar9 != (undefined4 *)0x0);
    local_c = *(int *)(param_1 + 2);
  }
LAB_1000af14:
  do {
    while( true ) {
      local_10 = param_1 + 1;
      puVar9 = *(undefined4 **)local_10;
      if (puVar9 == (undefined4 *)0x0) break;
      iVar6 = local_c + (int)puVar9;
      if (0x4000 < ((iVar6 - DAT_102f2da8) - 1U & 0x3fff) + local_c) {
        iVar6 = 0;
      }
      plVar1 = param_1 + 1;
      LOCK();
      if (puVar9 == *(undefined4 **)plVar1) {
        *(int *)plVar1 = iVar6;
        puVar3 = puVar9;
      }
      else {
        puVar3 = *(undefined4 **)plVar1;
      }
      if (puVar3 == puVar9) {
LAB_1000af44:
        LOCK();
        (&DAT_102f2dbc)[((uint)((int)puVar9 - DAT_102f2da8) >> 0xe) * 6] =
             (&DAT_102f2dbc)[((uint)((int)puVar9 - DAT_102f2da8) >> 0xe) * 6] + 1;
        LOCK();
        DAT_102f2d98 = DAT_102f2d98 - 1;
        return puVar9;
      }
    }
    plVar1 = param_1 + 3;
    DVar4 = GetCurrentThreadId();
    if (DVar4 == *(DWORD *)plVar1) {
LAB_1000afcf:
      *(int *)((int)param_1 + 0x1c) = *(int *)((int)param_1 + 0x1c) + 1;
      if (*(int *)local_10 == 0) {
        do {
          puVar9 = DAT_102f2d90;
          DAT_102f2d90 = puVar9;
          if (puVar9 == (undefined4 *)0x0) goto joined_r0x1000b027;
          uVar10 = ThreadInterlockedAssignIf64
                             ((longlong *)&DAT_102f2d90,CONCAT44(DAT_102f2d94 + -1,*puVar9),puVar9,
                              DAT_102f2d94);
        } while ((char)uVar10 == '\0');
        uVar7 = (int)(puVar9 + -0x40bcb6c) / 0x18;
        goto LAB_1000b0b5;
      }
      goto LAB_1000b0e9;
    }
    DVar5 = 0;
    LOCK();
    if (*(DWORD *)plVar1 == 0) {
      *(DWORD *)plVar1 = DVar4;
    }
    else {
      DVar5 = *(DWORD *)plVar1;
    }
    if (DVar5 == 0) goto LAB_1000afcf;
    if (local_14 == 0x7fffffff) {
      local_14 = ThreadGetPriority((HANDLE)0x0);
    }
    if (0 < local_14) {
      ThreadSleep(0);
    }
  } while( true );
  while( true ) {
    DAT_102f2da4 = uVar7 + 0x4000;
    LOCK();
    if (false) {
      DAT_102f2da4 = uVar7;
    }
    if (true) break;
joined_r0x1000b027:
    uVar7 = DAT_102f2da4;
    DAT_102f2da4 = uVar7;
    if (_DAT_102f2dac <= uVar7) goto LAB_1000b04e;
  }
  uVar7 = uVar7 - DAT_102f2da8 >> 0xe;
  puVar9 = (undefined4 *)(&DAT_102f2db0 + uVar7 * 0x18);
LAB_1000b0b5:
  if (puVar9 == (undefined4 *)0x0) {
LAB_1000b04e:
    *(int *)local_10 = 0;
    *(int *)((int)param_1 + 0x1c) = *(int *)((int)param_1 + 0x1c) + -1;
    if (*(int *)((int)param_1 + 0x1c) == 0) {
      *(undefined4 *)(param_1 + 3) = 0;
    }
    LOCK();
    DAT_102f2d98 = DAT_102f2d98 - 1;
    return (undefined4 *)0x0;
  }
  iVar6 = uVar7 * 0x4000 + DAT_102f2da8;
  puVar9[1] = param_1;
  puVar9[3] = 0;
  puVar9[2] = *(undefined4 *)((int)param_1 + 0xc);
  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 1;
  *(undefined4 **)((int)param_1 + 0xc) = puVar9;
  *(int *)(param_1 + 1) = iVar6;
LAB_1000b0e9:
  *(int *)((int)param_1 + 0x1c) = *(int *)((int)param_1 + 0x1c) + -1;
  if (*(int *)((int)param_1 + 0x1c) == 0) {
    *(DWORD *)plVar1 = 0;
  }
  goto LAB_1000af14;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 * __fastcall FUN_1000b100(longlong *param_1)

{
  longlong *plVar1;
  uint uVar2;
  undefined4 *puVar3;
  DWORD DVar4;
  DWORD DVar5;
  int iVar6;
  uint uVar7;
  uint uVar8;
  undefined4 *puVar9;
  undefined8 uVar10;
  int local_14;
  longlong *local_10;
  int local_c;
  
  if ((DAT_10052d70 & 0x10000) == 0) {
    uVar8 = DAT_10052d70 & 0xffff;
    LOCK();
    uVar7 = uVar8;
    uVar2 = uVar8 + 1;
    if (uVar8 != DAT_10052d70) {
      uVar7 = DAT_10052d70;
      uVar2 = DAT_10052d70;
    }
    DAT_10052d70 = uVar2;
    if (uVar7 == uVar8) goto LAB_1000b165;
  }
  if ((DAT_10052d70 & 0x10000) == 0) {
    uVar8 = DAT_10052d70 & 0xffff;
    LOCK();
    uVar7 = uVar8;
    uVar2 = uVar8 + 1;
    if (uVar8 != DAT_10052d70) {
      uVar7 = DAT_10052d70;
      uVar2 = DAT_10052d70;
    }
    DAT_10052d70 = uVar2;
    if (uVar7 == uVar8) goto LAB_1000b165;
  }
  CThreadSpinRWLock::SpinLockForRead((CThreadSpinRWLock *)&DAT_10052d70);
LAB_1000b165:
  local_14 = 0x7fffffff;
  puVar9 = *(undefined4 **)param_1;
  iVar6 = *(int *)((int)param_1 + 4);
  if (puVar9 == (undefined4 *)0x0) {
LAB_1000b1b0:
    local_c = *(int *)(param_1 + 2);
  }
  else {
    do {
      uVar10 = ThreadInterlockedAssignIf64(param_1,CONCAT44(iVar6 + -1,*puVar9),puVar9,iVar6);
      if ((char)uVar10 != '\0') {
        if (puVar9 == (undefined4 *)0x0) goto LAB_1000b1b0;
        goto LAB_1000b1f4;
      }
      puVar9 = *(undefined4 **)param_1;
      iVar6 = *(int *)((int)param_1 + 4);
    } while (puVar9 != (undefined4 *)0x0);
    local_c = *(int *)(param_1 + 2);
  }
LAB_1000b1c4:
  do {
    while( true ) {
      local_10 = param_1 + 1;
      puVar9 = *(undefined4 **)local_10;
      if (puVar9 == (undefined4 *)0x0) break;
      iVar6 = local_c + (int)puVar9;
      if (0x4000 < ((iVar6 - DAT_10052d80) - 1U & 0x3fff) + local_c) {
        iVar6 = 0;
      }
      plVar1 = param_1 + 1;
      LOCK();
      if (puVar9 == *(undefined4 **)plVar1) {
        *(int *)plVar1 = iVar6;
        puVar3 = puVar9;
      }
      else {
        puVar3 = *(undefined4 **)plVar1;
      }
      if (puVar3 == puVar9) {
LAB_1000b1f4:
        LOCK();
        (&DAT_10052d94)[((uint)((int)puVar9 - DAT_10052d80) >> 0xe) * 6] =
             (&DAT_10052d94)[((uint)((int)puVar9 - DAT_10052d80) >> 0xe) * 6] + 1;
        LOCK();
        DAT_10052d70 = DAT_10052d70 - 1;
        return puVar9;
      }
    }
    plVar1 = param_1 + 3;
    DVar4 = GetCurrentThreadId();
    if (DVar4 == *(DWORD *)plVar1) {
LAB_1000b27f:
      *(int *)((int)param_1 + 0x1c) = *(int *)((int)param_1 + 0x1c) + 1;
      if (*(int *)local_10 == 0) {
        do {
          puVar9 = DAT_10052d68;
          DAT_10052d68 = puVar9;
          if (puVar9 == (undefined4 *)0x0) goto joined_r0x1000b2d7;
          uVar10 = ThreadInterlockedAssignIf64
                             ((longlong *)&DAT_10052d68,CONCAT44(DAT_10052d6c + -1,*puVar9),puVar9,
                              DAT_10052d6c);
        } while ((char)uVar10 == '\0');
        uVar7 = (int)(puVar9 + -0x4014b62) / 0x18;
        goto LAB_1000b365;
      }
      goto LAB_1000b399;
    }
    DVar5 = 0;
    LOCK();
    if (*(DWORD *)plVar1 == 0) {
      *(DWORD *)plVar1 = DVar4;
    }
    else {
      DVar5 = *(DWORD *)plVar1;
    }
    if (DVar5 == 0) goto LAB_1000b27f;
    if (local_14 == 0x7fffffff) {
      local_14 = ThreadGetPriority((HANDLE)0x0);
    }
    if (0 < local_14) {
      ThreadSleep(0);
    }
  } while( true );
  while( true ) {
    DAT_10052d7c = uVar7 + 0x4000;
    LOCK();
    if (false) {
      DAT_10052d7c = uVar7;
    }
    if (true) break;
joined_r0x1000b2d7:
    uVar7 = DAT_10052d7c;
    DAT_10052d7c = uVar7;
    if (_DAT_10052d84 <= uVar7) goto LAB_1000b2fe;
  }
  uVar7 = uVar7 - DAT_10052d80 >> 0xe;
  puVar9 = (undefined4 *)(&DAT_10052d88 + uVar7 * 0x18);
LAB_1000b365:
  if (puVar9 == (undefined4 *)0x0) {
LAB_1000b2fe:
    *(int *)local_10 = 0;
    *(int *)((int)param_1 + 0x1c) = *(int *)((int)param_1 + 0x1c) + -1;
    if (*(int *)((int)param_1 + 0x1c) == 0) {
      *(undefined4 *)(param_1 + 3) = 0;
    }
    LOCK();
    DAT_10052d70 = DAT_10052d70 - 1;
    return (undefined4 *)0x0;
  }
  iVar6 = uVar7 * 0x4000 + DAT_10052d80;
  puVar9[1] = param_1;
  puVar9[3] = 0;
  puVar9[2] = *(undefined4 *)((int)param_1 + 0xc);
  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 1;
  *(undefined4 **)((int)param_1 + 0xc) = puVar9;
  *(int *)(param_1 + 1) = iVar6;
LAB_1000b399:
  *(int *)((int)param_1 + 0x1c) = *(int *)((int)param_1 + 0x1c) + -1;
  if (*(int *)((int)param_1 + 0x1c) == 0) {
    *(DWORD *)plVar1 = 0;
  }
  goto LAB_1000b1c4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 * __fastcall FUN_1000b3b0(longlong *param_1)

{
  longlong *plVar1;
  int iVar2;
  uint uVar3;
  undefined4 *puVar4;
  DWORD DVar5;
  DWORD DVar6;
  int iVar7;
  uint uVar8;
  uint uVar9;
  LPVOID lpAddress;
  undefined4 *puVar10;
  longlong *plVar11;
  undefined8 uVar12;
  int local_10;
  
  if ((DAT_10592dc0 & 0x10000) == 0) {
    uVar8 = DAT_10592dc0 & 0xffff;
    LOCK();
    uVar9 = uVar8;
    uVar3 = uVar8 + 1;
    if (uVar8 != DAT_10592dc0) {
      uVar9 = DAT_10592dc0;
      uVar3 = DAT_10592dc0;
    }
    DAT_10592dc0 = uVar3;
    if (uVar9 == uVar8) goto LAB_1000b415;
  }
  if ((DAT_10592dc0 & 0x10000) == 0) {
    uVar8 = DAT_10592dc0 & 0xffff;
    LOCK();
    uVar9 = uVar8;
    uVar3 = uVar8 + 1;
    if (uVar8 != DAT_10592dc0) {
      uVar9 = DAT_10592dc0;
      uVar3 = DAT_10592dc0;
    }
    DAT_10592dc0 = uVar3;
    if (uVar9 == uVar8) goto LAB_1000b415;
  }
  CThreadSpinRWLock::SpinLockForRead((CThreadSpinRWLock *)&DAT_10592dc0);
LAB_1000b415:
  local_10 = 0x7fffffff;
  iVar2 = *(int *)((int)param_1 + 4);
  puVar10 = *(undefined4 **)param_1;
  while (puVar10 != (undefined4 *)0x0) {
    uVar12 = ThreadInterlockedAssignIf64(param_1,CONCAT44(iVar2 + -1,*puVar10),puVar10,iVar2);
    if ((char)uVar12 != '\0') {
      if (puVar10 != (undefined4 *)0x0) goto LAB_1000b63b;
      break;
    }
    iVar2 = *(int *)((int)param_1 + 4);
    puVar10 = *(undefined4 **)param_1;
  }
  iVar2 = *(int *)(param_1 + 2);
LAB_1000b464:
  do {
    while( true ) {
      plVar11 = param_1 + 1;
      puVar10 = *(undefined4 **)plVar11;
      if (puVar10 == (undefined4 *)0x0) break;
      iVar7 = iVar2 + (int)puVar10;
      if (0x10000 < ((iVar7 - DAT_10592dd0) - 1U & 0xffff) + iVar2) {
        iVar7 = 0;
      }
      LOCK();
      if (puVar10 == *(undefined4 **)plVar11) {
        *(int *)plVar11 = iVar7;
        puVar4 = puVar10;
      }
      else {
        puVar4 = *(undefined4 **)plVar11;
      }
      if (puVar4 == puVar10) {
LAB_1000b63b:
        LOCK();
        (&DAT_10592de4)[((uint)((int)puVar10 - DAT_10592dd0) >> 0x10) * 6] =
             (&DAT_10592de4)[((uint)((int)puVar10 - DAT_10592dd0) >> 0x10) * 6] + 1;
        LOCK();
        DAT_10592dc0 = DAT_10592dc0 - 1;
        return puVar10;
      }
    }
    plVar1 = param_1 + 3;
    DVar5 = GetCurrentThreadId();
    if (DVar5 == *(DWORD *)plVar1) {
LAB_1000b4f2:
      *(int *)((int)param_1 + 0x1c) = *(int *)((int)param_1 + 0x1c) + 1;
      if (*(int *)plVar11 == 0) {
        do {
          puVar10 = DAT_10592db8;
          DAT_10592db8 = puVar10;
          if (puVar10 == (undefined4 *)0x0) goto joined_r0x1000b547;
          uVar12 = ThreadInterlockedAssignIf64
                             ((longlong *)&DAT_10592db8,CONCAT44(_DAT_10592dbc + -1,*puVar10),
                              puVar10,_DAT_10592dbc);
        } while ((char)uVar12 == '\0');
        uVar9 = (int)(puVar10 + -0x4164b76) / 0x18;
        goto LAB_1000b5d5;
      }
      goto LAB_1000b622;
    }
    DVar6 = 0;
    LOCK();
    if (*(DWORD *)plVar1 == 0) {
      *(DWORD *)plVar1 = DVar5;
    }
    else {
      DVar6 = *(DWORD *)plVar1;
    }
    if (DVar6 == 0) goto LAB_1000b4f2;
    if (local_10 == 0x7fffffff) {
      local_10 = ThreadGetPriority((HANDLE)0x0);
    }
    if (0 < local_10) {
      ThreadSleep(0);
    }
  } while( true );
  while( true ) {
    DAT_10592dcc = uVar9 + 0x10000;
    LOCK();
    if (false) {
      DAT_10592dcc = uVar9;
    }
    if (true) break;
joined_r0x1000b547:
    uVar9 = DAT_10592dcc;
    DAT_10592dcc = uVar9;
    if (_DAT_10592dd4 <= uVar9) goto LAB_1000b56e;
  }
  uVar9 = uVar9 - DAT_10592dd0 >> 0x10;
  puVar10 = (undefined4 *)(&DAT_10592dd8 + uVar9 * 0x18);
LAB_1000b5d5:
  if (puVar10 == (undefined4 *)0x0) {
LAB_1000b56e:
    *(undefined4 *)(param_1 + 1) = 0;
    *(int *)((int)param_1 + 0x1c) = *(int *)((int)param_1 + 0x1c) + -1;
    if (*(int *)((int)param_1 + 0x1c) == 0) {
      *(undefined4 *)(param_1 + 3) = 0;
    }
    LOCK();
    DAT_10592dc0 = DAT_10592dc0 - 1;
    return (undefined4 *)0x0;
  }
  lpAddress = (LPVOID)(uVar9 * 0x10000 + DAT_10592dd0);
  if (puVar10[3] == -1) {
    VirtualAlloc(lpAddress,0x10000,0x1000,4);
  }
  puVar10[1] = param_1;
  puVar10[3] = 0;
  puVar10[2] = *(undefined4 *)((int)param_1 + 0xc);
  *(int *)((int)param_1 + 0x14) = *(int *)((int)param_1 + 0x14) + 1;
  *(undefined4 **)((int)param_1 + 0xc) = puVar10;
  *(LPVOID *)(param_1 + 1) = lpAddress;
LAB_1000b622:
  *(int *)((int)param_1 + 0x1c) = *(int *)((int)param_1 + 0x1c) + -1;
  if (*(int *)((int)param_1 + 0x1c) == 0) {
    *(DWORD *)plVar1 = 0;
  }
  goto LAB_1000b464;
}



uint ** __thiscall FUN_1000b670(void *this,uint param_1)

{
  uint **ppuVar1;
  int iVar2;
  uint uVar3;
  
  if (param_1 < 0x801) {
    uVar3 = param_1;
    if (param_1 == 0) {
      uVar3 = 1;
    }
    ppuVar1 = (uint **)FUN_1000b100(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 8));
    if (ppuVar1 != (uint **)0x0) goto LAB_1000b7f7;
    uVar3 = param_1;
    if (param_1 == 0) {
      uVar3 = 1;
    }
    ppuVar1 = (uint **)FUN_1000ae50(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 0xea0));
    if (ppuVar1 != (uint **)0x0) goto LAB_1000b7f7;
    uVar3 = param_1;
    if (param_1 == 0) {
      uVar3 = 1;
    }
    ppuVar1 = (uint **)FUN_1000b3b0(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 0x1d38));
    if (ppuVar1 != (uint **)0x0) goto LAB_1000b7f7;
    (**(code **)((int)this + 0x2bd0))(param_1);
    iVar2 = FUN_1000d8b0(this,'\x01');
    if (iVar2 != 0) {
      uVar3 = param_1;
      if (param_1 == 0) {
        uVar3 = 1;
      }
      ppuVar1 = (uint **)FUN_1000b100(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 8));
      if (ppuVar1 != (uint **)0x0) goto LAB_1000b7f7;
      uVar3 = param_1;
      if (param_1 == 0) {
        uVar3 = 1;
      }
      ppuVar1 = (uint **)FUN_1000ae50(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 0xea0));
      if (ppuVar1 != (uint **)0x0) goto LAB_1000b7f7;
      uVar3 = param_1;
      if (param_1 == 0) {
        uVar3 = 1;
      }
      ppuVar1 = (uint **)FUN_1000b3b0(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 0x1d38))
      ;
      if (ppuVar1 != (uint **)0x0) goto LAB_1000b7f7;
      (**(code **)((int)this + 0x2bd0))(param_1);
    }
    if (DAT_108331e8 < 1) {
      DAT_108331e8 = DAT_108331e8 + 1;
      DevWarning("\n\nDRASTIC MEMORY OVERFLOW: Fell out of small block heap!\n\n\n");
    }
  }
  ppuVar1 = FUN_1001edb0((uint *)(&DAT_10832ddc)[param_1 < 0x40000],param_1);
  if (ppuVar1 == (uint **)0x0) {
                    // WARNING: Load size is inaccurate
    (**(code **)(*this + 0x78))();
    ppuVar1 = FUN_1001edb0((uint *)(&DAT_10832ddc)[param_1 < 0x40000],param_1);
    if (ppuVar1 == (uint **)0x0) {
      FUN_1000ebf0(this,param_1);
      return (uint **)0x0;
    }
  }
LAB_1000b7f7:
  if (DAT_10046638 != '\0') {
    FUN_10009a20(ppuVar1,param_1);
  }
  return ppuVar1;
}



uint ** __thiscall FUN_1000b820(void *this,uint param_1)

{
  uint **ppuVar1;
  int iVar2;
  uint uVar3;
  
  if (param_1 < 0x801) {
    uVar3 = param_1;
    if (param_1 == 0) {
      uVar3 = 1;
    }
    ppuVar1 = (uint **)FUN_1000b100(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 8));
    if (ppuVar1 != (uint **)0x0) goto LAB_1000b9a7;
    uVar3 = param_1;
    if (param_1 == 0) {
      uVar3 = 1;
    }
    ppuVar1 = (uint **)FUN_1000ae50(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 0xea0));
    if (ppuVar1 != (uint **)0x0) goto LAB_1000b9a7;
    uVar3 = param_1;
    if (param_1 == 0) {
      uVar3 = 1;
    }
    ppuVar1 = (uint **)FUN_1000b3b0(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 0x1d38));
    if (ppuVar1 != (uint **)0x0) goto LAB_1000b9a7;
    (**(code **)((int)this + 0x2bd0))(param_1);
    iVar2 = FUN_1000d8b0(this,'\x01');
    if (iVar2 != 0) {
      uVar3 = param_1;
      if (param_1 == 0) {
        uVar3 = 1;
      }
      ppuVar1 = (uint **)FUN_1000b100(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 8));
      if (ppuVar1 != (uint **)0x0) goto LAB_1000b9a7;
      uVar3 = param_1;
      if (param_1 == 0) {
        uVar3 = 1;
      }
      ppuVar1 = (uint **)FUN_1000ae50(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 0xea0));
      if (ppuVar1 != (uint **)0x0) goto LAB_1000b9a7;
      uVar3 = param_1;
      if (param_1 == 0) {
        uVar3 = 1;
      }
      ppuVar1 = (uint **)FUN_1000b3b0(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 0x1d38))
      ;
      if (ppuVar1 != (uint **)0x0) goto LAB_1000b9a7;
      (**(code **)((int)this + 0x2bd0))(param_1);
    }
    if (DAT_108331e8 < 1) {
      DAT_108331e8 = DAT_108331e8 + 1;
      DevWarning("\n\nDRASTIC MEMORY OVERFLOW: Fell out of small block heap!\n\n\n");
    }
  }
  ppuVar1 = FUN_1001edb0((uint *)(&DAT_10832ddc)[param_1 < 0x40000],param_1);
  if (ppuVar1 == (uint **)0x0) {
                    // WARNING: Load size is inaccurate
    (**(code **)(*this + 0x78))();
    ppuVar1 = FUN_1001edb0((uint *)(&DAT_10832ddc)[param_1 < 0x40000],param_1);
    if (ppuVar1 == (uint **)0x0) {
      FUN_1000ebf0(this,param_1);
      return (uint **)0x0;
    }
  }
LAB_1000b9a7:
  if (DAT_10046638 != '\0') {
    FUN_10009a20(ppuVar1,param_1);
  }
  return ppuVar1;
}



void __fastcall FUN_1000b9d0(CVProfNode *param_1,undefined param_2,undefined4 param_3)

{
  CVProfNode::GetPrevLoadHitStoreLessChildren(param_1);
  return;
}



int __thiscall FUN_1000b9f0(void *this,char param_1)

{
  int iVar1;
  int iVar2;
  void *this_00;
  int iVar3;
  
  if (DAT_10052d58 != '\0') {
    return 0;
  }
  iVar3 = 0;
  iVar2 = 0x2a;
  if (param_1 == '\0') {
    this_00 = (void *)((int)this + 0x800);
    do {
      iVar1 = FUN_1000bbd0(this_00,'\0');
      iVar3 = iVar3 + iVar1;
      this_00 = (void *)((int)this_00 + 0x28);
      iVar2 = iVar2 + -1;
    } while (iVar2 != 0);
  }
  else {
    DAT_10833204 = DAT_10833204 + 1;
    iVar2 = 0;
    do {
      iVar1 = (DAT_10833204 + iVar2) % 0x2a;
      iVar3 = FUN_1000bbd0((void *)((int)this + iVar1 * 0x28 + 0x800),param_1);
      if (iVar3 != 0) {
        DAT_10833204 = iVar1;
        return iVar3;
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 < 0x2a);
  }
  return iVar3;
}



int __thiscall FUN_1000ba90(void *this,char param_1)

{
  int iVar1;
  int iVar2;
  void *this_00;
  int iVar3;
  
  if (DAT_10052d58 != '\0') {
    return 0;
  }
  iVar3 = 0;
  iVar2 = 0x2a;
  if (param_1 == '\0') {
    this_00 = (void *)((int)this + 0x800);
    do {
      iVar1 = FUN_1000be10(this_00,'\0');
      iVar3 = iVar3 + iVar1;
      this_00 = (void *)((int)this_00 + 0x28);
      iVar2 = iVar2 + -1;
    } while (iVar2 != 0);
  }
  else {
    DAT_10833200 = DAT_10833200 + 1;
    iVar2 = 0;
    do {
      iVar1 = (DAT_10833200 + iVar2) % 0x2a;
      iVar3 = FUN_1000be10((void *)((int)this + iVar1 * 0x28 + 0x800),param_1);
      if (iVar3 != 0) {
        DAT_10833200 = iVar1;
        return iVar3;
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 < 0x2a);
  }
  return iVar3;
}



int __thiscall FUN_1000bb30(void *this,char param_1)

{
  int iVar1;
  int iVar2;
  void *this_00;
  int iVar3;
  
  if (DAT_10052d58 != '\0') {
    return 0;
  }
  iVar3 = 0;
  iVar2 = 0x2a;
  if (param_1 == '\0') {
    this_00 = (void *)((int)this + 0x800);
    do {
      iVar1 = FUN_1000c040(this_00,'\0');
      iVar3 = iVar3 + iVar1;
      this_00 = (void *)((int)this_00 + 0x28);
      iVar2 = iVar2 + -1;
    } while (iVar2 != 0);
  }
  else {
    DAT_10833208 = DAT_10833208 + 1;
    iVar2 = 0;
    do {
      iVar1 = (DAT_10833208 + iVar2) % 0x2a;
      iVar3 = FUN_1000c040((void *)((int)this + iVar1 * 0x28 + 0x800),param_1);
      if (iVar3 != 0) {
        DAT_10833208 = iVar1;
        return iVar3;
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 < 0x2a);
  }
  return iVar3;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Unable to track spacebase fully for stack
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __thiscall FUN_1000bbd0(void *this,char param_1)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int local_2c;
  int local_28;
  int local_24;
  undefined *local_20;
  int local_1c;
  int *local_18;
  undefined *local_14;
  void *local_10;
  undefined *local_c;
  char local_5;
  
  if ((*(int *)((int)this + 0x20) != 0) || (DAT_10052d58 != '\0')) {
    return 0;
  }
  local_5 = '\0';
  local_24 = 0;
  if ((DAT_102f2d98 & 0x10000) == 0) {
    LOCK();
    uVar3 = DAT_102f2d98;
    if (DAT_102f2d98 == 0) {
      DAT_102f2d98 = 0x10000;
      uVar3 = 0;
    }
    if (uVar3 == 0) {
      _DAT_102f2d9c = GetCurrentThreadId();
      goto LAB_1000bc33;
    }
  }
  CThreadSpinRWLock::SpinLockForWrite((CThreadSpinRWLock *)&DAT_102f2d98);
LAB_1000bc33:
  iVar2 = *(int *)((int)this + 0xc);
  if (iVar2 != 0) {
    uVar3 = *(int *)((int)this + 0x14) * 4 + 0xfU & 0xfffffff0;
    local_14 = &stack0xffffffcc + -uVar3;
    local_c = &stack0xffffffcc + uVar3 * -2;
    local_10 = this;
    *(undefined4 *)(&stack0xffffffc8 + -uVar3) = 0x1000bc5c;
    *(undefined4 *)(&stack0xffffffc8 + uVar3 * -2) = 0x1000bc66;
    local_20 = &stack0xffffffcc;
    local_18 = (int *)&stack0xffffffcc;
    piVar1 = (int *)&stack0xffffffcc;
    local_28 = (int)local_14 - (int)&stack0xffffffcc;
    iVar4 = 0;
    local_2c = (int)local_c - (int)&stack0xffffffcc;
    local_1c = 0;
    do {
      iVar5 = iVar2;
      if (*(int *)(iVar5 + 0xc) == 0) {
        *(int *)(local_28 + (int)piVar1) = iVar5;
        iVar2 = local_2c;
        iVar4 = iVar4 + 1;
        *local_18 = ((iVar5 + -0x102f2db0) / 0x18) * 0x4000 + DAT_102f2da8;
        *(int *)(iVar2 + (int)local_18) = local_1c;
        piVar1 = local_18 + 1;
        local_18 = piVar1;
        if (param_1 != '\0') break;
      }
      iVar2 = *(int *)(iVar5 + 8);
      local_1c = iVar5;
    } while (*(int *)(iVar5 + 8) != 0);
    this = local_10;
    if (iVar4 != 0) {
      uVar3 = FUN_1000e260(local_10,(int)local_20,iVar4,param_1 == '\0');
      if (((char)uVar3 == '\0') && (DAT_1083320d == '\0')) {
        DAT_1083320d = '\x01';
        local_5 = '\x01';
      }
      *(int *)((int)local_10 + 0x14) = *(int *)((int)local_10 + 0x14) - iVar4;
      iVar2 = iVar4 + -1;
      local_24 = iVar4 << 0xe;
      if (-1 < iVar2) {
        piVar1 = (int *)(local_14 + iVar2 * 4);
        do {
          iVar5 = *(int *)(((int)local_c - (int)local_14) + (int)piVar1);
          if (iVar5 == 0) {
            *(undefined4 *)((int)local_10 + 0xc) = *(undefined4 *)(*piVar1 + 8);
          }
          else {
            *(undefined4 *)(iVar5 + 8) = *(undefined4 *)(*piVar1 + 8);
          }
          *(undefined4 *)(*piVar1 + 8) = 0;
          iVar5 = *piVar1;
          piVar1 = piVar1 + -1;
          iVar2 = iVar2 + -1;
          *(undefined4 *)(iVar5 + 4) = 0;
        } while (-1 < iVar2);
      }
      iVar2 = 0;
      if (0 < iVar4) {
        do {
          FUN_1000da50(&DAT_102f2d90,*(undefined4 **)(local_14 + iVar2 * 4));
          iVar2 = iVar2 + 1;
        } while (iVar2 < iVar4);
      }
    }
  }
  if (param_1 == '\0') {
    *(undefined4 *)((int)this + 0x20) = 1;
  }
  _DAT_102f2d9c = 0;
  DAT_102f2d98 = 0;
  if (local_5 != '\0') {
    Warning((byte *)
            "***** HEAP IS CORRUPT (free compromised for block size %d,in %s heap, possible write after free *****)\n"
           );
  }
  return local_24;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Unable to track spacebase fully for stack
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __thiscall FUN_1000be10(void *this,char param_1)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  int iVar5;
  int local_2c;
  int local_28;
  int local_24;
  undefined *local_20;
  int local_1c;
  int *local_18;
  undefined *local_14;
  void *local_10;
  undefined *local_c;
  char local_5;
  
  if ((*(int *)((int)this + 0x20) != 0) || (DAT_10052d58 != '\0')) {
    return 0;
  }
  local_5 = '\0';
  local_24 = 0;
  if ((DAT_10052d70 & 0x10000) == 0) {
    LOCK();
    uVar3 = DAT_10052d70;
    if (DAT_10052d70 == 0) {
      DAT_10052d70 = 0x10000;
      uVar3 = 0;
    }
    if (uVar3 == 0) {
      _DAT_10052d74 = GetCurrentThreadId();
      goto LAB_1000be73;
    }
  }
  CThreadSpinRWLock::SpinLockForWrite((CThreadSpinRWLock *)&DAT_10052d70);
LAB_1000be73:
  iVar2 = *(int *)((int)this + 0xc);
  if (iVar2 != 0) {
    uVar3 = *(int *)((int)this + 0x14) * 4 + 0xfU & 0xfffffff0;
    local_14 = &stack0xffffffcc + -uVar3;
    local_c = &stack0xffffffcc + uVar3 * -2;
    local_10 = this;
    *(undefined4 *)(&stack0xffffffc8 + -uVar3) = 0x1000be9c;
    *(undefined4 *)(&stack0xffffffc8 + uVar3 * -2) = 0x1000bea6;
    local_20 = &stack0xffffffcc;
    local_18 = (int *)&stack0xffffffcc;
    piVar1 = (int *)&stack0xffffffcc;
    local_28 = (int)local_14 - (int)&stack0xffffffcc;
    iVar4 = 0;
    local_2c = (int)local_c - (int)&stack0xffffffcc;
    local_1c = 0;
    do {
      iVar5 = iVar2;
      if (*(int *)(iVar5 + 0xc) == 0) {
        *(int *)(local_28 + (int)piVar1) = iVar5;
        iVar2 = local_2c;
        iVar4 = iVar4 + 1;
        *local_18 = ((iVar5 + -0x10052d88) / 0x18) * 0x4000 + DAT_10052d80;
        *(int *)(iVar2 + (int)local_18) = local_1c;
        piVar1 = local_18 + 1;
        local_18 = piVar1;
        if (param_1 != '\0') break;
      }
      iVar2 = *(int *)(iVar5 + 8);
      local_1c = iVar5;
    } while (*(int *)(iVar5 + 8) != 0);
    this = local_10;
    if (iVar4 != 0) {
      uVar3 = FUN_1000e580(local_10,(int)local_20,iVar4,param_1 == '\0');
      if (((char)uVar3 == '\0') && (DAT_1083320c == '\0')) {
        DAT_1083320c = '\x01';
        local_5 = '\x01';
      }
      *(int *)((int)local_10 + 0x14) = *(int *)((int)local_10 + 0x14) - iVar4;
      iVar2 = iVar4 + -1;
      local_24 = iVar4 << 0xe;
      if (-1 < iVar2) {
        piVar1 = (int *)(local_14 + iVar2 * 4);
        do {
          iVar5 = *(int *)(((int)local_c - (int)local_14) + (int)piVar1);
          if (iVar5 == 0) {
            *(undefined4 *)((int)local_10 + 0xc) = *(undefined4 *)(*piVar1 + 8);
          }
          else {
            *(undefined4 *)(iVar5 + 8) = *(undefined4 *)(*piVar1 + 8);
          }
          *(undefined4 *)(*piVar1 + 8) = 0;
          iVar5 = *piVar1;
          piVar1 = piVar1 + -1;
          iVar2 = iVar2 + -1;
          *(undefined4 *)(iVar5 + 4) = 0;
        } while (-1 < iVar2);
      }
      iVar2 = 0;
      if (0 < iVar4) {
        do {
          FUN_1000da50(&DAT_10052d68,*(undefined4 **)(local_14 + iVar2 * 4));
          iVar2 = iVar2 + 1;
        } while (iVar2 < iVar4);
      }
    }
  }
  if (param_1 == '\0') {
    *(undefined4 *)((int)this + 0x20) = 1;
  }
  _DAT_10052d74 = 0;
  DAT_10052d70 = 0;
  if (local_5 != '\0') {
    Warning((byte *)
            "***** HEAP IS CORRUPT (free compromised for block size %d,in %s heap, possible write after free *****)\n"
           );
  }
  return local_24;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Unable to track spacebase fully for stack
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __thiscall FUN_1000c040(void *this,char param_1)

{
  int **ppiVar1;
  char cVar2;
  int **ppiVar3;
  int *piVar4;
  int **ppiVar5;
  int iVar6;
  uint uVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int **ppiVar11;
  ulonglong uVar12;
  undefined8 uVar13;
  int local_40;
  int local_38;
  int local_34;
  undefined *local_30;
  int local_2c;
  int *local_28;
  undefined *local_20;
  int *local_1c;
  void *local_18;
  char local_11;
  
  if ((*(int *)((int)this + 0x20) != 0) || (DAT_10052d58 != '\0')) {
    return 0;
  }
  local_11 = '\0';
  local_34 = 0;
  if ((DAT_10592dc0 & 0x10000) == 0) {
    LOCK();
    uVar7 = DAT_10592dc0;
    if (DAT_10592dc0 == 0) {
      DAT_10592dc0 = 0x10000;
      uVar7 = 0;
    }
    if (uVar7 == 0) {
      _DAT_10592dc4 = GetCurrentThreadId();
      goto LAB_1000c0b6;
    }
  }
  CThreadSpinRWLock::SpinLockForWrite((CThreadSpinRWLock *)&DAT_10592dc0);
LAB_1000c0b6:
  iVar10 = *(int *)((int)this + 0xc);
  if (iVar10 != 0) {
    uVar7 = *(int *)((int)this + 0x14) * 4 + 0xfU & 0xfffffff0;
    local_1c = (int *)(&stack0xffffffb8 + -uVar7);
    local_30 = &stack0xffffffb8 + uVar7 * -2;
    local_18 = this;
    *(undefined4 *)(&stack0xffffffb4 + -uVar7) = 0x1000c0df;
    *(undefined4 *)(&stack0xffffffb4 + uVar7 * -2) = 0x1000c0e9;
    local_20 = &stack0xffffffb8;
    local_28 = (int *)&stack0xffffffb8;
    piVar4 = (int *)&stack0xffffffb8;
    local_2c = 0;
    iVar6 = (int)local_1c - (int)&stack0xffffffb8;
    local_38 = (int)local_30 - (int)&stack0xffffffb8;
    iVar8 = 0;
    local_40 = iVar6;
    do {
      iVar9 = iVar10;
      if (*(int *)(iVar9 + 0xc) == 0) {
        *(int *)(iVar6 + (int)piVar4) = iVar9;
        iVar10 = local_38;
        iVar8 = iVar8 + 1;
        *local_28 = ((iVar9 + -0x10592dd8) / 0x18) * 0x10000 + DAT_10592dd0;
        *(int *)(iVar10 + (int)local_28) = local_2c;
        piVar4 = local_28 + 1;
        iVar6 = local_40;
        local_28 = piVar4;
        if (param_1 != '\0') break;
      }
      iVar10 = *(int *)(iVar9 + 8);
      local_2c = iVar9;
    } while (*(int *)(iVar9 + 8) != 0);
    this = local_18;
    if (iVar8 != 0) {
      uVar7 = FUN_1000e8a0(local_18,(int)local_20,iVar8,param_1 == '\0');
      if (((char)uVar7 == '\0') && (DAT_1083320e == '\0')) {
        DAT_1083320e = '\x01';
        local_11 = '\x01';
      }
      *(int *)((int)local_18 + 0x14) = *(int *)((int)local_18 + 0x14) - iVar8;
      iVar10 = iVar8 + -1;
      local_34 = iVar8 << 0x10;
      if (-1 < iVar10) {
        piVar4 = local_1c + iVar10;
        do {
          if (*(int *)(((int)local_30 - (int)local_1c) + (int)piVar4) == 0) {
            *(undefined4 *)((int)local_18 + 0xc) = *(undefined4 *)(*piVar4 + 8);
          }
          else {
            *(undefined4 *)(*(int *)(((int)local_30 - (int)local_1c) + (int)piVar4) + 8) =
                 *(undefined4 *)(*piVar4 + 8);
          }
          *(undefined4 *)(*piVar4 + 8) = 0;
          iVar6 = *piVar4;
          piVar4 = piVar4 + -1;
          iVar10 = iVar10 + -1;
          *(undefined4 *)(iVar6 + 4) = 0;
        } while (-1 < iVar10);
      }
      iVar10 = 4;
      if (param_1 != '\0') {
        iVar10 = 0x20;
      }
      iVar10 = iVar10 - DAT_10592dbc;
      if (0 < iVar10) {
        iVar6 = iVar8;
        if (iVar10 < iVar8) {
          iVar6 = iVar10;
        }
        for (; iVar6 != 0; iVar6 = iVar6 + -1) {
          iVar10 = iVar8 + -1;
          iVar8 = iVar8 + -1;
          FUN_1000da50(&DAT_10592db8,(undefined4 *)local_1c[iVar10]);
        }
      }
      if (iVar8 != 0) {
        uVar12 = FUN_1000c560((longlong *)&DAT_10592db8,(uint)local_1c);
        ppiVar11 = (int **)uVar12;
        if (0 < iVar8) {
          iVar10 = (int)local_20 - (int)local_1c;
          do {
            *(undefined4 *)(*local_1c + 0xc) = 0xffffffff;
            VirtualFree(*(LPVOID *)(iVar10 + (int)local_1c),0x10000,0x4000);
            FUN_1000da50(&DAT_10592db8,(undefined4 *)*local_1c);
            local_1c = local_1c + 1;
            iVar8 = iVar8 + -1;
          } while (iVar8 != 0);
        }
        ppiVar1 = ppiVar11;
        ppiVar5 = (int **)0x0;
        if (ppiVar11 != (int **)0x0) {
          while (ppiVar3 = ppiVar1, ppiVar3[3] != (int *)0xffffffff) {
            ppiVar1 = (int **)*ppiVar3;
            ppiVar5 = ppiVar3;
            piVar4 = DAT_10592db8;
            iVar10 = _DAT_10592dbc;
            if ((int **)*ppiVar3 == (int **)0x0) goto joined_r0x1000c2d6;
          }
          if (ppiVar5 == (int **)0x0) {
            ppiVar11 = (int **)0x0;
          }
          else {
            *ppiVar5 = (int *)0x0;
          }
          do {
            ppiVar1 = (int **)*ppiVar3;
            FUN_1000da50(&DAT_10592db8,ppiVar3);
            ppiVar3 = ppiVar1;
            piVar4 = DAT_10592db8;
            iVar10 = _DAT_10592dbc;
          } while (ppiVar1 != (int **)0x0);
joined_r0x1000c2d6:
          while (ppiVar1 = ppiVar11, DAT_10592db8 = piVar4, _DAT_10592dbc = iVar10,
                ppiVar1 != (int **)0x0) {
            ppiVar11 = (int **)*ppiVar1;
            *ppiVar1 = piVar4;
            uVar13 = ThreadInterlockedAssignIf64
                               ((longlong *)&DAT_10592db8,CONCAT44(iVar10 + 0x10001,ppiVar1),piVar4,
                                iVar10);
            cVar2 = (char)uVar13;
            piVar4 = DAT_10592db8;
            iVar10 = _DAT_10592dbc;
            while (cVar2 == '\0') {
              DAT_10592db8 = piVar4;
              _DAT_10592dbc = iVar10;
              *ppiVar1 = piVar4;
              uVar13 = ThreadInterlockedAssignIf64
                                 ((longlong *)&DAT_10592db8,CONCAT44(iVar10 + 0x10001,ppiVar1),
                                  piVar4,iVar10);
              piVar4 = DAT_10592db8;
              iVar10 = _DAT_10592dbc;
              cVar2 = (char)uVar13;
            }
          }
        }
      }
    }
  }
  if (param_1 == '\0') {
    *(undefined4 *)((int)this + 0x20) = 1;
  }
  _DAT_10592dc4 = 0;
  DAT_10592dc0 = 0;
  if (local_11 != '\0') {
    Warning((byte *)
            "***** HEAP IS CORRUPT (free compromised for block size %d,in %s heap, possible write after free *****)\n"
           );
  }
  return local_34;
}



void __fastcall FUN_1000c3b0(void *param_1)

{
  FUN_1000d8b0(param_1,'\0');
  return;
}



DWORD __fastcall FUN_1000c3c0(int param_1)

{
  DWORD *pDVar1;
  DWORD DVar2;
  DWORD DVar3;
  
  pDVar1 = (DWORD *)(param_1 + 0x2bd8);
  DVar2 = GetCurrentThreadId();
  DVar3 = DVar2;
  if (DVar2 != *pDVar1) {
    DVar3 = 0;
    LOCK();
    if (*pDVar1 == 0) {
      *pDVar1 = DVar2;
    }
    else {
      DVar3 = *pDVar1;
    }
    if (DVar3 != 0) {
      return DVar3;
    }
  }
  *(int *)(param_1 + 0x2bdc) = *(int *)(param_1 + 0x2bdc) + 1;
  if (*(char *)(param_1 + 0x2be0) == '\0') {
    *(undefined *)(param_1 + 0x2be0) = 1;
    FUN_1000bb30((void *)(param_1 + 0x1d38),'\x01');
    FUN_1000ba90((void *)(param_1 + 8),'\x01');
    DVar3 = FUN_1000b9f0((void *)(param_1 + 0xea0),'\x01');
    *(undefined *)(param_1 + 0x2be0) = 0;
  }
  *(int *)(param_1 + 0x2bdc) = *(int *)(param_1 + 0x2bdc) + -1;
  if (*(int *)(param_1 + 0x2bdc) == 0) {
    DVar3 = *pDVar1;
    *pDVar1 = 0;
  }
  return DVar3;
}



undefined4 __fastcall FUN_1000c430(int param_1)

{
  bool bVar1;
  uint uVar2;
  undefined4 *puVar3;
  int iVar4;
  
  bVar1 = true;
  iVar4 = 0x2a;
  puVar3 = (undefined4 *)(param_1 + 0x808);
  do {
    uVar2 = FUN_1000f0b0(puVar3);
    if (((char)uVar2 == '\0') || (!bVar1)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    puVar3 = puVar3 + 10;
    iVar4 = iVar4 + -1;
  } while (iVar4 != 0);
  if ((!bVar1) && (DAT_108331ec < 1)) {
    DAT_108331ec = DAT_108331ec + 1;
    Msg((byte *)"Small block heap is corrupt (primary)\n ");
  }
  bVar1 = true;
  puVar3 = (undefined4 *)(param_1 + 0x16a0);
  iVar4 = 0x2a;
  do {
    uVar2 = FUN_1000eeb0(puVar3);
    if (((char)uVar2 == '\0') || (!bVar1)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    puVar3 = puVar3 + 10;
    iVar4 = iVar4 + -1;
  } while (iVar4 != 0);
  if ((!bVar1) && (DAT_108331f0 < 1)) {
    DAT_108331f0 = DAT_108331f0 + 1;
    Msg((byte *)"Small block heap is corrupt (secondary)\n ");
  }
  bVar1 = true;
  puVar3 = (undefined4 *)(param_1 + 0x2538);
  iVar4 = 0x2a;
  do {
    uVar2 = FUN_1000f2b0(puVar3);
    if (((char)uVar2 == '\0') || (!bVar1)) {
      bVar1 = false;
    }
    else {
      bVar1 = true;
    }
    puVar3 = puVar3 + 10;
    iVar4 = iVar4 + -1;
  } while (iVar4 != 0);
  if ((!bVar1) && (DAT_108331f4 < 1)) {
    DAT_108331f4 = DAT_108331f4 + 1;
    Msg((byte *)"Small block heap is corrupt (fallback)\n ");
  }
  return 1;
}



undefined4 FUN_1000c540(void)

{
  return 1;
}



undefined4 FUN_1000c550(void)

{
  return 1;
}



ulonglong __fastcall FUN_1000c560(longlong *param_1,uint param_2)

{
  uint uVar1;
  ulonglong uVar2;
  
  uVar2 = (ulonglong)param_2 << 0x20;
  do {
    uVar1 = *(uint *)param_1;
    if (uVar1 == 0) {
      return uVar2 & 0xffffffff00000000;
    }
    uVar2 = ThreadInterlockedAssignIf64
                      (param_1,((ulonglong)*(uint *)((int)param_1 + 4) & 0xffff0000) << 0x20,uVar1,
                       *(uint *)((int)param_1 + 4));
  } while ((char)uVar2 == '\0');
  return uVar2 & 0xffffffff00000000 | (ulonglong)uVar1;
}



// public: void __thiscall CThreadFullMutex::SetTrace(bool)

void __thiscall CThreadFullMutex::SetTrace(CThreadFullMutex *this,bool param_1)

{
                    // 0xc5a0  221  ?SetTrace@CThreadFullMutex@@QAEX_N@Z
  return;
}



void __thiscall FUN_1000c5b0(void *this,undefined4 param_1,FILE *param_2,int param_3)

{
  uint uVar1;
  int *piVar2;
  int iVar3;
  uint local_c;
  uint local_8;
  
  FUN_1000edb0(this,(int *)&local_8,&local_c);
  if (param_2 == (FILE *)0x0) {
    if ((local_8 != 0) || (local_c != 0)) {
      iVar3 = 0;
      piVar2 = (int *)((int)this + 0x814);
      do {
        uVar1 = (int)(0x4000 / (ulonglong)(uint)piVar2[-1]) * *piVar2;
        if (uVar1 == 0) {
          Msg((byte *)"Pool %3i: (%5u-byte) not used\n");
        }
        else {
          FUN_1000ec60(*piVar2 << 0xe,0);
          FUN_1000ec60(uVar1,0);
          FUN_1000ec60(0,0);
          FUN_1000ec60(0,0);
          Msg((byte *)
              "Pool %3i: (size: %5u) blocks: allocated:%16s (%2d%%) free:%16s (%2d%%) committed:%16s (committed size:%16s)\n"
             );
        }
        iVar3 = iVar3 + 1;
        piVar2 = piVar2 + 10;
      } while (iVar3 < 0x2a);
    }
    FUN_1000ec60(local_c,0);
    FUN_1000ec60(local_8,0);
    Msg((byte *)"Totals (%s): Committed:%16s Allocated:%16s\n");
    return;
  }
  if ((local_8 == 0) && (local_c == 0)) {
    FUN_1002158b(param_2,(byte *)"%s is Empty\n");
    return;
  }
  if (param_3 != 1) {
    piVar2 = (int *)((int)this + 0x814);
    iVar3 = 0;
    do {
      uVar1 = (int)(0x4000 / (ulonglong)(uint)piVar2[-1]) * *piVar2;
      if (uVar1 == 0) {
        FUN_1002158b(param_2,(byte *)"Pool %3i: (%5u-byte) not used\n");
      }
      else {
        FUN_1000ec60(*piVar2 << 0xe,0);
        FUN_1000ec60(uVar1,0);
        FUN_1000ec60(0,0);
        FUN_1000ec60(0,0);
        FUN_1002158b(param_2,(byte *)
                             "Pool %3i: (%5u-byte) blocks used:%16s (%2d%%) free:%16s (%2d%%) commit:%16s (bytes:%16s)\n"
                    );
      }
      iVar3 = iVar3 + 1;
      piVar2 = piVar2 + 10;
    } while (iVar3 < 0x2a);
    FUN_1000ec60(local_c,0);
    FUN_1000ec60(local_8,0);
    FUN_1002158b(param_2,(byte *)"Totals (%s): Committed:%16s Allocated:%16s\n");
    return;
  }
  FUN_1002158b(param_2,(byte *)"<div class=\"sbhTable\" data-role=\"collapsible\">");
  FUN_1000ec60(local_c,0);
  FUN_1000ec60(local_8,0);
  FUN_1002158b(param_2,(byte *)"<legend%s>Committed:<b>%16s</b> Allocated:<b>%16s</b></legend>\n");
  FUN_1002158b(param_2,(byte *)
                       "<table class=\"dataTable\" style=\"border:1px solid grey;text-align:right;margin:1px;width:auto;\"><tbody><tr style=\"color:white;border:1px solid grey;margin:2px\"><th>Pool&nbsp;</th><th>Size&nbsp;</th><th>Used#&nbsp;</th><th>(%%)&nbsp;</th><th>Free#&nbsp;</th><th>(%%)&nbsp;</th><th>Commit#&nbsp;</th><th>Commit mem&nbsp;</th></tr>"
              );
  piVar2 = (int *)((int)this + 0x814);
  iVar3 = 0;
  do {
    uVar1 = (int)(0x4000 / (ulonglong)(uint)piVar2[-1]) * *piVar2;
    if (uVar1 == 0) {
      FUN_1002158b(param_2,(byte *)
                           "<tr style=\"color:#444444\"><td>%d</td><td>%d</td><td colspan=6>Not Used</td></tr>\n"
                  );
    }
    else {
      FUN_1000ec60(*piVar2 << 0xe,0);
      FUN_1000ec60(uVar1,0);
      FUN_1000ec60(0,0);
      FUN_1000ec60(0,0);
      FUN_1002158b(param_2,(byte *)
                           "<tr><td>%d</td><td>%d</td><td>%s</td><td><i>%d%%</i></td><td>%s</td><td><i>%d%%</i></td><td>%s</td><td>%s</td></tr>\n"
                  );
    }
    iVar3 = iVar3 + 1;
    piVar2 = piVar2 + 10;
  } while (iVar3 < 0x2a);
  FUN_1002158b(param_2,(byte *)
                       "</tbody></table></div><script>$(document).ready(function(){$(\".sbhTable\").accordion( { collapsible:true, active:false } );});</script>"
              );
  return;
}



void __thiscall FUN_1000c900(void *this,undefined4 param_1,FILE *param_2,int param_3)

{
  uint uVar1;
  int *piVar2;
  int iVar3;
  uint local_c;
  uint local_8;
  
  FUN_1000ee30(this,(int *)&local_8,&local_c);
  if (param_2 == (FILE *)0x0) {
    if ((local_8 != 0) || (local_c != 0)) {
      iVar3 = 0;
      piVar2 = (int *)((int)this + 0x814);
      do {
        uVar1 = (int)(0x10000 / (ulonglong)(uint)piVar2[-1]) * *piVar2;
        if (uVar1 == 0) {
          Msg((byte *)"Pool %3i: (%5u-byte) not used\n");
        }
        else {
          FUN_1000ec60(*piVar2 << 0x10,0);
          FUN_1000ec60(uVar1,0);
          FUN_1000ec60(0,0);
          FUN_1000ec60(0,0);
          Msg((byte *)
              "Pool %3i: (size: %5u) blocks: allocated:%16s (%2d%%) free:%16s (%2d%%) committed:%16s (committed size:%16s)\n"
             );
        }
        iVar3 = iVar3 + 1;
        piVar2 = piVar2 + 10;
      } while (iVar3 < 0x2a);
    }
    FUN_1000ec60(local_c,0);
    FUN_1000ec60(local_8,0);
    Msg((byte *)"Totals (%s): Committed:%16s Allocated:%16s\n");
    return;
  }
  if ((local_8 == 0) && (local_c == 0)) {
    FUN_1002158b(param_2,(byte *)"%s is Empty\n");
    return;
  }
  if (param_3 != 1) {
    piVar2 = (int *)((int)this + 0x814);
    iVar3 = 0;
    do {
      uVar1 = (int)(0x10000 / (ulonglong)(uint)piVar2[-1]) * *piVar2;
      if (uVar1 == 0) {
        FUN_1002158b(param_2,(byte *)"Pool %3i: (%5u-byte) not used\n");
      }
      else {
        FUN_1000ec60(*piVar2 << 0x10,0);
        FUN_1000ec60(uVar1,0);
        FUN_1000ec60(0,0);
        FUN_1000ec60(0,0);
        FUN_1002158b(param_2,(byte *)
                             "Pool %3i: (%5u-byte) blocks used:%16s (%2d%%) free:%16s (%2d%%) commit:%16s (bytes:%16s)\n"
                    );
      }
      iVar3 = iVar3 + 1;
      piVar2 = piVar2 + 10;
    } while (iVar3 < 0x2a);
    FUN_1000ec60(local_c,0);
    FUN_1000ec60(local_8,0);
    FUN_1002158b(param_2,(byte *)"Totals (%s): Committed:%16s Allocated:%16s\n");
    return;
  }
  FUN_1002158b(param_2,(byte *)"<div class=\"sbhTable\" data-role=\"collapsible\">");
  FUN_1000ec60(local_c,0);
  FUN_1000ec60(local_8,0);
  FUN_1002158b(param_2,(byte *)"<legend%s>Committed:<b>%16s</b> Allocated:<b>%16s</b></legend>\n");
  FUN_1002158b(param_2,(byte *)
                       "<table class=\"dataTable\" style=\"border:1px solid grey;text-align:right;margin:1px;width:auto;\"><tbody><tr style=\"color:white;border:1px solid grey;margin:2px\"><th>Pool&nbsp;</th><th>Size&nbsp;</th><th>Used#&nbsp;</th><th>(%%)&nbsp;</th><th>Free#&nbsp;</th><th>(%%)&nbsp;</th><th>Commit#&nbsp;</th><th>Commit mem&nbsp;</th></tr>"
              );
  piVar2 = (int *)((int)this + 0x814);
  iVar3 = 0;
  do {
    uVar1 = (int)(0x10000 / (ulonglong)(uint)piVar2[-1]) * *piVar2;
    if (uVar1 == 0) {
      FUN_1002158b(param_2,(byte *)
                           "<tr style=\"color:#444444\"><td>%d</td><td>%d</td><td colspan=6>Not Used</td></tr>\n"
                  );
    }
    else {
      FUN_1000ec60(*piVar2 << 0x10,0);
      FUN_1000ec60(uVar1,0);
      FUN_1000ec60(0,0);
      FUN_1000ec60(0,0);
      FUN_1002158b(param_2,(byte *)
                           "<tr><td>%d</td><td>%d</td><td>%s</td><td><i>%d%%</i></td><td>%s</td><td><i>%d%%</i></td><td>%s</td><td>%s</td></tr>\n"
                  );
    }
    iVar3 = iVar3 + 1;
    piVar2 = piVar2 + 10;
  } while (iVar3 < 0x2a);
  FUN_1002158b(param_2,(byte *)
                       "</tbody></table></div><script>$(document).ready(function(){$(\".sbhTable\").accordion( { collapsible:true, active:false } );});</script>"
              );
  return;
}



void __fastcall FUN_1000cc50(int *param_1)

{
  (**(code **)(*param_1 + 0x4c))("memstats",0);
  return;
}



void __thiscall FUN_1000cc60(void *this,undefined4 param_1,int param_2)

{
  FILE *_File;
  char local_204 [511];
  undefined local_5;
  
  FUN_1002169d(local_204,0x1ff,(byte *)"%s.txt");
  local_5 = 0;
  _File = _fopen(local_204,"wt");
  if (_File == (FILE *)0x0) {
    Msg((byte *)"Fixed Page SBH:\n");
  }
  else {
    FUN_1002158b(_File,(byte *)"Fixed Page SBH:\n");
  }
  FUN_1000c5b0((void *)((int)this + 8),"Fixed Page SBH",_File,param_2);
  if (_File == (FILE *)0x0) {
    Msg((byte *)"Secondary Page SBH:\n");
  }
  else {
    FUN_1002158b(_File,(byte *)"Secondary Fixed Page SBH:\n");
  }
  FUN_1000c5b0((void *)((int)this + 0xea0),"Secondary Page SBH",_File,0);
  if (_File == (FILE *)0x0) {
    Msg((byte *)"\nFallback SBH:\n");
  }
  else {
    FUN_1002158b(_File,(byte *)"\nFallback SBH:\n");
  }
  FUN_1000c900((void *)((int)this + 0x1d38),"Fallback SBH",_File,param_2);
  FUN_1000f510(_File,param_2);
  if (_File != (FILE *)0x0) {
    _fclose(_File);
  }
  return;
}



void __thiscall FUN_1000cd60(void *this,undefined4 *param_1)

{
  int iVar1;
  void *this_00;
  code *pcVar2;
  bool bVar3;
  uint uVar4;
  
  iVar1 = *(int *)((int)this + 0xe90);
  uVar4 = (uint)((int)param_1 - *(int *)(iVar1 + 0x20)) >> 0xe;
  if ((uVar4 < *(uint *)(iVar1 + 0x18)) &&
     (this_00 = *(void **)(iVar1 + 0x2c + uVar4 * 0x18), this_00 != (void *)0x0)) {
    FUN_1000cde0(this_00,param_1);
    return;
  }
  bVar3 = Plat_IsInDebugSession();
  if (bVar3) {
    pcVar2 = (code *)swi(3);
    (*pcVar2)();
    return;
  }
  return;
}



void __thiscall FUN_1000cda0(void *this,undefined4 *param_1)

{
  int iVar1;
  void *this_00;
  code *pcVar2;
  bool bVar3;
  uint uVar4;
  
  iVar1 = *(int *)((int)this + 0xe90);
  uVar4 = (uint)((int)param_1 - *(int *)(iVar1 + 0x20)) >> 0x10;
  if ((uVar4 < *(uint *)(iVar1 + 0x18)) &&
     (this_00 = *(void **)(iVar1 + 0x2c + uVar4 * 0x18), this_00 != (void *)0x0)) {
    FUN_1000cf60(this_00,param_1);
    return;
  }
  bVar3 = Plat_IsInDebugSession();
  if (bVar3) {
    pcVar2 = (code *)swi(3);
    (*pcVar2)();
    return;
  }
  return;
}



void __thiscall FUN_1000cde0(void *this,undefined4 *param_1)

{
  int *piVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  
  uVar5 = (int)param_1 - DAT_102f2da8;
  if ((DAT_102f2d98 & 0x10000) == 0) {
    uVar4 = DAT_102f2d98 & 0xffff;
    LOCK();
    uVar3 = uVar4;
    uVar2 = uVar4 + 1;
    if (uVar4 != DAT_102f2d98) {
      uVar3 = DAT_102f2d98;
      uVar2 = DAT_102f2d98;
    }
    DAT_102f2d98 = uVar2;
    if (uVar3 == uVar4) goto LAB_1000ce5e;
  }
  if ((DAT_102f2d98 & 0x10000) == 0) {
    uVar4 = DAT_102f2d98 & 0xffff;
    LOCK();
    uVar3 = uVar4;
    uVar2 = uVar4 + 1;
    if (uVar4 != DAT_102f2d98) {
      uVar3 = DAT_102f2d98;
      uVar2 = DAT_102f2d98;
    }
    DAT_102f2d98 = uVar2;
    if (uVar3 == uVar4) goto LAB_1000ce5e;
  }
  CThreadSpinRWLock::SpinLockForRead((CThreadSpinRWLock *)&DAT_102f2d98);
LAB_1000ce5e:
  piVar1 = &DAT_102f2dbc + (uVar5 >> 0xe) * 6;
  LOCK();
  *piVar1 = *piVar1 + -1;
  if (*piVar1 == 0) {
    *(undefined4 *)((int)this + 0x20) = 0;
  }
  FUN_1000da50(this,param_1);
  LOCK();
  DAT_102f2d98 = DAT_102f2d98 - 1;
  return;
}



void __thiscall FUN_1000cea0(void *this,undefined4 *param_1)

{
  int *piVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  
  uVar5 = (int)param_1 - DAT_10052d80;
  if ((DAT_10052d70 & 0x10000) == 0) {
    uVar4 = DAT_10052d70 & 0xffff;
    LOCK();
    uVar3 = uVar4;
    uVar2 = uVar4 + 1;
    if (uVar4 != DAT_10052d70) {
      uVar3 = DAT_10052d70;
      uVar2 = DAT_10052d70;
    }
    DAT_10052d70 = uVar2;
    if (uVar3 == uVar4) goto LAB_1000cf1e;
  }
  if ((DAT_10052d70 & 0x10000) == 0) {
    uVar4 = DAT_10052d70 & 0xffff;
    LOCK();
    uVar3 = uVar4;
    uVar2 = uVar4 + 1;
    if (uVar4 != DAT_10052d70) {
      uVar3 = DAT_10052d70;
      uVar2 = DAT_10052d70;
    }
    DAT_10052d70 = uVar2;
    if (uVar3 == uVar4) goto LAB_1000cf1e;
  }
  CThreadSpinRWLock::SpinLockForRead((CThreadSpinRWLock *)&DAT_10052d70);
LAB_1000cf1e:
  piVar1 = &DAT_10052d94 + (uVar5 >> 0xe) * 6;
  LOCK();
  *piVar1 = *piVar1 + -1;
  if (*piVar1 == 0) {
    *(undefined4 *)((int)this + 0x20) = 0;
  }
  FUN_1000da50(this,param_1);
  LOCK();
  DAT_10052d70 = DAT_10052d70 - 1;
  return;
}



void __thiscall FUN_1000cf60(void *this,undefined4 *param_1)

{
  int *piVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  
  uVar5 = (int)param_1 - DAT_10592dd0;
  if ((DAT_10592dc0 & 0x10000) == 0) {
    uVar4 = DAT_10592dc0 & 0xffff;
    LOCK();
    uVar3 = uVar4;
    uVar2 = uVar4 + 1;
    if (uVar4 != DAT_10592dc0) {
      uVar3 = DAT_10592dc0;
      uVar2 = DAT_10592dc0;
    }
    DAT_10592dc0 = uVar2;
    if (uVar3 == uVar4) goto LAB_1000cfde;
  }
  if ((DAT_10592dc0 & 0x10000) == 0) {
    uVar4 = DAT_10592dc0 & 0xffff;
    LOCK();
    uVar3 = uVar4;
    uVar2 = uVar4 + 1;
    if (uVar4 != DAT_10592dc0) {
      uVar3 = DAT_10592dc0;
      uVar2 = DAT_10592dc0;
    }
    DAT_10592dc0 = uVar2;
    if (uVar3 == uVar4) goto LAB_1000cfde;
  }
  CThreadSpinRWLock::SpinLockForRead((CThreadSpinRWLock *)&DAT_10592dc0);
LAB_1000cfde:
  piVar1 = &DAT_10592de4 + (uVar5 >> 0x10) * 6;
  LOCK();
  *piVar1 = *piVar1 + -1;
  if (*piVar1 == 0) {
    *(undefined4 *)((int)this + 0x20) = 0;
  }
  FUN_1000da50(this,param_1);
  LOCK();
  DAT_10592dc0 = DAT_10592dc0 - 1;
  return;
}



void __thiscall FUN_1000d020(void *this,uint *param_1)

{
  int iVar1;
  void *this_00;
  uint *puVar2;
  code *pcVar3;
  bool bVar4;
  uint uVar5;
  
  if (param_1 != (uint *)0x0) {
    iVar1 = *(int *)((int)this + 0xe98);
    if ((param_1 < *(uint **)(iVar1 + 0x20)) ||
       (*(uint *)(iVar1 + 0x18) <= (uint)((int)param_1 - (int)*(uint **)(iVar1 + 0x20)) >> 0xe)) {
      iVar1 = *(int *)((int)this + 0x1d30);
      if ((*(uint **)(iVar1 + 0x20) <= param_1) &&
         ((uint)((int)param_1 - *(int *)(iVar1 + 0x20)) >> 0xe < *(uint *)(iVar1 + 0x18))) {
        FUN_1000cd60((void *)((int)this + 0xea0),param_1);
        return;
      }
      puVar2 = *(uint **)(*(int *)((int)this + 0x2bc8) + 0x20);
      if ((puVar2 <= param_1) &&
         ((uint)((int)param_1 - (int)puVar2) >> 0x10 <
          *(uint *)(*(int *)((int)this + 0x2bc8) + 0x18))) {
        FUN_1000cda0((void *)((int)this + 0x1d38),param_1);
        return;
      }
      FUN_1001da20(param_1);
    }
    else {
      uVar5 = (uint)((int)param_1 - *(int *)(iVar1 + 0x20)) >> 0xe;
      if ((uVar5 < *(uint *)(iVar1 + 0x18)) &&
         (this_00 = *(void **)(iVar1 + 0x2c + uVar5 * 0x18), this_00 != (void *)0x0)) {
        FUN_1000cea0(this_00,param_1);
        return;
      }
      bVar4 = Plat_IsInDebugSession();
      if (bVar4) {
        pcVar3 = (code *)swi(3);
        (*pcVar3)();
        return;
      }
    }
  }
  return;
}



void __thiscall FUN_1000d0f0(void *this,uint *param_1)

{
  int iVar1;
  void *this_00;
  uint *puVar2;
  code *pcVar3;
  bool bVar4;
  uint uVar5;
  
  if (param_1 != (uint *)0x0) {
    iVar1 = *(int *)((int)this + 0xe98);
    if ((param_1 < *(uint **)(iVar1 + 0x20)) ||
       (*(uint *)(iVar1 + 0x18) <= (uint)((int)param_1 - (int)*(uint **)(iVar1 + 0x20)) >> 0xe)) {
      iVar1 = *(int *)((int)this + 0x1d30);
      if ((*(uint **)(iVar1 + 0x20) <= param_1) &&
         ((uint)((int)param_1 - *(int *)(iVar1 + 0x20)) >> 0xe < *(uint *)(iVar1 + 0x18))) {
        FUN_1000cd60((void *)((int)this + 0xea0),param_1);
        return;
      }
      puVar2 = *(uint **)(*(int *)((int)this + 0x2bc8) + 0x20);
      if ((puVar2 <= param_1) &&
         ((uint)((int)param_1 - (int)puVar2) >> 0x10 <
          *(uint *)(*(int *)((int)this + 0x2bc8) + 0x18))) {
        FUN_1000cda0((void *)((int)this + 0x1d38),param_1);
        return;
      }
      FUN_1001da20(param_1);
    }
    else {
      uVar5 = (uint)((int)param_1 - *(int *)(iVar1 + 0x20)) >> 0xe;
      if ((uVar5 < *(uint *)(iVar1 + 0x18)) &&
         (this_00 = *(void **)(iVar1 + 0x2c + uVar5 * 0x18), this_00 != (void *)0x0)) {
        FUN_1000cea0(this_00,param_1);
        return;
      }
      bVar4 = Plat_IsInDebugSession();
      if (bVar4) {
        pcVar3 = (code *)swi(3);
        (*pcVar3)();
        return;
      }
    }
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __thiscall FUN_1000d1d0(void *this,undefined4 *param_1)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  int *piVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  int local_58 [10];
  int local_30;
  int iStack44;
  int iStack40;
  int iStack36;
  int local_20;
  int iStack28;
  int iStack24;
  int iStack20;
  undefined8 local_10;
  undefined4 local_8;
  
  puVar1 = param_1;
  if (param_1 == (undefined4 *)0x0) {
    return 0;
  }
  DAT_10052d5c = 0;
  FUN_1000edb0((void *)((int)this + 8),(int *)&param_1,&local_8);
  puVar2 = param_1;
  FUN_1000edb0((void *)((int)this + 0xea0),(int *)&param_1,&local_8);
  iVar6 = (int)puVar2 + (int)param_1;
  FUN_1000ee30((void *)((int)this + 0x1d38),(int *)&param_1,&local_8);
  _DAT_1004ff44 = iVar6 + (int)param_1;
  _DAT_1004ff4c = _DAT_1004ff44;
  if (_DAT_1004ff44 < DAT_108331f8) {
    _DAT_1004ff4c = DAT_108331f8;
  }
  _DAT_1004ff40 = "SBH_cur";
  _DAT_1004ff48 = "SBH_max";
  DAT_10052d5c = 2;
  DAT_108331f8 = _DAT_1004ff4c;
  piVar3 = FUN_1001ed40(local_58,DAT_10832de0);
  uVar4 = piVar3[7];
  local_30 = *piVar3;
  iStack44 = piVar3[1];
  iStack40 = piVar3[2];
  iStack36 = piVar3[3];
  local_10 = *(undefined8 *)(piVar3 + 8);
  uVar5 = uVar4;
  if (uVar4 < DAT_108331fc) {
    uVar5 = DAT_108331fc;
  }
  iVar6 = DAT_10052d5c;
  DAT_108331fc = uVar5;
  if (DAT_10052d5c < 0x40) {
    *(char **)(&DAT_1004ff40 + DAT_10052d5c * 8) = "MBH_cur";
    *(uint *)(&DAT_1004ff44 + DAT_10052d5c * 8) = uVar4;
    iVar6 = DAT_10052d5c + 1;
    if (iVar6 < 0x40) {
      *(char **)(&DAT_1004ff40 + iVar6 * 8) = "MBH_max";
      *(uint *)(&DAT_1004ff44 + iVar6 * 8) = uVar5;
      iVar6 = DAT_10052d5c + 2;
    }
  }
  DAT_10052d5c = iVar6;
  piVar3 = FUN_1001ed40(local_58,DAT_10832ddc);
  local_30 = *piVar3;
  iStack44 = piVar3[1];
  iStack40 = piVar3[2];
  iStack36 = piVar3[3];
  local_20 = piVar3[4];
  iStack28 = piVar3[5];
  iStack24 = piVar3[6];
  iStack20 = piVar3[7];
  local_10 = *(undefined8 *)(piVar3 + 8);
  uVar4 = FUN_1001e590(DAT_10832ddc);
  uVar5 = FUN_1001f0f0(DAT_10832ddc);
  iVar6 = DAT_10052d5c;
  if (DAT_10052d5c < 0x40) {
    *(char **)(&DAT_1004ff40 + DAT_10052d5c * 8) = "LBH_cur";
    *(uint *)(&DAT_1004ff44 + DAT_10052d5c * 8) = uVar4;
    iVar6 = DAT_10052d5c + 1;
    if (iVar6 < 0x40) {
      *(char **)(&DAT_1004ff40 + iVar6 * 8) = "LBH_max";
      *(uint *)(&DAT_1004ff44 + iVar6 * 8) = uVar5;
      iVar6 = DAT_10052d5c + 2;
      if (iVar6 < 0x40) {
        *(char **)(&DAT_1004ff40 + iVar6 * 8) = "LBH_arena";
        *(int *)(&DAT_1004ff44 + iVar6 * 8) = local_30;
        iVar6 = DAT_10052d5c + 3;
        if (iVar6 < 0x40) {
          *(char **)(&DAT_1004ff40 + iVar6 * 8) = "LBH_free";
          *(undefined4 *)(&DAT_1004ff44 + iVar6 * 8) = (undefined4)local_10;
          iVar6 = DAT_10052d5c + 4;
        }
      }
    }
  }
  DAT_10052d5c = iVar6;
  *puVar1 = &DAT_1004ff40;
  return DAT_10052d5c;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 __thiscall FUN_1000d3e0(void *this,int param_1)

{
  int iVar1;
  uint uVar2;
  
  iVar1 = *(int *)((int)this + 0xe90);
  uVar2 = (uint)(param_1 - *(int *)(iVar1 + 0x20)) >> 0xe;
  if (uVar2 < *(uint *)(iVar1 + 0x18)) {
    return *(undefined4 *)(*(int *)(iVar1 + 0x2c + uVar2 * 0x18) + 0x10);
  }
  return _DAT_00000010;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 __thiscall FUN_1000d410(void *this,int param_1)

{
  int iVar1;
  uint uVar2;
  
  iVar1 = *(int *)((int)this + 0xe90);
  uVar2 = (uint)(param_1 - *(int *)(iVar1 + 0x20)) >> 0x10;
  if (uVar2 < *(uint *)(iVar1 + 0x18)) {
    return *(undefined4 *)(*(int *)(iVar1 + 0x2c + uVar2 * 0x18) + 0x10);
  }
  return _DAT_00000010;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __thiscall FUN_1000d440(void *this,uint param_1)

{
  int iVar1;
  uint uVar2;
  
  if (param_1 == 0) {
    iVar1 = FUN_100099c0();
    return iVar1;
  }
  iVar1 = *(int *)((int)this + 0xe98);
  if ((*(uint *)(iVar1 + 0x20) <= param_1) &&
     (param_1 - *(uint *)(iVar1 + 0x20) >> 0xe < *(uint *)(iVar1 + 0x18))) {
    uVar2 = param_1 - *(int *)(iVar1 + 0x20) >> 0xe;
    if (uVar2 < *(uint *)(iVar1 + 0x18)) {
      return *(int *)(*(int *)(iVar1 + 0x2c + uVar2 * 0x18) + 0x10);
    }
    return _DAT_00000010;
  }
  iVar1 = *(int *)((int)this + 0x1d30);
  if ((*(uint *)(iVar1 + 0x20) <= param_1) &&
     (param_1 - *(int *)(iVar1 + 0x20) >> 0xe < *(uint *)(iVar1 + 0x18))) {
    iVar1 = FUN_1000d3e0((void *)((int)this + 0xea0),param_1);
    return iVar1;
  }
  uVar2 = FUN_1000d970((void *)((int)this + 0x1d38),param_1);
  if ((char)uVar2 != '\0') {
    iVar1 = FUN_1000d410((void *)((int)this + 0x1d38),param_1);
    return iVar1;
  }
  iVar1 = FUN_1001e520(param_1);
  return iVar1;
}



void FUN_1000d500(undefined4 *param_1,undefined4 *param_2)

{
  int local_2c [10];
  
  if ((param_1 != (undefined4 *)0x0) && (param_2 != (undefined4 *)0x0)) {
    FUN_1001ed40(local_2c,DAT_10832ddc);
    *param_2 = 0;
    *param_1 = 0;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 __thiscall FUN_1000d540(void *this,uint param_1)

{
  code *pcVar1;
  undefined (*pauVar2) [16];
  undefined (*pauVar3) [16];
  int iVar4;
  undefined4 uVar5;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  undefined4 extraout_ECX_01;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 uVar6;
  
  if (DAT_102f2da8 == (LPVOID)0x0) {
    if (DAT_10052d54 == 0) {
      pauVar2 = (undefined (*) [16])Plat_GetCommandLine();
      uVar5 = extraout_ECX;
      uVar6 = extraout_EDX;
      if ((pauVar2 == (undefined (*) [16])0x0) ||
         (pauVar3 = FUN_10021ad0(extraout_ECX,extraout_EDX,pauVar2,
                                 (undefined (*) [16])"-forcesbhsizemb "), uVar5 = extraout_ECX_00,
         uVar6 = extraout_EDX_00, pauVar3 == (undefined (*) [16])0x0)) {
        DAT_10052d54 = 0x8000000;
      }
      else {
        iVar4 = FUN_10020d54((char *)pauVar3[1]);
        DAT_10052d54 = iVar4 * 0x100000;
        Msg((byte *)"SBH size forced override -forcesbhsizemb: %llu bytes (%u MB)\n");
        uVar5 = extraout_ECX_01;
        uVar6 = extraout_EDX_01;
      }
      if ((pauVar2 != (undefined (*) [16])0x0) &&
         (pauVar2 = FUN_10021ad0(uVar5,uVar6,pauVar2,(undefined (*) [16])"-sbhcompactdisabled "),
         pauVar2 != (undefined (*) [16])0x0)) {
        DAT_10052d58 = 1;
        Msg((byte *)"SBH compact disabled\n");
      }
    }
    DAT_102f2da4 = VirtualAlloc((LPVOID)0x0,0x4000000,0x1000,4);
    _DAT_102f2da0 = 0x1000;
    _DAT_102f2dac = (int)DAT_102f2da4 + 0x4000000;
    DAT_102f2da8 = DAT_102f2da4;
  }
  if (((param_1 & 7) == 0) && (7 < param_1)) {
    *(uint *)((int)this + 0x10) = param_1;
    *(undefined4 *)((int)this + 8) = 0;
    *(undefined4 *)((int)this + 0x14) = 0;
    *(undefined4 *)((int)this + 0x20) = 1;
    return *(undefined4 *)((int)this + 0x20);
  }
  pcVar1 = (code *)swi(3);
  uVar5 = (*pcVar1)();
  return uVar5;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 __thiscall FUN_1000d650(void *this,uint param_1)

{
  code *pcVar1;
  undefined (*pauVar2) [16];
  undefined (*pauVar3) [16];
  int iVar4;
  undefined4 uVar5;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  undefined4 extraout_ECX_01;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 uVar6;
  
  if (DAT_10052d80 == (LPVOID)0x0) {
    if (DAT_10052d54 == 0) {
      pauVar2 = (undefined (*) [16])Plat_GetCommandLine();
      uVar5 = extraout_ECX;
      uVar6 = extraout_EDX;
      if ((pauVar2 == (undefined (*) [16])0x0) ||
         (pauVar3 = FUN_10021ad0(extraout_ECX,extraout_EDX,pauVar2,
                                 (undefined (*) [16])"-forcesbhsizemb "), uVar5 = extraout_ECX_00,
         uVar6 = extraout_EDX_00, pauVar3 == (undefined (*) [16])0x0)) {
        DAT_10052d54 = 0x8000000;
      }
      else {
        iVar4 = FUN_10020d54((char *)pauVar3[1]);
        DAT_10052d54 = iVar4 * 0x100000;
        Msg((byte *)"SBH size forced override -forcesbhsizemb: %llu bytes (%u MB)\n");
        uVar5 = extraout_ECX_01;
        uVar6 = extraout_EDX_01;
      }
      if ((pauVar2 != (undefined (*) [16])0x0) &&
         (pauVar2 = FUN_10021ad0(uVar5,uVar6,pauVar2,(undefined (*) [16])"-sbhcompactdisabled "),
         pauVar2 != (undefined (*) [16])0x0)) {
        DAT_10052d58 = 1;
        Msg((byte *)"SBH compact disabled\n");
      }
    }
    DAT_10052d80 = VirtualAlloc((LPVOID)0x0,DAT_10052d54,0x1000,4);
    _DAT_10052d78 = DAT_10052d54 >> 0xe;
    if (0x1c000 < _DAT_10052d78) {
      Error((byte *)"SBH Configuration Error! (%u < %u)");
    }
    _DAT_10052d84 = (int)DAT_10052d80 + DAT_10052d54;
    DAT_10052d7c = DAT_10052d80;
  }
  if (((param_1 & 7) == 0) && (7 < param_1)) {
    *(uint *)((int)this + 0x10) = param_1;
    *(undefined4 *)((int)this + 8) = 0;
    *(undefined4 *)((int)this + 0x14) = 0;
    *(undefined4 *)((int)this + 0x20) = 1;
    return *(undefined4 *)((int)this + 0x20);
  }
  pcVar1 = (code *)swi(3);
  uVar5 = (*pcVar1)();
  return uVar5;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 __thiscall FUN_1000d790(void *this,uint param_1)

{
  code *pcVar1;
  undefined (*pauVar2) [16];
  undefined (*pauVar3) [16];
  int iVar4;
  undefined4 uVar5;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  undefined4 extraout_ECX_01;
  undefined4 extraout_EDX;
  undefined4 extraout_EDX_00;
  undefined4 extraout_EDX_01;
  undefined4 uVar6;
  
  if (DAT_10592dd0 == (LPVOID)0x0) {
    if (DAT_10052d54 == 0) {
      pauVar2 = (undefined (*) [16])Plat_GetCommandLine();
      uVar5 = extraout_ECX;
      uVar6 = extraout_EDX;
      if ((pauVar2 == (undefined (*) [16])0x0) ||
         (pauVar3 = FUN_10021ad0(extraout_ECX,extraout_EDX,pauVar2,
                                 (undefined (*) [16])"-forcesbhsizemb "), uVar5 = extraout_ECX_00,
         uVar6 = extraout_EDX_00, pauVar3 == (undefined (*) [16])0x0)) {
        DAT_10052d54 = 0x8000000;
      }
      else {
        iVar4 = FUN_10020d54((char *)pauVar3[1]);
        DAT_10052d54 = iVar4 * 0x100000;
        Msg((byte *)"SBH size forced override -forcesbhsizemb: %llu bytes (%u MB)\n");
        uVar5 = extraout_ECX_01;
        uVar6 = extraout_EDX_01;
      }
      if ((pauVar2 != (undefined (*) [16])0x0) &&
         (pauVar2 = FUN_10021ad0(uVar5,uVar6,pauVar2,(undefined (*) [16])"-sbhcompactdisabled "),
         pauVar2 != (undefined (*) [16])0x0)) {
        DAT_10052d58 = 1;
        Msg((byte *)"SBH compact disabled\n");
      }
    }
    DAT_10592dcc = VirtualAlloc((LPVOID)0x0,0x2000000,0x2000,1);
    _DAT_10592dc8 = 0x200;
    _DAT_10592dd4 = (int)DAT_10592dcc + 0x2000000;
    DAT_10592dd0 = DAT_10592dcc;
  }
  if (((param_1 & 7) == 0) && (7 < param_1)) {
    *(uint *)((int)this + 0x10) = param_1;
    *(undefined4 *)((int)this + 8) = 0;
    *(undefined4 *)((int)this + 0x14) = 0;
    *(undefined4 *)((int)this + 0x20) = 1;
    return *(undefined4 *)((int)this + 0x20);
  }
  pcVar1 = (code *)swi(3);
  uVar5 = (*pcVar1)();
  return uVar5;
}



void FUN_1000d8a0(void)

{
  return;
}



int __thiscall FUN_1000d8b0(void *this,char param_1)

{
  DWORD *pDVar1;
  DWORD DVar2;
  DWORD DVar3;
  int iVar4;
  int iVar5;
  int iVar6;
  
  pDVar1 = (DWORD *)((int)this + 0x2bd8);
  DVar2 = GetCurrentThreadId();
  if (DVar2 != *pDVar1) {
    DVar3 = 0;
    LOCK();
    if (*pDVar1 == 0) {
      *pDVar1 = DVar2;
    }
    else {
      DVar3 = *pDVar1;
    }
    if (DVar3 != 0) {
      return 0;
    }
  }
  *(int *)((int)this + 0x2bdc) = *(int *)((int)this + 0x2bdc) + 1;
  if (*(char *)((int)this + 0x2be0) != '\0') {
    *(int *)((int)this + 0x2bdc) = *(int *)((int)this + 0x2bdc) + -1;
    if (*(int *)((int)this + 0x2bdc) == 0) {
      *pDVar1 = 0;
    }
    return 0;
  }
  *(undefined *)((int)this + 0x2be0) = 1;
  iVar4 = FUN_1000bb30((void *)((int)this + 0x1d38),'\0');
  iVar5 = FUN_1000ba90((void *)((int)this + 8),'\0');
  iVar6 = FUN_1000b9f0((void *)((int)this + 0xea0),'\0');
  iVar4 = iVar6 + iVar4 + iVar5 * 2;
  if (param_1 == '\0') {
    iVar5 = FUN_1000f4b0();
    iVar4 = iVar4 + iVar5;
  }
  FUN_1000f4b0();
  *(undefined *)((int)this + 0x2be0) = 0;
  *(int *)((int)this + 0x2bdc) = *(int *)((int)this + 0x2bdc) + -1;
  if (*(int *)((int)this + 0x2bdc) == 0) {
    *pDVar1 = 0;
  }
  return iVar4;
}



uint __thiscall FUN_1000d970(void *this,uint param_1)

{
  uint uVar1;
  
  uVar1 = *(uint *)(*(int *)((int)this + 0xe90) + 0x20);
  if (uVar1 <= param_1) {
    return (uint)(param_1 - uVar1 >> 0x10 < *(uint *)(*(int *)((int)this + 0xe90) + 0x18));
  }
  return param_1 & 0xffffff00;
}



undefined4 __fastcall FUN_1000d9a0(int param_1)

{
  return *(undefined4 *)(param_1 + 0x2bd4);
}



void __thiscall FUN_1000d9b0(void *this,undefined4 param_1)

{
  FUN_1000ebf0(this,param_1);
  return;
}



int __cdecl FUN_1000d9c0(int *param_1,int *param_2)

{
  return (int)*(short *)(&DAT_102f2dc4 + *param_1 * 0x18) -
         (int)*(short *)(&DAT_102f2dc4 + *param_2 * 0x18);
}



int __cdecl FUN_1000d9f0(int *param_1,int *param_2)

{
  return (int)*(short *)(&DAT_10052d9c + *param_1 * 0x18) -
         (int)*(short *)(&DAT_10052d9c + *param_2 * 0x18);
}



int __cdecl FUN_1000da20(int *param_1,int *param_2)

{
  return (int)*(short *)(&DAT_10592dec + *param_1 * 0x18) -
         (int)*(short *)(&DAT_10592dec + *param_2 * 0x18);
}



undefined8 __thiscall FUN_1000da50(void *this,undefined4 *param_1)

{
  int iVar1;
  undefined4 uVar2;
  char cVar3;
  undefined4 uVar4;
  undefined8 uVar5;
  
  iVar1 = *(int *)((int)this + 4);
                    // WARNING: Load size is inaccurate
  uVar2 = *this;
  *param_1 = uVar2;
  uVar5 = ThreadInterlockedAssignIf64
                    ((longlong *)this,CONCAT44(iVar1 + 0x10001,param_1),uVar2,iVar1);
  uVar4 = (undefined4)((ulonglong)uVar5 >> 0x20);
  cVar3 = (char)uVar5;
  while (cVar3 == '\0') {
    iVar1 = *(int *)((int)this + 4);
                    // WARNING: Load size is inaccurate
    uVar2 = *this;
    *param_1 = uVar2;
    uVar5 = ThreadInterlockedAssignIf64
                      ((longlong *)this,CONCAT44(iVar1 + 0x10001,param_1),uVar2,iVar1);
    uVar4 = (undefined4)((ulonglong)uVar5 >> 0x20);
    cVar3 = (char)uVar5;
  }
  return CONCAT44(uVar4,uVar2);
}



uint ** __thiscall FUN_1000dab0(void *this,uint **param_1,uint **param_2)

{
  int iVar1;
  uint uVar2;
  void *pvVar3;
  uint **_Dst;
  uint **_Size;
  void *this_00;
  bool bVar4;
  
  iVar1 = *(int *)((int)this + 0xe90);
  if (param_2 == (uint **)0x0) {
    param_2 = (uint **)0x1;
  }
  uVar2 = (uint)((int)param_1 - *(int *)(iVar1 + 0x20)) >> 0xe;
  if (uVar2 < *(uint *)(iVar1 + 0x18)) {
    this_00 = *(void **)(iVar1 + 0x2c + uVar2 * 0x18);
  }
  else {
    this_00 = (void *)0x0;
  }
  if (param_2 < (uint **)0x801) {
    pvVar3 = *(void **)((int)this + ((int)param_2 - 1U & 0xfffffffc));
  }
  else {
    pvVar3 = (void *)0x0;
  }
  if (this_00 != pvVar3) {
    _Dst = (uint **)(**(code **)(*(int *)g_pMemAlloc + 4))(param_2);
    if ((_Dst == (uint **)0x0) &&
       (_Dst = FUN_1001edb0((uint *)(&DAT_10832ddc)[param_2 < (uint **)0x40000],(uint)param_2),
       _Dst == (uint **)0x0)) {
      bVar4 = param_2 < *(uint ***)((int)this_00 + 0x10);
      param_2 = _Dst;
      if (bVar4) {
        return param_1;
      }
    }
    else {
      _Size = *(uint ***)((int)this_00 + 0x10);
      if (param_2 < *(uint ***)((int)this_00 + 0x10)) {
        _Size = param_2;
      }
      FID_conflict__memcpy(_Dst,param_1,(size_t)_Size);
      param_2 = _Dst;
    }
    FUN_1000cde0(this_00,param_1);
    return param_2;
  }
  return param_1;
}



uint ** __thiscall FUN_1000db70(void *this,uint **param_1,uint **param_2)

{
  int iVar1;
  uint uVar2;
  void *pvVar3;
  uint **_Dst;
  uint **_Size;
  void *this_00;
  bool bVar4;
  
  iVar1 = *(int *)((int)this + 0xe90);
  if (param_2 == (uint **)0x0) {
    param_2 = (uint **)0x1;
  }
  uVar2 = (uint)((int)param_1 - *(int *)(iVar1 + 0x20)) >> 0xe;
  if (uVar2 < *(uint *)(iVar1 + 0x18)) {
    this_00 = *(void **)(iVar1 + 0x2c + uVar2 * 0x18);
  }
  else {
    this_00 = (void *)0x0;
  }
  if (param_2 < (uint **)0x801) {
    pvVar3 = *(void **)((int)this + ((int)param_2 - 1U & 0xfffffffc));
  }
  else {
    pvVar3 = (void *)0x0;
  }
  if (this_00 != pvVar3) {
    _Dst = (uint **)(**(code **)(*(int *)g_pMemAlloc + 4))(param_2);
    if ((_Dst == (uint **)0x0) &&
       (_Dst = FUN_1001edb0((uint *)(&DAT_10832ddc)[param_2 < (uint **)0x40000],(uint)param_2),
       _Dst == (uint **)0x0)) {
      bVar4 = param_2 < *(uint ***)((int)this_00 + 0x10);
      param_2 = _Dst;
      if (bVar4) {
        return param_1;
      }
    }
    else {
      _Size = *(uint ***)((int)this_00 + 0x10);
      if (param_2 < *(uint ***)((int)this_00 + 0x10)) {
        _Size = param_2;
      }
      FID_conflict__memcpy(_Dst,param_1,(size_t)_Size);
      param_2 = _Dst;
    }
    FUN_1000cea0(this_00,param_1);
    return param_2;
  }
  return param_1;
}



uint ** __thiscall FUN_1000dc30(void *this,uint **param_1,uint **param_2)

{
  int iVar1;
  uint uVar2;
  void *pvVar3;
  uint **_Dst;
  uint **_Size;
  void *this_00;
  bool bVar4;
  
  iVar1 = *(int *)((int)this + 0xe90);
  if (param_2 == (uint **)0x0) {
    param_2 = (uint **)0x1;
  }
  uVar2 = (uint)((int)param_1 - *(int *)(iVar1 + 0x20)) >> 0x10;
  if (uVar2 < *(uint *)(iVar1 + 0x18)) {
    this_00 = *(void **)(iVar1 + 0x2c + uVar2 * 0x18);
  }
  else {
    this_00 = (void *)0x0;
  }
  if (param_2 < (uint **)0x801) {
    pvVar3 = *(void **)((int)this + ((int)param_2 - 1U & 0xfffffffc));
  }
  else {
    pvVar3 = (void *)0x0;
  }
  if (this_00 != pvVar3) {
    _Dst = (uint **)(**(code **)(*(int *)g_pMemAlloc + 4))(param_2);
    if ((_Dst == (uint **)0x0) &&
       (_Dst = FUN_1001edb0((uint *)(&DAT_10832ddc)[param_2 < (uint **)0x40000],(uint)param_2),
       _Dst == (uint **)0x0)) {
      bVar4 = param_2 < *(uint ***)((int)this_00 + 0x10);
      param_2 = _Dst;
      if (bVar4) {
        return param_1;
      }
    }
    else {
      _Size = *(uint ***)((int)this_00 + 0x10);
      if (param_2 < *(uint ***)((int)this_00 + 0x10)) {
        _Size = param_2;
      }
      FID_conflict__memcpy(_Dst,param_1,(size_t)_Size);
      param_2 = _Dst;
    }
    FUN_1000cf60(this_00,param_1);
    return param_2;
  }
  return param_1;
}



uint ** __thiscall FUN_1000dcf0(void *this,uint **param_1,uint **param_2)

{
  uint **ppuVar1;
  
  if (param_1 == (uint **)0x0) {
                    // WARNING: Load size is inaccurate
    ppuVar1 = (uint **)(**(code **)(*this + 0x98))(0,param_2);
    return ppuVar1;
  }
  ppuVar1 = *(uint ***)(*(int *)((int)this + 0xe98) + 0x20);
  if ((ppuVar1 <= param_1) &&
     ((uint)((int)param_1 - (int)ppuVar1) >> 0xe < *(uint *)(*(int *)((int)this + 0xe98) + 0x18))) {
    ppuVar1 = FUN_1000db70((void *)((int)this + 8),param_1,param_2);
    return ppuVar1;
  }
  ppuVar1 = *(uint ***)(*(int *)((int)this + 0x1d30) + 0x20);
  if ((ppuVar1 <= param_1) &&
     ((uint)((int)param_1 - (int)ppuVar1) >> 0xe < *(uint *)(*(int *)((int)this + 0x1d30) + 0x18)))
  {
    ppuVar1 = FUN_1000dab0((void *)((int)this + 0xea0),param_1,param_2);
    return ppuVar1;
  }
  ppuVar1 = *(uint ***)(*(int *)((int)this + 0x2bc8) + 0x20);
  if ((ppuVar1 <= param_1) &&
     ((uint)((int)param_1 - (int)ppuVar1) >> 0x10 < *(uint *)(*(int *)((int)this + 0x2bc8) + 0x18)))
  {
    ppuVar1 = FUN_1000dc30((void *)((int)this + 0x1d38),param_1,param_2);
    return ppuVar1;
  }
  ppuVar1 = (uint **)FUN_1001e540((uint *)param_1,(uint)param_2);
  if (ppuVar1 == (uint **)0x0) {
                    // WARNING: Load size is inaccurate
    (**(code **)(*this + 0x78))();
    ppuVar1 = (uint **)FUN_1001e540((uint *)param_1,(uint)param_2);
    if (ppuVar1 == (uint **)0x0) {
      FUN_1000ebf0(this,param_2);
    }
  }
  return ppuVar1;
}



uint ** __thiscall FUN_1000ddf0(void *this,uint **param_1,uint **param_2)

{
  uint **ppuVar1;
  
  if (param_1 == (uint **)0x0) {
                    // WARNING: Load size is inaccurate
    ppuVar1 = (uint **)(**(code **)(*this + 0x98))(0,param_2);
    return ppuVar1;
  }
  ppuVar1 = *(uint ***)(*(int *)((int)this + 0xe98) + 0x20);
  if ((ppuVar1 <= param_1) &&
     ((uint)((int)param_1 - (int)ppuVar1) >> 0xe < *(uint *)(*(int *)((int)this + 0xe98) + 0x18))) {
    ppuVar1 = FUN_1000db70((void *)((int)this + 8),param_1,param_2);
    return ppuVar1;
  }
  ppuVar1 = *(uint ***)(*(int *)((int)this + 0x1d30) + 0x20);
  if ((ppuVar1 <= param_1) &&
     ((uint)((int)param_1 - (int)ppuVar1) >> 0xe < *(uint *)(*(int *)((int)this + 0x1d30) + 0x18)))
  {
    ppuVar1 = FUN_1000dab0((void *)((int)this + 0xea0),param_1,param_2);
    return ppuVar1;
  }
  ppuVar1 = *(uint ***)(*(int *)((int)this + 0x2bc8) + 0x20);
  if ((ppuVar1 <= param_1) &&
     ((uint)((int)param_1 - (int)ppuVar1) >> 0x10 < *(uint *)(*(int *)((int)this + 0x2bc8) + 0x18)))
  {
    ppuVar1 = FUN_1000dc30((void *)((int)this + 0x1d38),param_1,param_2);
    return ppuVar1;
  }
  ppuVar1 = (uint **)FUN_1001e540((uint *)param_1,(uint)param_2);
  if (ppuVar1 == (uint **)0x0) {
                    // WARNING: Load size is inaccurate
    (**(code **)(*this + 0x78))();
    ppuVar1 = (uint **)FUN_1001e540((uint *)param_1,(uint)param_2);
    if (ppuVar1 == (uint **)0x0) {
      FUN_1000ebf0(this,param_2);
    }
  }
  return ppuVar1;
}



uint ** __thiscall FUN_1000def0(void *this,undefined4 param_1,uint param_2)

{
  uint **ppuVar1;
  int iVar2;
  uint uVar3;
  
  if (param_2 < 0x801) {
    uVar3 = param_2;
    if (param_2 == 0) {
      uVar3 = 1;
    }
    ppuVar1 = (uint **)FUN_1000b100(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 8));
    if (ppuVar1 != (uint **)0x0) goto LAB_1000e077;
    uVar3 = param_2;
    if (param_2 == 0) {
      uVar3 = 1;
    }
    ppuVar1 = (uint **)FUN_1000ae50(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 0xea0));
    if (ppuVar1 != (uint **)0x0) goto LAB_1000e077;
    uVar3 = param_2;
    if (param_2 == 0) {
      uVar3 = 1;
    }
    ppuVar1 = (uint **)FUN_1000b3b0(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 0x1d38));
    if (ppuVar1 != (uint **)0x0) goto LAB_1000e077;
    (**(code **)((int)this + 0x2bd0))(param_2);
    iVar2 = FUN_1000d8b0(this,'\x01');
    if (iVar2 != 0) {
      uVar3 = param_2;
      if (param_2 == 0) {
        uVar3 = 1;
      }
      ppuVar1 = (uint **)FUN_1000b100(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 8));
      if (ppuVar1 != (uint **)0x0) goto LAB_1000e077;
      uVar3 = param_2;
      if (param_2 == 0) {
        uVar3 = 1;
      }
      ppuVar1 = (uint **)FUN_1000ae50(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 0xea0));
      if (ppuVar1 != (uint **)0x0) goto LAB_1000e077;
      uVar3 = param_2;
      if (param_2 == 0) {
        uVar3 = 1;
      }
      ppuVar1 = (uint **)FUN_1000b3b0(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 0x1d38))
      ;
      if (ppuVar1 != (uint **)0x0) goto LAB_1000e077;
      (**(code **)((int)this + 0x2bd0))(param_2);
    }
    if (DAT_108331e8 < 1) {
      DAT_108331e8 = DAT_108331e8 + 1;
      DevWarning("\n\nDRASTIC MEMORY OVERFLOW: Fell out of small block heap!\n\n\n");
    }
  }
  ppuVar1 = FUN_1001edb0((uint *)(&DAT_10832ddc)[param_2 < 0x40000],param_2);
  if (ppuVar1 == (uint **)0x0) {
                    // WARNING: Load size is inaccurate
    (**(code **)(*this + 0x78))();
    ppuVar1 = FUN_1001edb0((uint *)(&DAT_10832ddc)[param_2 < 0x40000],param_2);
    if (ppuVar1 == (uint **)0x0) {
      FUN_1000ebf0(this,param_2);
      return (uint **)0x0;
    }
  }
LAB_1000e077:
  if (DAT_10046638 != '\0') {
    FUN_10009a20(ppuVar1,param_2);
  }
  return ppuVar1;
}



uint ** __thiscall FUN_1000e0a0(void *this,undefined4 param_1,uint param_2)

{
  uint **ppuVar1;
  int iVar2;
  uint uVar3;
  
  if (param_2 < 0x801) {
    uVar3 = param_2;
    if (param_2 == 0) {
      uVar3 = 1;
    }
    ppuVar1 = (uint **)FUN_1000b100(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 8));
    if (ppuVar1 != (uint **)0x0) goto LAB_1000e227;
    uVar3 = param_2;
    if (param_2 == 0) {
      uVar3 = 1;
    }
    ppuVar1 = (uint **)FUN_1000ae50(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 0xea0));
    if (ppuVar1 != (uint **)0x0) goto LAB_1000e227;
    uVar3 = param_2;
    if (param_2 == 0) {
      uVar3 = 1;
    }
    ppuVar1 = (uint **)FUN_1000b3b0(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 0x1d38));
    if (ppuVar1 != (uint **)0x0) goto LAB_1000e227;
    (**(code **)((int)this + 0x2bd0))(param_2);
    iVar2 = FUN_1000d8b0(this,'\x01');
    if (iVar2 != 0) {
      uVar3 = param_2;
      if (param_2 == 0) {
        uVar3 = 1;
      }
      ppuVar1 = (uint **)FUN_1000b100(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 8));
      if (ppuVar1 != (uint **)0x0) goto LAB_1000e227;
      uVar3 = param_2;
      if (param_2 == 0) {
        uVar3 = 1;
      }
      ppuVar1 = (uint **)FUN_1000ae50(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 0xea0));
      if (ppuVar1 != (uint **)0x0) goto LAB_1000e227;
      uVar3 = param_2;
      if (param_2 == 0) {
        uVar3 = 1;
      }
      ppuVar1 = (uint **)FUN_1000b3b0(*(longlong **)((int)this + (uVar3 - 1 & 0xfffffffc) + 0x1d38))
      ;
      if (ppuVar1 != (uint **)0x0) goto LAB_1000e227;
      (**(code **)((int)this + 0x2bd0))(param_2);
    }
    if (DAT_108331e8 < 1) {
      DAT_108331e8 = DAT_108331e8 + 1;
      DevWarning("\n\nDRASTIC MEMORY OVERFLOW: Fell out of small block heap!\n\n\n");
    }
  }
  ppuVar1 = FUN_1001edb0((uint *)(&DAT_10832ddc)[param_2 < 0x40000],param_2);
  if (ppuVar1 == (uint **)0x0) {
                    // WARNING: Load size is inaccurate
    (**(code **)(*this + 0x78))();
    ppuVar1 = FUN_1001edb0((uint *)(&DAT_10832ddc)[param_2 < 0x40000],param_2);
    if (ppuVar1 == (uint **)0x0) {
      FUN_1000ebf0(this,param_2);
      return (uint **)0x0;
    }
  }
LAB_1000e227:
  if (DAT_10046638 != '\0') {
    FUN_10009a20(ppuVar1,param_2);
  }
  return ppuVar1;
}



void FUN_1000e250(void)

{
  return;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Unable to track spacebase fully for stack

uint __thiscall FUN_1000e260(void *this,int param_1,int param_2,char param_3)

{
  undefined4 uVar1;
  int iVar2;
  code *pcVar3;
  int iVar4;
  char cVar5;
  bool bVar6;
  undefined4 *puVar7;
  uint *puVar8;
  uint uVar9;
  longlong **pplVar10;
  longlong *plVar11;
  int iVar12;
  int iVar13;
  undefined *puVar14;
  uint *puVar15;
  ulonglong uVar16;
  undefined8 uVar17;
  longlong *aplStack68 [2];
  undefined8 uStack60;
  uint uStack52;
  code *pcStack48;
  undefined4 *puStack36;
  int local_20;
  longlong *local_1c;
  undefined4 *local_18;
  int local_14;
  uint *local_10;
  int local_c;
  uint local_8;
  
  pcStack48 = (code *)0x1000e27f;
  iVar4 = -(param_2 * 4 + 0xfU & 0xfffffff0);
  local_10 = (uint *)(&stack0xffffffd4 + iVar4);
  puVar15 = (uint *)(&stack0xffffffd4 + iVar4);
  local_8 = 0;
  uVar9 = 0;
  local_1c = (longlong *)this;
  puVar8 = (uint *)(&stack0xffffffd4 + iVar4);
  if (0 < param_2) {
    plVar11 = (longlong *)((int)this + 8);
    local_c = param_1 - (int)(&stack0xffffffd4 + iVar4);
    local_14 = param_2;
    do {
      iVar12 = local_c;
      iVar13 = local_14;
      *puVar15 = *(int *)(local_c + (int)puVar15) + 0x4000;
      if ((*(uint *)(iVar12 + (int)puVar15) <= *(uint *)plVar11) && (*(uint *)plVar11 < *puVar15)) {
        local_8 = (*puVar15 - *(uint *)plVar11) / *(uint *)(local_1c + 2);
        *(undefined4 *)(local_1c + 1) = 0;
        plVar11 = local_1c + 1;
        iVar13 = local_14;
      }
      puVar15 = puVar15 + 1;
      local_14 = iVar13 + -1;
      uVar9 = local_8;
      puVar8 = local_10;
    } while (local_14 != 0);
  }
  local_10 = puVar8;
  plVar11 = local_1c;
  local_8 = 0;
  local_14 = (int)(0x4000 / (ulonglong)*(uint *)(local_1c + 2)) * param_2 - uVar9;
  if ((param_3 == '\0') || (*(int *)((int)local_1c + 0x14) - param_2 == 1)) {
    puVar14 = &stack0xffffffd4 + iVar4;
    for (plVar11 = *(longlong **)local_1c; plVar11 != (longlong *)0x0;
        plVar11 = *(longlong **)plVar11) {
      if (local_8 == local_14) goto LAB_1000e4a6;
      iVar13 = 0;
      if (0 < param_2) {
        pplVar10 = (longlong **)(&stack0xffffffd4 + iVar4);
        do {
          if ((*(longlong **)((int)pplVar10 + (param_1 - (int)(&stack0xffffffd4 + iVar4))) <=
               plVar11) && (plVar11 < *pplVar10)) {
            local_8 = local_8 + 1;
            *(undefined4 *)local_1c = *(undefined4 *)plVar11;
            goto LAB_1000e55e;
          }
          iVar13 = iVar13 + 1;
          pplVar10 = pplVar10 + 1;
        } while (iVar13 < param_2);
      }
      *(longlong **)local_1c = plVar11;
      local_1c = plVar11;
LAB_1000e55e:
      puVar14 = &stack0xffffffd4 + iVar4;
    }
  }
  else {
    local_20 = DAT_102f2da8;
    *(undefined4 *)((int)&uStack52 + iVar4 + 4) = 0x1000e327;
    uVar16 = FUN_1000c560(plVar11,0);
    puVar7 = (undefined4 *)uVar16;
    iVar13 = *(int *)((int)plVar11 + 0x14);
    local_c = 0;
    *(undefined4 *)((int)&uStack52 + iVar4 + 4) = 0x1000e342;
    iVar13 = -(iVar13 * 4 + 0xfU & 0xfffffff0);
    if (puVar7 != (undefined4 *)0x0) {
      do {
        puStack36 = (undefined4 *)*puVar7;
        iVar12 = 0;
        if (0 < param_2) {
          puVar8 = local_10;
          do {
            if ((*(undefined4 **)((int)puVar8 + (param_1 - (int)local_10)) <= puVar7) &&
               (puVar7 < (undefined4 *)*puVar8)) {
              local_8 = local_8 + 1;
              goto LAB_1000e403;
            }
            iVar12 = iVar12 + 1;
            puVar8 = puVar8 + 1;
          } while (iVar12 < param_2);
        }
        iVar12 = (int)(((int)puVar7 - local_20) + ((int)puVar7 - local_20 >> 0x1f & 0x3fffU)) >> 0xe
        ;
        if (*(short *)(&DAT_102f2dc4 + iVar12 * 0x18) == 0) {
          *(int *)(&stack0xffffffd4 + local_c * 4 + iVar13 + iVar4) = iVar12;
          local_c = local_c + 1;
        }
        uVar1 = *(undefined4 *)(&DAT_102f2dc0 + iVar12 * 0x18);
        local_18 = (undefined4 *)(&DAT_102f2dc0 + iVar12 * 0x18);
        iVar12 = *(int *)(&DAT_102f2dc4 + iVar12 * 0x18);
        *(int *)((int)&uStack52 + iVar13 + iVar4 + 4) = iVar12;
        *(undefined4 *)((int)&uStack52 + iVar13 + iVar4) = uVar1;
        *puVar7 = uVar1;
        *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar12 + 0x10001;
        *(undefined4 **)((int)&uStack60 + iVar13 + iVar4) = puVar7;
        *(undefined4 **)((int)aplStack68 + iVar13 + iVar4 + 4) = local_18;
        *(undefined4 *)((int)aplStack68 + iVar13 + iVar4) = 0x1000e3d1;
        uVar17 = ThreadInterlockedAssignIf64
                           (*(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4),
                            *(longlong *)((int)&uStack60 + iVar13 + iVar4),
                            *(undefined4 *)((int)&uStack52 + iVar13 + iVar4),
                            *(undefined4 *)((int)&uStack52 + iVar13 + iVar4 + 4));
        cVar5 = (char)uVar17;
        while (cVar5 == '\0') {
          iVar12 = local_18[1];
          uVar1 = *local_18;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + 4) = iVar12;
          *(undefined4 *)((int)&uStack52 + iVar13 + iVar4) = uVar1;
          *puVar7 = uVar1;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar12 + 0x10001;
          *(undefined4 **)((int)&uStack60 + iVar13 + iVar4) = puVar7;
          *(undefined4 **)((int)aplStack68 + iVar13 + iVar4 + 4) = local_18;
          *(undefined4 *)((int)aplStack68 + iVar13 + iVar4) = 0x1000e3f9;
          uVar17 = ThreadInterlockedAssignIf64
                             (*(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4),
                              *(longlong *)((int)&uStack60 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4 + 4));
          cVar5 = (char)uVar17;
        }
LAB_1000e403:
        iVar12 = local_c;
        puVar7 = puStack36;
      } while (puStack36 != (undefined4 *)0x0);
      if (1 < local_c) {
        *(code **)((int)&uStack52 + iVar13 + iVar4 + 4) = FUN_1000d9c0;
        *(undefined4 *)((int)&uStack52 + iVar13 + iVar4) = 4;
        *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar12;
        *(undefined **)((int)&uStack60 + iVar13 + iVar4) = &stack0xffffffd4 + iVar13 + iVar4;
        *(undefined4 *)((int)aplStack68 + iVar13 + iVar4 + 4) = 0x1000e428;
        FUN_100222d0(*(undefined **)((int)&uStack60 + iVar13 + iVar4),
                     *(uint *)((int)&uStack52 + iVar13 + iVar4 + -4),
                     *(uint *)((int)&uStack52 + iVar13 + iVar4),
                     *(undefined **)((int)&uStack52 + iVar13 + iVar4 + 4));
      }
    }
    param_2 = 0;
    puVar14 = &stack0xffffffd4 + iVar13 + iVar4 + -0x2c + 0x2c;
    if (0 < local_c) {
LAB_1000e440:
      do {
        puVar7 = *(undefined4 **)
                  (&DAT_102f2dc0 + *(int *)(&stack0xffffffd4 + param_2 * 4 + iVar13 + iVar4) * 0x18)
        ;
        iVar12 = *(int *)(&stack0xffffffd4 + param_2 * 4 + iVar13 + iVar4) * 0x18;
        iVar2 = *(int *)(&DAT_102f2dc4 + iVar12);
        while( true ) {
          if (puVar7 == (undefined4 *)0x0) goto LAB_1000e480;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + 4) = iVar2;
          *(undefined4 **)((int)&uStack52 + iVar13 + iVar4) = puVar7;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar2 + -1;
          *(undefined4 *)((int)&uStack60 + iVar13 + iVar4) = *puVar7;
          *(undefined **)((int)aplStack68 + iVar13 + iVar4 + 4) = &DAT_102f2dc0 + iVar12;
          *(undefined4 *)((int)aplStack68 + iVar13 + iVar4) = 0x1000e46e;
          plVar11 = local_1c;
          uVar17 = ThreadInterlockedAssignIf64
                             (*(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4),
                              *(longlong *)((int)&uStack60 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4 + 4));
          if ((char)uVar17 != '\0') break;
          puVar7 = *(undefined4 **)(&DAT_102f2dc0 + iVar12);
          iVar2 = *(int *)(&DAT_102f2dc4 + iVar12);
        }
        iVar12 = *(int *)((int)local_1c + 4);
        uVar1 = *(undefined4 *)local_1c;
        *(int *)((int)&uStack52 + iVar13 + iVar4 + 4) = iVar12;
        *(undefined4 *)((int)&uStack52 + iVar13 + iVar4) = uVar1;
        *puVar7 = uVar1;
        *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar12 + 0x10001;
        *(undefined4 **)((int)&uStack60 + iVar13 + iVar4) = puVar7;
        *(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4) = plVar11;
        *(undefined4 *)((int)aplStack68 + iVar13 + iVar4) = 0x1000e4db;
        uVar17 = ThreadInterlockedAssignIf64
                           (*(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4),
                            *(longlong *)((int)&uStack60 + iVar13 + iVar4),
                            *(undefined4 *)((int)&uStack52 + iVar13 + iVar4),
                            *(undefined4 *)((int)&uStack52 + iVar13 + iVar4 + 4));
        cVar5 = (char)uVar17;
        while (cVar5 == '\0') {
          iVar12 = *(int *)((int)plVar11 + 4);
          uVar1 = *(undefined4 *)plVar11;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + 4) = iVar12;
          *(undefined4 *)((int)&uStack52 + iVar13 + iVar4) = uVar1;
          *puVar7 = uVar1;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar12 + 0x10001;
          *(undefined4 **)((int)&uStack60 + iVar13 + iVar4) = puVar7;
          *(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4) = plVar11;
          *(undefined4 *)((int)aplStack68 + iVar13 + iVar4) = 0x1000e509;
          uVar17 = ThreadInterlockedAssignIf64
                             (*(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4),
                              *(longlong *)((int)&uStack60 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4 + 4));
          cVar5 = (char)uVar17;
        }
      } while( true );
    }
  }
LAB_1000e495:
  if (local_14 != local_8) {
    *(undefined4 *)(puVar14 + -4) = 0x1000e49e;
    bVar6 = Plat_IsInDebugSession();
    if (bVar6) {
      pcVar3 = (code *)swi(3);
      uVar9 = (*pcVar3)();
      return uVar9;
    }
  }
LAB_1000e4a6:
  return (uint)(local_14 == local_8);
LAB_1000e480:
  param_2 = param_2 + 1;
  puVar14 = &stack0xffffffd4 + iVar13 + iVar4 + -0x2c + 0x2c;
  if (local_c <= param_2) goto LAB_1000e495;
  goto LAB_1000e440;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Unable to track spacebase fully for stack

uint __thiscall FUN_1000e580(void *this,int param_1,int param_2,char param_3)

{
  undefined4 uVar1;
  int iVar2;
  code *pcVar3;
  int iVar4;
  char cVar5;
  bool bVar6;
  undefined4 *puVar7;
  uint *puVar8;
  uint uVar9;
  longlong **pplVar10;
  longlong *plVar11;
  int iVar12;
  int iVar13;
  undefined *puVar14;
  uint *puVar15;
  ulonglong uVar16;
  undefined8 uVar17;
  longlong *aplStack68 [2];
  undefined8 uStack60;
  uint uStack52;
  code *pcStack48;
  undefined4 *puStack36;
  int local_20;
  longlong *local_1c;
  undefined4 *local_18;
  int local_14;
  uint *local_10;
  int local_c;
  uint local_8;
  
  pcStack48 = (code *)0x1000e59f;
  iVar4 = -(param_2 * 4 + 0xfU & 0xfffffff0);
  local_10 = (uint *)(&stack0xffffffd4 + iVar4);
  puVar15 = (uint *)(&stack0xffffffd4 + iVar4);
  local_8 = 0;
  uVar9 = 0;
  local_1c = (longlong *)this;
  puVar8 = (uint *)(&stack0xffffffd4 + iVar4);
  if (0 < param_2) {
    plVar11 = (longlong *)((int)this + 8);
    local_c = param_1 - (int)(&stack0xffffffd4 + iVar4);
    local_14 = param_2;
    do {
      iVar12 = local_c;
      iVar13 = local_14;
      *puVar15 = *(int *)(local_c + (int)puVar15) + 0x4000;
      if ((*(uint *)(iVar12 + (int)puVar15) <= *(uint *)plVar11) && (*(uint *)plVar11 < *puVar15)) {
        local_8 = (*puVar15 - *(uint *)plVar11) / *(uint *)(local_1c + 2);
        *(undefined4 *)(local_1c + 1) = 0;
        plVar11 = local_1c + 1;
        iVar13 = local_14;
      }
      puVar15 = puVar15 + 1;
      local_14 = iVar13 + -1;
      uVar9 = local_8;
      puVar8 = local_10;
    } while (local_14 != 0);
  }
  local_10 = puVar8;
  plVar11 = local_1c;
  local_8 = 0;
  local_14 = (int)(0x4000 / (ulonglong)*(uint *)(local_1c + 2)) * param_2 - uVar9;
  if ((param_3 == '\0') || (*(int *)((int)local_1c + 0x14) - param_2 == 1)) {
    puVar14 = &stack0xffffffd4 + iVar4;
    for (plVar11 = *(longlong **)local_1c; plVar11 != (longlong *)0x0;
        plVar11 = *(longlong **)plVar11) {
      if (local_8 == local_14) goto LAB_1000e7c6;
      iVar13 = 0;
      if (0 < param_2) {
        pplVar10 = (longlong **)(&stack0xffffffd4 + iVar4);
        do {
          if ((*(longlong **)((int)pplVar10 + (param_1 - (int)(&stack0xffffffd4 + iVar4))) <=
               plVar11) && (plVar11 < *pplVar10)) {
            local_8 = local_8 + 1;
            *(undefined4 *)local_1c = *(undefined4 *)plVar11;
            goto LAB_1000e87e;
          }
          iVar13 = iVar13 + 1;
          pplVar10 = pplVar10 + 1;
        } while (iVar13 < param_2);
      }
      *(longlong **)local_1c = plVar11;
      local_1c = plVar11;
LAB_1000e87e:
      puVar14 = &stack0xffffffd4 + iVar4;
    }
  }
  else {
    local_20 = DAT_10052d80;
    *(undefined4 *)((int)&uStack52 + iVar4 + 4) = 0x1000e647;
    uVar16 = FUN_1000c560(plVar11,0);
    puVar7 = (undefined4 *)uVar16;
    iVar13 = *(int *)((int)plVar11 + 0x14);
    local_c = 0;
    *(undefined4 *)((int)&uStack52 + iVar4 + 4) = 0x1000e662;
    iVar13 = -(iVar13 * 4 + 0xfU & 0xfffffff0);
    if (puVar7 != (undefined4 *)0x0) {
      do {
        puStack36 = (undefined4 *)*puVar7;
        iVar12 = 0;
        if (0 < param_2) {
          puVar8 = local_10;
          do {
            if ((*(undefined4 **)((int)puVar8 + (param_1 - (int)local_10)) <= puVar7) &&
               (puVar7 < (undefined4 *)*puVar8)) {
              local_8 = local_8 + 1;
              goto LAB_1000e723;
            }
            iVar12 = iVar12 + 1;
            puVar8 = puVar8 + 1;
          } while (iVar12 < param_2);
        }
        iVar12 = (int)(((int)puVar7 - local_20) + ((int)puVar7 - local_20 >> 0x1f & 0x3fffU)) >> 0xe
        ;
        if (*(short *)(&DAT_10052d9c + iVar12 * 0x18) == 0) {
          *(int *)(&stack0xffffffd4 + local_c * 4 + iVar13 + iVar4) = iVar12;
          local_c = local_c + 1;
        }
        uVar1 = *(undefined4 *)(&DAT_10052d98 + iVar12 * 0x18);
        local_18 = (undefined4 *)(&DAT_10052d98 + iVar12 * 0x18);
        iVar12 = *(int *)(&DAT_10052d9c + iVar12 * 0x18);
        *(int *)((int)&uStack52 + iVar13 + iVar4 + 4) = iVar12;
        *(undefined4 *)((int)&uStack52 + iVar13 + iVar4) = uVar1;
        *puVar7 = uVar1;
        *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar12 + 0x10001;
        *(undefined4 **)((int)&uStack60 + iVar13 + iVar4) = puVar7;
        *(undefined4 **)((int)aplStack68 + iVar13 + iVar4 + 4) = local_18;
        *(undefined4 *)((int)aplStack68 + iVar13 + iVar4) = 0x1000e6f1;
        uVar17 = ThreadInterlockedAssignIf64
                           (*(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4),
                            *(longlong *)((int)&uStack60 + iVar13 + iVar4),
                            *(undefined4 *)((int)&uStack52 + iVar13 + iVar4),
                            *(undefined4 *)((int)&uStack52 + iVar13 + iVar4 + 4));
        cVar5 = (char)uVar17;
        while (cVar5 == '\0') {
          iVar12 = local_18[1];
          uVar1 = *local_18;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + 4) = iVar12;
          *(undefined4 *)((int)&uStack52 + iVar13 + iVar4) = uVar1;
          *puVar7 = uVar1;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar12 + 0x10001;
          *(undefined4 **)((int)&uStack60 + iVar13 + iVar4) = puVar7;
          *(undefined4 **)((int)aplStack68 + iVar13 + iVar4 + 4) = local_18;
          *(undefined4 *)((int)aplStack68 + iVar13 + iVar4) = 0x1000e719;
          uVar17 = ThreadInterlockedAssignIf64
                             (*(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4),
                              *(longlong *)((int)&uStack60 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4 + 4));
          cVar5 = (char)uVar17;
        }
LAB_1000e723:
        iVar12 = local_c;
        puVar7 = puStack36;
      } while (puStack36 != (undefined4 *)0x0);
      if (1 < local_c) {
        *(code **)((int)&uStack52 + iVar13 + iVar4 + 4) = FUN_1000d9f0;
        *(undefined4 *)((int)&uStack52 + iVar13 + iVar4) = 4;
        *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar12;
        *(undefined **)((int)&uStack60 + iVar13 + iVar4) = &stack0xffffffd4 + iVar13 + iVar4;
        *(undefined4 *)((int)aplStack68 + iVar13 + iVar4 + 4) = 0x1000e748;
        FUN_100222d0(*(undefined **)((int)&uStack60 + iVar13 + iVar4),
                     *(uint *)((int)&uStack52 + iVar13 + iVar4 + -4),
                     *(uint *)((int)&uStack52 + iVar13 + iVar4),
                     *(undefined **)((int)&uStack52 + iVar13 + iVar4 + 4));
      }
    }
    param_2 = 0;
    puVar14 = &stack0xffffffd4 + iVar13 + iVar4 + -0x2c + 0x2c;
    if (0 < local_c) {
LAB_1000e760:
      do {
        puVar7 = *(undefined4 **)
                  (&DAT_10052d98 + *(int *)(&stack0xffffffd4 + param_2 * 4 + iVar13 + iVar4) * 0x18)
        ;
        iVar12 = *(int *)(&stack0xffffffd4 + param_2 * 4 + iVar13 + iVar4) * 0x18;
        iVar2 = *(int *)(&DAT_10052d9c + iVar12);
        while( true ) {
          if (puVar7 == (undefined4 *)0x0) goto LAB_1000e7a0;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + 4) = iVar2;
          *(undefined4 **)((int)&uStack52 + iVar13 + iVar4) = puVar7;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar2 + -1;
          *(undefined4 *)((int)&uStack60 + iVar13 + iVar4) = *puVar7;
          *(undefined **)((int)aplStack68 + iVar13 + iVar4 + 4) = &DAT_10052d98 + iVar12;
          *(undefined4 *)((int)aplStack68 + iVar13 + iVar4) = 0x1000e78e;
          plVar11 = local_1c;
          uVar17 = ThreadInterlockedAssignIf64
                             (*(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4),
                              *(longlong *)((int)&uStack60 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4 + 4));
          if ((char)uVar17 != '\0') break;
          puVar7 = *(undefined4 **)(&DAT_10052d98 + iVar12);
          iVar2 = *(int *)(&DAT_10052d9c + iVar12);
        }
        iVar12 = *(int *)((int)local_1c + 4);
        uVar1 = *(undefined4 *)local_1c;
        *(int *)((int)&uStack52 + iVar13 + iVar4 + 4) = iVar12;
        *(undefined4 *)((int)&uStack52 + iVar13 + iVar4) = uVar1;
        *puVar7 = uVar1;
        *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar12 + 0x10001;
        *(undefined4 **)((int)&uStack60 + iVar13 + iVar4) = puVar7;
        *(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4) = plVar11;
        *(undefined4 *)((int)aplStack68 + iVar13 + iVar4) = 0x1000e7fb;
        uVar17 = ThreadInterlockedAssignIf64
                           (*(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4),
                            *(longlong *)((int)&uStack60 + iVar13 + iVar4),
                            *(undefined4 *)((int)&uStack52 + iVar13 + iVar4),
                            *(undefined4 *)((int)&uStack52 + iVar13 + iVar4 + 4));
        cVar5 = (char)uVar17;
        while (cVar5 == '\0') {
          iVar12 = *(int *)((int)plVar11 + 4);
          uVar1 = *(undefined4 *)plVar11;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + 4) = iVar12;
          *(undefined4 *)((int)&uStack52 + iVar13 + iVar4) = uVar1;
          *puVar7 = uVar1;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar12 + 0x10001;
          *(undefined4 **)((int)&uStack60 + iVar13 + iVar4) = puVar7;
          *(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4) = plVar11;
          *(undefined4 *)((int)aplStack68 + iVar13 + iVar4) = 0x1000e829;
          uVar17 = ThreadInterlockedAssignIf64
                             (*(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4),
                              *(longlong *)((int)&uStack60 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4 + 4));
          cVar5 = (char)uVar17;
        }
      } while( true );
    }
  }
LAB_1000e7b5:
  if (local_14 != local_8) {
    *(undefined4 *)(puVar14 + -4) = 0x1000e7be;
    bVar6 = Plat_IsInDebugSession();
    if (bVar6) {
      pcVar3 = (code *)swi(3);
      uVar9 = (*pcVar3)();
      return uVar9;
    }
  }
LAB_1000e7c6:
  return (uint)(local_14 == local_8);
LAB_1000e7a0:
  param_2 = param_2 + 1;
  puVar14 = &stack0xffffffd4 + iVar13 + iVar4 + -0x2c + 0x2c;
  if (local_c <= param_2) goto LAB_1000e7b5;
  goto LAB_1000e760;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Unable to track spacebase fully for stack

uint __thiscall FUN_1000e8a0(void *this,int param_1,int param_2,char param_3)

{
  undefined4 uVar1;
  int iVar2;
  code *pcVar3;
  int iVar4;
  char cVar5;
  bool bVar6;
  undefined4 *puVar7;
  uint *puVar8;
  uint uVar9;
  longlong **pplVar10;
  longlong *plVar11;
  int iVar12;
  int iVar13;
  undefined *puVar14;
  uint *puVar15;
  ulonglong uVar16;
  undefined8 uVar17;
  longlong *aplStack68 [2];
  undefined8 uStack60;
  uint uStack52;
  code *pcStack48;
  undefined4 *puStack36;
  int local_20;
  longlong *local_1c;
  undefined4 *local_18;
  int local_14;
  uint *local_10;
  int local_c;
  uint local_8;
  
  pcStack48 = (code *)0x1000e8bf;
  iVar4 = -(param_2 * 4 + 0xfU & 0xfffffff0);
  local_10 = (uint *)(&stack0xffffffd4 + iVar4);
  puVar15 = (uint *)(&stack0xffffffd4 + iVar4);
  local_8 = 0;
  uVar9 = 0;
  local_1c = (longlong *)this;
  puVar8 = (uint *)(&stack0xffffffd4 + iVar4);
  if (0 < param_2) {
    plVar11 = (longlong *)((int)this + 8);
    local_c = param_1 - (int)(&stack0xffffffd4 + iVar4);
    local_14 = param_2;
    do {
      iVar12 = local_c;
      iVar13 = local_14;
      *puVar15 = *(int *)(local_c + (int)puVar15) + 0x10000;
      if ((*(uint *)(iVar12 + (int)puVar15) <= *(uint *)plVar11) && (*(uint *)plVar11 < *puVar15)) {
        local_8 = (*puVar15 - *(uint *)plVar11) / *(uint *)(local_1c + 2);
        *(undefined4 *)(local_1c + 1) = 0;
        plVar11 = local_1c + 1;
        iVar13 = local_14;
      }
      puVar15 = puVar15 + 1;
      local_14 = iVar13 + -1;
      uVar9 = local_8;
      puVar8 = local_10;
    } while (local_14 != 0);
  }
  local_10 = puVar8;
  plVar11 = local_1c;
  local_8 = 0;
  local_14 = (int)(0x10000 / (ulonglong)*(uint *)(local_1c + 2)) * param_2 - uVar9;
  if ((param_3 == '\0') || (*(int *)((int)local_1c + 0x14) - param_2 == 1)) {
    puVar14 = &stack0xffffffd4 + iVar4;
    for (plVar11 = *(longlong **)local_1c; plVar11 != (longlong *)0x0;
        plVar11 = *(longlong **)plVar11) {
      if (local_8 == local_14) goto LAB_1000eae6;
      iVar13 = 0;
      if (0 < param_2) {
        pplVar10 = (longlong **)(&stack0xffffffd4 + iVar4);
        do {
          if ((*(longlong **)((int)pplVar10 + (param_1 - (int)(&stack0xffffffd4 + iVar4))) <=
               plVar11) && (plVar11 < *pplVar10)) {
            local_8 = local_8 + 1;
            *(undefined4 *)local_1c = *(undefined4 *)plVar11;
            goto LAB_1000eb9e;
          }
          iVar13 = iVar13 + 1;
          pplVar10 = pplVar10 + 1;
        } while (iVar13 < param_2);
      }
      *(longlong **)local_1c = plVar11;
      local_1c = plVar11;
LAB_1000eb9e:
      puVar14 = &stack0xffffffd4 + iVar4;
    }
  }
  else {
    local_20 = DAT_10592dd0;
    *(undefined4 *)((int)&uStack52 + iVar4 + 4) = 0x1000e967;
    uVar16 = FUN_1000c560(plVar11,0);
    puVar7 = (undefined4 *)uVar16;
    iVar13 = *(int *)((int)plVar11 + 0x14);
    local_c = 0;
    *(undefined4 *)((int)&uStack52 + iVar4 + 4) = 0x1000e982;
    iVar13 = -(iVar13 * 4 + 0xfU & 0xfffffff0);
    if (puVar7 != (undefined4 *)0x0) {
      do {
        puStack36 = (undefined4 *)*puVar7;
        iVar12 = 0;
        if (0 < param_2) {
          puVar8 = local_10;
          do {
            if ((*(undefined4 **)((int)puVar8 + (param_1 - (int)local_10)) <= puVar7) &&
               (puVar7 < (undefined4 *)*puVar8)) {
              local_8 = local_8 + 1;
              goto LAB_1000ea43;
            }
            iVar12 = iVar12 + 1;
            puVar8 = puVar8 + 1;
          } while (iVar12 < param_2);
        }
        iVar12 = (int)(((int)puVar7 - local_20) + ((int)puVar7 - local_20 >> 0x1f & 0xffffU)) >>
                 0x10;
        if (*(short *)(&DAT_10592dec + iVar12 * 0x18) == 0) {
          *(int *)(&stack0xffffffd4 + local_c * 4 + iVar13 + iVar4) = iVar12;
          local_c = local_c + 1;
        }
        uVar1 = *(undefined4 *)(&DAT_10592de8 + iVar12 * 0x18);
        local_18 = (undefined4 *)(&DAT_10592de8 + iVar12 * 0x18);
        iVar12 = *(int *)(&DAT_10592dec + iVar12 * 0x18);
        *(int *)((int)&uStack52 + iVar13 + iVar4 + 4) = iVar12;
        *(undefined4 *)((int)&uStack52 + iVar13 + iVar4) = uVar1;
        *puVar7 = uVar1;
        *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar12 + 0x10001;
        *(undefined4 **)((int)&uStack60 + iVar13 + iVar4) = puVar7;
        *(undefined4 **)((int)aplStack68 + iVar13 + iVar4 + 4) = local_18;
        *(undefined4 *)((int)aplStack68 + iVar13 + iVar4) = 0x1000ea11;
        uVar17 = ThreadInterlockedAssignIf64
                           (*(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4),
                            *(longlong *)((int)&uStack60 + iVar13 + iVar4),
                            *(undefined4 *)((int)&uStack52 + iVar13 + iVar4),
                            *(undefined4 *)((int)&uStack52 + iVar13 + iVar4 + 4));
        cVar5 = (char)uVar17;
        while (cVar5 == '\0') {
          iVar12 = local_18[1];
          uVar1 = *local_18;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + 4) = iVar12;
          *(undefined4 *)((int)&uStack52 + iVar13 + iVar4) = uVar1;
          *puVar7 = uVar1;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar12 + 0x10001;
          *(undefined4 **)((int)&uStack60 + iVar13 + iVar4) = puVar7;
          *(undefined4 **)((int)aplStack68 + iVar13 + iVar4 + 4) = local_18;
          *(undefined4 *)((int)aplStack68 + iVar13 + iVar4) = 0x1000ea39;
          uVar17 = ThreadInterlockedAssignIf64
                             (*(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4),
                              *(longlong *)((int)&uStack60 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4 + 4));
          cVar5 = (char)uVar17;
        }
LAB_1000ea43:
        iVar12 = local_c;
        puVar7 = puStack36;
      } while (puStack36 != (undefined4 *)0x0);
      if (1 < local_c) {
        *(code **)((int)&uStack52 + iVar13 + iVar4 + 4) = FUN_1000da20;
        *(undefined4 *)((int)&uStack52 + iVar13 + iVar4) = 4;
        *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar12;
        *(undefined **)((int)&uStack60 + iVar13 + iVar4) = &stack0xffffffd4 + iVar13 + iVar4;
        *(undefined4 *)((int)aplStack68 + iVar13 + iVar4 + 4) = 0x1000ea68;
        FUN_100222d0(*(undefined **)((int)&uStack60 + iVar13 + iVar4),
                     *(uint *)((int)&uStack52 + iVar13 + iVar4 + -4),
                     *(uint *)((int)&uStack52 + iVar13 + iVar4),
                     *(undefined **)((int)&uStack52 + iVar13 + iVar4 + 4));
      }
    }
    param_2 = 0;
    puVar14 = &stack0xffffffd4 + iVar13 + iVar4 + -0x2c + 0x2c;
    if (0 < local_c) {
LAB_1000ea80:
      do {
        puVar7 = *(undefined4 **)
                  (&DAT_10592de8 + *(int *)(&stack0xffffffd4 + param_2 * 4 + iVar13 + iVar4) * 0x18)
        ;
        iVar12 = *(int *)(&stack0xffffffd4 + param_2 * 4 + iVar13 + iVar4) * 0x18;
        iVar2 = *(int *)(&DAT_10592dec + iVar12);
        while( true ) {
          if (puVar7 == (undefined4 *)0x0) goto LAB_1000eac0;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + 4) = iVar2;
          *(undefined4 **)((int)&uStack52 + iVar13 + iVar4) = puVar7;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar2 + -1;
          *(undefined4 *)((int)&uStack60 + iVar13 + iVar4) = *puVar7;
          *(undefined **)((int)aplStack68 + iVar13 + iVar4 + 4) = &DAT_10592de8 + iVar12;
          *(undefined4 *)((int)aplStack68 + iVar13 + iVar4) = 0x1000eaae;
          plVar11 = local_1c;
          uVar17 = ThreadInterlockedAssignIf64
                             (*(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4),
                              *(longlong *)((int)&uStack60 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4 + 4));
          if ((char)uVar17 != '\0') break;
          puVar7 = *(undefined4 **)(&DAT_10592de8 + iVar12);
          iVar2 = *(int *)(&DAT_10592dec + iVar12);
        }
        iVar12 = *(int *)((int)local_1c + 4);
        uVar1 = *(undefined4 *)local_1c;
        *(int *)((int)&uStack52 + iVar13 + iVar4 + 4) = iVar12;
        *(undefined4 *)((int)&uStack52 + iVar13 + iVar4) = uVar1;
        *puVar7 = uVar1;
        *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar12 + 0x10001;
        *(undefined4 **)((int)&uStack60 + iVar13 + iVar4) = puVar7;
        *(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4) = plVar11;
        *(undefined4 *)((int)aplStack68 + iVar13 + iVar4) = 0x1000eb1b;
        uVar17 = ThreadInterlockedAssignIf64
                           (*(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4),
                            *(longlong *)((int)&uStack60 + iVar13 + iVar4),
                            *(undefined4 *)((int)&uStack52 + iVar13 + iVar4),
                            *(undefined4 *)((int)&uStack52 + iVar13 + iVar4 + 4));
        cVar5 = (char)uVar17;
        while (cVar5 == '\0') {
          iVar12 = *(int *)((int)plVar11 + 4);
          uVar1 = *(undefined4 *)plVar11;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + 4) = iVar12;
          *(undefined4 *)((int)&uStack52 + iVar13 + iVar4) = uVar1;
          *puVar7 = uVar1;
          *(int *)((int)&uStack52 + iVar13 + iVar4 + -4) = iVar12 + 0x10001;
          *(undefined4 **)((int)&uStack60 + iVar13 + iVar4) = puVar7;
          *(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4) = plVar11;
          *(undefined4 *)((int)aplStack68 + iVar13 + iVar4) = 0x1000eb49;
          uVar17 = ThreadInterlockedAssignIf64
                             (*(longlong **)((int)aplStack68 + iVar13 + iVar4 + 4),
                              *(longlong *)((int)&uStack60 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4),
                              *(undefined4 *)((int)&uStack52 + iVar13 + iVar4 + 4));
          cVar5 = (char)uVar17;
        }
      } while( true );
    }
  }
LAB_1000ead5:
  if (local_14 != local_8) {
    *(undefined4 *)(puVar14 + -4) = 0x1000eade;
    bVar6 = Plat_IsInDebugSession();
    if (bVar6) {
      pcVar3 = (code *)swi(3);
      uVar9 = (*pcVar3)();
      return uVar9;
    }
  }
LAB_1000eae6:
  return (uint)(local_14 == local_8);
LAB_1000eac0:
  param_2 = param_2 + 1;
  puVar14 = &stack0xffffffd4 + iVar13 + iVar4 + -0x2c + 0x2c;
  if (local_c <= param_2) goto LAB_1000ead5;
  goto LAB_1000ea80;
}



undefined4 __thiscall FUN_1000ebc0(void *this,undefined4 param_1)

{
  undefined4 uVar1;
  
  uVar1 = *(undefined4 *)((int)this + 0x2bd0);
  *(undefined4 *)((int)this + 0x2bd0) = param_1;
  return uVar1;
}



void __cdecl FUN_1000ebe0(undefined *param_1)

{
  g_pMemAlloc = param_1;
  return;
}



void __thiscall FUN_1000ebf0(void *this,undefined4 param_1)

{
  code *pcVar1;
  bool bVar2;
  char local_104 [256];
  
  *(undefined4 *)((int)this + 0x2bd4) = param_1;
  bVar2 = Plat_IsInDebugSession();
  if (bVar2) {
    pcVar1 = (code *)swi(3);
    (*pcVar1)();
    return;
  }
  FUN_1002169d(local_104,0x100,(byte *)"***** OUT OF MEMORY! attempted allocation size: %u ****\n");
  OutputDebugStringA(local_104);
  bVar2 = Plat_IsInDebugSession();
  if (bVar2) {
    return;
  }
  WriteMiniDump();
  _abort();
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



char * __cdecl FUN_1000ec60(uint param_1,uint param_2)

{
  code *pcVar1;
  bool bVar2;
  char *pcVar3;
  char *pcVar4;
  int iVar5;
  char *pcVar6;
  int iVar7;
  longlong lVar8;
  longlong lVar9;
  uint local_c;
  uint local_8;
  
  iVar5 = 1;
  if ((0 < (int)param_2) || ((-1 < (int)param_2 && (true)))) {
    iVar7 = 0;
  }
  else {
    iVar7 = 1;
  }
  lVar8 = __alldiv(param_1,param_2,10,0);
  for (lVar9 = lVar8; lVar9 != 0; lVar9 = __alldiv((uint)lVar9,local_c,10,0)) {
    local_c = (uint)((ulonglong)lVar9 >> 0x20);
    if (iVar5 == (iVar5 / 3) * 3) {
      iVar7 = iVar7 + 1;
    }
    iVar5 = iVar5 + 1;
  }
  pcVar4 = &DAT_10832de8;
  if (PTR_DAT_10046640 + iVar5 + iVar7 + 1 < &DAT_108331e8) {
    pcVar4 = PTR_DAT_10046640;
  }
  pcVar3 = pcVar4 + iVar5 + iVar7;
  iVar5 = 1;
  pcVar6 = pcVar3 + -1;
  PTR_DAT_10046640 = pcVar4;
  *pcVar3 = '\0';
  *pcVar6 = (char)param_1 + (char)lVar8 * -10 + '0';
  while (lVar8 != 0) {
    local_8 = (uint)((ulonglong)lVar8 >> 0x20);
    if (iVar5 == (iVar5 / 3) * 3) {
      pcVar6 = pcVar6 + -1;
      *pcVar6 = ',';
    }
    pcVar6 = pcVar6 + -1;
    lVar9 = __alldiv((uint)lVar8,local_8,10,0);
    iVar5 = iVar5 + 1;
    *pcVar6 = (char)lVar8 + (char)lVar9 * -10 + '0';
    lVar8 = lVar9;
  }
  if (((int)param_2 < 1) && (((int)param_2 < 0 || (false)))) {
    pcVar6 = pcVar6 + -1;
    *pcVar6 = '-';
  }
  if ((pcVar6 != pcVar4) && (bVar2 = Plat_IsInDebugSession(), bVar2)) {
    pcVar1 = (code *)swi(3);
    pcVar4 = (char *)(*pcVar1)();
    return pcVar4;
  }
  PTR_DAT_10046640 = pcVar3 + 1;
  return pcVar6;
}



void __thiscall FUN_1000edb0(void *this,int *param_1,undefined4 *param_2)

{
  int iVar1;
  int *piVar2;
  int iVar3;
  
  *param_1 = 0;
  *param_2 = 0;
  iVar3 = 7;
  piVar2 = (int *)((int)this + 0x83c);
  do {
    *param_1 = *param_1 + piVar2[-10] * 0x4000;
    iVar1 = *param_1 + *piVar2 * 0x4000;
    *param_1 = iVar1;
    iVar1 = iVar1 + piVar2[10] * 0x4000;
    *param_1 = iVar1;
    iVar1 = iVar1 + piVar2[0x14] * 0x4000;
    *param_1 = iVar1;
    iVar1 = iVar1 + piVar2[0x1e] * 0x4000;
    *param_1 = iVar1;
    *param_1 = piVar2[0x28] * 0x4000 + iVar1;
    iVar3 = iVar3 + -1;
    piVar2 = piVar2 + 0x3c;
  } while (iVar3 != 0);
  return;
}



void __thiscall FUN_1000ee30(void *this,int *param_1,undefined4 *param_2)

{
  int iVar1;
  int *piVar2;
  int iVar3;
  
  *param_1 = 0;
  *param_2 = 0;
  iVar3 = 7;
  piVar2 = (int *)((int)this + 0x83c);
  do {
    *param_1 = *param_1 + piVar2[-10] * 0x10000;
    iVar1 = *param_1 + *piVar2 * 0x10000;
    *param_1 = iVar1;
    iVar1 = iVar1 + piVar2[10] * 0x10000;
    *param_1 = iVar1;
    iVar1 = iVar1 + piVar2[0x14] * 0x10000;
    *param_1 = iVar1;
    iVar1 = iVar1 + piVar2[0x1e] * 0x10000;
    *param_1 = iVar1;
    *param_1 = piVar2[0x28] * 0x10000 + iVar1;
    iVar3 = iVar3 + -1;
    piVar2 = piVar2 + 0x3c;
  } while (iVar3 != 0);
  return;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Unable to track spacebase fully for stack
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint __fastcall FUN_1000eeb0(undefined4 *param_1)

{
  uint uVar1;
  undefined4 *puVar2;
  uint uVar3;
  uint *puVar4;
  uint uVar5;
  int iVar6;
  undefined4 uStack52;
  uint *puStack48;
  uint auStack44 [2];
  int local_18;
  uint *local_14;
  int *local_10;
  uint *local_c;
  int local_8;
  
  if ((DAT_102f2d98 & 0x10000) == 0) {
    LOCK();
    uVar5 = DAT_102f2d98;
    if (DAT_102f2d98 == 0) {
      DAT_102f2d98 = 0x10000;
      uVar5 = 0;
    }
    if (uVar5 != 0) goto LAB_1000eee8;
    auStack44[1] = 0x1000eee1;
    _DAT_102f2d9c = GetCurrentThreadId();
  }
  else {
LAB_1000eee8:
    auStack44[1] = 0x1000eeed;
    CThreadSpinRWLock::SpinLockForWrite((CThreadSpinRWLock *)&DAT_102f2d98);
  }
  iVar6 = param_1[5];
  uVar5 = iVar6 * 4 + 0xfU & 0xfffffff0;
  auStack44[1] = 0x1000ef00;
  local_14 = (uint *)(&stack0xffffffdc + -uVar5);
  local_10 = (int *)(&stack0xffffffdc + uVar5 * -2);
  *(undefined4 *)((int)auStack44 + -uVar5 + 4) = 0x1000ef0a;
  *(int *)((int)auStack44 + uVar5 * -2 + 4) = iVar6 * 4;
  *(undefined4 *)((int)auStack44 + uVar5 * -2) = 0;
  *(undefined **)((int)&puStack48 + uVar5 * -2) = &stack0xffffffdc + uVar5 * -2;
  *(undefined4 *)((int)&uStack52 + uVar5 * -2) = 0x1000ef18;
  FUN_10021290(*(uint **)((int)&puStack48 + uVar5 * -2),*(byte *)((int)auStack44 + uVar5 * -2),
               *(uint *)((int)auStack44 + uVar5 * -2 + 4));
  iVar6 = param_1[3];
  uVar5 = 0;
  local_8 = 0;
  if (iVar6 == 0) {
    if (param_1[5] != 0) {
      uVar5 = 0x439;
      goto LAB_1000f06b;
    }
  }
  else {
    local_18 = (int)local_10 - (int)local_14;
    local_c = local_14;
    do {
      puVar4 = local_c;
      *local_c = ((iVar6 + -0x102f2db0) / 0x18) * 0x4000 + DAT_102f2da8;
      if (*(undefined4 **)(iVar6 + 4) != param_1) {
        uVar5 = 0x445;
        goto LAB_1000f06b;
      }
      if ((uint)param_1[5] <= uVar5 && uVar5 != param_1[5]) {
        uVar5 = 0x44a;
        goto LAB_1000f06b;
      }
      if ((*puVar4 <= (uint)param_1[2]) && ((uint)param_1[2] < *puVar4 + 0x4000)) {
        *(uint *)(local_18 + (int)local_c) = ((*puVar4 - param_1[2]) + 0x4000) / (uint)param_1[4];
        puVar4 = local_c;
      }
      if (*(int *)(iVar6 + 0xc) == 0) {
        local_8 = local_8 + 1;
      }
      iVar6 = *(int *)(iVar6 + 8);
      local_c = puVar4 + 1;
      uVar5 = uVar5 + 1;
    } while (iVar6 != 0);
    if (uVar5 != param_1[5]) {
      uVar5 = 0x45e;
      goto LAB_1000f06b;
    }
    if ((local_8 != 0) && (param_1[8] != 0)) {
      uVar5 = 0x466;
      goto LAB_1000f06b;
    }
  }
  uVar1 = param_1[4];
  for (puVar2 = (undefined4 *)*param_1; puVar2 != (undefined4 *)0x0; puVar2 = (undefined4 *)*puVar2)
  {
    uVar3 = 0;
    if (uVar5 != 0) {
      do {
        if (((undefined4 *)local_14[uVar3] <= puVar2) &&
           (puVar2 < (undefined4 *)local_14[uVar3] + 0x1000)) {
          local_10[uVar3] = local_10[uVar3] + 1;
          break;
        }
        uVar3 = uVar3 + 1;
      } while (uVar3 < uVar5);
    }
    if (uVar3 == uVar5) {
      uVar5 = 0x481;
      goto LAB_1000f06b;
    }
  }
  for (iVar6 = param_1[3]; iVar6 != 0; iVar6 = *(int *)(iVar6 + 8)) {
    if ((int)(0x4000 / (ulonglong)uVar1) - *(int *)(iVar6 + 0xc) != *local_10) {
      uVar5 = 0x48f;
      goto LAB_1000f06b;
    }
    local_10 = local_10 + 1;
  }
  uVar5 = 0;
LAB_1000f06b:
  DAT_102f2d98 = 0;
  _DAT_102f2d9c = 0;
  return uVar5 & 0xffffff00 | (uint)(uVar5 == 0);
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Unable to track spacebase fully for stack
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint __fastcall FUN_1000f0b0(undefined4 *param_1)

{
  uint uVar1;
  undefined4 *puVar2;
  uint uVar3;
  uint *puVar4;
  uint uVar5;
  int iVar6;
  undefined4 uStack52;
  uint *puStack48;
  uint auStack44 [2];
  int local_18;
  uint *local_14;
  int *local_10;
  uint *local_c;
  int local_8;
  
  if ((DAT_10052d70 & 0x10000) == 0) {
    LOCK();
    uVar5 = DAT_10052d70;
    if (DAT_10052d70 == 0) {
      DAT_10052d70 = 0x10000;
      uVar5 = 0;
    }
    if (uVar5 != 0) goto LAB_1000f0e8;
    auStack44[1] = 0x1000f0e1;
    _DAT_10052d74 = GetCurrentThreadId();
  }
  else {
LAB_1000f0e8:
    auStack44[1] = 0x1000f0ed;
    CThreadSpinRWLock::SpinLockForWrite((CThreadSpinRWLock *)&DAT_10052d70);
  }
  iVar6 = param_1[5];
  uVar5 = iVar6 * 4 + 0xfU & 0xfffffff0;
  auStack44[1] = 0x1000f100;
  local_14 = (uint *)(&stack0xffffffdc + -uVar5);
  local_10 = (int *)(&stack0xffffffdc + uVar5 * -2);
  *(undefined4 *)((int)auStack44 + -uVar5 + 4) = 0x1000f10a;
  *(int *)((int)auStack44 + uVar5 * -2 + 4) = iVar6 * 4;
  *(undefined4 *)((int)auStack44 + uVar5 * -2) = 0;
  *(undefined **)((int)&puStack48 + uVar5 * -2) = &stack0xffffffdc + uVar5 * -2;
  *(undefined4 *)((int)&uStack52 + uVar5 * -2) = 0x1000f118;
  FUN_10021290(*(uint **)((int)&puStack48 + uVar5 * -2),*(byte *)((int)auStack44 + uVar5 * -2),
               *(uint *)((int)auStack44 + uVar5 * -2 + 4));
  iVar6 = param_1[3];
  uVar5 = 0;
  local_8 = 0;
  if (iVar6 == 0) {
    if (param_1[5] != 0) {
      uVar5 = 0x439;
      goto LAB_1000f26b;
    }
  }
  else {
    local_18 = (int)local_10 - (int)local_14;
    local_c = local_14;
    do {
      puVar4 = local_c;
      *local_c = ((iVar6 + -0x10052d88) / 0x18) * 0x4000 + DAT_10052d80;
      if (*(undefined4 **)(iVar6 + 4) != param_1) {
        uVar5 = 0x445;
        goto LAB_1000f26b;
      }
      if ((uint)param_1[5] <= uVar5 && uVar5 != param_1[5]) {
        uVar5 = 0x44a;
        goto LAB_1000f26b;
      }
      if ((*puVar4 <= (uint)param_1[2]) && ((uint)param_1[2] < *puVar4 + 0x4000)) {
        *(uint *)(local_18 + (int)local_c) = ((*puVar4 - param_1[2]) + 0x4000) / (uint)param_1[4];
        puVar4 = local_c;
      }
      if (*(int *)(iVar6 + 0xc) == 0) {
        local_8 = local_8 + 1;
      }
      iVar6 = *(int *)(iVar6 + 8);
      local_c = puVar4 + 1;
      uVar5 = uVar5 + 1;
    } while (iVar6 != 0);
    if (uVar5 != param_1[5]) {
      uVar5 = 0x45e;
      goto LAB_1000f26b;
    }
    if ((local_8 != 0) && (param_1[8] != 0)) {
      uVar5 = 0x466;
      goto LAB_1000f26b;
    }
  }
  uVar1 = param_1[4];
  for (puVar2 = (undefined4 *)*param_1; puVar2 != (undefined4 *)0x0; puVar2 = (undefined4 *)*puVar2)
  {
    uVar3 = 0;
    if (uVar5 != 0) {
      do {
        if (((undefined4 *)local_14[uVar3] <= puVar2) &&
           (puVar2 < (undefined4 *)local_14[uVar3] + 0x1000)) {
          local_10[uVar3] = local_10[uVar3] + 1;
          break;
        }
        uVar3 = uVar3 + 1;
      } while (uVar3 < uVar5);
    }
    if (uVar3 == uVar5) {
      uVar5 = 0x481;
      goto LAB_1000f26b;
    }
  }
  for (iVar6 = param_1[3]; iVar6 != 0; iVar6 = *(int *)(iVar6 + 8)) {
    if ((int)(0x4000 / (ulonglong)uVar1) - *(int *)(iVar6 + 0xc) != *local_10) {
      uVar5 = 0x48f;
      goto LAB_1000f26b;
    }
    local_10 = local_10 + 1;
  }
  uVar5 = 0;
LAB_1000f26b:
  DAT_10052d70 = 0;
  _DAT_10052d74 = 0;
  return uVar5 & 0xffffff00 | (uint)(uVar5 == 0);
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Unable to track spacebase fully for stack
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint __fastcall FUN_1000f2b0(undefined4 *param_1)

{
  uint uVar1;
  undefined4 *puVar2;
  uint *puVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  undefined4 uStack52;
  uint *puStack48;
  uint auStack44 [2];
  int local_18;
  uint *local_14;
  int *local_10;
  uint *local_c;
  int local_8;
  
  if ((DAT_10592dc0 & 0x10000) == 0) {
    LOCK();
    uVar5 = DAT_10592dc0;
    if (DAT_10592dc0 == 0) {
      DAT_10592dc0 = 0x10000;
      uVar5 = 0;
    }
    if (uVar5 != 0) goto LAB_1000f2e8;
    auStack44[1] = 0x1000f2e1;
    _DAT_10592dc4 = GetCurrentThreadId();
  }
  else {
LAB_1000f2e8:
    auStack44[1] = 0x1000f2ed;
    CThreadSpinRWLock::SpinLockForWrite((CThreadSpinRWLock *)&DAT_10592dc0);
  }
  iVar6 = param_1[5];
  uVar5 = iVar6 * 4 + 0xfU & 0xfffffff0;
  auStack44[1] = 0x1000f300;
  local_14 = (uint *)(&stack0xffffffdc + -uVar5);
  local_10 = (int *)(&stack0xffffffdc + uVar5 * -2);
  *(undefined4 *)((int)auStack44 + -uVar5 + 4) = 0x1000f30a;
  *(int *)((int)auStack44 + uVar5 * -2 + 4) = iVar6 * 4;
  *(undefined4 *)((int)auStack44 + uVar5 * -2) = 0;
  *(undefined **)((int)&puStack48 + uVar5 * -2) = &stack0xffffffdc + uVar5 * -2;
  *(undefined4 *)((int)&uStack52 + uVar5 * -2) = 0x1000f318;
  FUN_10021290(*(uint **)((int)&puStack48 + uVar5 * -2),*(byte *)((int)auStack44 + uVar5 * -2),
               *(uint *)((int)auStack44 + uVar5 * -2 + 4));
  iVar6 = param_1[3];
  uVar5 = 0;
  local_8 = 0;
  if (iVar6 == 0) {
    if (param_1[5] != 0) {
      uVar5 = 0x439;
      goto LAB_1000f46b;
    }
  }
  else {
    local_18 = (int)local_10 - (int)local_14;
    local_c = local_14;
    do {
      puVar3 = local_c;
      *local_c = ((iVar6 + -0x10592dd8) / 0x18) * 0x10000 + DAT_10592dd0;
      if (*(undefined4 **)(iVar6 + 4) != param_1) {
        uVar5 = 0x445;
        goto LAB_1000f46b;
      }
      if ((uint)param_1[5] <= uVar5 && uVar5 != param_1[5]) {
        uVar5 = 0x44a;
        goto LAB_1000f46b;
      }
      if ((*puVar3 <= (uint)param_1[2]) && ((uint)param_1[2] < *puVar3 + 0x10000)) {
        *(uint *)(local_18 + (int)local_c) = ((*puVar3 - param_1[2]) + 0x10000) / (uint)param_1[4];
        puVar3 = local_c;
      }
      if (*(int *)(iVar6 + 0xc) == 0) {
        local_8 = local_8 + 1;
      }
      iVar6 = *(int *)(iVar6 + 8);
      local_c = puVar3 + 1;
      uVar5 = uVar5 + 1;
    } while (iVar6 != 0);
    if (uVar5 != param_1[5]) {
      uVar5 = 0x45e;
      goto LAB_1000f46b;
    }
    if ((local_8 != 0) && (param_1[8] != 0)) {
      uVar5 = 0x466;
      goto LAB_1000f46b;
    }
  }
  uVar1 = param_1[4];
  for (puVar2 = (undefined4 *)*param_1; puVar2 != (undefined4 *)0x0; puVar2 = (undefined4 *)*puVar2)
  {
    uVar4 = 0;
    if (uVar5 != 0) {
      do {
        if (((undefined4 *)local_14[uVar4] <= puVar2) &&
           (puVar2 < (undefined4 *)local_14[uVar4] + 0x4000)) {
          local_10[uVar4] = local_10[uVar4] + 1;
          break;
        }
        uVar4 = uVar4 + 1;
      } while (uVar4 < uVar5);
    }
    if (uVar4 == uVar5) {
      uVar5 = 0x481;
      goto LAB_1000f46b;
    }
  }
  for (iVar6 = param_1[3]; iVar6 != 0; iVar6 = *(int *)(iVar6 + 8)) {
    if ((int)(0x10000 / (ulonglong)uVar1) - *(int *)(iVar6 + 0xc) != *local_10) {
      uVar5 = 0x48f;
      goto LAB_1000f46b;
    }
    local_10 = local_10 + 1;
  }
  uVar5 = 0;
LAB_1000f46b:
  DAT_10592dc0 = 0;
  _DAT_10592dc4 = 0;
  return uVar5 & 0xffffff00 | (uint)(uVar5 == 0);
}



int FUN_1000f4b0(void)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  int iVar4;
  
  iVar4 = 0;
  iVar2 = 0;
  uVar3 = 0;
  do {
    uVar1 = FUN_1001e590(*(int *)((int)&DAT_10832ddc + uVar3));
    iVar4 = iVar4 + uVar1;
    FUN_1001f120(*(int *)((int)&DAT_10832ddc + uVar3),0);
    uVar1 = FUN_1001e590(*(int *)((int)&DAT_10832ddc + uVar3));
    uVar3 = uVar3 + 4;
    iVar2 = iVar2 + uVar1;
  } while (uVar3 < 8);
  return iVar4 - iVar2;
}



undefined4 __fastcall FUN_1000f500(int *param_1)

{
  (**(code **)(*param_1 + 0x3c))();
  return 0xfffffffe;
}



void __cdecl FUN_1000f510(FILE *param_1,int param_2)

{
  int *piVar1;
  uint uVar2;
  char local_454 [1024];
  int local_54 [10];
  int local_2c;
  int iStack40;
  int iStack36;
  int iStack32;
  int local_1c;
  int iStack24;
  int iStack20;
  int iStack16;
  undefined8 local_c;
  
  uVar2 = 0;
  do {
    piVar1 = FUN_1001ed40(local_54,(&DAT_10832ddc)[uVar2]);
    local_2c = *piVar1;
    iStack40 = piVar1[1];
    iStack36 = piVar1[2];
    iStack32 = piVar1[3];
    local_1c = piVar1[4];
    iStack24 = piVar1[5];
    iStack20 = piVar1[6];
    iStack16 = piVar1[7];
    local_c = *(undefined8 *)(piVar1 + 8);
    FUN_1001e590((&DAT_10832ddc)[uVar2]);
    FUN_1001f0f0((&DAT_10832ddc)[uVar2]);
    if (param_2 == 1) {
      FUN_1002169d(local_454,0x400,
                   (byte *)
                   "\n<div class=\"sbhTable\"><legend>dlmalloc mspace #%d: %u MiB allocated of %u MiB footprint</legend><pre>\n     %d:footprint     ~ %5u MiB (total space used by the mspace)\n     %d:footprint_max ~ %5u MiB (maximum total space used by the mspace)\n     %d:arena         ~ %5u MiB (non-mmapped space allocated from system)\n     %d:ordblks       ~ %5u MiB (number of free chunks)\n     %d:hblkhd        ~ %5u MiB (space in mmapped regions)\n     %d:usmblks       ~ %5u MiB (maximum total allocated space)\n     %d:uordblks      ~ %5u MiB (total allocated space)\n     %d:fordblks      ~ %5u MiB (total free space)\n     %d:keepcost      ~ %5u MiB (releasable (via malloc_trim) space)\n</pre></div>"
                  );
    }
    else {
      FUN_1002169d(local_454,0x400,
                   (byte *)
                   "\ndlmalloc mspace #%d. 1 MiB=2^20 bytes\n     %d:footprint     ~ %5u MiB (total space used by the mspace)\n     %d:footprint_max ~ %5u MiB (maximum total space used by the mspace)\n     %d:arena         ~ %5u MiB (non-mmapped space allocated from system)\n     %d:ordblks       ~ %5u MiB (number of free chunks)\n     %d:hblkhd        ~ %5u MiB (space in mmapped regions)\n     %d:usmblks       ~ %5u MiB (maximum total allocated space)\n     %d:uordblks      ~ %5u MiB (total allocated space)\n     %d:fordblks      ~ %5u MiB (total free space)\n     %d:keepcost      ~ %5u MiB (releasable (via malloc_trim) space)\n"
                  );
    }
    if (param_1 == (FILE *)0x0) {
      Msg(&DAT_10036b98);
    }
    else {
      FUN_1002158b(param_1,&DAT_10036b98);
    }
    uVar2 = uVar2 + 1;
  } while (uVar2 < 2);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl AddMemoryInfoCallback(undefined4 param_1)

{
                    // 0xf680  277  AddMemoryInfoCallback
  CThreadMutex::Lock((CThreadMutex *)&DAT_10052d30);
  if (DAT_10052d50 < 100) {
    (&DAT_1004fdb0)[DAT_10052d50] = param_1;
    DAT_10052d50 = DAT_10052d50 + 1;
  }
  _DAT_10052d4c = _DAT_10052d4c + -1;
  if (_DAT_10052d4c == 0) {
    if (DAT_10052d4e != '\0') {
      Msg((byte *)"Thread %u releasing lock 0x%p\n");
    }
    DAT_10052d48 = 0;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_10052d30);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void DumpMemoryInfoStats(void)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  double dVar4;
  
                    // 0xf6f0  299  DumpMemoryInfoStats
  CThreadMutex::Lock((CThreadMutex *)&DAT_10052d30);
  uVar3 = 0;
  if (DAT_10052d50 != 0) {
    do {
      piVar1 = (int *)(&DAT_1004fdb0)[uVar3];
      (**(code **)(*piVar1 + 4))();
      (**(code **)(*piVar1 + 0x10))();
      (**(code **)(*piVar1 + 8))();
      (**(code **)(*piVar1 + 0xc))();
      (**(code **)*piVar1)();
      iVar2 = (**(code **)(*piVar1 + 0xc))();
      if (iVar2 != 0) {
        iVar2 = (**(code **)(*piVar1 + 0xc))();
        dVar4 = ((double)iVar2 + (double)(&DAT_100366d0)[-(iVar2 >> 0x1f)]) * 9.5367431640625e-07;
        iVar2 = (**(code **)(*piVar1 + 8))(SUB84(dVar4,0),(int)((ulonglong)dVar4 >> 0x20));
        dVar4 = ((double)iVar2 + (double)(&DAT_100366d0)[-(iVar2 >> 0x1f)]) * 9.5367431640625e-07;
        iVar2 = (**(code **)(*piVar1 + 0x10))(SUB84(dVar4,0),(int)((ulonglong)dVar4 >> 0x20));
        dVar4 = ((double)iVar2 + (double)(&DAT_100366d0)[-(iVar2 >> 0x1f)]) * 9.5367431640625e-07;
        (**(code **)(*piVar1 + 4))(SUB84(dVar4,0),(int)((ulonglong)dVar4 >> 0x20));
        Msg((byte *)
            "%-40s: %4.1f MB allocated (%4.1f MB peak), %4.1f MB committed, %4.1f MB reserved\n");
      }
      uVar3 = uVar3 + 1;
    } while (uVar3 < DAT_10052d50);
  }
  Msg((byte *)"%-40s: %4.1f MB allocated (%4.1f MB peak), %4.1f MB committed, %4.1f MB reserved\n");
  _DAT_10052d4c = _DAT_10052d4c + -1;
  if (_DAT_10052d4c == 0) {
    if (DAT_10052d4e != '\0') {
      Msg((byte *)"Thread %u releasing lock 0x%p\n");
    }
    DAT_10052d48 = 0;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_10052d30);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl RemoveMemoryInfoCallback(int param_1)

{
  int iVar1;
  uint uVar2;
  
                    // 0xf940  435  RemoveMemoryInfoCallback
  CThreadMutex::Lock((CThreadMutex *)&DAT_10052d30);
  uVar2 = 0;
  if (DAT_10052d50 != 0) {
    do {
      if ((&DAT_1004fdb0)[uVar2] == param_1) {
        iVar1 = DAT_10052d50 * 4;
        DAT_10052d50 = DAT_10052d50 - 1;
        (&DAT_1004fdb0)[uVar2] = *(undefined4 *)(&DAT_1004fdac + iVar1);
        break;
      }
      uVar2 = uVar2 + 1;
    } while (uVar2 < DAT_10052d50);
  }
  _DAT_10052d4c = _DAT_10052d4c + -1;
  if (_DAT_10052d4c == 0) {
    if (DAT_10052d4e != '\0') {
      Msg((byte *)"Thread %u releasing lock 0x%p\n");
    }
    DAT_10052d48 = 0;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_10052d30);
  return;
}



// public: int __thiscall CVProfNode::GetPrevLoadHitStoreLessChildren(void)

int __thiscall CVProfNode::GetPrevLoadHitStoreLessChildren(CVProfNode *this)

{
                    // 0xf9d0  136  ?GetPrevLoadHitStoreLessChildren@CVProfNode@@QAEHXZ
  return 0;
}



HMODULE * __fastcall FUN_1000f9e0(HMODULE *param_1)

{
  char cVar1;
  HMODULE pHVar2;
  
  pHVar2 = GetModuleHandleA("tier0_s.dll");
  *param_1 = pHVar2;
  if (pHVar2 == (HMODULE)0x0) {
    param_1[1] = (HMODULE)0x0;
    param_1[2] = (HMODULE)0x0;
  }
  else {
    pHVar2 = (HMODULE)GetProcAddress(pHVar2,"BGetMiniDumpLock");
    param_1[1] = pHVar2;
    pHVar2 = (HMODULE)GetProcAddress(*param_1,"MiniDumpUnlock");
    param_1[2] = pHVar2;
  }
  if ((param_1[1] != (HMODULE)0x0) && (param_1[2] != (HMODULE)0x0)) {
    cVar1 = (*(code *)param_1[1])();
    while (cVar1 == '\0') {
      Sleep(100);
      cVar1 = (*(code *)param_1[1])();
    }
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 __fastcall FUN_1000fa60(undefined4 param_1)

{
  LONG LVar1;
  
  do {
    if (_DAT_10833220 == 0) {
      LVar1 = InterlockedIncrement((LONG *)&DAT_10833220);
      if (LVar1 == 1) {
        _DAT_10833b3c = GetCurrentThreadId();
        return param_1;
      }
      InterlockedDecrement((LONG *)&DAT_10833220);
    }
    Sleep(100);
  } while( true );
}



void __cdecl FUN_1000fac0(int *param_1)

{
  undefined4 *in_FS_OFFSET;
  undefined4 local_14;
  code *pcStack16;
  undefined *puStack12;
  undefined4 local_8;
  
  puStack12 = &DAT_1003f558;
  pcStack16 = FUN_100213a8;
  local_14 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_14;
  local_8 = 0;
  FUN_1000fd00(param_1);
  *in_FS_OFFSET = local_14;
  return;
}



char * __cdecl FUN_1000fb60(uint param_1)

{
  if (param_1 < 0xc0000006) {
    if (param_1 == 0xc0000005) {
      return "accessviolation";
    }
    if (param_1 == 0x80000002) {
      return "datatypemisalignment";
    }
    if (param_1 == 0x80000003) {
      return "breakpoint";
    }
    if (param_1 == 0x80000004) {
      return "singlestep";
    }
  }
  else if (true) {
    switch(param_1) {
    case 0xc0000025:
      return "noncontinuableexception";
    case 0xc000008c:
      return "arrayboundsexceeded";
    case 0xc000008d:
      return "fltdenormaloperand";
    case 0xc000008e:
      return "fltdividebyzero";
    case 0xc000008f:
      return "fltinexactresult";
    case 0xc0000090:
      return "fltinvalidoperation";
    case 0xc0000091:
      return "fltoverflow";
    case 0xc0000092:
      return "fltstackcheck";
    case 0xc0000093:
      return "fltunderflow";
    case 0xc0000094:
      return "intdividebyzero";
    case 0xc0000095:
      return "intoverflow";
    case 0xc0000096:
      return "privinstruction";
    }
  }
  return "crash";
}



void __cdecl FUN_1000fcc0(undefined4 param_1,undefined4 param_2,undefined4 param_3)

{
  uint uVar1;
  
  uVar1 = WriteMiniDumpUsingExceptionInfo(param_1,param_2,0x41,param_3,(char *)0x0);
  if ((char)uVar1 == '\0') {
    WriteMiniDumpUsingExceptionInfo(param_1,param_2,1,param_3,(char *)0x0);
  }
  return;
}



undefined4 __fastcall FUN_1000fd00(int *param_1)

{
  int iVar1;
  undefined4 uVar2;
  
  iVar1 = *param_1;
  if (iVar1 == 1) {
    if ((param_1[2] == 0) || (param_1[3] == 0)) {
      Error((byte *)"CatchAndWriteContext_t::Invoke with bogus argc/argv");
    }
    (*(code *)param_1[1])(*(undefined4 *)param_1[2],*(undefined4 *)param_1[3]);
  }
  else {
    if (iVar1 == 2) {
      if ((param_1[2] == 0) || (param_1[3] == 0)) {
        Error((byte *)"CatchAndWriteContext_t::Invoke with bogus argc/argv");
      }
      uVar2 = (*(code *)param_1[1])(*(undefined4 *)param_1[2],*(undefined4 *)param_1[3]);
      return uVar2;
    }
    if (iVar1 == 3) {
      if (param_1[4] == iVar1 + -3) {
        Error((byte *)"CatchAndWriteContext_t::Invoke with bogus void *ptr");
      }
      (*(code *)param_1[1])(*(undefined4 *)param_1[4]);
      return 0;
    }
  }
  return 0;
}



undefined4 FUN_1000fd90(undefined4 *param_1)

{
  (*DAT_1083322c)(*(undefined4 *)*param_1,param_1,0);
  return 0;
}



void __cdecl CatchAndWriteMiniDump(int param_1,undefined4 param_2,undefined4 param_3)

{
  int local_20;
  int local_1c;
  undefined4 *local_18;
  undefined4 *local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_8;
  
                    // 0xfdb0  284  CatchAndWriteMiniDump
  local_18 = &param_3;
  local_8 = param_3;
  param_3 = param_2;
  local_14 = &local_8;
  local_20 = 1;
  local_c = 0;
  local_1c = param_1;
  local_10 = 0;
  if (param_1 == 0) {
    Error((byte *)"CatchAndWriteContext_t::Set w/o a function pointer!");
  }
  FUN_1000fac0(&local_20);
  return;
}



void __cdecl
CatchAndWriteMiniDumpEx(int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)

{
  int local_1c;
  int local_18;
  undefined4 *local_14;
  undefined4 *local_10;
  undefined4 local_c;
  undefined4 local_8;
  
                    // 0xfe10  285  CatchAndWriteMiniDumpEx
  local_14 = &param_2;
  local_8 = param_4;
  local_10 = &param_3;
  local_1c = 1;
  local_18 = param_1;
  local_c = 0;
  if (param_1 == 0) {
    Error((byte *)"CatchAndWriteContext_t::Set w/o a function pointer!");
  }
  FUN_1000fac0(&local_1c);
  return;
}



void __cdecl CatchAndWriteMiniDumpExForVoidPtrFn(int param_1,undefined4 param_2,undefined4 param_3)

{
  int local_1c;
  int local_18;
  undefined4 local_14;
  undefined4 local_10;
  undefined4 *local_c;
  undefined4 local_8;
  
                    // 0xfe60  286  CatchAndWriteMiniDumpExForVoidPtrFn
  local_c = &param_2;
  local_8 = param_3;
  local_1c = 3;
  local_18 = param_1;
  local_14 = 0;
  local_10 = 0;
  if (param_1 == 0) {
    Error((byte *)"CatchAndWriteContext_t::Set w/o a function pointer!");
  }
  FUN_1000fac0(&local_1c);
  return;
}



void __cdecl
CatchAndWriteMiniDumpExReturnsInt
          (int param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4)

{
  int local_1c;
  int local_18;
  undefined4 *local_14;
  undefined4 *local_10;
  undefined4 local_c;
  undefined4 local_8;
  
                    // 0xfeb0  287  CatchAndWriteMiniDumpExReturnsInt
  local_14 = &param_2;
  local_8 = param_4;
  local_10 = &param_3;
  local_1c = 2;
  local_18 = param_1;
  local_c = 0;
  if (param_1 == 0) {
    Error((byte *)"CatchAndWriteContext_t::Set w/o a function pointer!");
  }
  FUN_1000fac0(&local_1c);
  return;
}



void __cdecl CatchAndWriteMiniDumpForVoidPtrFn(int param_1,undefined4 param_2,char param_3)

{
  int local_1c;
  int local_18;
  undefined4 local_14;
  undefined4 local_10;
  undefined4 *local_c;
  uint local_8;
  
                    // 0xff00  288  CatchAndWriteMiniDumpForVoidPtrFn
  local_c = &param_2;
  local_1c = 3;
  local_8 = (uint)(param_3 == '\0');
  local_14 = 0;
  local_18 = param_1;
  local_10 = 0;
  if (param_1 == 0) {
    Error((byte *)"CatchAndWriteContext_t::Set w/o a function pointer!");
  }
  FUN_1000fac0(&local_1c);
  return;
}



void EnableCrashingOnCrashes(void)

{
  HMODULE hModule;
  FARPROC pFVar1;
  FARPROC pFVar2;
  int iVar3;
  uint local_8;
  
                    // 0xff60  326  EnableCrashingOnCrashes
  hModule = LoadLibraryA("kernel32.dll");
  pFVar1 = GetProcAddress(hModule,"GetProcessUserModeExceptionPolicy");
  pFVar2 = GetProcAddress(hModule,"SetProcessUserModeExceptionPolicy");
  if ((pFVar1 != (FARPROC)0x0) && (pFVar2 != (FARPROC)0x0)) {
    iVar3 = (*pFVar1)(&local_8);
    if (iVar3 != 0) {
      (*pFVar2)(local_8 & 0xfffffffe);
    }
  }
  return;
}



void __cdecl MinidumpSetUnhandledExceptionFunction(undefined4 param_1)

{
                    // 0xffb0  379  MinidumpSetUnhandledExceptionFunction
  DAT_1083322c = param_1;
  SetUnhandledExceptionFilter(FUN_1000fd90);
  return;
}



undefined * __cdecl SetMiniDumpFunction(undefined *param_1)

{
  undefined *puVar1;
  
                    // 0xffd0  446  SetMiniDumpFunction
  puVar1 = PTR_FUN_10046644;
  PTR_FUN_10046644 = param_1;
  return puVar1;
}



void __cdecl SetMinidumpComment(char *param_1)

{
  char *_Source;
  
                    // 0xfff0  447  SetMinidumpComment
  _Source = "";
  if (param_1 != (char *)0x0) {
    _Source = param_1;
  }
  _strncpy(&DAT_10833338,_Source,0x7ff);
  return;
}



void __cdecl SetMinidumpFilenamePrefix(char *param_1)

{
                    // 0x10020  448  SetMinidumpFilenamePrefix
  _strncpy(&DAT_10833230,param_1,0x103);
  return;
}



void WriteMiniDump(void)

{
  undefined4 *in_FS_OFFSET;
  undefined4 local_14;
  code *pcStack16;
  undefined *puStack12;
  undefined4 local_8;
  
                    // 0x10040  484  WriteMiniDump
  puStack12 = &DAT_1003f548;
  pcStack16 = FUN_100213a8;
  local_14 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_14;
  local_8 = 0;
  RaiseException(0x80000003,1,0,(ULONG_PTR *)0x0);
  *in_FS_OFFSET = local_14;
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint __cdecl
WriteMiniDumpUsingExceptionInfo
          (undefined4 param_1,undefined4 param_2,undefined4 param_3,int param_4,char *param_5)

{
  char cVar1;
  uint uVar2;
  undefined *puVar3;
  int iVar4;
  HANDLE pvVar5;
  DWORD DVar6;
  HANDLE pvVar7;
  char *pcVar8;
  char *pcVar9;
  byte bVar10;
  DWORD *pDVar11;
  longlong *plVar12;
  undefined4 uVar13;
  byte local_254 [259];
  undefined local_151;
  char local_150 [259];
  undefined local_4d;
  undefined4 local_4c;
  char *pcStack72;
  char *pcStack68;
  HMODULE local_40;
  int local_3c;
  code *local_38;
  DWORD local_34;
  undefined4 local_30;
  undefined4 local_2c;
  FARPROC local_28;
  HANDLE local_24;
  undefined1 *local_20;
  HMODULE local_1c;
  undefined8 local_18;
  longlong local_10;
  undefined local_5;
  
                    // 0x100c0  485  WriteMiniDumpUsingExceptionInfo
  FUN_1000f9e0(&local_40);
  uVar2 = GetCurrentThreadId();
  if (_DAT_10833b3c == uVar2) {
    bVar10 = 0;
    goto LAB_10010399;
  }
  FUN_1000fa60(&local_5);
  if (param_5 != (char *)0x0) {
    *param_5 = '\0';
  }
  local_1c = LoadLibraryA("DbgHelp.dll");
  bVar10 = 0;
  if (local_1c != (HMODULE)0x0) {
    local_28 = GetProcAddress(local_1c,"MiniDumpWriteDump");
    bVar10 = 0;
    if (local_28 != (FARPROC)0x0) {
      local_18 = FUN_10022adf((undefined4 *)0x0);
      FUN_10022840(&local_18);
      DAT_10833b38 = DAT_10833b38 + 1;
      if (DAT_10833230 == '\0') {
        GetModuleFileNameA((HMODULE)0x0,(LPSTR)local_254,0x104);
        puVar3 = (undefined *)FUN_100226d7(local_254,0x2e);
        if (puVar3 != (undefined *)0x0) {
          *puVar3 = 0;
        }
        iVar4 = FUN_100226d7(local_254,0x5c);
        if (iVar4 == 0) {
          pcVar8 = "unknown";
        }
        else {
          pcVar8 = (char *)(iVar4 + 1);
        }
        pcVar9 = pcVar8;
        do {
          cVar1 = *pcVar9;
          pcVar9 = pcVar9 + 1;
          pcVar9[0x1083322f - (int)pcVar8] = cVar1;
        } while (cVar1 != '\0');
      }
      FUN_1002169d(local_150,0x104,(byte *)"%s_%d%02d%02d_%02d%02d%02d_%d_x%p%hs%hs.mdmp");
      local_4d = 0;
      pcVar8 = local_150;
      while (local_150[0] != '\0') {
        cVar1 = *pcVar8;
        if ((cVar1 == '/') || (cVar1 == '\\')) {
          *pcVar8 = '\0';
          CreateDirectoryA(local_150,(LPSECURITY_ATTRIBUTES)0x0);
          *pcVar8 = cVar1;
        }
        pcVar8 = pcVar8 + 1;
        local_150[0] = *pcVar8;
      }
      bVar10 = 0;
      pvVar5 = CreateFileA(local_150,0x40000000,2,(LPSECURITY_ATTRIBUTES)0x0,2,0x80,(HANDLE)0x0);
      local_24 = pvVar5;
      if (pvVar5 != (HANDLE)0x0) {
        local_34 = GetCurrentThreadId();
        local_30 = param_2;
        local_2c = 0;
        local_10 = ZEXT48(&local_4c) << 0x20;
        if (DAT_10833338 != '\0') {
          local_10 = CONCAT44(&local_4c,1);
          local_4c = 10;
          pcStack68 = &DAT_10833338;
          local_20 = &DAT_10833339;
          pcVar8 = &DAT_10833338;
          do {
            pcStack72 = pcVar8;
            pcVar8 = pcStack72 + 1;
          } while (*pcStack72 != '\0');
          pcStack72 = pcStack72 + -0x10833337;
        }
        uVar13 = 0;
        plVar12 = &local_10;
        pDVar11 = &local_34;
        DVar6 = GetCurrentProcessId();
        pvVar7 = GetCurrentProcess();
        iVar4 = (*local_28)(pvVar7,DVar6,pvVar5,param_3,pDVar11,plVar12,uVar13);
        CloseHandle(local_24);
        DAT_10833338 = '\0';
        if (iVar4 != 0) {
          bVar10 = 1;
          if (param_5 != (char *)0x0) {
            pcVar8 = param_5;
            do {
              cVar1 = pcVar8[(int)(local_150 + -(int)param_5)];
              *pcVar8 = cVar1;
              pcVar8 = pcVar8 + 1;
            } while (cVar1 != '\0');
          }
          goto LAB_1001037a;
        }
      }
      FUN_1002169d((char *)local_254,0x104,(byte *)"(failed)%s");
      local_151 = 0;
      FUN_1002277d(local_150,(LPCSTR)local_254);
    }
LAB_1001037a:
    FreeLibrary(local_1c);
  }
  _DAT_10833b3c = 0;
  uVar2 = InterlockedDecrement((LONG *)&DAT_10833220);
LAB_10010399:
  if ((local_3c != 0) && (local_38 != (code *)0x0)) {
    uVar2 = (*local_38)();
  }
  return uVar2 & 0xffffff00 | (uint)bVar10;
}



undefined8 GetHardwareClockReliably(void)

{
                    // 0x103b0  339  GetHardwareClockReliably
  return 0;
}



void __cdecl MicroProfilerAddTS(longlong *param_1,uint param_2,int param_3)

{
                    // 0x103c0  378  MicroProfilerAddTS
  ThreadInterlockedExchangeAdd64(param_1,param_2,param_3);
  LOCK();
  *(int *)(param_1 + 1) = *(int *)(param_1 + 1) + 1;
  return;
}



void __cdecl PopMiniProfilerTS(void *param_1)

{
                    // 0x103f0  429  PopMiniProfilerTS
  GenericThreadLocals::CThreadLocalBase::Set((CThreadLocalBase *)&DAT_10833b5c,param_1);
  return;
}



undefined * __cdecl PushMiniProfilerTS(void *param_1)

{
  undefined *puVar1;
  undefined *puVar2;
  
                    // 0x10410  433  PushMiniProfilerTS
  puVar1 = (undefined *)
           GenericThreadLocals::CThreadLocalBase::Get((CThreadLocalBase *)&DAT_10833b5c);
  puVar2 = &DAT_10833b60;
  if (puVar1 != (undefined *)0x0) {
    puVar2 = puVar1;
  }
  GenericThreadLocals::CThreadLocalBase::Set((CThreadLocalBase *)&DAT_10833b5c,param_1);
  return puVar2;
}



// public: __thiscall CPerfStatsData::CPerfStatsData(void)

CPerfStatsData * __thiscall CPerfStatsData::CPerfStatsData(CPerfStatsData *this)

{
                    // 0x10440  5  ??0CPerfStatsData@@QAE@XZ
  *(undefined4 *)(this + 0x10) = 0;
  *(undefined4 *)(this + 0x14) = 0;
  *(undefined4 *)(this + 0x18) = 0;
  *(undefined4 *)(this + 0x1c) = 0;
  *(undefined4 *)(this + 0x20) = 0;
  *(undefined4 *)(this + 0x24) = 0;
  *(undefined4 *)(this + 0x28) = 0;
  *(undefined4 *)(this + 0x2c) = 0;
  *(undefined4 *)(this + 0x38) = 0;
  *(undefined4 *)(this + 0x3c) = 0;
  *(undefined4 *)(this + 0x40) = 0;
  *(undefined4 *)(this + 0x44) = 0;
  *(undefined4 *)(this + 0x48) = 0;
  *(undefined4 *)(this + 0x4c) = 0;
  *(undefined4 *)(this + 0x50) = 0;
  *(undefined4 *)(this + 0x54) = 0;
  *(undefined4 *)(this + 0x60) = 0;
  *(undefined4 *)(this + 100) = 0;
  *(undefined4 *)(this + 0x68) = 0;
  *(undefined4 *)(this + 0x6c) = 0;
  *(undefined4 *)(this + 0x70) = 0;
  *(undefined4 *)(this + 0x74) = 0;
  *(undefined4 *)(this + 0x78) = 0;
  *(undefined4 *)(this + 0x7c) = 0;
  *(undefined4 *)(this + 0x88) = 0;
  *(undefined4 *)(this + 0x8c) = 0;
  *(undefined4 *)(this + 0x90) = 0;
  *(undefined4 *)(this + 0x94) = 0;
  *(undefined4 *)(this + 0x98) = 0;
  *(undefined4 *)(this + 0x9c) = 0;
  *(undefined4 *)(this + 0xa0) = 0;
  *(undefined4 *)(this + 0xa4) = 0;
  *(undefined4 *)(this + 0xb0) = 0;
  *(undefined4 *)(this + 0xb4) = 0;
  *(undefined4 *)(this + 0xb8) = 0;
  *(undefined4 *)(this + 0xbc) = 0;
  *(undefined4 *)(this + 0xc0) = 0;
  *(undefined4 *)(this + 0xc4) = 0;
  *(undefined4 *)(this + 200) = 0;
  *(undefined4 *)(this + 0xcc) = 0;
  Reset(this);
  return this;
}



// public: class CPerfStatsData & __thiscall CPerfStatsData::operator=(class CPerfStatsData const &)

CPerfStatsData * __thiscall CPerfStatsData::operator_(CPerfStatsData *this,CPerfStatsData *param_1)

{
  int iVar1;
  undefined4 *puVar2;
  
                    // 0x105a0  46  ??4CPerfStatsData@@QAEAAV0@ABV0@@Z
  puVar2 = (undefined4 *)this;
  for (iVar1 = 0x34; iVar1 != 0; iVar1 = iVar1 + -1) {
    *puVar2 = *(undefined4 *)param_1;
    param_1 = (CPerfStatsData *)((int)param_1 + 4);
    puVar2 = puVar2 + 1;
  }
  return this;
}



// public: void __thiscall CPerfStatsData::Reset(void)

void __thiscall CPerfStatsData::Reset(CPerfStatsData *this)

{
                    // 0x105c0  202  ?Reset@CPerfStatsData@@QAEXXZ
  *(undefined4 *)this = 0;
  *(undefined4 *)(this + 4) = 0;
  *(undefined4 *)(this + 8) = 0;
  *(undefined4 *)(this + 0x30) = 0;
  *(undefined4 *)(this + 0x18) = 0;
  *(undefined4 *)(this + 0x1c) = 0;
  *(undefined4 *)(this + 0x20) = 0;
  *(undefined4 *)(this + 0x24) = 0;
  *(undefined4 *)(this + 0x28) = 0;
  *(undefined4 *)(this + 0x2c) = 0;
  *(undefined4 *)(this + 0x40) = 0;
  *(undefined4 *)(this + 0x44) = 0;
  *(undefined4 *)(this + 0x48) = 0;
  *(undefined4 *)(this + 0x4c) = 0;
  *(undefined4 *)(this + 0x50) = 0;
  *(undefined4 *)(this + 0x54) = 0;
  *(undefined4 *)(this + 0x58) = 0;
  *(undefined4 *)(this + 0x68) = 0;
  *(undefined4 *)(this + 0x6c) = 0;
  *(undefined4 *)(this + 0x70) = 0;
  *(undefined4 *)(this + 0x74) = 0;
  *(undefined4 *)(this + 0x78) = 0;
  *(undefined4 *)(this + 0x7c) = 0;
  *(undefined4 *)(this + 0x80) = 0;
  *(undefined4 *)(this + 0x90) = 0;
  *(undefined4 *)(this + 0x94) = 0;
  *(undefined4 *)(this + 0x98) = 0;
  *(undefined4 *)(this + 0x9c) = 0;
  *(undefined4 *)(this + 0xa0) = 0;
  *(undefined4 *)(this + 0xa4) = 0;
  *(undefined4 *)(this + 0xa8) = 0;
  *(undefined4 *)(this + 0xb8) = 0;
  *(undefined4 *)(this + 0xbc) = 0;
  *(undefined4 *)(this + 0xc0) = 0;
  *(undefined4 *)(this + 0xc4) = 0;
  *(undefined4 *)(this + 200) = 0;
  *(undefined4 *)(this + 0xcc) = 0;
  return;
}



// public: void __thiscall CPerfStatsData::Tick(void)

void __thiscall CPerfStatsData::Tick(CPerfStatsData *this)

{
  uint *puVar1;
  uint uVar2;
  undefined8 uVar3;
  uint uVar4;
  int iVar5;
  
                    // 0x106f0  238  ?Tick@CPerfStatsData@@QAEXXZ
  if ((*(uint *)this | *(uint *)(this + 4)) != 0) {
    uVar3 = rdtsc();
    uVar2 = *(uint *)(this + 0x10);
    uVar4 = (uint)uVar3 - *(uint *)(this + 0x10);
    *(uint *)(this + 0x10) = uVar4;
    iVar5 = ((int)((ulonglong)uVar3 >> 0x20) - *(int *)(this + 0x14)) - (uint)((uint)uVar3 < uVar2);
    *(int *)(this + 0x14) = iVar5;
    puVar1 = (uint *)(this + 0x18);
    uVar2 = *puVar1;
    *puVar1 = *puVar1 + uVar4;
    *(uint *)(this + 0x1c) = *(int *)(this + 0x1c) + iVar5 + (uint)CARRY4(uVar2,uVar4);
    puVar1 = (uint *)(this + 0x28);
    uVar2 = *puVar1;
    *puVar1 = *puVar1 + *(uint *)(this + 0x10);
    *(uint *)(this + 0x2c) =
         *(int *)(this + 0x2c) + iVar5 + (uint)CARRY4(uVar2,*(uint *)(this + 0x10));
    *(char **)(this + 0x30) = "MainThreadNoWait";
    uVar4 = *(uint *)(this + 0x18) - *(uint *)(this + 0x90);
    *(uint *)(this + 0x44) =
         (*(int *)(this + 0x1c) - *(int *)(this + 0x94)) -
         (uint)(*(uint *)(this + 0x18) < *(uint *)(this + 0x90));
    *(uint *)(this + 0x40) = uVar4;
    puVar1 = (uint *)(this + 0x50);
    uVar2 = *puVar1;
    *puVar1 = *puVar1 + uVar4;
    *(uint *)(this + 0x54) =
         *(int *)(this + 0x54) + *(int *)(this + 0x44) + (uint)CARRY4(uVar2,uVar4);
  }
  uVar2 = *(uint *)this;
  *(int *)this = *(int *)this + 1;
  *(uint *)(this + 4) = *(int *)(this + 4) + (uint)(0xfffffffe < uVar2);
  *(undefined4 *)(this + 0x20) = *(undefined4 *)(this + 0x18);
  *(undefined4 *)(this + 0x24) = *(undefined4 *)(this + 0x1c);
  *(undefined4 *)(this + 0x48) = *(undefined4 *)(this + 0x40);
  *(undefined4 *)(this + 0x4c) = *(undefined4 *)(this + 0x44);
  *(undefined4 *)(this + 0x70) = *(undefined4 *)(this + 0x68);
  *(undefined4 *)(this + 0x74) = *(undefined4 *)(this + 0x6c);
  *(undefined4 *)(this + 0x98) = *(undefined4 *)(this + 0x90);
  *(undefined4 *)(this + 0x9c) = *(undefined4 *)(this + 0x94);
  *(undefined4 *)(this + 0xc0) = *(undefined4 *)(this + 0xb8);
  *(undefined4 *)(this + 0xc4) = *(undefined4 *)(this + 0xbc);
  *(undefined4 *)(this + 0x18) = 0;
  *(undefined4 *)(this + 0x1c) = 0;
  *(undefined4 *)(this + 0x40) = 0;
  *(undefined4 *)(this + 0x44) = 0;
  *(undefined4 *)(this + 0x68) = 0;
  *(undefined4 *)(this + 0x6c) = 0;
  *(undefined4 *)(this + 0x90) = 0;
  *(undefined4 *)(this + 0x94) = 0;
  *(undefined4 *)(this + 0xb8) = 0;
  *(undefined4 *)(this + 0xbc) = 0;
  uVar3 = rdtsc();
  *(char **)(this + 8) = "MainThread";
  *(int *)(this + 0x10) = (int)uVar3;
  *(int *)(this + 0x14) = (int)((ulonglong)uVar3 >> 0x20);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_10010810(void)

{
  double in_XMM0_Qa;
  
  if (DAT_10833c6d == '\0') {
    DAT_10833c6d = '\x01';
    QueryPerformanceFrequency((LARGE_INTEGER *)&DAT_10833c78);
    FUN_10001aaf(DAT_10833c78,DAT_10833c7c);
    _DAT_10833c80 = 1.0 / in_XMM0_Qa;
    _DAT_10833c88 = _DAT_10833c80 * 1000.0;
    _DAT_10833c90 = _DAT_10833c80 * 1000000.0;
    QueryPerformanceCounter((LARGE_INTEGER *)&DAT_10833c98);
  }
  return;
}



void __cdecl GetCurrentDate(undefined4 *param_1,int *param_2,int *param_3)

{
  undefined local_30 [12];
  undefined4 local_24;
  int local_20;
  int local_1c;
  undefined4 local_c;
  undefined4 local_8;
  
                    // 0x10880  335  GetCurrentDate
  FUN_10022adf(&local_c);
  Plat_ConvertToLocalTime(local_c,local_8,(undefined (*) [16])local_30);
  *param_1 = local_24;
  *param_2 = local_20 + 1;
  *param_3 = local_1c + 0x76c;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

bool Is64BitOS(void)

{
  HMODULE hModule;
  HANDLE pvVar1;
  int iVar2;
  char *lpProcName;
  undefined *puVar3;
  
                    // 0x108d0  348  Is64BitOS
  if ((DAT_10833cc0 & 1) == 0) {
    lpProcName = "IsWow64Process";
    DAT_10833cc0 = DAT_10833cc0 | 1;
    hModule = GetModuleHandleA("kernel32");
    DAT_10833cbc = GetProcAddress(hModule,lpProcName);
  }
  if (DAT_10833cc8 == '\0') {
    DAT_10833cc8 = '\x01';
    if (DAT_10833cbc != (FARPROC)0x0) {
      puVar3 = &DAT_10833cc4;
      pvVar1 = GetCurrentProcess();
      iVar2 = (*DAT_10833cbc)(pvVar1,puVar3);
      if ((iVar2 != 0) && (_DAT_10833cc4 != 0)) {
        return true;
      }
    }
    return false;
  }
  return _DAT_10833cc4 == 1;
}



int __cdecl Plat_Alloc(undefined4 param_1)

{
  int iVar1;
  
                    // 0x10950  381  Plat_Alloc
  EnterCriticalSection((LPCRITICAL_SECTION)&DAT_10833c48);
  iVar1 = (**(code **)(*(int *)g_pMemAlloc + 4))(param_1);
  LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_10833c48);
  if (iVar1 != 0) {
    return iVar1;
  }
  (*(code *)PTR_AssertUseable_10046650)(param_1);
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined (*) [16] __cdecl
Plat_ConvertToLocalTime(undefined4 param_1,undefined4 param_2,undefined (*param_3) [16])

{
  int iVar1;
  int iVar2;
  int iVar3;
  undefined (*pauVar4) [16];
  undefined (*pauVar5) [16];
  undefined (*pauVar6) [16];
  tm *ptVar7;
  undefined in_XMM0 [16];
  undefined4 local_c;
  undefined4 local_8;
  
                    // 0x109a0  382  Plat_ConvertToLocalTime
  pauVar5 = (undefined (*) [16])GetCurrentThreadId();
  if (pauVar5 != DAT_10833c64) {
    pauVar6 = (undefined (*) [16])0x0;
    LOCK();
    pauVar4 = pauVar5;
    if (DAT_10833c64 != (undefined (*) [16])0x0) {
      pauVar6 = DAT_10833c64;
      pauVar4 = DAT_10833c64;
    }
    DAT_10833c64 = pauVar4;
    if (pauVar6 != (undefined (*) [16])0x0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)&DAT_10833c64,(uint)pauVar5,0);
      goto LAB_100109dc;
    }
  }
  _DAT_10833c68 = _DAT_10833c68 + 1;
LAB_100109dc:
  local_c = param_1;
  local_8 = param_2;
  ptVar7 = FUN_10022840((longlong *)&local_c);
  if (ptVar7 == (tm *)0x0) {
    *param_3 = in_XMM0 & (undefined  [16])0x0;
    param_3[1] = in_XMM0 & (undefined  [16])0x0;
    *(undefined4 *)param_3[2] = 0;
  }
  else {
    iVar1 = ptVar7->tm_min;
    iVar2 = ptVar7->tm_hour;
    iVar3 = ptVar7->tm_mday;
    *(int *)*param_3 = ptVar7->tm_sec;
    *(int *)(*param_3 + 4) = iVar1;
    *(int *)(*param_3 + 8) = iVar2;
    *(int *)(*param_3 + 0xc) = iVar3;
    iVar1 = ptVar7->tm_year;
    iVar2 = ptVar7->tm_wday;
    iVar3 = ptVar7->tm_yday;
    *(int *)param_3[1] = ptVar7->tm_mon;
    *(int *)(param_3[1] + 4) = iVar1;
    *(int *)(param_3[1] + 8) = iVar2;
    *(int *)(param_3[1] + 0xc) = iVar3;
    pauVar5 = (undefined (*) [16])ptVar7->tm_isdst;
    *(undefined (**) [16])param_3[2] = pauVar5;
    param_3 = pauVar5;
  }
  pauVar5 = DAT_10833c64;
  _DAT_10833c68 = _DAT_10833c68 + -1;
  if (_DAT_10833c68 == 0) {
    DAT_10833c64 = (undefined (*) [16])0x0;
    param_3 = pauVar5;
  }
  return param_3;
}



void __cdecl Plat_DebugString(LPCSTR param_1)

{
                    // 0x10a40  384  Plat_DebugString
  OutputDebugStringA(param_1);
  return;
}



void __cdecl Plat_ExitProcess(UINT param_1)

{
  HANDLE hProcess;
  
                    // 0x10a50  385  Plat_ExitProcess
  hProcess = GetCurrentProcess();
  TerminateProcess(hProcess,param_1);
  return;
}



void __cdecl Plat_ExitProcessWithError(UINT param_1,char param_2)

{
  char cVar1;
  BOOL BVar2;
  HANDLE hProcess;
  
                    // 0x10a70  386  Plat_ExitProcessWithError
  if ((DAT_10833c70 != (code *)0x0) && (cVar1 = (*DAT_10833c70)(param_1), cVar1 != '\0')) {
    return;
  }
  if ((param_2 != '\0') && (BVar2 = IsDebuggerPresent(), BVar2 == 0)) {
    WriteMiniDump();
  }
  hProcess = GetCurrentProcess();
  TerminateProcess(hProcess,param_1);
  return;
}



// WARNING: Could not reconcile some variable overlaps
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

float10 Plat_FloatTime(void)

{
  float10 fVar1;
  double in_XMM0_Qa;
  undefined8 local_c;
  
                    // 0x10ac0  388  Plat_FloatTime
  if (DAT_10833c6d == '\0') {
    FUN_10010810();
  }
  if (DAT_10833ca0 != '\0') {
    fVar1 = (float10)_DAT_10833ca8;
    _DAT_10833ca8 = (double)((float10)DAT_10046658 + fVar1);
    return (float10)DAT_10046658 + fVar1;
  }
  QueryPerformanceCounter(&local_c);
  FUN_10001aaf((uint)local_c - DAT_10833c98,
               (local_c._4_4_ - DAT_10833c9c) - (uint)((uint)local_c < DAT_10833c98));
  return (float10)(in_XMM0_Qa * _DAT_10833c80);
}



void __cdecl Plat_Free(undefined4 param_1)

{
                    // 0x10b30  389  Plat_Free
  EnterCriticalSection((LPCRITICAL_SECTION)&DAT_10833c48);
  (**(code **)(*(int *)g_pMemAlloc + 0x14))(param_1);
  LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_10833c48);
  return;
}



undefined8 Plat_GetClockStart(void)

{
                    // 0x10b60  390  Plat_GetClockStart
  if (DAT_10833c6d == '\0') {
    FUN_10010810();
  }
  return CONCAT44(DAT_10833c9c,DAT_10833c98);
}



LPSTR Plat_GetCommandLine(void)

{
  LPSTR pCVar1;
  
                    // WARNING: Could not recover jumptable at 0x10010b80. Too many branches
                    // WARNING: Treating indirect jump as call
                    // 0x10b80  391  Plat_GetCommandLine
                    // 0x10b80  392  Plat_GetCommandLineA
  pCVar1 = GetCommandLineA();
  return pCVar1;
}



void __cdecl Plat_GetLocalTime(undefined (*param_1) [16])

{
  undefined4 local_c;
  undefined4 local_8;
  
                    // 0x10b90  394  Plat_GetLocalTime
  FUN_10022adf(&local_c);
  Plat_ConvertToLocalTime(local_c,local_8,param_1);
  return;
}



void __cdecl Plat_GetModuleFilename(LPSTR param_1,DWORD param_2)

{
  DWORD DVar1;
  
                    // 0x10bc0  396  Plat_GetModuleFilename
  SetLastError(0);
  GetModuleFileNameA((HMODULE)0x0,param_1,param_2);
  DVar1 = GetLastError();
  if (DVar1 != 0) {
    Error((byte *)"Plat_GetModuleFilename: The buffer given is too small (%d bytes).");
    return;
  }
  return;
}



int Plat_GetOSVersion(void)

{
  BOOL BVar1;
  _OSVERSIONINFOA local_98;
  
                    // 0x10c00  397  Plat_GetOSVersion
  local_98.dwOSVersionInfoSize = 0x94;
  BVar1 = GetVersionExA(&local_98);
  if (BVar1 != 0) {
    if (0x18 < local_98.dwMajorVersion) {
      local_98.dwMajorVersion = 0x18;
    }
    return local_98.dwMinorVersion + (local_98.dwMajorVersion - local_98.dwMinorVersion / 10) * 10;
  }
  return -1;
}



undefined8 Plat_GetTime(void)

{
  undefined8 local_c;
  
                    // 0x10c60  400  Plat_GetTime
  FUN_10022adf((undefined4 *)&local_c);
  return local_c;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

char * __cdecl Plat_GetTimeString(int *param_1,char *param_2,size_t param_3)

{
  char *pcVar1;
  char *pcVar2;
  char *pcVar3;
  
                    // 0x10c80  401  Plat_GetTimeString
  pcVar2 = (char *)GetCurrentThreadId();
  if (pcVar2 != DAT_10833c64) {
    pcVar3 = (char *)0x0;
    LOCK();
    pcVar1 = pcVar2;
    if (DAT_10833c64 != (char *)0x0) {
      pcVar3 = DAT_10833c64;
      pcVar1 = DAT_10833c64;
    }
    DAT_10833c64 = pcVar1;
    if (pcVar3 != (char *)0x0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)&DAT_10833c64,(uint)pcVar2,0);
      goto LAB_10010cb9;
    }
  }
  _DAT_10833c68 = _DAT_10833c68 + 1;
LAB_10010cb9:
  pcVar2 = FUN_10022b30(param_1);
  pcVar3 = _strncpy(param_2,pcVar2,param_3);
  param_2[param_3 - 1] = '\0';
  pcVar2 = DAT_10833c64;
  _DAT_10833c68 = _DAT_10833c68 + -1;
  if (_DAT_10833c68 == 0) {
    DAT_10833c64 = (char *)0x0;
    pcVar3 = pcVar2;
  }
  return pcVar3;
}



undefined Plat_IsInBenchmarkMode(void)

{
                    // 0x10cf0  403  Plat_IsInBenchmarkMode
  return DAT_10833ca0;
}



bool Plat_IsInDebugSession(void)

{
  BOOL BVar1;
  
                    // 0x10d00  404  Plat_IsInDebugSession
  BVar1 = IsDebuggerPresent();
  return BVar1 != 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulonglong Plat_MSTime(void)

{
  ulonglong uVar1;
  uint local_c;
  int local_8;
  
                    // 0x10d10  406  Plat_MSTime
  if (DAT_10833c6d == '\0') {
    FUN_10010810();
  }
  if (DAT_10833ca0 != '\0') {
    _DAT_10833ca8 = DAT_10046658 + _DAT_10833ca8;
    uVar1 = FUN_100018f1();
    return uVar1;
  }
  QueryPerformanceCounter((LARGE_INTEGER *)&local_c);
  FUN_10001aaf(local_c - DAT_10833c98,(local_8 - DAT_10833c9c) - (uint)(local_c < DAT_10833c98));
  uVar1 = FUN_100018f1();
  return uVar1;
}



void __cdecl Plat_MessageBox(LPCSTR param_1,LPCSTR param_2)

{
                    // 0x10d90  407  Plat_MessageBox
  MessageBoxA((HWND)0x0,param_2,param_1,0);
  return;
}



int __cdecl Plat_Realloc(undefined4 param_1,undefined4 param_2)

{
  int iVar1;
  
                    // 0x10db0  409  Plat_Realloc
  EnterCriticalSection((LPCRITICAL_SECTION)&DAT_10833c48);
  iVar1 = (**(code **)(*(int *)g_pMemAlloc + 0xc))(param_1,param_2);
  LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_10833c48);
  if (iVar1 != 0) {
    return iVar1;
  }
  (*(code *)PTR_AssertUseable_10046650)(param_2);
  return 0;
}



void __cdecl Plat_SetAllocErrorFn(undefined *param_1)

{
  PTR_AssertUseable_10046650 = param_1;
                    // 0x10e00  411  Plat_SetAllocErrorFn
  return;
}



void __cdecl Plat_SetBenchmarkMode(undefined4 param_1)

{
  DAT_10833ca0 = (undefined)param_1;
                    // 0x10e10  412  Plat_SetBenchmarkMode
  return;
}



void __cdecl Plat_SetExitProcessWithErrorCB(undefined4 param_1)

{
  DAT_10833c70 = param_1;
                    // 0x10e20  413  Plat_SetExitProcessWithErrorCB
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulonglong Plat_USTime(void)

{
  ulonglong uVar1;
  uint local_c;
  int local_8;
  
                    // 0x10e30  417  Plat_USTime
  if (DAT_10833c6d == '\0') {
    FUN_10010810();
  }
  if (DAT_10833ca0 != '\0') {
    _DAT_10833ca8 = DAT_10046658 + _DAT_10833ca8;
    uVar1 = FUN_10001900();
    return uVar1;
  }
  QueryPerformanceCounter((LARGE_INTEGER *)&local_c);
  FUN_10001aaf(local_c - DAT_10833c98,(local_8 - DAT_10833c9c) - (uint)(local_c < DAT_10833c98));
  uVar1 = FUN_10001900();
  return uVar1;
}



undefined * __cdecl Plat_ctime(longlong *param_1,undefined *param_2,uint param_3)

{
  int iVar1;
  
                    // 0x10eb0  422  Plat_ctime
  iVar1 = FUN_10022f24(param_2,param_3,param_1);
  if (iVar1 == 0x16) {
    param_2 = (undefined *)0x0;
  }
  return param_2;
}



undefined4 Plat_daylight(void)

{
                    // 0x10ee0  423  Plat_daylight
  return DAT_1004744c;
}



void __cdecl Plat_getwd(LPSTR param_1,uint param_2)

{
                    // 0x10ef0  424  Plat_getwd
  FUN_100234a0(param_1,param_2);
  V_tier0_strncat(param_1,"\\",param_2,0xffffffff);
  return;
}



tm * __cdecl Plat_localtime(longlong *param_1,tm *param_2)

{
  int iVar1;
  
                    // 0x10f20  425  Plat_localtime
  iVar1 = FUN_10022865(param_2,param_1);
  if (iVar1 == 0x16) {
    param_2 = (tm *)0x0;
  }
  return param_2;
}



void __cdecl Plat_timegm(int *param_1)

{
                    // 0x10f40  426  Plat_timegm
  FUN_100231e1(param_1,0);
  return;
}



undefined4 Plat_timezone(void)

{
                    // 0x10f50  427  Plat_timezone
  return DAT_10047448;
}



void __cdecl Platform_gmtime(undefined4 param_1,undefined4 param_2,uint *param_3)

{
  undefined4 local_c;
  undefined4 local_8;
  
                    // 0x10f60  428  Platform_gmtime
  local_c = param_1;
  local_8 = param_2;
  FUN_10022fb6(param_3,(longlong *)&local_c);
  return;
}



undefined4 __cdecl vtune(char param_1)

{
  HMODULE hModule;
  FARPROC pFVar1;
  int iVar2;
  
                    // 0x10f90  511  vtune
  if (DAT_10833cb0 == '\0') {
    DAT_10833cb0 = '\x01';
    hModule = LoadLibraryA("vtuneapi.dll");
    if (hModule != (HMODULE)0x0) {
      DAT_10833cb4 = GetProcAddress(hModule,"VTResume");
      DAT_10833cb8 = GetProcAddress(hModule,"VTPause");
    }
  }
  pFVar1 = DAT_10833cb8;
  if (param_1 != '\0') {
    pFVar1 = DAT_10833cb4;
  }
  if (pFVar1 == (FARPROC)0x0) {
    return 0;
  }
  iVar2 = (*pFVar1)();
  return CONCAT31((int3)((uint)iVar2 >> 8),1);
}



void __cdecl GetCurrentDayOfTheWeek(int *param_1)

{
  tm *ptVar1;
  longlong local_c;
  
                    // 0x11000  336  GetCurrentDayOfTheWeek
  FUN_10022adf((undefined4 *)&local_c);
  ptVar1 = FUN_10022840(&local_c);
  *param_1 = ptVar1->tm_wday;
  return;
}



void __cdecl GetCurrentDayOfTheYear(int *param_1)

{
  tm *ptVar1;
  longlong local_c;
  
                    // 0x11030  337  GetCurrentDayOfTheYear
  FUN_10022adf((undefined4 *)&local_c);
  ptVar1 = FUN_10022840(&local_c);
  *param_1 = ptVar1->tm_yday;
  return;
}



void __cdecl
Plat_CreateWindow(HINSTANCE param_1,LPCSTR param_2,int param_3,int param_4,byte param_5)

{
  DWORD dwStyle;
  WNDCLASSEXA local_44;
  tagRECT local_14;
  
                    // 0x11060  383  Plat_CreateWindow
  FUN_10021290(&local_44.cbSize,0,0x30);
  local_44.lpfnWndProc = DefWindowProcA_exref;
  local_44.cbSize = 0x30;
  local_44.style = 0x28;
  local_44.hInstance = param_1;
  local_44.lpszClassName = "Valve001";
  local_44.hIcon = (HICON)0x0;
  local_44.hIconSm = (HICON)0x0;
  RegisterClassExA(&local_44);
  dwStyle = 0x84000000;
  if ((param_5 & 1) == 0) {
    dwStyle = ((int)(char)param_5 & 2U) << 0x11 | 0x84cb0000;
  }
  local_14.right = param_3;
  local_14.bottom = param_4;
  local_14.top = 0;
  local_14.left = 0;
  AdjustWindowRectEx(&local_14,dwStyle,0,0);
  CreateWindowExA(0,local_44.lpszClassName,param_2,dwStyle,0,0,local_14.right - local_14.left,
                  local_14.bottom - local_14.top,(HWND)0x0,(HMENU)0x0,param_1,(LPVOID)0x0);
  return;
}



void __cdecl Plat_GetDesktopResolution(int *param_1,int *param_2)

{
  int iVar1;
  
                    // 0x11130  393  Plat_GetDesktopResolution
  iVar1 = GetSystemMetrics(0);
  *param_1 = iVar1;
  iVar1 = GetSystemMetrics(1);
  *param_2 = iVar1;
  return;
}



HWND Plat_GetShellWindow(void)

{
  HWND pHVar1;
  
                    // WARNING: Could not recover jumptable at 0x10011150. Too many branches
                    // WARNING: Treating indirect jump as call
                    // 0x11150  399  Plat_GetShellWindow
  pHVar1 = GetShellWindow();
  return pHVar1;
}



void __cdecl Plat_GetWindowClientSize(HWND param_1,int *param_2,int *param_3)

{
  tagRECT local_14;
  
                    // 0x11160  402  Plat_GetWindowClientSize
  GetClientRect(param_1,&local_14);
  *param_2 = local_14.right - local_14.left;
  *param_3 = local_14.bottom - local_14.top;
  return;
}



bool __cdecl Plat_IsWindowMinimized(HWND param_1)

{
  BOOL BVar1;
  
                    // 0x11190  405  Plat_IsWindowMinimized
  BVar1 = IsIconic(param_1);
  return BVar1 != 0;
}



void __cdecl Plat_ScreenToWindowCoords(HWND param_1,LONG *param_2,LONG *param_3)

{
  tagPOINT local_c;
  
                    // 0x111b0  410  Plat_ScreenToWindowCoords
  local_c.x = *param_2;
  local_c.y = *param_3;
  ScreenToClient(param_1,&local_c);
  *param_2 = local_c.x;
  *param_3 = local_c.y;
  return;
}



void __cdecl Plat_SetWindowPos(HWND param_1,int param_2,int param_3)

{
                    // 0x111f0  414  Plat_SetWindowPos
  SetWindowPos(param_1,(HWND)0x0,param_2,param_3,0,0,0x65);
  return;
}



void __cdecl Plat_SetWindowTitle(HWND param_1,LPCSTR param_2)

{
                    // 0x11210  415  Plat_SetWindowTitle
  SetWindowTextA(param_1,param_2);
  return;
}



void __cdecl Plat_WindowToScreenCoords(HWND param_1,LONG *param_2,LONG *param_3)

{
  tagPOINT local_c;
  
                    // 0x11230  421  Plat_WindowToScreenCoords
  local_c.x = *param_2;
  local_c.y = *param_3;
  ClientToScreen(param_1,&local_c);
  *param_2 = local_c.x;
  *param_3 = local_c.y;
  return;
}



int * __fastcall FUN_10011270(int *param_1)

{
  undefined4 *puVar1;
  
  *param_1 = DAT_10833ce4;
  DAT_10833ce4 = DAT_10833ce4 + 1;
  puVar1 = (undefined4 *)FUN_1001f8b3(0x30);
  if (puVar1 == (undefined4 *)0x0) {
    puVar1 = (undefined4 *)0x0;
  }
  else {
    puVar1 = FUN_100112d0(puVar1);
  }
  param_1[1] = (int)puVar1;
  param_1[6] = 0;
  param_1[2] = 0;
  param_1[3] = 0;
  param_1[4] = 0;
  param_1[5] = 0;
  return param_1;
}



undefined4 * __fastcall FUN_100112d0(undefined4 *param_1)

{
  undefined4 *puVar1;
  
  puVar1 = FUN_10011e20();
  param_1[3] = puVar1;
  param_1[10] = 0;
  param_1[0xb] = param_1 + 1;
  *(undefined2 *)(param_1 + 1) = 0;
  param_1[4] = 0x18000000;
  param_1[5] = 0;
  param_1[6] = 0x3e000;
  param_1[7] = 0;
  param_1[2] = "BSQ_cache_reference";
  *param_1 = 0;
  param_1[9] = 0x360;
  param_1[8] = 0x300;
  param_1[10] = 0x3a0;
  return param_1;
}



void __fastcall FUN_10011330(int param_1)

{
  if (*(void **)(param_1 + 4) != (void *)0x0) {
    FID_conflict__free(*(void **)(param_1 + 4));
    *(undefined4 *)(param_1 + 4) = 0;
  }
  return;
}



undefined4 * __thiscall FUN_10011350(void *this,byte param_1)

{
  *(undefined ***)this = std::error_category::vftable;
  if ((param_1 & 1) != 0) {
    FID_conflict__free(this);
  }
  return (undefined4 *)this;
}



// WARNING: Could not reconcile some variable overlaps

void __fastcall FUN_10011380(int param_1)

{
  uint *puVar1;
  int iVar2;
  uint uVar3;
  int iVar5;
  undefined8 local_c;
  uint uVar4;
  
  iVar2 = *(int *)(param_1 + 4);
  if (iVar2 != 0) {
    local_c = 0;
    FUN_10011e80(*(void **)(iVar2 + 0xc),*(undefined4 *)(iVar2 + 0x20),&local_c);
    iVar2 = *(int *)(param_1 + 4);
    puVar1 = (uint *)(iVar2 + 0x18);
    *(uint *)(param_1 + 0x10) = (uint)local_c;
    uVar3 = *(uint *)(param_1 + 8);
    uVar4 = *(uint *)(param_1 + 8);
    *(int *)(param_1 + 0x14) = local_c._4_4_;
    iVar5 = *(int *)(param_1 + 0xc);
    *puVar1 = *puVar1 & 0xffffefff;
    local_c = local_c & 0xffffffff |
              (ulonglong)((local_c._4_4_ - iVar5) - (uint)((uint)local_c < uVar3)) << 0x20;
    *(undefined4 *)(iVar2 + 0x1c) = *(undefined4 *)(iVar2 + 0x1c);
    FUN_10011ed0(*(void **)(iVar2 + 0xc),*(DWORD *)(iVar2 + 0x24),puVar1);
    *(uint *)(param_1 + 0x18) = (uint)local_c - uVar4;
  }
  return;
}



// WARNING: Could not reconcile some variable overlaps

void __fastcall FUN_100113f0(int param_1)

{
  uint *puVar1;
  ushort *puVar2;
  int iVar3;
  undefined8 local_c;
  
  if (*(int *)(param_1 + 4) != 0) {
    puVar2 = *(ushort **)(*(int *)(param_1 + 4) + 0x2c);
    *puVar2 = *puVar2 | 0x100;
    iVar3 = *(int *)(param_1 + 4);
    puVar1 = (uint *)(iVar3 + 0x10);
    *puVar1 = *puVar1 | 4;
    *puVar1 = *puVar1 | 8;
    *(undefined4 *)(iVar3 + 0x14) = *(undefined4 *)(iVar3 + 0x14);
    *(undefined4 *)(iVar3 + 0x14) = *(undefined4 *)(iVar3 + 0x14);
    *puVar1 = (uint)*(ushort *)(iVar3 + 4) << 9 | *puVar1 & 0xfe0001ff;
    FUN_10011ed0(*(void **)(iVar3 + 0xc),*(DWORD *)(iVar3 + 0x28),puVar1);
    iVar3 = *(int *)(param_1 + 4);
    puVar1 = (uint *)(iVar3 + 0x18);
    *puVar1 = *puVar1 & 0xffffefff;
    *(undefined4 *)(iVar3 + 0x1c) = *(undefined4 *)(iVar3 + 0x1c);
    FUN_10011ed0(*(void **)(iVar3 + 0xc),*(DWORD *)(iVar3 + 0x24),puVar1);
    local_c = 0;
    FUN_10011ed0(*(void **)(*(int *)(param_1 + 4) + 0xc),*(DWORD *)(*(int *)(param_1 + 4) + 0x20),
                 (undefined4 *)&local_c);
    iVar3 = *(int *)(param_1 + 4);
    puVar1 = (uint *)(iVar3 + 0x18);
    *puVar1 = *puVar1 | 0x1000;
    *(undefined4 *)(iVar3 + 0x1c) = *(undefined4 *)(iVar3 + 0x1c);
    FUN_10011ed0(*(void **)(iVar3 + 0xc),*(DWORD *)(iVar3 + 0x24),puVar1);
    local_c = 0;
    FUN_10011e80(*(void **)(*(int *)(param_1 + 4) + 0xc),
                 *(undefined4 *)(*(int *)(param_1 + 4) + 0x20),&local_c);
    *(undefined4 *)(param_1 + 8) = (undefined4)local_c;
    *(undefined4 *)(param_1 + 0xc) = local_c._4_4_;
  }
  return;
}



void __thiscall FUN_100114d0(void *this,void *param_1,void *param_2)

{
  uint uVar1;
  uint uVar2;
  void *_Src;
  void *pvVar3;
  undefined4 *in_FS_OFFSET;
  undefined4 local_10;
  code *pcStack12;
  undefined4 local_8;
  
  pcStack12 = FUN_10034fa0;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_10;
  pvVar3 = (void *)((uint)param_1 | 0xf);
  if (pvVar3 != (void *)0xffffffff) {
    uVar1 = *(uint *)((int)this + 0x14);
    uVar2 = uVar1 >> 1;
    param_1 = pvVar3;
    if (((uint)pvVar3 / 3 < uVar2) && (param_1 = (void *)(uVar2 + uVar1), -uVar2 - 2 < uVar1)) {
      param_1 = (void *)0xfffffffe;
    }
  }
  local_8 = 0;
  pvVar3 = (void *)FUN_10011610((int)param_1 + 1);
  local_8 = 0xffffffff;
  if (param_2 != (void *)0x0) {
    _Src = this;
    if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
      _Src = *this;
    }
    if (param_2 != (void *)0x0) {
      FID_conflict__memcpy(pvVar3,_Src,(size_t)param_2);
    }
  }
  if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
    FID_conflict__free(*this);
  }
  *(undefined *)this = 0;
  *(void **)this = pvVar3;
  *(void **)((int)this + 0x14) = param_1;
  *(void **)((int)this + 0x10) = param_2;
  if ((void *)0xf < param_1) {
    this = pvVar3;
  }
  *(undefined *)((int)this + (int)param_2) = 0;
  *in_FS_OFFSET = local_10;
  return;
}



undefined * Catch_1001154d(void)

{
  int iVar1;
  int unaff_EBP;
  
  *(BADSPACEBASE **)(unaff_EBP + -0x10) = register0x00000010;
  *(int *)(unaff_EBP + -0x20) = *(int *)(unaff_EBP + 8);
  *(undefined *)(unaff_EBP + -4) = 2;
  iVar1 = FUN_10011610(*(int *)(unaff_EBP + 8) + 1);
  *(int *)(unaff_EBP + -0x18) = iVar1;
  *(undefined4 *)(unaff_EBP + -4) = 1;
  return &DAT_10011574;
}



void Catch_100115e2(void)

{
  void **ppvVar1;
  code *pcVar2;
  int unaff_EBP;
  
  ppvVar1 = *(void ***)(unaff_EBP + -0x1c);
  if ((void *)0xf < ppvVar1[5]) {
    FID_conflict__free(*ppvVar1);
  }
  ppvVar1[5] = (void *)0xf;
  ppvVar1[4] = (void *)0x0;
  *(undefined *)ppvVar1 = 0;
  FUN_1002364d((int *)0x0,(byte *)0x0);
  pcVar2 = (code *)swi(3);
  (*pcVar2)();
  return;
}



int FUN_10011610(size_t param_1)

{
  code *pcVar1;
  int iVar2;
  
  if (param_1 == 0) {
    return 0;
  }
  if ((true) && (iVar2 = FUN_1001f8b3(param_1), iVar2 != 0)) {
    return iVar2;
  }
  FUN_10034d37();
  pcVar1 = (code *)swi(3);
  iVar2 = (*pcVar1)();
  return iVar2;
}



int ** __thiscall FUN_10011640(void *this,int **param_1,int *param_2,int *param_3)

{
  undefined *puVar1;
  code *pcVar2;
  int **ppiVar3;
  void *_Dst;
  int *_Size;
  
  if (param_1[4] < param_2) {
    FUN_10034d96("invalid string position");
  }
  else {
    _Size = (int *)((int)param_1[4] - (int)param_2);
    if (param_3 < _Size) {
      _Size = param_3;
    }
    if ((int **)this != param_1) {
      if (_Size != (int *)0xffffffff) {
        if (*(int **)((int)this + 0x14) < _Size) {
          FUN_100114d0(this,_Size,*(void **)((int)this + 0x10));
          if (_Size == (int *)0x0) {
            return (int **)this;
          }
        }
        else if (_Size == (int *)0x0) {
          *(undefined4 *)((int)this + 0x10) = 0;
          if (&DAT_00000010 <= *(int **)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
            **this = 0;
            return (int **)this;
          }
          *(undefined *)this = 0;
          return (int **)this;
        }
        if ((int *)0xf < param_1[5]) {
          param_1 = (int **)*param_1;
        }
        _Dst = this;
        if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
          _Dst = *this;
        }
        if (_Size != (int *)0x0) {
          FID_conflict__memcpy(_Dst,(void *)((int)param_1 + (int)param_2),(size_t)_Size);
        }
        *(int **)((int)this + 0x10) = _Size;
        if (*(uint *)((int)this + 0x14) < 0x10) {
          *(undefined *)((int)this + (int)_Size) = 0;
          return (int **)this;
        }
                    // WARNING: Load size is inaccurate
        *(undefined *)(*this + (int)_Size) = 0;
        return (int **)this;
      }
      goto LAB_10011756;
    }
    puVar1 = (undefined *)((int)_Size + (int)param_2);
    if (puVar1 <= *(undefined **)((int)this + 0x10)) {
      *(undefined **)((int)this + 0x10) = puVar1;
      if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
        puVar1[*this] = 0;
        FUN_10011930(this,(int *)0x0,(uint)param_2);
        return (int **)this;
      }
      *(undefined *)((int)this + (int)puVar1) = 0;
      FUN_10011930(this,(int *)0x0,(uint)param_2);
      return (int **)this;
    }
  }
  FUN_10034d96("invalid string position");
LAB_10011756:
  FUN_10034d68("string too long");
  pcVar2 = (code *)swi(3);
  ppiVar3 = (int **)(*pcVar2)();
  return ppiVar3;
}



int ** __thiscall FUN_10011770(void *this,int **param_1,int *param_2)

{
  uint uVar1;
  code *pcVar2;
  int **ppiVar3;
  void *pvVar4;
  
  if (param_1 != (int **)0x0) {
    uVar1 = *(uint *)((int)this + 0x14);
    ppiVar3 = (int **)this;
    if (0xf < uVar1) {
                    // WARNING: Load size is inaccurate
      ppiVar3 = *this;
    }
    if (ppiVar3 <= param_1) {
      pvVar4 = this;
      if (0xf < uVar1) {
                    // WARNING: Load size is inaccurate
        pvVar4 = *this;
      }
      if (param_1 < (int **)(*(int *)((int)this + 0x10) + (int)pvVar4)) {
        if (0xf < uVar1) {
                    // WARNING: Load size is inaccurate
          ppiVar3 = FUN_10011640(this,(int **)this,(int *)((int)param_1 - *this),param_2);
          return ppiVar3;
        }
        ppiVar3 = FUN_10011640(this,(int **)this,(int *)((int)param_1 - (int)this),param_2);
        return ppiVar3;
      }
    }
  }
  if (param_2 == (int *)0xffffffff) {
    FUN_10034d68("string too long");
    pcVar2 = (code *)swi(3);
    ppiVar3 = (int **)(*pcVar2)();
    return ppiVar3;
  }
  if (*(int **)((int)this + 0x14) < param_2) {
    FUN_100114d0(this,param_2,*(void **)((int)this + 0x10));
    if (param_2 == (int *)0x0) {
      return (int **)this;
    }
  }
  else if (param_2 == (int *)0x0) {
    *(undefined4 *)((int)this + 0x10) = 0;
    if (&DAT_00000010 <= *(int **)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
      **this = 0;
      return (int **)this;
    }
    *(undefined *)this = 0;
    return (int **)this;
  }
  pvVar4 = this;
  if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
    pvVar4 = *this;
  }
  if (param_2 != (int *)0x0) {
    FID_conflict__memcpy(pvVar4,param_1,(size_t)param_2);
  }
  *(int **)((int)this + 0x10) = param_2;
  if (*(uint *)((int)this + 0x14) < 0x10) {
    *(undefined *)((int)this + (int)param_2) = 0;
    return (int **)this;
  }
                    // WARNING: Load size is inaccurate
  *(undefined *)(*this + (int)param_2) = 0;
  return (int **)this;
}



void FUN_10011870(int *param_1,int param_2)

{
  int iVar1;
  
  iVar1 = FUN_10034dc4(param_2);
  *param_1 = param_2;
  if (iVar1 != 0) {
    param_1[1] = (int)&PTR_vftable_10046660;
    return;
  }
  param_1[1] = (int)&PTR_vftable_10046668;
  return;
}



void __thiscall FUN_100118b0(void *this,undefined4 *param_1,undefined4 param_2)

{
  *param_1 = param_2;
  param_1[1] = this;
  return;
}



uint __thiscall FUN_100118d0(void *this,int *param_1,int param_2)

{
  if ((this == (void *)param_1[1]) && (param_1 = (int *)*param_1, param_1 == (int *)param_2)) {
    return CONCAT31((int3)((uint)param_1 >> 8),1);
  }
  return (uint)param_1 & 0xffffff00;
}



uint __thiscall FUN_100118f0(void *this,undefined4 param_1,int *param_2)

{
  int *piVar1;
  undefined local_c [8];
  
                    // WARNING: Load size is inaccurate
  piVar1 = (int *)(**(code **)(*this + 0xc))(local_c,param_1);
  if ((piVar1[1] == param_2[1]) && (piVar1 = (int *)*piVar1, piVar1 == (int *)*param_2)) {
    return CONCAT31((int3)((uint)piVar1 >> 8),1);
  }
  return (uint)piVar1 & 0xffffff00;
}



int ** __thiscall FUN_10011930(void *this,int *param_1,uint param_2)

{
  int *piVar1;
  code *pcVar2;
  void *pvVar3;
  int **ppiVar4;
  int iVar5;
  
  piVar1 = *(int **)((int)this + 0x10);
  if (piVar1 < param_1) {
    FUN_10034d96("invalid string position");
    pcVar2 = (code *)swi(3);
    ppiVar4 = (int **)(*pcVar2)();
    return ppiVar4;
  }
  if (param_2 < (uint)((int)piVar1 - (int)param_1)) {
    if (param_2 != 0) {
      pvVar3 = this;
      if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
        pvVar3 = *this;
      }
      iVar5 = (int)piVar1 - param_2;
      if (iVar5 - (int)param_1 != 0) {
        FID_conflict__memcpy
                  ((void *)((int)pvVar3 + (int)param_1),
                   (void *)((int)(void *)((int)pvVar3 + (int)param_1) + param_2),
                   iVar5 - (int)param_1);
      }
      *(int *)((int)this + 0x10) = iVar5;
      if (0xf < *(uint *)((int)this + 0x14)) {
                    // WARNING: Load size is inaccurate
        *(undefined *)(*this + iVar5) = 0;
        return (int **)this;
      }
      *(undefined *)((int)this + iVar5) = 0;
    }
    return (int **)this;
  }
  *(int **)((int)this + 0x10) = param_1;
  if (*(uint *)((int)this + 0x14) < 0x10) {
    *(undefined *)((int)this + (int)param_1) = 0;
    return (int **)this;
  }
                    // WARNING: Load size is inaccurate
  *(undefined *)(*this + (int)param_1) = 0;
  return (int **)this;
}



undefined * FUN_100119d0(undefined *param_1,int param_2)

{
  char cVar1;
  int **ppiVar2;
  int **ppiVar3;
  
  ppiVar2 = (int **)FUN_10034dc4(param_2);
  ppiVar3 = (int **)"unknown error";
  if (ppiVar2 != (int **)0x0) {
    ppiVar3 = ppiVar2;
  }
  *(undefined4 *)(param_1 + 0x14) = 0xf;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *param_1 = 0;
  if (*(char *)ppiVar3 == '\0') {
    FUN_10011770(param_1,ppiVar3,(int *)0x0);
    return param_1;
  }
  ppiVar2 = ppiVar3;
  do {
    cVar1 = *(char *)ppiVar2;
    ppiVar2 = (int **)((int)ppiVar2 + 1);
  } while (cVar1 != '\0');
  FUN_10011770(param_1,ppiVar3,(int *)((int)ppiVar2 - ((int)ppiVar3 + 1)));
  return param_1;
}



undefined * FUN_10011a40(undefined *param_1,int param_2)

{
  if (param_2 == 1) {
    *(undefined4 *)(param_1 + 0x14) = 0xf;
    *(undefined4 *)(param_1 + 0x10) = 0;
    *param_1 = 0;
    FUN_10011770(param_1,(int **)"iostream stream error",(int *)0x15);
    return param_1;
  }
  FUN_100119d0(param_1,param_2);
  return param_1;
}



undefined * FUN_10011a90(undefined *param_1,int param_2)

{
  char cVar1;
  int **ppiVar2;
  int **ppiVar3;
  
  ppiVar2 = (int **)FUN_10034dee(param_2);
  ppiVar3 = (int **)"unknown error";
  if (ppiVar2 != (int **)0x0) {
    ppiVar3 = ppiVar2;
  }
  *(undefined4 *)(param_1 + 0x14) = 0xf;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *param_1 = 0;
  if (*(char *)ppiVar3 == '\0') {
    FUN_10011770(param_1,ppiVar3,(int *)0x0);
    return param_1;
  }
  ppiVar2 = ppiVar3;
  do {
    cVar1 = *(char *)ppiVar2;
    ppiVar2 = (int **)((int)ppiVar2 + 1);
  } while (cVar1 != '\0');
  FUN_10011770(param_1,ppiVar3,(int *)((int)ppiVar2 - ((int)ppiVar3 + 1)));
  return param_1;
}



char * FUN_10011b00(void)

{
  return "generic";
}



char * FUN_10011b10(void)

{
  return "iostream";
}



char * FUN_10011b20(void)

{
  return "system";
}



void InitPME(void)

{
  undefined4 *puVar1;
  HANDLE pvVar2;
  DWORD dwPriorityClass;
  int nPriority;
  
                    // 0x11b30  345  InitPME
  puVar1 = FUN_10011e20();
  if (puVar1 == (undefined4 *)0x0) {
    DevMsg(1,(byte *)"PME Uninitialized.\n");
    DAT_10834fc4 = 0;
  }
  else if ((puVar1[6] == 0) && ((puVar1[0xd] & 0xf00) == 0xf00)) {
    dwPriorityClass = 0x100;
    pvVar2 = GetCurrentProcess();
    SetPriorityClass(pvVar2,dwPriorityClass);
    nPriority = 2;
    pvVar2 = GetCurrentThread();
    SetThreadPriority(pvVar2,nPriority);
    DevMsg(1,(byte *)"PME Initialized.\n");
    DAT_10834fc4 = 1;
    return;
  }
  return;
}



void ShutdownPME(void)

{
  undefined4 *puVar1;
  HANDLE pvVar2;
  DWORD dwPriorityClass;
  int nPriority;
  
                    // 0x11bb0  454  ShutdownPME
  puVar1 = FUN_10011e20();
  if (puVar1 != (undefined4 *)0x0) {
    dwPriorityClass = 0x20;
    pvVar2 = GetCurrentProcess();
    SetPriorityClass(pvVar2,dwPriorityClass);
    nPriority = 0;
    pvVar2 = GetCurrentThread();
    SetThreadPriority(pvVar2,nPriority);
  }
  DAT_10834fc4 = 0;
  return;
}



undefined4 * __fastcall FUN_10011be0(undefined4 *param_1)

{
  undefined4 *puVar1;
  longlong lVar2;
  uint uVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  int iVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  uint local_c;
  
  param_1[5] = 0xf;
  param_1[4] = 0;
  *(undefined *)param_1 = 0;
  param_1[0xc] = 0xf;
  param_1[0xb] = 0;
  *(undefined *)(param_1 + 7) = 0;
  param_1[0x10] = 0;
  uVar3 = FUN_10011f30(param_1);
  lVar2 = (ulonglong)(uVar3 * 4) * 4;
  puVar4 = (undefined4 *)FUN_10023b7a(-(uint)((int)((ulonglong)lVar2 >> 0x20) != 0) | (uint)lVar2);
  local_c = 1;
  if (uVar3 != 0) {
    do {
      puVar5 = puVar4 + local_c * 4 + -4;
      if (local_c == 0) {
        puVar1 = (undefined4 *)cpuid_basic_info(0);
      }
      else if (local_c == 1) {
        puVar1 = (undefined4 *)cpuid_Version_info(1);
      }
      else if (local_c == 2) {
        puVar1 = (undefined4 *)cpuid_cache_tlb_info(2);
      }
      else if (local_c == 3) {
        puVar1 = (undefined4 *)cpuid_serial_info(3);
      }
      else if (local_c == 4) {
        puVar1 = (undefined4 *)cpuid_Deterministic_Cache_Parameters_info(4);
      }
      else if (local_c == 5) {
        puVar1 = (undefined4 *)cpuid_MONITOR_MWAIT_Features_info(5);
      }
      else if (local_c == 6) {
        puVar1 = (undefined4 *)cpuid_Thermal_Power_Management_info(6);
      }
      else if (local_c == 7) {
        puVar1 = (undefined4 *)cpuid_Extended_Feature_Enumeration_info(7);
      }
      else if (local_c == 9) {
        puVar1 = (undefined4 *)cpuid_Direct_Cache_Access_info(9);
      }
      else if (local_c == 10) {
        puVar1 = (undefined4 *)cpuid_Architectural_Performance_Monitoring_info(10);
      }
      else if (local_c == 0xb) {
        puVar1 = (undefined4 *)cpuid_Extended_Topology_info(0xb);
      }
      else if (local_c == 0xd) {
        puVar1 = (undefined4 *)cpuid_Processor_Extended_States_info(0xd);
      }
      else if (local_c == 0xf) {
        puVar1 = (undefined4 *)cpuid_Quality_of_Service_info(0xf);
      }
      else if (local_c == 0x80000002) {
        puVar1 = (undefined4 *)cpuid_brand_part1_info(0x80000002);
      }
      else if (local_c == 0x80000003) {
        puVar1 = (undefined4 *)cpuid_brand_part2_info(0x80000003);
      }
      else if (local_c == 0x80000004) {
        puVar1 = (undefined4 *)cpuid_brand_part3_info(0x80000004);
      }
      else {
        puVar1 = (undefined4 *)cpuid(local_c);
      }
      uVar9 = puVar1[1];
      uVar8 = puVar1[2];
      uVar7 = puVar1[3];
      *puVar5 = *puVar1;
      puVar5[1] = uVar9;
      puVar5[2] = uVar7;
      puVar5[3] = uVar8;
      local_c = local_c + 1;
    } while (local_c <= uVar3);
    if (uVar3 != 0) {
      param_1[0xd] = *puVar4;
      param_1[0xe] = puVar4[1];
      param_1[0xf] = puVar4[3];
    }
  }
  if (1 < uVar3) {
    FUN_10012070(param_1,(uint)*(byte *)(puVar4 + 4));
  }
  FID_conflict__free(puVar4);
  FUN_10011fa0((int)param_1);
  puVar4 = param_1;
  if (0xf < (uint)param_1[5]) {
    puVar4 = (undefined4 *)*param_1;
  }
  iVar6 = FUN_10023a9c((byte *)puVar4,(byte *)"GenuineIntel");
  if (iVar6 != 0) {
    puVar4 = param_1;
    if (0xf < (uint)param_1[5]) {
      puVar4 = (undefined4 *)*param_1;
    }
    iVar6 = FUN_10023a9c((byte *)puVar4,(byte *)"AuthenticAMD");
    param_1[6] = (iVar6 != 0) + 1;
    return param_1;
  }
  param_1[6] = 0;
  return param_1;
}



undefined4 __fastcall FUN_10011d20(void *param_1)

{
  HANDLE pvVar1;
  char *lpFileName;
  _OSVERSIONINFOA local_a0;
  undefined4 local_c;
  undefined4 local_8;
  
  if (*(char *)((int)param_1 + 0x48) != '\0') {
    return 0xfffffffb;
  }
  if (*(uint *)((int)param_1 + 0x18) < 2) {
    local_a0.dwOSVersionInfoSize = 0x94;
    GetVersionExA(&local_a0);
    if (local_a0.dwPlatformId == 2) {
      lpFileName = "\\\\.\\GDPERF";
    }
    else {
      lpFileName = "\\\\.\\GDPERF.VXD";
    }
    pvVar1 = CreateFileA(lpFileName,0x80000000,0,(LPSECURITY_ATTRIBUTES)0x0,3,0x80,(HANDLE)0x0);
    *(HANDLE *)((int)param_1 + 0x44) = pvVar1;
    if (pvVar1 == (HANDLE)0xffffffff) {
      return 0xfffffffc;
    }
    *(undefined *)((int)param_1 + 0x48) = 1;
    if ((*(int *)((int)param_1 + 0x18) == 0) && ((*(uint *)((int)param_1 + 0x34) & 0xf00) == 0x600))
    {
      local_c = 0x470079;
      local_8 = 0;
      FUN_10011ed0(param_1,0x186,&local_c);
      if ((*(char *)((int)param_1 + 0x48) != '\0') &&
         ((*(uint *)((int)param_1 + 0x34) & 0xf00) == 0x600)) {
        local_c = 0x470079;
        local_8 = 0;
        FUN_10011ed0(param_1,0x187,&local_c);
      }
    }
    return 0;
  }
  *(undefined *)((int)param_1 + 0x48) = 0;
  return 0xffffffff;
}



undefined4 * FUN_10011e20(void)

{
  undefined4 *puVar1;
  
  if (DAT_10833cf0 == (undefined4 *)0x0) {
    puVar1 = (undefined4 *)FUN_1001f8b3(0x58);
    if (puVar1 != (undefined4 *)0x0) {
      FUN_10011be0(puVar1);
      puVar1[0x11] = 0;
      *(undefined *)(puVar1 + 0x12) = 0;
      *(undefined8 *)(puVar1 + 0x14) = 0;
      FUN_10011d20(puVar1);
      DAT_10833cf0 = puVar1;
      return puVar1;
    }
    DAT_10833cf0 = (undefined4 *)0x0;
  }
  return DAT_10833cf0;
}



BOOL __thiscall FUN_10011e80(void *this,undefined4 param_1,LPVOID param_2)

{
  BOOL BVar1;
  undefined *local_8;
  
  if (*(char *)((int)this + 0x48) == '\0') {
    return -6;
  }
  local_8 = (undefined *)this;
  BVar1 = DeviceIoControl(*(HANDLE *)((int)this + 0x44),0x9c406404,&param_1,4,param_2,8,
                          (LPDWORD)&local_8,(LPOVERLAPPED)0x0);
  if ((BVar1 == 0) && (local_8 != &DAT_00000008)) {
    BVar1 = -8;
  }
  return BVar1;
}



BOOL __thiscall FUN_10011ed0(void *this,DWORD param_1,undefined4 *param_2)

{
  BOOL BVar1;
  DWORD local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  if (*(char *)((int)this + 0x48) == '\0') {
    return -6;
  }
  local_10 = param_1;
  local_c = *param_2;
  local_8 = param_2[1];
  BVar1 = DeviceIoControl(*(HANDLE *)((int)this + 0x44),0x9c406400,&local_10,0xc,(LPVOID)0x0,0,
                          &param_1,(LPOVERLAPPED)0x0);
  if ((BVar1 == 0) && (param_1 != 0)) {
    BVar1 = -8;
  }
  return BVar1;
}



undefined4 __fastcall FUN_10011f30(void *param_1)

{
  char cVar1;
  undefined4 uVar2;
  int *piVar3;
  undefined4 *puVar4;
  undefined4 local_14;
  undefined4 local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  if (true) {
    puVar4 = (undefined4 *)cpuid_basic_info(0);
  }
  else if (false) {
    puVar4 = (undefined4 *)cpuid_Version_info(0);
  }
  else if (false) {
    puVar4 = (undefined4 *)cpuid_cache_tlb_info(0);
  }
  else if (false) {
    puVar4 = (undefined4 *)cpuid_serial_info(0);
  }
  else if (false) {
    puVar4 = (undefined4 *)cpuid_Deterministic_Cache_Parameters_info(0);
  }
  else if (false) {
    puVar4 = (undefined4 *)cpuid_MONITOR_MWAIT_Features_info(0);
  }
  else if (false) {
    puVar4 = (undefined4 *)cpuid_Thermal_Power_Management_info(0);
  }
  else if (false) {
    puVar4 = (undefined4 *)cpuid_Extended_Feature_Enumeration_info(0);
  }
  else if (false) {
    puVar4 = (undefined4 *)cpuid_Direct_Cache_Access_info(0);
  }
  else if (false) {
    puVar4 = (undefined4 *)cpuid_Architectural_Performance_Monitoring_info(0);
  }
  else if (false) {
    puVar4 = (undefined4 *)cpuid_Extended_Topology_info(0);
  }
  else if (false) {
    puVar4 = (undefined4 *)cpuid_Processor_Extended_States_info(0);
  }
  else if (false) {
    puVar4 = (undefined4 *)cpuid_Quality_of_Service_info(0);
  }
  else if (false) {
    puVar4 = (undefined4 *)cpuid_brand_part1_info(0);
  }
  else if (false) {
    puVar4 = (undefined4 *)cpuid_brand_part2_info(0);
  }
  else if (false) {
    puVar4 = (undefined4 *)cpuid_brand_part3_info(0);
  }
  else {
    puVar4 = (undefined4 *)cpuid(0);
  }
  uVar2 = *puVar4;
  local_14 = (int *)puVar4[1];
  local_14._0_1_ = (char)(int *)puVar4[1];
  local_8 = 0;
  local_10 = puVar4[2];
  local_c = puVar4[3];
  if ((char)local_14 == '\0') {
    piVar3 = (int *)0x0;
  }
  else {
    puVar4 = &local_14;
    do {
      cVar1 = *(char *)puVar4;
      puVar4 = (undefined4 *)((int)puVar4 + 1);
    } while (cVar1 != '\0');
    piVar3 = (int *)((int)puVar4 - ((int)&local_14 + 1));
  }
  FUN_10011770(param_1,(int **)&local_14,piVar3);
  return uVar2;
}



void __fastcall FUN_10011fa0(int param_1)

{
  char cVar1;
  uint *puVar2;
  undefined4 *puVar3;
  longlong lVar4;
  uint uVar5;
  void *_Memory;
  undefined4 *puVar6;
  undefined4 uVar7;
  int *piVar8;
  int **ppiVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  uint local_c;
  
  if (false) {
    puVar2 = (uint *)cpuid_basic_info(0x80000000);
  }
  else if (false) {
    puVar2 = (uint *)cpuid_Version_info(0x80000000);
  }
  else if (false) {
    puVar2 = (uint *)cpuid_cache_tlb_info(0x80000000);
  }
  else if (false) {
    puVar2 = (uint *)cpuid_serial_info(0x80000000);
  }
  else if (false) {
    puVar2 = (uint *)cpuid_Deterministic_Cache_Parameters_info(0x80000000);
  }
  else if (false) {
    puVar2 = (uint *)cpuid_MONITOR_MWAIT_Features_info(0x80000000);
  }
  else if (false) {
    puVar2 = (uint *)cpuid_Thermal_Power_Management_info(0x80000000);
  }
  else if (false) {
    puVar2 = (uint *)cpuid_Extended_Feature_Enumeration_info(0x80000000);
  }
  else if (false) {
    puVar2 = (uint *)cpuid_Direct_Cache_Access_info(0x80000000);
  }
  else if (false) {
    puVar2 = (uint *)cpuid_Architectural_Performance_Monitoring_info(0x80000000);
  }
  else if (false) {
    puVar2 = (uint *)cpuid_Extended_Topology_info(0x80000000);
  }
  else if (false) {
    puVar2 = (uint *)cpuid_Processor_Extended_States_info(0x80000000);
  }
  else if (false) {
    puVar2 = (uint *)cpuid_Quality_of_Service_info(0x80000000);
  }
  else if (false) {
    puVar2 = (uint *)cpuid_brand_part1_info(0x80000000);
  }
  else if (false) {
    puVar2 = (uint *)cpuid_brand_part2_info(0x80000000);
  }
  else if (false) {
    puVar2 = (uint *)cpuid_brand_part3_info(0x80000000);
  }
  else {
    puVar2 = (uint *)cpuid(0x80000000);
  }
  uVar5 = *puVar2;
  if ((int)uVar5 < 0) {
    lVar4 = (ulonglong)(uVar5 << 2) * 4;
    _Memory = (void *)FUN_10023b7a(-(uint)((int)((ulonglong)lVar4 >> 0x20) != 0) | (uint)lVar4);
    local_c = 0x80000001;
    if (0x80000000 < uVar5) {
      do {
        puVar6 = (undefined4 *)((int)_Memory + local_c * 0x10 + -0x10);
        if (local_c == 0) {
          puVar3 = (undefined4 *)cpuid_basic_info(0);
        }
        else if (local_c == 1) {
          puVar3 = (undefined4 *)cpuid_Version_info(1);
        }
        else if (local_c == 2) {
          puVar3 = (undefined4 *)cpuid_cache_tlb_info(2);
        }
        else if (local_c == 3) {
          puVar3 = (undefined4 *)cpuid_serial_info(3);
        }
        else if (local_c == 4) {
          puVar3 = (undefined4 *)cpuid_Deterministic_Cache_Parameters_info(4);
        }
        else if (local_c == 5) {
          puVar3 = (undefined4 *)cpuid_MONITOR_MWAIT_Features_info(5);
        }
        else if (local_c == 6) {
          puVar3 = (undefined4 *)cpuid_Thermal_Power_Management_info(6);
        }
        else if (local_c == 7) {
          puVar3 = (undefined4 *)cpuid_Extended_Feature_Enumeration_info(7);
        }
        else if (local_c == 9) {
          puVar3 = (undefined4 *)cpuid_Direct_Cache_Access_info(9);
        }
        else if (local_c == 10) {
          puVar3 = (undefined4 *)cpuid_Architectural_Performance_Monitoring_info(10);
        }
        else if (local_c == 0xb) {
          puVar3 = (undefined4 *)cpuid_Extended_Topology_info(0xb);
        }
        else if (local_c == 0xd) {
          puVar3 = (undefined4 *)cpuid_Processor_Extended_States_info(0xd);
        }
        else if (local_c == 0xf) {
          puVar3 = (undefined4 *)cpuid_Quality_of_Service_info(0xf);
        }
        else if (local_c == 0x80000002) {
          puVar3 = (undefined4 *)cpuid_brand_part1_info(0x80000002);
        }
        else if (local_c == 0x80000003) {
          puVar3 = (undefined4 *)cpuid_brand_part2_info(0x80000003);
        }
        else if (local_c == 0x80000004) {
          puVar3 = (undefined4 *)cpuid_brand_part3_info(0x80000004);
        }
        else {
          puVar3 = (undefined4 *)cpuid(local_c);
        }
        uVar11 = puVar3[1];
        uVar10 = puVar3[2];
        uVar7 = puVar3[3];
        *puVar6 = *puVar3;
        puVar6[1] = uVar11;
        puVar6[2] = uVar7;
        puVar6[3] = uVar10;
        local_c = local_c + 1;
      } while (local_c <= uVar5);
    }
    if (0x80000001 < uVar5) {
      if (*(char *)((int)_Memory + 0x10) == '\0') {
        piVar8 = (int *)0x0;
      }
      else {
        ppiVar9 = (int **)((int)_Memory + 0x10);
        do {
          cVar1 = *(char *)ppiVar9;
          ppiVar9 = (int **)((int)ppiVar9 + 1);
        } while (cVar1 != '\0');
        piVar8 = (int *)((int)ppiVar9 - ((int)_Memory + 0x11));
      }
      FUN_10011770((void *)(param_1 + 0x1c),(int **)((int)_Memory + 0x10),piVar8);
    }
    FID_conflict__free(_Memory);
  }
  return;
}



void __thiscall FUN_10012070(void *this,uint param_1)

{
  uint *puVar1;
  uint uVar2;
  size_t sVar3;
  undefined4 uVar4;
  byte bVar5;
  int iVar6;
  int iVar7;
  undefined4 *puVar8;
  undefined4 local_118;
  uint local_18;
  uint local_14;
  uint local_10;
  uint local_c;
  void *local_8;
  
  puVar8 = &local_118;
  local_8 = this;
  for (iVar6 = 0x40; iVar6 != 0; iVar6 = iVar6 + -1) {
    *puVar8 = 0;
    puVar8 = puVar8 + 1;
  }
  iVar6 = 0;
  if ((param_1 & 0xff) != 0) {
    do {
      if (false) {
        puVar1 = (uint *)cpuid_basic_info(2);
      }
      else if (false) {
        puVar1 = (uint *)cpuid_Version_info(2);
      }
      else if (true) {
        puVar1 = (uint *)cpuid_cache_tlb_info(2);
      }
      else if (false) {
        puVar1 = (uint *)cpuid_serial_info(2);
      }
      else if (false) {
        puVar1 = (uint *)cpuid_Deterministic_Cache_Parameters_info(2);
      }
      else if (false) {
        puVar1 = (uint *)cpuid_MONITOR_MWAIT_Features_info(2);
      }
      else if (false) {
        puVar1 = (uint *)cpuid_Thermal_Power_Management_info(2);
      }
      else if (false) {
        puVar1 = (uint *)cpuid_Extended_Feature_Enumeration_info(2);
      }
      else if (false) {
        puVar1 = (uint *)cpuid_Direct_Cache_Access_info(2);
      }
      else if (false) {
        puVar1 = (uint *)cpuid_Architectural_Performance_Monitoring_info(2);
      }
      else if (false) {
        puVar1 = (uint *)cpuid_Extended_Topology_info(2);
      }
      else if (false) {
        puVar1 = (uint *)cpuid_Processor_Extended_States_info(2);
      }
      else if (false) {
        puVar1 = (uint *)cpuid_Quality_of_Service_info(2);
      }
      else if (false) {
        puVar1 = (uint *)cpuid_brand_part1_info(2);
      }
      else if (false) {
        puVar1 = (uint *)cpuid_brand_part2_info(2);
      }
      else if (false) {
        puVar1 = (uint *)cpuid_brand_part3_info(2);
      }
      else {
        puVar1 = (uint *)cpuid(2);
      }
      local_14 = puVar1[1];
      local_c = puVar1[2];
      local_10 = puVar1[3];
      bVar5 = (byte)*puVar1;
      if (iVar6 == 0) {
        bVar5 = 0;
      }
      local_18 = *puVar1 & 0xffffff00 | (uint)bVar5;
      uVar2 = local_18;
      if (-1 < (int)local_18) {
        iVar7 = 0;
        do {
          bVar5 = (byte)iVar7;
          iVar7 = iVar7 + 8;
          *(undefined *)((int)&local_118 + (uVar2 >> (bVar5 & 0x1f) & 0xff)) = 1;
        } while (iVar7 < 0x20);
      }
      uVar2 = local_14;
      if (-1 < (int)local_14) {
        iVar7 = 0;
        do {
          bVar5 = (byte)iVar7;
          iVar7 = iVar7 + 8;
          *(undefined *)((int)&local_118 + (uVar2 >> (bVar5 & 0x1f) & 0xff)) = 1;
        } while (iVar7 < 0x20);
      }
      uVar2 = local_10;
      if (-1 < (int)local_10) {
        iVar7 = 0;
        do {
          bVar5 = (byte)iVar7;
          iVar7 = iVar7 + 8;
          *(undefined *)((int)&local_118 + (uVar2 >> (bVar5 & 0x1f) & 0xff)) = 1;
        } while (iVar7 < 0x20);
      }
      uVar2 = local_c;
      if (-1 < (int)local_c) {
        iVar7 = 0;
        do {
          bVar5 = (byte)iVar7;
          iVar7 = iVar7 + 8;
          *(undefined *)((int)&local_118 + (uVar2 >> (bVar5 & 0x1f) & 0xff)) = 1;
        } while (iVar7 < 0x20);
      }
      iVar6 = iVar6 + 1;
      this = local_8;
    } while (iVar6 < (int)(param_1 & 0xff));
  }
  sVar3 = 0;
  iVar6 = 0;
  do {
    if (*(char *)((int)&local_118 + iVar6) != '\0') {
      sVar3 = sVar3 + 1;
    }
    if (*(char *)((int)&local_118 + iVar6 + 1) != '\0') {
      sVar3 = sVar3 + 1;
    }
    if (*(char *)((int)&local_118 + iVar6 + 2) != '\0') {
      sVar3 = sVar3 + 1;
    }
    if (*(char *)((int)&local_118 + iVar6 + 3) != '\0') {
      sVar3 = sVar3 + 1;
    }
    iVar6 = iVar6 + 4;
  } while (iVar6 < 0x100);
  uVar4 = FUN_10023b7a(sVar3);
  *(undefined4 *)((int)this + 0x40) = uVar4;
  iVar7 = 0;
  iVar6 = 1;
  do {
    if (*(char *)((int)&local_118 + iVar6) != '\0') {
      *(char *)(iVar7 + *(int *)((int)this + 0x40)) = (char)iVar6;
      iVar7 = iVar7 + 1;
    }
    iVar6 = iVar6 + 1;
  } while (iVar6 < 0x100);
  *(undefined *)(iVar7 + *(int *)((int)this + 0x40)) = 0;
  return;
}



undefined4 __cdecl InstallProgressReportHandler(undefined4 param_1)

{
  undefined4 uVar1;
  
                    // 0x121e0  347  InstallProgressReportHandler
  uVar1 = DAT_10833cfc;
  DAT_10833cfc = param_1;
  return uVar1;
}



void ReportProgress(void)

{
                    // 0x12200  437  ReportProgress
  if (DAT_10833cfc != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x1001220d. Too many branches
                    // WARNING: Treating indirect jump as call
    (*DAT_10833cfc)();
    return;
  }
  return;
}



void __cdecl
FUN_10012220(FILE *param_1,WCHAR *param_2,uint param_3,WCHAR *param_4,uint param_5,uint *param_6)

{
  uint uVar1;
  
  uVar1 = *param_6;
  if (param_3 < uVar1 + param_5) {
    if (uVar1 != 0) {
      FUN_1002445b(param_2,1,uVar1,param_1);
      *param_6 = 0;
    }
    if (param_3 < param_5) {
      FUN_1002445b(param_4,param_5,1,param_1);
      return;
    }
  }
  FID_conflict__memcpy((void *)(*param_6 + (int)param_2),param_4,param_5);
  *param_6 = *param_6 + param_5;
  return;
}



// public: virtual unsigned int __thiscall BasicStatStructFieldDesc::DescribeField(unsigned char
// *,unsigned int)

uint __thiscall
BasicStatStructFieldDesc::DescribeField(BasicStatStructFieldDesc *this,uchar *param_1,uint param_2)

{
  char *pcVar1;
  char cVar2;
  char *pcVar3;
  
                    // 0x12290  89  ?DescribeField@BasicStatStructFieldDesc@@UAEIPAEI@Z
  pcVar3 = *(char **)(this + 4);
  pcVar1 = pcVar3 + 1;
  do {
    cVar2 = *pcVar3;
    pcVar3 = pcVar3 + 1;
  } while (cVar2 != '\0');
  if (param_2 < pcVar3 + (8 - (int)pcVar1)) {
    return 0;
  }
  *param_1 = '\0';
  *(BasicStatStructFieldDesc *)(param_1 + 1) = this[0x10];
  *(BasicStatStructFieldDesc *)(param_1 + 2) = this[0x14];
  *(undefined4 *)(param_1 + 3) = *(undefined4 *)(this + 8);
  FID_conflict__memcpy(param_1 + 7,*(void **)(this + 4),(size_t)(pcVar3 + (1 - (int)pcVar1)));
  return (uint)(pcVar3 + (8 - (int)pcVar1));
}



// WARNING: Type propagation algorithm not settling

uint __cdecl FUN_100122f0(int *param_1,int **param_2)

{
  undefined4 *puVar1;
  char cVar2;
  byte bVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  int iVar7;
  WCHAR *pWVar8;
  undefined2 *puVar9;
  uint *puVar10;
  int *piVar11;
  int *piVar12;
  int iVar13;
  int iVar14;
  FILE *pFVar15;
  undefined2 local_450;
  int local_50;
  int local_4c;
  WCHAR *local_48;
  undefined4 local_44;
  int local_40;
  uint local_3c;
  uint *local_38;
  int local_34;
  int local_30;
  int *local_2c;
  uint local_28;
  int *local_24;
  uint local_20;
  int local_1c;
  int *local_18;
  int local_14;
  FILE *local_10;
  int *local_c;
  int *local_8;
  
  local_20 = 0;
  local_30 = 0;
  local_24 = (int *)0x0;
  local_1c = 0;
  local_40 = 0;
  local_2c = (int *)0x0;
  local_48 = L"";
  uVar4 = (**(code **)param_1[1])
                    (*param_1,&local_48,&local_20,&local_30,&local_24,&local_1c,&local_40,&local_2c)
  ;
  if (local_1c == 0) {
    return uVar4 & 0xffffff00;
  }
  local_8 = *param_2;
  puVar10 = (uint *)param_2[2];
  local_c = param_2[1];
  pFVar15 = (FILE *)param_2[3];
  pWVar8 = local_48;
  do {
    cVar2 = *(char *)pWVar8;
    pWVar8 = (WCHAR *)((int)pWVar8 + 1);
  } while (cVar2 != '\0');
  local_38 = puVar10;
  local_10 = pFVar15;
  FUN_10012220(pFVar15,(WCHAR *)local_8,(uint)local_c,local_48,
               (uint)((int)pWVar8 + (1 - ((int)local_48 + 1))),puVar10);
  uVar4 = *puVar10;
  local_18 = local_2c;
  if (local_c < (int *)(uVar4 + 4)) {
    if (uVar4 != 0) {
      FUN_1002445b((WCHAR *)local_8,1,uVar4,pFVar15);
      *puVar10 = 0;
    }
    if ((int *)0x3 < local_c) goto LAB_100123ed;
    FUN_1002445b((WCHAR *)&local_18,4,1,pFVar15);
  }
  else {
LAB_100123ed:
    *(int **)(*puVar10 + (int)local_8) = local_18;
    *puVar10 = *puVar10 + 4;
  }
  piVar11 = (int *)0x0;
  if (local_2c != (int *)0x0) {
    do {
      uVar4 = *puVar10;
      puVar1 = (undefined4 *)(local_40 + (int)piVar11 * 8);
      if (local_c < (int *)(uVar4 + 4)) {
        if (uVar4 != 0) {
          FUN_1002445b((WCHAR *)local_8,1,uVar4,local_10);
          *puVar10 = 0;
        }
        if ((int *)0x3 < local_c) goto LAB_10012443;
        FUN_1002445b((WCHAR *)puVar1,4,1,local_10);
      }
      else {
LAB_10012443:
        *(undefined4 *)(*puVar10 + (int)local_8) = *puVar1;
        *puVar10 = *puVar10 + 4;
      }
      piVar11 = (int *)((int)piVar11 + 1);
    } while (piVar11 != local_2c);
  }
  pFVar15 = local_10;
  uVar4 = *puVar10;
  if (local_c < (int *)(uVar4 + 4)) {
    if (uVar4 != 0) {
      FUN_1002445b((WCHAR *)local_8,1,uVar4,local_10);
      *puVar10 = 0;
    }
    if ((int *)0x3 < local_c) goto LAB_1001249a;
    FUN_1002445b((WCHAR *)&local_20,4,1,pFVar15);
  }
  else {
LAB_1001249a:
    *(uint *)(*puVar10 + (int)local_8) = local_20;
    *puVar10 = *puVar10 + 4;
    pFVar15 = local_10;
  }
  uVar4 = *puVar10;
  if (local_c < (int *)(uVar4 + 4)) {
    if (uVar4 != 0) {
      FUN_1002445b((WCHAR *)local_8,1,uVar4,pFVar15);
      *puVar10 = 0;
    }
    if ((int *)0x3 < local_c) goto LAB_100124e8;
    FUN_1002445b((WCHAR *)&local_30,4,1,pFVar15);
  }
  else {
LAB_100124e8:
    *(int *)(*puVar10 + (int)local_8) = local_30;
    *puVar10 = *puVar10 + 4;
  }
  if (*puVar10 != 0) {
    FUN_1002445b((WCHAR *)local_8,1,*puVar10,pFVar15);
    *puVar10 = 0;
  }
  piVar11 = local_8;
  uVar6 = *puVar10;
  uVar4 = uVar6 + 4;
  *puVar10 = uVar4;
  iVar5 = (**(code **)(param_1[1] + 0xc))(uVar4 + (int)local_8,(int)local_c - uVar4);
  pFVar15 = local_10;
  *puVar10 = *puVar10 + iVar5;
  *(uint *)(uVar6 + (int)piVar11) = *puVar10 + (-4 - uVar6);
  uVar4 = *puVar10;
  if (local_c < (int *)(uVar4 + 4)) {
    if (uVar4 != 0) {
      FUN_1002445b((WCHAR *)piVar11,1,uVar4,local_10);
      *puVar10 = 0;
    }
    if ((int *)0x3 < local_c) goto LAB_10012577;
    FUN_1002445b((WCHAR *)&local_1c,4,1,pFVar15);
  }
  else {
LAB_10012577:
    *(int *)(*puVar10 + (int)piVar11) = local_1c;
    *puVar10 = *puVar10 + 4;
    pFVar15 = local_10;
  }
  uVar4 = *puVar10;
  local_50 = FUN_10024296(pFVar15);
  piVar11 = local_24;
  local_50 = uVar4 + local_50;
  piVar12 = (int *)(local_1c * local_30);
  if (local_c < (int *)(uVar4 + (int)piVar12)) {
    if (uVar4 != 0) {
      FUN_1002445b((WCHAR *)local_8,1,uVar4,local_10);
      *local_38 = 0;
    }
    pFVar15 = local_10;
    if (piVar12 < local_c || (int)piVar12 - (int)local_c == 0) goto LAB_100125e3;
    FUN_1002445b((WCHAR *)piVar11,(uint)piVar12,1,local_10);
    puVar10 = local_38;
  }
  else {
LAB_100125e3:
    puVar10 = local_38;
    FID_conflict__memcpy((void *)(*local_38 + (int)local_8),piVar11,(size_t)piVar12);
    *puVar10 = *puVar10 + (int)piVar12;
    pFVar15 = local_10;
  }
  if (*puVar10 != 0) {
    FUN_1002445b((WCHAR *)local_8,1,*puVar10,pFVar15);
    *puVar10 = 0;
  }
  iVar5 = 0;
  uVar6 = (uint)local_c >> 2;
  local_14 = 0;
  param_1 = local_8;
  local_18 = local_24;
  local_34 = 0;
  uVar4 = local_20;
  iVar14 = local_1c;
  piVar11 = local_8;
  local_3c = uVar6;
  if (local_1c == 0) {
LAB_100127e6:
    local_8 = local_8 + iVar5;
    local_c = local_c + -iVar5;
  }
  else {
    do {
      local_3c = 0;
      if (uVar4 != 0) {
        do {
          local_28 = local_18[local_3c];
          iVar14 = local_1c;
          if (local_28 == 0) break;
          iVar14 = iVar5 + -1;
          iVar13 = 0;
          if (-1 < iVar14) {
            do {
              iVar7 = iVar13 + iVar14 >> 1;
              uVar4 = local_20;
              if (local_28 < (uint)param_1[iVar7]) {
                iVar14 = iVar7 + -1;
              }
              else {
                iVar13 = iVar7;
                if (local_28 <= (uint)param_1[iVar7]) break;
                iVar13 = iVar7 + 1;
              }
            } while (iVar13 <= iVar14);
          }
          if (iVar5 < iVar13) {
            if (iVar5 < (int)uVar6) {
              param_1[iVar13] = local_28;
              iVar5 = local_14 + 1;
              local_14 = iVar5;
            }
            else {
              uVar6 = local_1c * uVar4 * 4;
              if ((*(char *)(param_2 + 4) == '\0') ||
                 (piVar11 = (int *)FUN_10023b7a(-(uint)((int)((ulonglong)uVar6 * 4 >> 0x20) != 0) |
                                                (uint)((ulonglong)uVar6 * 4)), iVar5 = local_14,
                 piVar11 == (int *)0x0)) {
                piVar11 = local_24;
              }
              FID_conflict__memcpy(piVar11,param_1,iVar5 * 4);
              piVar11[iVar13] = local_28;
              iVar5 = local_14 + 1;
              param_1 = piVar11;
              local_14 = iVar5;
            }
          }
          else {
            local_4c = iVar13 * 4;
            if (param_1[iVar13] != local_28) {
              iVar14 = iVar5;
              if ((int)uVar6 <= iVar5) {
                uVar6 = local_1c * local_20 * 4;
                if ((*(char *)(param_2 + 4) == '\0') ||
                   (piVar11 = (int *)FUN_10023b7a(-(uint)((int)((ulonglong)uVar6 * 4 >> 0x20) != 0)
                                                  | (uint)((ulonglong)uVar6 * 4)), iVar5 = local_14,
                   piVar11 == (int *)0x0)) {
                  piVar11 = local_24;
                }
                FID_conflict__memcpy(piVar11,param_1,iVar5 * 4);
                iVar5 = local_14;
                iVar14 = local_14;
                param_1 = piVar11;
              }
              while (iVar7 = iVar14 + -1, iVar13 <= iVar7) {
                param_1[iVar14] = param_1[iVar7];
                iVar5 = local_14;
                iVar14 = iVar7;
              }
              iVar5 = iVar5 + 1;
              *(uint *)(local_4c + (int)param_1) = local_28;
              local_14 = iVar5;
            }
          }
          local_3c = local_3c + 1;
          uVar4 = local_20;
          iVar14 = local_1c;
          piVar11 = param_1;
        } while (local_3c != local_20);
      }
      local_18 = (int *)((int)local_18 + local_30);
      local_34 = local_34 + 1;
    } while (local_34 != iVar14);
    puVar10 = local_38;
    if (piVar11 == local_8) goto LAB_100127e6;
  }
  pFVar15 = local_10;
  uVar4 = *puVar10;
  if (local_c < (int *)(uVar4 + 4)) {
    if (uVar4 != 0) {
      FUN_1002445b((WCHAR *)local_8,1,uVar4,local_10);
      *puVar10 = 0;
      iVar5 = local_14;
    }
    if ((int *)0x3 < local_c) goto LAB_10012837;
    FUN_1002445b((WCHAR *)&local_14,4,1,pFVar15);
  }
  else {
LAB_10012837:
    *(int *)(*puVar10 + (int)local_8) = iVar5;
    *puVar10 = *puVar10 + 4;
    pFVar15 = local_10;
  }
  local_34 = 0;
  piVar12 = piVar11;
  if (local_14 != 0) {
    do {
      uVar4 = *puVar10;
      if (local_c < (int *)(uVar4 + 4)) {
        if (uVar4 != 0) {
          FUN_1002445b((WCHAR *)local_8,1,uVar4,pFVar15);
          *puVar10 = 0;
        }
        if ((int *)0x3 < local_c) goto LAB_1001288e;
        FUN_1002445b((WCHAR *)piVar11,4,1,pFVar15);
      }
      else {
LAB_1001288e:
        *(int *)(*puVar10 + (int)local_8) = *piVar11;
        *puVar10 = *puVar10 + 4;
      }
      cVar2 = GetModuleNameFromAddress(*piVar11,(char *)&local_450,0x400);
      puVar9 = &local_450;
      local_450._0_1_ = (byte)local_450 & -(cVar2 != '\0');
      do {
        cVar2 = *(char *)puVar9;
        puVar9 = (undefined2 *)((int)puVar9 + 1);
      } while (cVar2 != '\0');
      piVar12 = (int *)((int)puVar9 + (1 - ((int)&local_450 + 1)));
      uVar4 = *puVar10;
      if (local_c < (int *)(uVar4 + (int)piVar12)) {
        if (uVar4 != 0) {
          FUN_1002445b((WCHAR *)local_8,1,uVar4,local_10);
          *puVar10 = 0;
        }
        if (piVar12 <= local_c) goto LAB_10012910;
        FUN_1002445b(&local_450,(uint)piVar12,1,local_10);
      }
      else {
LAB_10012910:
        FID_conflict__memcpy((void *)(*puVar10 + (int)local_8),&local_450,(size_t)piVar12);
        *puVar10 = *puVar10 + (int)piVar12;
      }
      cVar2 = GetSymbolNameFromAddress(*piVar11,(char *)&local_450,0x400,(undefined4 *)0x0);
      puVar9 = &local_450;
      local_450._0_1_ = (byte)local_450 & -(cVar2 != '\0');
      do {
        cVar2 = *(char *)puVar9;
        puVar9 = (undefined2 *)((int)puVar9 + 1);
      } while (cVar2 != '\0');
      piVar12 = (int *)((int)puVar9 + (1 - ((int)&local_450 + 1)));
      uVar4 = *puVar10;
      if (local_c < (int *)(uVar4 + (int)piVar12)) {
        if (uVar4 != 0) {
          FUN_1002445b((WCHAR *)local_8,1,uVar4,local_10);
          *puVar10 = 0;
        }
        if (piVar12 <= local_c) goto LAB_100129a0;
        FUN_1002445b(&local_450,(uint)piVar12,1,local_10);
      }
      else {
LAB_100129a0:
        FID_conflict__memcpy((void *)(*puVar10 + (int)local_8),&local_450,(size_t)piVar12);
        *puVar10 = *puVar10 + (int)piVar12;
      }
      bVar3 = GetFileAndLineFromAddress
                        (*piVar11,(char *)&local_450,0x400,&local_18,(undefined4 *)0x0);
      if (bVar3 == 0) {
        local_450._0_1_ = bVar3;
        local_18 = (int *)0x0;
      }
      puVar9 = &local_450;
      do {
        cVar2 = *(char *)puVar9;
        puVar9 = (undefined2 *)((int)puVar9 + 1);
      } while (cVar2 != '\0');
      piVar12 = (int *)((int)puVar9 + (1 - ((int)&local_450 + 1)));
      uVar4 = *puVar10;
      if (local_c < (int *)(uVar4 + (int)piVar12)) {
        if (uVar4 != 0) {
          FUN_1002445b((WCHAR *)local_8,1,uVar4,local_10);
          *puVar10 = 0;
        }
        if (piVar12 <= local_c) goto LAB_10012a3d;
        FUN_1002445b(&local_450,(uint)piVar12,1,local_10);
      }
      else {
LAB_10012a3d:
        FID_conflict__memcpy((void *)(*puVar10 + (int)local_8),&local_450,(size_t)piVar12);
        *puVar10 = *puVar10 + (int)piVar12;
      }
      pFVar15 = local_10;
      uVar4 = *puVar10;
      if (local_c < (int *)(uVar4 + 4)) {
        if (uVar4 != 0) {
          FUN_1002445b((WCHAR *)local_8,1,uVar4,local_10);
          *puVar10 = 0;
        }
        if ((int *)0x3 < local_c) goto LAB_10012a94;
        FUN_1002445b((WCHAR *)&local_18,4,1,pFVar15);
      }
      else {
LAB_10012a94:
        *(int **)(*puVar10 + (int)local_8) = local_18;
        *puVar10 = *puVar10 + 4;
        pFVar15 = local_10;
      }
      piVar11 = piVar11 + 1;
      local_34 = local_34 + 1;
      piVar12 = param_1;
    } while (local_34 != local_14);
  }
  local_44 = 0;
  uVar4 = *puVar10;
  if (local_c < (int *)(uVar4 + 4)) {
    if (uVar4 != 0) {
      FUN_1002445b((WCHAR *)local_8,1,uVar4,pFVar15);
      *puVar10 = 0;
    }
    if (local_c < &DAT_00000004) {
      FUN_1002445b((WCHAR *)&local_44,4,1,pFVar15);
      goto LAB_10012b0c;
    }
  }
  *(undefined4 *)(*puVar10 + (int)local_8) = local_44;
  *puVar10 = *puVar10 + 4;
LAB_10012b0c:
  if (*puVar10 != 0) {
    FUN_1002445b((WCHAR *)local_8,1,*puVar10,pFVar15);
    *puVar10 = 0;
  }
  if (piVar12 == local_24) {
    FUN_10023e83(pFVar15,local_50,0);
    _fread(local_24,local_14 << 2,1,pFVar15);
    FUN_10023e83(pFVar15,0,2);
  }
  else if (piVar12 != *param_2) {
    FID_conflict__free(piVar12);
  }
  piVar11 = (int *)0x0;
  if (local_2c != (int *)0x0) {
    do {
      uVar4 = FUN_100122f0((int *)(local_40 + (int)piVar11 * 8),param_2);
      if ((char)uVar4 == '\0') {
        return uVar4 & 0xffffff00;
      }
      piVar11 = (int *)((int)piVar11 + 1);
    } while (piVar11 != local_2c);
  }
  return CONCAT31((int3)((uint)param_2 >> 8),1);
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe

uint __cdecl
_CCallStackStatsGatherer_Internal_DumpStatsToFile(char *param_1,int *param_2,undefined4 param_3)

{
  int *piVar1;
  FILE *_File;
  uint uVar2;
  uint uVar3;
  int aiStack262176 [65536];
  int *local_20;
  undefined4 local_1c;
  uint *local_18;
  FILE *local_14;
  undefined local_10;
  undefined4 local_c;
  uint local_8;
  
                    // 0x12ba0  490  _CCallStackStatsGatherer_Internal_DumpStatsToFile
  piVar1 = param_2;
  local_8 = 0x10012bad;
  if (*param_2 == 0) {
    return 0x40000;
  }
  _File = _fopen(param_1,"wb");
  if (_File == (FILE *)0x0) {
    return 0;
  }
  local_8 = 0;
  param_2 = (int *)CONCAT13(3,param_2._0_3_);
  FUN_10012220(_File,(WCHAR *)aiStack262176,0x40000,(WCHAR *)((int)&param_2 + 3),1,&local_8);
  local_c = 0x12345678;
  FUN_10012220(_File,(WCHAR *)aiStack262176,0x40000,(WCHAR *)&local_c,4,&local_8);
  local_20 = aiStack262176;
  local_1c = 0x40000;
  local_18 = &local_8;
  local_10 = (undefined)param_3;
  local_14 = _File;
  uVar2 = FUN_100122f0(piVar1,&local_20);
  if (local_8 != 0) {
    FUN_1002445b((WCHAR *)aiStack262176,1,local_8,_File);
    local_8 = 0;
  }
  uVar3 = _fclose(_File);
  return uVar3 & 0xffffff00 | uVar2 & 0xff;
}



int __cdecl
_CCallStackStatsGatherer_Write_FieldDescriptions
          (undefined4 *param_1,undefined4 *param_2,int param_3)

{
  int iVar1;
  int iVar2;
  int iVar3;
  
                    // 0x12c90  491  _CCallStackStatsGatherer_Write_FieldDescriptions
  iVar2 = 0;
  *param_2 = 2;
  iVar3 = 0xc;
  if (param_1 != (undefined4 *)0x0) {
    do {
      iVar1 = (**(code **)*param_1)(iVar3 + (int)param_2,param_3 - iVar3);
      if (iVar1 != 0) {
        iVar2 = iVar2 + 1;
      }
      param_1 = (undefined4 *)param_1[3];
      iVar3 = iVar3 + iVar1;
    } while (param_1 != (undefined4 *)0x0);
  }
  param_2[2] = iVar2;
  param_2[1] = iVar3 + -8;
  return iVar3;
}



// public: __thiscall CCallStackStorage::CCallStackStorage(int (__cdecl*)(void * *,int,int),unsigned
// int)

CCallStackStorage * __thiscall
CCallStackStorage::CCallStackStorage(CCallStackStorage *this,FuncDef0 *param_1,uint param_2)

{
  int iVar1;
  
                    // 0x12cf0  4  ??0CCallStackStorage@@QAE@P6AHPAPAXHH@ZI@Z
  iVar1 = (*param_1)((void **)this,0x80,param_2 + 1);
  *(int *)(this + 0x200) = iVar1;
  return this;
}



// WARNING: Restarted to delay deadcode elimination for space: stack
// public: __thiscall CStackTop_CopyParentStack::CStackTop_CopyParentStack(void * const *,int)

CStackTop_CopyParentStack * __thiscall
CStackTop_CopyParentStack::CStackTop_CopyParentStack
          (CStackTop_CopyParentStack *this,void **param_1,int param_2)

{
  void **ppvVar1;
  void *pvVar2;
  int unaff_EBP;
  
                    // 0x12d20  6  ??0CStackTop_CopyParentStack@@QAE@PBQAXH@Z
  *(undefined4 *)(this + 8) = *(undefined4 *)(unaff_EBP + 4);
  *(undefined4 **)(this + 4) = (undefined4 *)(unaff_EBP + 4);
  *(undefined4 *)(this + 0xc) = 0;
  if ((param_1 != (void **)0x0) && (0 < param_2)) {
    ppvVar1 = param_1 + param_2 + -1;
    do {
      if (*ppvVar1 != (void *)0x0) {
        if (0 < param_2) {
          pvVar2 = (void *)FUN_1001f8b3(-(uint)((int)((ulonglong)(uint)param_2 * 4 >> 0x20) != 0) |
                                        (uint)((ulonglong)(uint)param_2 * 4));
          *(void **)(this + 0xc) = pvVar2;
          FID_conflict__memcpy(pvVar2,param_1,param_2 * 4);
        }
        break;
      }
      param_2 = param_2 - 1;
      ppvVar1 = ppvVar1 + -1;
    } while (0 < param_2);
  }
  *(int *)(this + 0x10) = param_2;
  pvVar2 = GenericThreadLocals::CThreadLocalBase::Get((CThreadLocalBase *)&DAT_10833d10);
  *(void **)this = pvVar2;
  GenericThreadLocals::CThreadLocalBase::Set((CThreadLocalBase *)&DAT_10833d10,this);
  return this;
}



// WARNING: Restarted to delay deadcode elimination for space: stack
// public: __thiscall CStackTop_ReferenceParentStack::CStackTop_ReferenceParentStack(void * const
// *,int)

CStackTop_ReferenceParentStack * __thiscall
CStackTop_ReferenceParentStack::CStackTop_ReferenceParentStack
          (CStackTop_ReferenceParentStack *this,void **param_1,int param_2)

{
  void *pvVar1;
  void **ppvVar2;
  int unaff_EBP;
  
                    // 0x12dd0  7  ??0CStackTop_ReferenceParentStack@@QAE@PBQAXH@Z
  *(undefined4 *)(this + 8) = *(undefined4 *)(unaff_EBP + 4);
  *(undefined4 **)(this + 4) = (undefined4 *)(unaff_EBP + 4);
  *(void ***)(this + 0xc) = param_1;
  if ((param_1 != (void **)0x0) && (0 < param_2)) {
    ppvVar2 = param_1 + param_2;
    do {
      ppvVar2 = ppvVar2 + -1;
      if (*ppvVar2 != (void *)0x0) break;
      param_2 = param_2 + -1;
    } while (0 < param_2);
  }
  *(int *)(this + 0x10) = param_2;
  pvVar1 = GenericThreadLocals::CThreadLocalBase::Get((CThreadLocalBase *)&DAT_10833d10);
  *(void **)this = pvVar1;
  GenericThreadLocals::CThreadLocalBase::Set((CThreadLocalBase *)&DAT_10833d10,this);
  return this;
}



// public: __thiscall CStackTop_CopyParentStack::~CStackTop_CopyParentStack(void)

void __thiscall
CStackTop_CopyParentStack::_CStackTop_CopyParentStack(CStackTop_CopyParentStack *this)

{
                    // 0x12e40  28  ??1CStackTop_CopyParentStack@@QAE@XZ
  GenericThreadLocals::CThreadLocalBase::Set((CThreadLocalBase *)&DAT_10833d10,*(void **)this);
  if (*(void **)(this + 0xc) != (void *)0x0) {
    FID_conflict__free(*(void **)(this + 0xc));
  }
  return;
}



// public: __thiscall CStackTop_ReferenceParentStack::~CStackTop_ReferenceParentStack(void)

void __thiscall
CStackTop_ReferenceParentStack::_CStackTop_ReferenceParentStack
          (CStackTop_ReferenceParentStack *this)

{
                    // 0x12e60  29  ??1CStackTop_ReferenceParentStack@@QAE@XZ
  GenericThreadLocals::CThreadLocalBase::Set((CThreadLocalBase *)&DAT_10833d10,*(void **)this);
  *(undefined4 *)(this + 0xc) = 0;
  *(undefined4 *)(this + 0x10) = 0;
  return;
}



int __cdecl FUN_10012e80(int param_1,int param_2,int param_3)

{
  void *pvVar1;
  int iVar2;
  int iVar3;
  
  pvVar1 = GenericThreadLocals::CThreadLocalBase::Get((CThreadLocalBase *)&DAT_10833d10);
  if (pvVar1 == (void *)0x0) {
    return param_3;
  }
  iVar3 = param_3;
  if (*(int *)((int)pvVar1 + 8) != 0) {
    for (iVar2 = param_3 + -1;
        (iVar3 = param_3, -1 < iVar2 &&
        (iVar3 = iVar2, *(int *)(param_1 + iVar2 * 4) != *(int *)((int)pvVar1 + 8)));
        iVar2 = iVar2 + -1) {
    }
  }
  iVar2 = *(int *)((int)pvVar1 + 0x10);
  if (iVar2 != 0) {
    if (param_2 - iVar3 < iVar2) {
      iVar2 = param_2 - iVar3;
    }
    FID_conflict__memcpy((void *)(param_1 + iVar3 * 4),*(void **)((int)pvVar1 + 0xc),iVar2 * 4);
    return iVar2 + iVar3;
  }
  return iVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __cdecl FUN_10012f00(undefined4 *param_1,int param_2,int param_3,int param_4)

{
  DWORD DVar1;
  DWORD DVar2;
  DWORD DVar3;
  HANDLE pvVar4;
  int iVar5;
  int iVar6;
  undefined4 *puVar7;
  undefined4 local_3d8 [45];
  uint local_324;
  undefined4 local_320;
  undefined4 local_10c;
  undefined4 local_108;
  uint local_104;
  undefined4 local_100;
  uint local_ec;
  uint local_e8;
  undefined4 local_e0;
  
  FUN_10013080(&DAT_10046670);
  DVar2 = GetCurrentThreadId();
  if (DVar2 != DAT_10046680) {
    DVar3 = 0;
    LOCK();
    DVar1 = DVar2;
    if (DAT_10046680 != 0) {
      DVar3 = DAT_10046680;
      DVar1 = DAT_10046680;
    }
    DAT_10046680 = DVar1;
    if (DVar3 != 0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)&DAT_10046680,DVar2,0);
      goto LAB_10012f4b;
    }
  }
  _DAT_10046684 = _DAT_10046684 + 1;
LAB_10012f4b:
  puVar7 = local_3d8;
  for (iVar6 = 0xb3; iVar6 != 0; iVar6 = iVar6 + -1) {
    *puVar7 = *param_1;
    param_1 = param_1 + 1;
    puVar7 = puVar7 + 1;
  }
  FUN_10021290(&local_104,0,0x100);
  local_10c = local_320;
  local_e0 = 3;
  local_100 = 3;
  local_108 = 0;
  local_ec = local_324;
  local_e8 = 0;
  pvVar4 = GetCurrentThread();
  iVar6 = 0;
  if (param_4 != 0) {
    do {
      iVar5 = (*(code *)PTR_FUN_100466b8)(0x14c,DAT_10046674,pvVar4,&local_10c,local_3d8,0,0,0,0);
      if ((iVar5 == 0) || ((local_ec | local_e8) == 0)) {
        iVar6 = 0;
        goto LAB_1001305b;
      }
      iVar6 = iVar6 + 1;
    } while (iVar6 != param_4);
  }
  iVar6 = 0;
  if (param_3 != 0) {
    do {
      iVar5 = (*(code *)PTR_FUN_100466b8)(0x14c,DAT_10046674,pvVar4,&local_10c,local_3d8,0,0,0,0);
      if ((iVar5 == 0) || ((local_ec | local_e8) == 0)) break;
      *(undefined4 *)(param_2 + iVar6 * 4) = local_10c;
      iVar6 = iVar6 + 1;
    } while (iVar6 != param_3);
  }
LAB_1001305b:
  _DAT_10046684 = _DAT_10046684 + -1;
  if (_DAT_10046684 == 0) {
    DAT_10046680 = 0;
  }
  return iVar6;
}



void __fastcall FUN_10013080(char *param_1)

{
  DWORD *this;
  DWORD DVar1;
  DWORD DVar2;
  undefined **ppuVar3;
  int iVar4;
  HANDLE pvVar5;
  HMODULE hModule;
  FARPROC pFVar6;
  code *pcVar7;
  uint uVar8;
  
  if (*param_1 != '\0') {
    if (param_1[1] == '\0') {
      return;
    }
    FUN_10013880(param_1);
    return;
  }
  this = (DWORD *)(param_1 + 0x10);
  DVar1 = GetCurrentThreadId();
  if (DVar1 == *this) {
LAB_100130c2:
    *(int *)(param_1 + 0x14) = *(int *)(param_1 + 0x14) + 1;
  }
  else {
    DVar2 = 0;
    LOCK();
    if (*this == 0) {
      *this = DVar1;
    }
    else {
      DVar2 = *this;
    }
    if (DVar2 == 0) goto LAB_100130c2;
    CThreadFastMutex::Lock((CThreadFastMutex *)this,DVar1,0);
  }
  ppuVar3 = CommandLine();
  iVar4 = (**(code **)(*ppuVar3 + 0x2c))("-steam");
  if (iVar4 != 0) {
    ppuVar3 = CommandLine();
    iVar4 = (**(code **)(*ppuVar3 + 0x2c))("-internalbuild");
    if (iVar4 == 0) {
      *param_1 = '\x01';
      goto LAB_10013298;
    }
  }
  pvVar5 = GetCurrentProcess();
  *(HANDLE *)(param_1 + 4) = pvVar5;
  if (pvVar5 != (HANDLE)0x0) {
    *param_1 = '\x01';
    hModule = LoadLibraryA("DbgHelp.dll");
    *(HMODULE *)(param_1 + 8) = hModule;
    if (hModule == (HMODULE)0x0) {
      if (*(int *)(param_1 + 0xc) == 0) {
        *param_1 = '\0';
      }
    }
    else {
      pFVar6 = GetProcAddress(hModule,"SymInitialize");
      *(FARPROC *)(param_1 + 0x18) = pFVar6;
      if (pFVar6 == (FARPROC)0x0) {
        FreeLibrary(*(HMODULE *)(param_1 + 8));
        *(undefined4 *)(param_1 + 8) = 0;
        *(code **)(param_1 + 0x18) = FUN_10013610;
      }
      else {
        pcVar7 = GetProcAddress(*(HMODULE *)(param_1 + 8),"SymCleanup");
        if (pcVar7 == (FARPROC)0x0) {
          pcVar7 = FUN_1000c540;
        }
        *(code **)(param_1 + 0x1c) = pcVar7;
        pcVar7 = GetProcAddress(*(HMODULE *)(param_1 + 8),"SymGetOptions");
        if (pcVar7 == (FARPROC)0x0) {
          pcVar7 = CVProfNode::GetPrevLoadHitStoreLessChildren;
        }
        *(code **)(param_1 + 0x20) = pcVar7;
        pcVar7 = GetProcAddress(*(HMODULE *)(param_1 + 8),"SymSetOptions");
        if (pcVar7 == (FARPROC)0x0) {
          pcVar7 = FUN_1000a3a0;
        }
        *(code **)(param_1 + 0x24) = pcVar7;
        pcVar7 = GetProcAddress(*(HMODULE *)(param_1 + 8),"SymSetSearchPath");
        if (pcVar7 == (FARPROC)0x0) {
          pcVar7 = FUN_10013630;
        }
        *(code **)(param_1 + 0x28) = pcVar7;
        pcVar7 = GetProcAddress(*(HMODULE *)(param_1 + 8),"SymEnumerateModules64");
        if (pcVar7 == (FARPROC)0x0) {
          pcVar7 = FUN_10013610;
        }
        *(code **)(param_1 + 0x2c) = pcVar7;
        pcVar7 = GetProcAddress(*(HMODULE *)(param_1 + 8),"EnumerateLoadedModules64");
        if (pcVar7 == (FARPROC)0x0) {
          pcVar7 = FUN_10013610;
        }
        *(code **)(param_1 + 0x30) = pcVar7;
        pcVar7 = GetProcAddress(*(HMODULE *)(param_1 + 8),"SymLoadModule64");
        if (pcVar7 == (FARPROC)0x0) {
          pcVar7 = FUN_10013620;
        }
        *(code **)(param_1 + 0x34) = pcVar7;
        pcVar7 = GetProcAddress(*(HMODULE *)(param_1 + 8),"SymUnloadModule64");
        if (pcVar7 == (FARPROC)0x0) {
          pcVar7 = FUN_10013610;
        }
        *(code **)(param_1 + 0x38) = pcVar7;
        pcVar7 = GetProcAddress(*(HMODULE *)(param_1 + 8),"SymFromAddr");
        if (pcVar7 == (FARPROC)0x0) {
          pcVar7 = FUN_100135f0;
        }
        *(code **)(param_1 + 0x3c) = pcVar7;
        pcVar7 = GetProcAddress(*(HMODULE *)(param_1 + 8),"SymGetLineFromAddr64");
        if (pcVar7 == (FARPROC)0x0) {
          pcVar7 = FUN_100135f0;
        }
        *(code **)(param_1 + 0x40) = pcVar7;
        pcVar7 = GetProcAddress(*(HMODULE *)(param_1 + 8),"SymGetModuleInfo64");
        if (pcVar7 == (FARPROC)0x0) {
          pcVar7 = FUN_10013600;
        }
        *(code **)(param_1 + 0x44) = pcVar7;
        pcVar7 = GetProcAddress(*(HMODULE *)(param_1 + 8),"StackWalk64");
        if (pcVar7 == (FARPROC)0x0) {
          pcVar7 = FUN_100135e0;
        }
        *(code **)(param_1 + 0x48) = pcVar7;
        uVar8 = (**(code **)(param_1 + 0x20))();
        (**(code **)(param_1 + 0x24))(uVar8 | 0x80614);
        (**(code **)(param_1 + 0x18))(*(undefined4 *)(param_1 + 4),*(undefined4 *)(param_1 + 0xc),0)
        ;
        FUN_10013880(param_1);
      }
    }
  }
LAB_10013298:
  *(int *)(param_1 + 0x14) = *(int *)(param_1 + 0x14) + -1;
  if (*(int *)(param_1 + 0x14) == 0) {
    *this = 0;
  }
  return;
}



void __cdecl FUN_100132b0(int param_1,int *param_2,int param_3,int param_4)

{
  int iVar1;
  
  iVar1 = FUN_10012f00(*(undefined4 **)(param_4 + 4),param_1,*param_2,param_3 + 1);
  *param_2 = iVar1;
  return;
}



uint __thiscall
FUN_100132e0(void *this,int param_1,char *param_2,size_t param_3,undefined4 *param_4,
            undefined4 *param_5)

{
  DWORD *this_00;
  uint in_EAX;
  DWORD DVar1;
  DWORD DVar2;
  int iVar3;
  undefined4 uVar4;
  char local_420 [1024];
  undefined4 local_20 [2];
  undefined4 local_18;
  char *local_14;
  undefined4 local_8;
  
  if (param_1 == 0) {
    return in_EAX & 0xffffff00;
  }
  this_00 = (DWORD *)((int)this + 0x10);
  DVar1 = GetCurrentThreadId();
  if (DVar1 != *this_00) {
    DVar2 = 0;
    LOCK();
    if (*this_00 == 0) {
      *this_00 = DVar1;
    }
    else {
      DVar2 = *this_00;
    }
    if (DVar2 != 0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)this_00,DVar1,0);
      goto LAB_10013328;
    }
  }
  *(int *)((int)this + 0x14) = *(int *)((int)this + 0x14) + 1;
LAB_10013328:
  local_14 = local_420;
  local_420[0] = '\0';
  local_20[0] = 0x18;
  iVar3 = (**(code **)((int)this + 0x40))
                    (*(undefined4 *)((int)this + 4),param_1,param_1 >> 0x1f,&local_8,local_20);
  if (iVar3 == 0) {
    uVar4 = 0;
  }
  else {
    _strncpy(param_2,local_14,param_3);
    *param_4 = local_18;
    if (param_5 != (undefined4 *)0x0) {
      *param_5 = local_8;
      local_18 = local_8;
    }
    uVar4 = CONCAT31((int3)((uint)local_18 >> 8),1);
  }
  *(int *)((int)this + 0x14) = *(int *)((int)this + 0x14) + -1;
  if (*(int *)((int)this + 0x14) == 0) {
    *this_00 = 0;
  }
  return uVar4;
}



bool __thiscall FUN_100133a0(void *this,int param_1,char *param_2,size_t param_3)

{
  DWORD *this_00;
  DWORD DVar1;
  DWORD DVar2;
  int iVar3;
  undefined4 local_68c [9];
  char local_668 [1636];
  
  this_00 = (DWORD *)((int)this + 0x10);
  DVar1 = GetCurrentThreadId();
  if (DVar1 != *this_00) {
    DVar2 = 0;
    LOCK();
    if (*this_00 == 0) {
      *this_00 = DVar1;
    }
    else {
      DVar2 = *this_00;
    }
    if (DVar2 != 0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)this_00,DVar1,0);
      goto LAB_100133da;
    }
  }
  *(int *)((int)this + 0x14) = *(int *)((int)this + 0x14) + 1;
LAB_100133da:
  local_68c[0] = 0x688;
  iVar3 = (**(code **)((int)this + 0x44))
                    (*(undefined4 *)((int)this + 4),param_1,param_1 >> 0x1f,local_68c);
  if (iVar3 != 0) {
    _strncpy(param_2,local_668,param_3);
  }
  *(int *)((int)this + 0x14) = *(int *)((int)this + 0x14) + -1;
  if (*(int *)((int)this + 0x14) == 0) {
    *this_00 = 0;
  }
  return iVar3 != 0;
}



uint __thiscall
FUN_10013430(void *this,int param_1,char *param_2,size_t param_3,undefined4 *param_4)

{
  DWORD *this_00;
  uint in_EAX;
  DWORD DVar1;
  DWORD DVar2;
  int iVar3;
  char *pcVar4;
  undefined4 uVar5;
  undefined4 local_834 [20];
  undefined4 local_7e4;
  char local_7e0 [2004];
  undefined4 local_c;
  char *local_8;
  
  if (param_1 == 0) {
    return in_EAX & 0xffffff00;
  }
  this_00 = (DWORD *)((int)this + 0x10);
  DVar1 = GetCurrentThreadId();
  if (DVar1 != *this_00) {
    DVar2 = 0;
    LOCK();
    if (*this_00 == 0) {
      *this_00 = DVar1;
    }
    else {
      DVar2 = *this_00;
    }
    if (DVar2 != 0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)this_00,DVar1,0);
      goto LAB_10013478;
    }
  }
  *(int *)((int)this + 0x14) = *(int *)((int)this + 0x14) + 1;
LAB_10013478:
  local_834[0] = 0x58;
  local_7e4 = 2000;
  iVar3 = (**(code **)((int)this + 0x3c))
                    (*(undefined4 *)((int)this + 4),param_1,param_1 >> 0x1f,&local_c,local_834);
  if (iVar3 == 0) {
    uVar5 = 0;
  }
  else {
    pcVar4 = _strncpy(param_2,local_7e0,param_3);
    if (param_4 != (undefined4 *)0x0) {
      *param_4 = local_c;
      param_4[1] = local_8;
      pcVar4 = local_8;
    }
    uVar5 = CONCAT31((int3)((uint)pcVar4 >> 8),1);
  }
  *(int *)((int)this + 0x14) = *(int *)((int)this + 0x14) + -1;
  if (*(int *)((int)this + 0x14) == 0) {
    *this_00 = 0;
  }
  return uVar5;
}



undefined4
FUN_100134f0(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,int param_5
            )

{
  (**(code **)(param_5 + 0x34))
            (*(undefined4 *)(param_5 + 4),0,param_1,param_1,param_2,param_3,param_4);
  return 1;
}



// public: void __thiscall CStackTop_ReferenceParentStack::ReleaseParentStackReferences(void)

void __thiscall
CStackTop_ReferenceParentStack::ReleaseParentStackReferences(CStackTop_ReferenceParentStack *this)

{
                    // 0x13520  200
                    // ?ReleaseParentStackReferences@CStackTop_ReferenceParentStack@@QAEXXZ
  *(undefined4 *)(this + 0xc) = 0;
  *(undefined4 *)(this + 0x10) = 0;
  return;
}



char * __thiscall FUN_10013530(void *this,char *param_1)

{
  char **this_00;
  char cVar1;
  char *pcVar2;
  char *pcVar3;
  void *_Dst;
  
  this_00 = (char **)((int)this + 0x10);
  pcVar2 = (char *)GetCurrentThreadId();
  if (pcVar2 != *this_00) {
    pcVar3 = (char *)0x0;
    LOCK();
    if (*this_00 == (char *)0x0) {
      *this_00 = pcVar2;
    }
    else {
      pcVar3 = *this_00;
    }
    if (pcVar3 != (char *)0x0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)this_00,(uint)pcVar2,0);
      goto LAB_10013567;
    }
  }
  *(int *)((int)this + 0x14) = *(int *)((int)this + 0x14) + 1;
LAB_10013567:
  if (*(void **)((int)this + 0xc) != (void *)0x0) {
    FID_conflict__free(*(void **)((int)this + 0xc));
  }
  if (param_1 == (char *)0x0) {
    *(undefined4 *)((int)this + 0xc) = 0;
  }
  else {
    pcVar2 = param_1;
    do {
      cVar1 = *pcVar2;
      pcVar2 = pcVar2 + 1;
    } while (cVar1 != '\0');
    _Dst = (void *)FUN_1001f8b3((size_t)(pcVar2 + (1 - (int)(param_1 + 1))));
    FID_conflict__memcpy(_Dst,param_1,(size_t)(pcVar2 + (1 - (int)(param_1 + 1))));
    *(void **)((int)this + 0xc) = _Dst;
    param_1 = (char *)(**(code **)((int)this + 0x28))(*(undefined4 *)((int)this + 4),_Dst);
    *(undefined *)((int)this + 1) = 1;
  }
  *(int *)((int)this + 0x14) = *(int *)((int)this + 0x14) + -1;
  if (*(int *)((int)this + 0x14) == 0) {
    param_1 = *this_00;
    *this_00 = (char *)0x0;
  }
  return param_1;
}



undefined4 FUN_100135e0(void)

{
  return 0;
}



undefined4 FUN_100135f0(void)

{
  return 0;
}



undefined4 FUN_10013600(void)

{
  return 0;
}



undefined4 FUN_10013610(void)

{
  return 0;
}



undefined8 FUN_10013620(void)

{
  return 0;
}



undefined4 FUN_10013630(void)

{
  return 0;
}



int __thiscall FUN_10013640(void *this,int param_1,undefined2 *param_2,size_t param_3,uint param_4)

{
  char cVar1;
  undefined2 *_Dest;
  bool bVar2;
  undefined4 in_EAX;
  uint3 uVar4;
  undefined3 extraout_var;
  undefined2 *puVar3;
  size_t _Size;
  undefined2 *puVar5;
  int iVar6;
  undefined2 *puVar7;
  size_t sVar8;
  char *pcVar9;
  char *pcVar10;
  char local_10c [260];
  void *local_8;
  
  sVar8 = param_3;
  _Dest = param_2;
  uVar4 = (uint3)((uint)in_EAX >> 8);
  if (param_2 == (undefined2 *)0x0) {
    return (uint)uVar4 << 8;
  }
  if ((int)param_3 < 1) {
    return (uint)uVar4 << 8;
  }
  *(undefined *)param_2 = 0;
  puVar5 = param_2;
  local_8 = this;
  if ((param_4 & 1) != 0) {
    bVar2 = FUN_100133a0(this,param_1,(char *)param_2,param_3);
    puVar3 = (undefined2 *)CONCAT31(extraout_var,bVar2);
    if (!bVar2) {
      puVar3 = (undefined2 *)_strncpy((char *)_Dest,"unknown_module",sVar8);
    }
    puVar5 = _Dest;
    do {
      cVar1 = *(char *)puVar5;
      puVar3 = (undefined2 *)((uint)puVar3 & 0xffffff00);
      puVar5 = (undefined2 *)((int)puVar5 + 1);
    } while (cVar1 != '\0');
    iVar6 = (int)puVar5 - ((int)_Dest + 1);
    sVar8 = sVar8 - iVar6;
    puVar5 = (undefined2 *)(iVar6 + (int)_Dest);
    if ((int)sVar8 < 2) goto LAB_100137e8;
    if ((param_4 & 2) != 0) {
      *(undefined *)puVar5 = 0x21;
      puVar5 = (undefined2 *)((int)puVar5 + 1);
      sVar8 = sVar8 - 1;
      *(undefined *)puVar5 = 0;
    }
  }
  puVar3 = (undefined2 *)FUN_10013430(local_8,param_1,(char *)puVar5,sVar8,(undefined4 *)0x0);
  if ((char)puVar3 == '\0') {
    puVar3 = (undefined2 *)FUN_1002169d((char *)puVar5,sVar8,&DAT_10038524);
    if ((int)puVar3 < 0) {
      *(undefined *)puVar5 = 0;
      return (uint)puVar3 & 0xffffff00;
    }
    goto LAB_10013867;
  }
  if ((param_4 & 2) == 0) {
    *(undefined *)puVar5 = 0;
  }
  else {
    param_2 = (undefined2 *)((int)puVar5 + 1);
    puVar3 = param_2;
    puVar7 = puVar5;
    do {
      cVar1 = *(char *)puVar7;
      puVar3 = (undefined2 *)((uint)puVar3 & 0xffffff00);
      puVar7 = (undefined2 *)((int)puVar7 + 1);
    } while (cVar1 != '\0');
    puVar5 = (undefined2 *)((int)puVar5 + ((int)puVar7 - (int)param_2));
    sVar8 = sVar8 - ((int)puVar7 - (int)param_2);
  }
  if ((param_4 & 0x3c) == 0) goto LAB_10013867;
  if (puVar5 != _Dest) {
    if ((int)sVar8 < 6) goto LAB_100137e8;
    *puVar5 = 0x2d20;
    *(undefined *)(puVar5 + 1) = 0x20;
    puVar5 = (undefined2 *)((int)puVar5 + 3);
    sVar8 = sVar8 - 3;
    *(undefined *)puVar5 = 0;
  }
  puVar3 = (undefined2 *)FUN_100132e0(local_8,param_1,local_10c,0x104,&param_3,&param_2);
  if ((char)puVar3 == '\0') {
    *(undefined *)((int)puVar5 + -3) = 0;
    goto LAB_10013867;
  }
  if ((param_4 & 4) == 0) {
    if ((param_4 & 8) != 0) {
      pcVar9 = local_10c;
      do {
        pcVar10 = pcVar9;
        pcVar9 = pcVar10 + 1;
      } while (*pcVar10 != '\0');
      iVar6 = 3;
      if (local_10c < pcVar10) {
        do {
          if (((*pcVar10 == '\\') || (*pcVar10 == '/')) && (iVar6 = iVar6 + -1, iVar6 == 0)) break;
          pcVar10 = pcVar10 + -1;
        } while (local_10c < pcVar10);
      }
      pcVar9 = pcVar10 + 1;
      do {
        cVar1 = *pcVar10;
        pcVar10 = pcVar10 + 1;
      } while (cVar1 != '\0');
      iVar6 = (int)pcVar10 - (int)pcVar9;
      _Size = iVar6 + 1;
      if ((int)sVar8 < (int)_Size) {
        *(undefined *)((int)puVar5 + -3) = 0;
        goto LAB_10013858;
      }
      goto LAB_10013799;
    }
  }
  else {
    pcVar9 = local_10c;
    do {
      cVar1 = *pcVar9;
      pcVar9 = pcVar9 + 1;
    } while (cVar1 != '\0');
    iVar6 = (int)pcVar9 - (int)(local_10c + 1);
    _Size = iVar6 + 1;
    if ((int)sVar8 < (int)_Size) {
LAB_10013858:
      return _Size & 0xffffff00;
    }
LAB_10013799:
    FID_conflict__memcpy(puVar5,local_10c,_Size);
    puVar5 = (undefined2 *)((int)puVar5 + iVar6);
    sVar8 = sVar8 - iVar6;
  }
  puVar3 = (undefined2 *)param_4;
  if ((param_4 & 0x30) != 0) {
    if (((param_4 & 0x20) == 0) || (pcVar9 = "(%d) + %d bytes", param_2 == (undefined2 *)0x0)) {
      pcVar9 = &DAT_1003853c;
    }
    puVar3 = (undefined2 *)FUN_1002169d((char *)puVar5,sVar8,(byte *)pcVar9);
    if ((int)puVar3 < 0) {
      *(undefined *)puVar5 = 0;
LAB_100137e8:
      return (uint)puVar3 & 0xffffff00;
    }
  }
LAB_10013867:
  return CONCAT31((int3)((uint)puVar3 >> 8),1);
}



void __fastcall FUN_10013880(char *param_1)

{
  DWORD *this;
  DWORD DVar1;
  DWORD DVar2;
  
  this = (DWORD *)(param_1 + 0x10);
  DVar1 = GetCurrentThreadId();
  if (DVar1 != *this) {
    DVar2 = 0;
    LOCK();
    if (*this == 0) {
      *this = DVar1;
    }
    else {
      DVar2 = *this;
    }
    if (DVar2 != 0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)this,DVar1,0);
      goto LAB_100138b0;
    }
  }
  *(int *)(param_1 + 0x14) = *(int *)(param_1 + 0x14) + 1;
LAB_100138b0:
  if (*param_1 != '\0') {
    (**(code **)(param_1 + 0x30))(*(undefined4 *)(param_1 + 4),FUN_100134f0,param_1);
    param_1[1] = '\0';
  }
  *(int *)(param_1 + 0x14) = *(int *)(param_1 + 0x14) + -1;
  if (*(int *)(param_1 + 0x14) == 0) {
    *this = 0;
  }
  return;
}



uint __cdecl DecodeBinaryFromString(byte *param_1,byte *param_2,int param_3,byte **param_4)

{
  int iVar1;
  uint uVar2;
  byte bVar4;
  int iVar3;
  byte bVar5;
  uint uVar6;
  byte *pbVar7;
  uint uVar8;
  
                    // 0x138e0  295  DecodeBinaryFromString
  if (((0x7f < *param_1) && (0x7f < param_1[1])) && (0x7f < param_1[2])) {
    uVar6 = (uint)CONCAT11(param_1[3],param_1[1]);
    bVar4 = (byte)(uVar6 >> 8);
    if (0x7f < bVar4) {
      uVar6 = (((*param_1 & 0x7f) << 7 | uVar6 & 0x7f) << 7 | param_1[2] & 0x7f) << 7 | bVar4 & 0x7f
      ;
      pbVar7 = param_1 + 4;
      iVar1 = 0;
      iVar3 = (uVar6 + 6) / 7 + uVar6;
      if (iVar3 != 0) {
        do {
          if (pbVar7[iVar1] < 0x80) {
            if (param_4 != (byte **)0x0) {
              *param_4 = param_1;
            }
            return 0x80000000;
          }
          iVar1 = iVar1 + 1;
        } while (iVar1 != iVar3);
      }
      if (param_3 < (int)uVar6) {
        if (param_4 != (byte **)0x0) {
          *param_4 = pbVar7;
        }
        uVar6 = -uVar6;
      }
      else {
        bVar4 = 0;
        uVar2 = (int)(pbVar7 + iVar3) - (int)pbVar7;
        uVar8 = 0;
        if (pbVar7 + iVar3 < pbVar7) {
          uVar2 = 0;
        }
        if (uVar2 != 0) {
          bVar5 = 0;
          do {
            if (bVar4 == 0) {
              bVar5 = *pbVar7;
            }
            else {
              *param_2 = bVar5 << bVar4 & 0x80 ^ *pbVar7;
              param_2 = param_2 + 1;
            }
            uVar8 = uVar8 + 1;
            bVar4 = bVar4 + 1 & 7;
            pbVar7 = pbVar7 + 1;
          } while (uVar8 < uVar2);
        }
        if (param_4 != (byte **)0x0) {
          *param_4 = pbVar7;
          return uVar6;
        }
      }
      return uVar6;
    }
  }
  if (param_4 != (byte **)0x0) {
    *param_4 = param_1;
  }
  return 0x80000000;
}



int __cdecl EncodeBinaryToString(byte *param_1,int param_2,byte *param_3,int param_4)

{
  byte *pbVar1;
  byte bVar2;
  byte *pbVar3;
  int iVar4;
  byte *pbVar5;
  
                    // 0x13a10  327  EncodeBinaryToString
  iVar4 = param_2 + 5 + (param_2 + 6) / 7;
  if (((iVar4 <= param_4) && (param_3 != (byte *)0x0)) && (param_1 != (byte *)0x0)) {
    *param_3 = (byte)(param_2 >> 0x15) | 0x80;
    param_3[1] = (byte)(param_2 >> 0xe) | 0x80;
    param_3[2] = (byte)(param_2 >> 7) | 0x80;
    param_3[3] = (byte)param_2 | 0x80;
    pbVar3 = param_3 + 4;
    pbVar1 = param_1 + param_2;
    bVar2 = 0;
    pbVar5 = pbVar3;
    if (param_1 < pbVar1) {
      do {
        if (bVar2 == 0) {
          *pbVar3 = 0x80;
          pbVar5 = pbVar3;
        }
        else {
          *pbVar3 = *param_1 | 0x80;
          *pbVar5 = *pbVar5 | (byte)((int)(~(uint)*param_1 & 0x80) >> bVar2);
          param_1 = param_1 + 1;
        }
        pbVar3 = pbVar3 + 1;
        bVar2 = bVar2 + 1 & 7;
      } while (param_1 < pbVar1);
    }
    *pbVar3 = 0;
    return iVar4 + -1;
  }
  return -iVar4;
}



void __cdecl GetCallStack(int param_1,int param_2,int param_3)

{
  undefined4 *in_FS_OFFSET;
  undefined4 local_14;
  code *pcStack16;
  undefined *puStack12;
  undefined4 local_8;
  
                    // 0x13ac0  333  GetCallStack
  local_8 = 0xffffffff;
  puStack12 = &DAT_1003f5f0;
  pcStack16 = FUN_100213a8;
  local_14 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_14;
  FUN_10013080(&DAT_10046670);
  if ((code *)PTR_FUN_100466b8 != FUN_100135e0) {
    local_8 = 0;
    RaiseException(0,1,0,(ULONG_PTR *)0x0);
    local_8 = 0xffffffff;
  }
  GetCallStack_Fast(param_1,param_2,param_3 + 1);
  *in_FS_OFFSET = local_14;
  return;
}



void __cdecl GetCallStack_Fast(int param_1,int param_2,int param_3)

{
  undefined4 *puVar1;
  void *pvVar2;
  int iVar3;
  BOOL BVar4;
  undefined4 *puVar5;
  undefined4 *puVar6;
  undefined4 *puVar7;
  undefined4 *puVar8;
  undefined4 *local_8;
  
                    // 0x13b90  334  GetCallStack_Fast
  puVar6 = (undefined4 *)&stack0xfffffffc;
  puVar5 = (undefined4 *)&stack0xfffffffc;
  puVar7 = (undefined4 *)&stack0xfffffffc;
  local_8 = (undefined4 *)&stack0xfffffffc;
  puVar8 = (undefined4 *)&stack0xfffffffc;
  pvVar2 = GenericThreadLocals::CThreadLocalBase::Get((CThreadLocalBase *)&DAT_10833d10);
  if (pvVar2 == (void *)0x0) {
    if (param_3 != 0) {
      iVar3 = 0;
      local_8 = (undefined4 *)&stack0xfffffffc;
      puVar5 = (undefined4 *)&stack0xfffffffc;
      do {
        puVar8 = local_8;
        if ((((((uint)puVar8 & 3) != 0) || (puVar8 < puVar5)) || (&stack0x000ffffc < puVar8)) ||
           (BVar4 = IsBadReadPtr(puVar8,8), BVar4 != 0)) goto LAB_10013c11;
        iVar3 = iVar3 + 1;
        local_8 = (undefined4 *)*puVar8;
        puVar5 = puVar8;
      } while (iVar3 != param_3);
    }
    iVar3 = 0;
    if (param_2 != 0) {
      do {
        if (((((uint)local_8 & 3) != 0) || (local_8 < puVar8)) ||
           ((&stack0x000ffffc < local_8 || (BVar4 = IsBadReadPtr(local_8,8), BVar4 != 0)))) break;
        *(undefined4 *)(param_1 + iVar3 * 4) = local_8[1];
        iVar3 = iVar3 + 1;
        puVar8 = local_8;
        local_8 = (undefined4 *)*local_8;
      } while (iVar3 != param_2);
    }
    FUN_10012e80(param_1,param_2,iVar3);
    return;
  }
  puVar8 = *(undefined4 **)((int)pvVar2 + 4);
  iVar3 = 0;
  puVar1 = (undefined4 *)&stack0xfffffffc;
  if (param_3 != 0) {
    do {
      puVar7 = puVar1;
      if ((puVar7 < puVar6) || (puVar8 < puVar7)) {
LAB_10013c11:
        FUN_10012e80(param_1,param_2,0);
        return;
      }
      iVar3 = iVar3 + 1;
      puVar5 = (undefined4 *)*puVar7;
      puVar1 = puVar5;
      puVar6 = puVar7;
    } while (iVar3 != param_3);
  }
  iVar3 = 0;
  if (param_2 != 0) {
    do {
      puVar6 = puVar5;
      if ((puVar6 < puVar7) || (puVar8 < puVar6)) break;
      *(undefined4 *)(param_1 + iVar3 * 4) = puVar6[1];
      iVar3 = iVar3 + 1;
      puVar5 = (undefined4 *)*puVar6;
      puVar7 = puVar6;
    } while (iVar3 != param_2);
  }
  FUN_10012e80(param_1,param_2,iVar3);
  return;
}



void __cdecl
GetFileAndLineFromAddress
          (int param_1,char *param_2,size_t param_3,undefined4 *param_4,undefined4 *param_5)

{
                    // 0x13cc0  338  GetFileAndLineFromAddress
  FUN_10013080(&DAT_10046670);
  FUN_100132e0(&DAT_10046670,param_1,param_2,param_3,param_4,param_5);
  return;
}



void __cdecl GetModuleNameFromAddress(int param_1,char *param_2,size_t param_3)

{
                    // 0x13cf0  340  GetModuleNameFromAddress
  FUN_10013080(&DAT_10046670);
  FUN_100133a0(&DAT_10046670,param_1,param_2,param_3);
  return;
}



void __cdecl GetSymbolNameFromAddress(int param_1,char *param_2,size_t param_3,undefined4 *param_4)

{
                    // 0x13d20  341  GetSymbolNameFromAddress
  FUN_10013080(&DAT_10046670);
  FUN_10013430(&DAT_10046670,param_1,param_2,param_3,param_4);
  return;
}



void __cdecl SetStackTranslationSymbolSearchPath(char *param_1)

{
                    // 0x13d50  449  SetStackTranslationSymbolSearchPath
  FUN_10013530(&DAT_10046670,param_1);
  return;
}



void StackToolsNotify_LoadedLibrary(void)

{
  DAT_10046671 = 1;
                    // 0x13d70  455  StackToolsNotify_LoadedLibrary
  return;
}



int __cdecl
TranslateStackInfo(int param_1,int param_2,undefined2 *param_3,size_t param_4,char *param_5,
                  uint param_6)

{
  char cVar1;
  undefined2 *puVar2;
  undefined4 uVar3;
  undefined2 *puVar4;
  int iVar5;
  char *_Src;
  undefined2 *_Dst;
  char *pcVar6;
  size_t _Size;
  
                    // 0x13d80  473  TranslateStackInfo
  puVar2 = param_3;
  FUN_10013080(&DAT_10046670);
  _Src = "";
  if (param_5 != (char *)0x0) {
    _Src = param_5;
  }
  pcVar6 = _Src;
  do {
    cVar1 = *pcVar6;
    pcVar6 = pcVar6 + 1;
  } while (cVar1 != '\0');
  _Size = (int)pcVar6 - (int)(_Src + 1);
  param_3 = (undefined2 *)0x0;
  _Dst = puVar2;
  if (0 < param_2) {
    do {
      uVar3 = FUN_10013640(&DAT_10046670,*(int *)(param_1 + (int)param_3 * 4),_Dst,param_4,param_6);
      if ((char)uVar3 == '\0') {
        return (int)param_3;
      }
      puVar4 = _Dst;
      do {
        cVar1 = *(char *)puVar4;
        puVar4 = (undefined2 *)((int)puVar4 + 1);
      } while (cVar1 != '\0');
      iVar5 = (int)puVar4 - ((int)_Dst + 1);
      param_4 = param_4 - iVar5;
      _Dst = (undefined2 *)((int)_Dst + iVar5);
      if ((int)_Size < (int)param_4) {
        FID_conflict__memcpy(_Dst,_Src,_Size);
        _Dst = (undefined2 *)((int)_Dst + _Size);
        param_4 = param_4 - _Size;
      }
      param_3 = (undefined2 *)((int)param_3 + 1);
      *(undefined *)_Dst = 0;
    } while ((int)param_3 < param_2);
  }
  if (puVar2 <= (undefined2 *)((int)_Dst - _Size)) {
    *(undefined *)(undefined2 *)((int)_Dst - _Size) = 0;
  }
  return param_2;
}



undefined4 * __thiscall FUN_10013e40(void *this,LPCSTR param_1,LPCSTR param_2)

{
  HMODULE hModule;
  FARPROC pFVar1;
  undefined4 uVar2;
  
  *(undefined4 *)this = 0;
  *(undefined4 *)((int)this + 4) = 0;
  *(undefined4 *)((int)this + 8) = 0;
  *(undefined2 *)((int)this + 0xc) = 1;
  hModule = GetModuleHandleA(param_1);
  *(HMODULE *)((int)this + 8) = hModule;
  *(undefined *)((int)this + 0xd) = 0;
  if (hModule == (HMODULE)0x0) {
    *(undefined4 *)this = 3;
    return (undefined4 *)this;
  }
  *(undefined *)((int)this + 0xc) = 1;
  pFVar1 = GetProcAddress(hModule,param_2);
  uVar2 = 0;
  *(FARPROC *)((int)this + 4) = pFVar1;
  if (pFVar1 == (FARPROC)0x0) {
    uVar2 = 2;
  }
  *(undefined4 *)this = uVar2;
  return (undefined4 *)this;
}



void __fastcall FUN_10013eb0(undefined4 *param_1)

{
  if (*(char *)(param_1 + 3) != '\0') {
    if ((*(char *)((int)param_1 + 0xd) != '\0') && ((HMODULE)param_1[2] != (HMODULE)0x0)) {
      FreeLibrary((HMODULE)param_1[2]);
    }
    *param_1 = 0;
    param_1[2] = 0;
    param_1[1] = 0;
    *(undefined2 *)(param_1 + 3) = 0;
  }
  return;
}



undefined4 Plat_GetMemPageSize(void)

{
                    // 0x13ef0  395  Plat_GetMemPageSize
  return 4;
}



int __cdecl Plat_GetPagedPoolInfo(undefined8 *param_1)

{
  uint uVar1;
  HANDLE pvVar2;
  int iVar3;
  int *piVar4;
  undefined local_1e8 [112];
  undefined4 local_178;
  undefined4 local_148;
  undefined local_b0 [8];
  undefined2 local_a8;
  int local_1c;
  code *local_18;
  undefined4 local_c;
  int local_8;
  
                    // 0x13f00  398  Plat_GetPagedPoolInfo
  uVar1 = DAT_10833d28;
  *param_1 = 0;
  if ((uVar1 & 1) == 0) {
    DAT_10833d28 = uVar1 | 1;
    FUN_10013e40(&DAT_10833d18,"ntdll.dll","NtQuerySystemInformation");
    FUN_1002050a(FUN_100352c0);
  }
  iVar3 = DAT_10833d18;
  if (DAT_10833d18 == 0) {
    if (DAT_10833d2c == '\0') {
      DAT_10833d2c = '\x01';
      FUN_10021290((uint *)local_b0,0,0x94);
      local_b0._0_4_ = 0x94;
      GetVersionExA((LPOSVERSIONINFOA)local_b0);
      if ((CONCAT22(local_b0._4_2_,local_a8) < 0x50001) ||
         (0x50002 < CONCAT22(local_b0._4_2_,local_a8))) {
        DAT_10833d18 = 4;
      }
      FUN_10013e40(&local_1c,"kernel32.dll","IsWow64Process");
      if (local_1c == 0) {
        piVar4 = &local_8;
        local_8 = 0;
        pvVar2 = GetCurrentProcess();
        iVar3 = (*local_18)(pvVar2,piVar4);
        if ((iVar3 != 0) && (local_8 != 0)) {
          DAT_10833d18 = 4;
          FUN_10013eb0(&local_1c);
          return 4;
        }
      }
      iVar3 = DAT_10833d18;
      if (DAT_10833d18 != 0) {
        FUN_10013eb0(&local_1c);
        return iVar3;
      }
      FUN_10013eb0(&local_1c);
    }
    local_c = 0x138;
    iVar3 = (*DAT_10833d1c)(2,local_1e8,0x138,&local_c);
    if (iVar3 != 0) {
      return 1;
    }
    *(undefined4 *)param_1 = local_178;
    *(undefined4 *)((int)param_1 + 4) = local_148;
    iVar3 = 0;
  }
  return iVar3;
}



// public: __thiscall CThread::CThread(void)

CThread * __thiscall CThread::CThread(CThread *this)

{
  HANDLE pvVar1;
  
                    // 0x14080  12  ??0CThread@@QAE@XZ
  *(undefined ***)this = _vftable_;
  *(undefined (*) [16])(LPCRITICAL_SECTION)(this + 4) = ZEXT816(0);
  *(undefined8 *)(this + 0x14) = 0;
  InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)(this + 4),4000);
  *(undefined2 *)(this + 0x20) = 0;
  *(undefined4 *)(this + 0x1c) = 0;
  this[0x22] = (CThread)0x0;
  *(undefined4 *)(this + 0x24) = 0;
  this[0x28] = (CThread)0x0;
  pvVar1 = CreateEventA((LPSECURITY_ATTRIBUTES)0x0,0,0,(LPCSTR)0x0);
  *(HANDLE *)(this + 0x24) = pvVar1;
  this[0x28] = (CThread)0x1;
  *(undefined4 *)(this + 0x2c) = 0;
  *(undefined4 *)(this + 0x30) = 0;
  *(undefined4 *)(this + 0x34) = 0;
  *(undefined4 *)(this + 0x5c) = 0;
  *(undefined4 *)(this + 0x60) = 0;
  this[100] = (CThread)0x0;
  pvVar1 = CreateEventA((LPSECURITY_ATTRIBUTES)0x0,1,0,(LPCSTR)0x0);
  *(HANDLE *)(this + 0x60) = pvVar1;
  this[100] = (CThread)0x1;
  this[0x38] = (CThread)0x0;
  SetEvent(pvVar1);
  return this;
}



// public: __thiscall CThreadEvent::CThreadEvent(char const *,bool,bool)

CThreadEvent * __thiscall
CThreadEvent::CThreadEvent(CThreadEvent *this,char *param_1,bool param_2,bool param_3)

{
  HANDLE pvVar1;
  
                    // 0x14120  13  ??0CThreadEvent@@QAE@PBD_N1@Z
  *(undefined4 *)this = 0;
  this[4] = (CThreadEvent)0x0;
  pvVar1 = CreateEventA((LPSECURITY_ATTRIBUTES)0x0,(uint)param_3,(uint)param_2,param_1);
  *(HANDLE *)this = pvVar1;
  return this;
}



// public: __thiscall CThreadEvent::CThreadEvent(bool)

CThreadEvent * __thiscall CThreadEvent::CThreadEvent(CThreadEvent *this,bool param_1)

{
  HANDLE pvVar1;
  
                    // 0x14160  14  ??0CThreadEvent@@QAE@_N@Z
  *(undefined4 *)this = 0;
  this[4] = (CThreadEvent)0x0;
  pvVar1 = CreateEventA((LPSECURITY_ATTRIBUTES)0x0,(uint)param_1,0,(LPCSTR)0x0);
  *(HANDLE *)this = pvVar1;
  this[4] = (CThreadEvent)0x1;
  return this;
}



// public: __thiscall CThreadFullMutex::CThreadFullMutex(bool,char const *)

CThreadFullMutex * __thiscall
CThreadFullMutex::CThreadFullMutex(CThreadFullMutex *this,bool param_1,char *param_2)

{
  HANDLE pvVar1;
  
                    // 0x14190  15  ??0CThreadFullMutex@@QAE@_NPBD@Z
  *(undefined4 *)this = 0;
  this[4] = (CThreadFullMutex)0x0;
  pvVar1 = CreateMutexA((LPSECURITY_ATTRIBUTES)0x0,(uint)param_1,param_2);
  *(HANDLE *)this = pvVar1;
  return this;
}



// public: __thiscall GenericThreadLocals::CThreadLocalBase::CThreadLocalBase(void)

CThreadLocalBase * __thiscall
GenericThreadLocals::CThreadLocalBase::CThreadLocalBase(CThreadLocalBase *this)

{
  DWORD DVar1;
  
                    // 0x141c0  16  ??0CThreadLocalBase@GenericThreadLocals@@QAE@XZ
  DVar1 = TlsAlloc();
  *(DWORD *)this = DVar1;
  if (DVar1 == 0xffffffff) {
    Error((byte *)"Out of thread local storage!\n");
  }
  return this;
}



// public: __thiscall CThreadMutex::CThreadMutex(void)

CThreadMutex * __thiscall CThreadMutex::CThreadMutex(CThreadMutex *this)

{
                    // 0x141f0  17  ??0CThreadMutex@@QAE@XZ
  *(undefined (*) [16])this = ZEXT816(0);
  *(undefined8 *)(this + 0x10) = 0;
  InitializeCriticalSectionAndSpinCount((LPCRITICAL_SECTION)this,4000);
  *(undefined2 *)(this + 0x1c) = 0;
  *(undefined4 *)(this + 0x18) = 0;
  this[0x1e] = (CThreadMutex)0x0;
  return this;
}



// public: __thiscall CThreadSemaphore::CThreadSemaphore(int,int)

CThreadSemaphore * __thiscall
CThreadSemaphore::CThreadSemaphore(CThreadSemaphore *this,int param_1,int param_2)

{
  HANDLE pvVar1;
  
                    // 0x14220  19  ??0CThreadSemaphore@@QAE@HH@Z
  *(undefined4 *)this = 0;
  this[4] = (CThreadSemaphore)0x0;
  if (param_2 != 0) {
    pvVar1 = CreateSemaphoreA((LPSECURITY_ATTRIBUTES)0x0,param_1,param_2,(LPCSTR)0x0);
    *(HANDLE *)this = pvVar1;
    return this;
  }
  *(undefined4 *)this = 0;
  return this;
}



// protected: __thiscall CThreadSyncObject::CThreadSyncObject(void)

CThreadSyncObject * __thiscall CThreadSyncObject::CThreadSyncObject(CThreadSyncObject *this)

{
                    // 0x14260  21  ??0CThreadSyncObject@@IAE@XZ
  *(undefined4 *)this = 0;
  this[4] = (CThreadSyncObject)0x0;
  return this;
}



// public: __thiscall CWorkerThread::CWorkerThread(void)

CWorkerThread * __thiscall CWorkerThread::CWorkerThread(CWorkerThread *this)

{
  HANDLE pvVar1;
  
                    // 0x14270  25  ??0CWorkerThread@@QAE@XZ
  CThread::CThread((CThread *)this);
  *(undefined ***)this = _vftable_;
  *(undefined4 *)(this + 0x68) = 0;
  this[0x6c] = (CWorkerThread)0x0;
  pvVar1 = CreateEventA((LPSECURITY_ATTRIBUTES)0x0,1,0,(LPCSTR)0x0);
  *(HANDLE *)(this + 0x68) = pvVar1;
  this[0x6c] = (CWorkerThread)0x1;
  *(undefined4 *)(this + 0x70) = 0;
  this[0x74] = (CWorkerThread)0x0;
  pvVar1 = CreateEventA((LPSECURITY_ATTRIBUTES)0x0,1,0,(LPCSTR)0x0);
  *(HANDLE *)(this + 0x70) = pvVar1;
  this[0x74] = (CWorkerThread)0x1;
  *(undefined4 *)(this + 0x78) = 0;
  *(undefined4 *)(this + 0x7c) = 0;
  return this;
}



// public: virtual __thiscall CThread::~CThread(void)

void __thiscall CThread::_CThread(CThread *this)

{
  BOOL BVar1;
  CThread *pCVar2;
  CThread *local_8;
  
                    // 0x142d0  32  ??1CThread@@UAE@XZ
  *(undefined ***)this = _vftable_;
  local_8 = this;
  if (*(HANDLE *)(this + 0x2c) != (HANDLE)0x0) {
    BVar1 = GetExitCodeThread(*(HANDLE *)(this + 0x2c),(LPDWORD)&local_8);
    if ((BVar1 != 0) && (local_8 == (CThread *)0x103)) {
      Msg((byte *)
          "Illegal termination of worker thread! Threads must negotiate an end to the thread before the CThread object is destroyed.\n"
         );
      DoNewAssertDialog((byte *)
                        "d:\\projects\\ti\\release\\ti_rel\\src\\public\\tier0\\threadtools.inl",
                        0x30,
                        "Illegal termination of worker thread! Threads must negotiate an end to the thread before the CThread object is destroyed.\n"
                       );
      if (DAT_10833d3c == 0xffffffff) {
        pCVar2 = (CThread *)0x0;
      }
      else {
        pCVar2 = (CThread *)TlsGetValue(DAT_10833d3c);
      }
      if (pCVar2 == this) {
        Stop(this,0);
      }
    }
  }
  if ((*(HANDLE *)(this + 0x60) != (HANDLE)0x0) && (this[100] != (CThread)0x0)) {
    CloseHandle(*(HANDLE *)(this + 0x60));
  }
  if ((*(HANDLE *)(this + 0x24) != (HANDLE)0x0) && (this[0x28] != (CThread)0x0)) {
    CloseHandle(*(HANDLE *)(this + 0x24));
  }
  DeleteCriticalSection((LPCRITICAL_SECTION)(this + 4));
  return;
}



// public: __thiscall GenericThreadLocals::CThreadLocalBase::~CThreadLocalBase(void)

void __thiscall GenericThreadLocals::CThreadLocalBase::_CThreadLocalBase(CThreadLocalBase *this)

{
                    // 0x14380  35  ??1CThreadLocalBase@GenericThreadLocals@@QAE@XZ
  if (*(DWORD *)this != 0xffffffff) {
    TlsFree(*(DWORD *)this);
  }
  *(undefined4 *)this = 0xffffffff;
  return;
}



// public: __thiscall CThreadMutex::~CThreadMutex(void)

void __thiscall CThreadMutex::_CThreadMutex(CThreadMutex *this)

{
                    // 0x143a0  36  ??1CThreadMutex@@QAE@XZ
  DeleteCriticalSection((LPCRITICAL_SECTION)this);
  return;
}



// public: __thiscall CThreadSyncObject::~CThreadSyncObject(void)

void __thiscall CThreadSyncObject::_CThreadSyncObject(CThreadSyncObject *this)

{
                    // 0x143b0  39  ??1CThreadSyncObject@@QAE@XZ
  if ((*(HANDLE *)this != (HANDLE)0x0) && (this[4] != (CThreadSyncObject)0x0)) {
    CloseHandle(*(HANDLE *)this);
  }
  return;
}



// public: bool __thiscall CThreadSyncObject::operator!(void)const 

bool __thiscall CThreadSyncObject::operator_(CThreadSyncObject *this)

{
                    // 0x143d0  57  ??7CThreadSyncObject@@QBE_NXZ
  return *(int *)this == 0;
}



CThread * __thiscall FUN_100143e0(void *this,uint param_1)

{
  int iVar1;
  CThread *this_00;
  
  if ((param_1 & 2) != 0) {
    iVar1 = *(int *)((int)this + -4);
    this_00 = (CThread *)(iVar1 * 0x68 + (int)this);
    while (iVar1 = iVar1 + -1, -1 < iVar1) {
      this_00 = this_00 + -0x68;
      CThread::_CThread(this_00);
    }
    if ((param_1 & 1) != 0) {
      FID_conflict__free((int *)((int)this + -4));
    }
    return (CThread *)((int)this + -4);
  }
  CThread::_CThread((CThread *)this);
  if ((param_1 & 1) != 0) {
    FID_conflict__free(this);
  }
  return (CThread *)this;
}



CThread * __thiscall FUN_10014450(void *this,uint param_1)

{
  int iVar1;
  int iVar2;
  
  if ((param_1 & 2) == 0) {
    if ((*(HANDLE *)((int)this + 0x70) != (HANDLE)0x0) && (*(char *)((int)this + 0x74) != '\0')) {
      CloseHandle(*(HANDLE *)((int)this + 0x70));
    }
    if ((*(HANDLE *)((int)this + 0x68) != (HANDLE)0x0) && (*(char *)((int)this + 0x6c) != '\0')) {
      CloseHandle(*(HANDLE *)((int)this + 0x68));
    }
    CThread::_CThread((CThread *)this);
    if ((param_1 & 1) != 0) {
      FID_conflict__free(this);
    }
    return (CThread *)this;
  }
  iVar2 = *(int *)((int)this + -4) + -1;
  if (-1 < iVar2) {
    iVar1 = (int)this + *(int *)((int)this + -4) * 0x80 + 0x70;
    do {
      if ((*(HANDLE *)(iVar1 + -0x80) != (HANDLE)0x0) && (*(char *)(iVar1 + -0x7c) != '\0')) {
        CloseHandle(*(HANDLE *)(iVar1 + -0x80));
      }
      if ((*(HANDLE *)(iVar1 + -0x88) != (HANDLE)0x0) && (*(char *)(iVar1 + -0x84) != '\0')) {
        CloseHandle(*(HANDLE *)(iVar1 + -0x88));
      }
      CThread::_CThread((CThread *)(iVar1 + -0xf0));
      iVar2 = iVar2 + -1;
      iVar1 = iVar1 + -0x80;
    } while (-1 < iVar2);
  }
  if ((param_1 & 1) != 0) {
    FID_conflict__free((CThread *)((int)this + -4));
  }
  return (CThread *)((int)this + -4);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_10014520(int param_1,int param_2)

{
  int *piVar1;
  
  if (param_1 != 0) {
    piVar1 = (int *)FUN_1001f8b3(0xc);
    piVar1[1] = param_2;
    *piVar1 = param_1;
    CThreadMutex::Lock((CThreadMutex *)&DAT_10833d50);
    piVar1[2] = (int)DAT_10833d30;
    _DAT_10833df8 = _DAT_10833df8 + 1;
    DAT_10833d6c = DAT_10833d6c + -1;
    DAT_10833d30 = piVar1;
    if (DAT_10833d6c == 0) {
      if (DAT_10833d6e != '\0') {
        Msg((byte *)"Thread %u releasing lock 0x%p\n");
      }
      DAT_10833d68 = 0;
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_10833d50);
    if (500 < _DAT_10833df8) {
      Error((byte *)"ThreadHandleToIDMap overflow.");
    }
  }
  return;
}



// public: int __thiscall CWorkerThread::BoostPriority(void)

int __thiscall CWorkerThread::BoostPriority(CWorkerThread *this)

{
  int iVar1;
  HANDLE pvVar2;
  int nPriority;
  
                    // 0x145d0  76  ?BoostPriority@CWorkerThread@@QAEHXZ
  iVar1 = GetThreadPriority(*(HANDLE *)(this + 0x2c));
  pvVar2 = *(HANDLE *)(this + 0x2c);
  if (pvVar2 == (HANDLE)0x0) {
    pvVar2 = GetCurrentThread();
  }
  nPriority = GetThreadPriority(pvVar2);
  if (iVar1 < nPriority) {
    pvVar2 = *(HANDLE *)(this + 0x2c);
    if (pvVar2 == (HANDLE)0x0) {
      pvVar2 = GetCurrentThread();
    }
    SetThreadPriority(pvVar2,nPriority);
  }
  return iVar1;
}



// protected: int __thiscall CWorkerThread::Call(unsigned int,unsigned int,bool,unsigned int
// (__cdecl*)(unsigned int,class CThreadEvent * *,int,unsigned int))

int __thiscall
CWorkerThread::Call(CWorkerThread *this,uint param_1,uint param_2,bool param_3,FuncDef1 *param_4)

{
  short *psVar1;
  BOOL BVar2;
  HANDLE hThread;
  int iVar3;
  CWorkerThread *local_8;
  
                    // 0x14620  81  ?Call@CWorkerThread@@IAEHII_NP6AIIPAPAVCThreadEvent@@HI@Z@Z
  local_8 = this;
  CThreadMutex::Lock((CThreadMutex *)(LPCRITICAL_SECTION)(this + 4));
  if (*(HANDLE *)(this + 0x2c) != (HANDLE)0x0) {
    BVar2 = GetExitCodeThread(*(HANDLE *)(this + 0x2c),(LPDWORD)&local_8);
    if ((BVar2 != 0) && (local_8 == (CWorkerThread *)0x103)) {
      iVar3 = 0;
      if (param_3 != false) {
        iVar3 = BoostPriority(this);
      }
      *(uint *)(this + 0x78) = param_1;
      ResetEvent(*(HANDLE *)(this + 0x70));
      SetEvent(*(HANDLE *)(this + 0x68));
      WaitForReply(this,param_2,(FuncDef3 *)param_4);
      if (param_3 != false) {
        hThread = *(HANDLE *)(this + 0x2c);
        if (hThread == (HANDLE)0x0) {
          hThread = GetCurrentThread();
        }
        SetThreadPriority(hThread,iVar3);
      }
      iVar3 = *(int *)(this + 0x7c);
      goto LAB_100146ab;
    }
  }
  iVar3 = -1;
LAB_100146ab:
  psVar1 = (short *)(this + 0x20);
  *psVar1 = *psVar1 + -1;
  if (*psVar1 == 0) {
    if (this[0x22] != (CWorkerThread)0x0) {
      Msg((byte *)"Thread %u releasing lock 0x%p\n");
    }
    *(undefined4 *)(this + 0x1c) = 0;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 4));
  return iVar3;
}



// public: int __thiscall CWorkerThread::CallMaster(unsigned int,unsigned int)

int __thiscall CWorkerThread::CallMaster(CWorkerThread *this,uint param_1,uint param_2)

{
  LPCRITICAL_SECTION lpCriticalSection;
  short *psVar1;
  int iVar2;
  BOOL BVar3;
  CWorkerThread *local_8;
  
                    // 0x146f0  82  ?CallMaster@CWorkerThread@@QAEHII@Z
  lpCriticalSection = (LPCRITICAL_SECTION)(this + 4);
  local_8 = this;
  CThreadMutex::Lock((CThreadMutex *)lpCriticalSection);
  if (*(HANDLE *)(this + 0x2c) != (HANDLE)0x0) {
    BVar3 = GetExitCodeThread(*(HANDLE *)(this + 0x2c),(LPDWORD)&local_8);
    if ((BVar3 != 0) && (local_8 == (CWorkerThread *)0x103)) {
      *(uint *)(this + 0x78) = param_1;
      ResetEvent(*(HANDLE *)(this + 0x70));
      SetEvent(*(HANDLE *)(this + 0x68));
      WaitForReply(this,param_2,(FuncDef3 *)0x0);
      iVar2 = *(int *)(this + 0x7c);
      psVar1 = (short *)(this + 0x20);
      *psVar1 = *psVar1 + -1;
      if (*psVar1 == 0) {
        if (this[0x22] != (CWorkerThread)0x0) {
          Msg((byte *)"Thread %u releasing lock 0x%p\n");
        }
        *(undefined4 *)(this + 0x1c) = 0;
      }
      LeaveCriticalSection(lpCriticalSection);
      return iVar2;
    }
  }
  psVar1 = (short *)(this + 0x20);
  *psVar1 = *psVar1 + -1;
  if (*psVar1 == 0) {
    if (this[0x22] != (CWorkerThread)0x0) {
      Msg((byte *)"Thread %u releasing lock 0x%p\n");
    }
    *(undefined4 *)(this + 0x1c) = 0;
  }
  LeaveCriticalSection(lpCriticalSection);
  return -1;
}



// public: int __thiscall CWorkerThread::CallWorker(unsigned int,unsigned int,bool)

int __thiscall CWorkerThread::CallWorker(CWorkerThread *this,uint param_1,uint param_2,bool param_3)

{
  int iVar1;
  
                    // 0x147c0  83  ?CallWorker@CWorkerThread@@QAEHII_N@Z
  iVar1 = Call(this,param_1,param_2,param_3,(FuncDef1 *)0x0);
  return iVar1;
}



// public: bool __thiscall CThreadEvent::Check(void)

bool __thiscall CThreadEvent::Check(CThreadEvent *this)

{
  DWORD DVar1;
  
                    // 0x147e0  84  ?Check@CThreadEvent@@QAE_NXZ
  DVar1 = WaitForSingleObject(*(HANDLE *)this,0);
  return (bool)('\x01' - (DVar1 != 0));
}



// public: static enum NamedEventResult_t __cdecl CThreadEvent::CheckNamedEvent(char const
// *,unsigned int)

NamedEventResult_t __cdecl CThreadEvent::CheckNamedEvent(char *param_1,uint param_2)

{
  HANDLE hHandle;
  DWORD DVar1;
  
                    // 0x147f0  85  ?CheckNamedEvent@CThreadEvent@@SA?AW4NamedEventResult_t@@PBDI@Z
  hHandle = OpenEventA(0x100000,0,param_1);
  if (hHandle == (HANDLE)0x0) {
    return 0;
  }
  DVar1 = WaitForSingleObject(hHandle,param_2);
  return 2 - (DVar1 != 0);
}



int * __cdecl FUN_10014820(undefined4 param_1,int param_2,int param_3)

{
  longlong lVar1;
  int *piVar2;
  undefined4 *lpParameter;
  HANDLE pvVar3;
  HANDLE hThread;
  int iVar4;
  DWORD local_8;
  
  lVar1 = (ulonglong)(param_2 + 1) * 4;
  piVar2 = (int *)FUN_10023b7a(-(uint)((int)((ulonglong)lVar1 >> 0x20) != 0) | (uint)lVar1);
  iVar4 = 0;
  *piVar2 = param_2;
  if (0 < param_2) {
    do {
      lpParameter = (undefined4 *)FUN_1001f8b3(8);
      if (lpParameter == (undefined4 *)0x0) {
        lpParameter = (undefined4 *)0x0;
      }
      else {
        *lpParameter = param_1;
        lpParameter[1] = iVar4;
      }
      pvVar3 = CreateThread((LPSECURITY_ATTRIBUTES)0x0,0x10000,FUN_10015840,lpParameter,0x10000,
                            &local_8);
      FUN_10014520((int)pvVar3,local_8);
      if (param_3 != 0) {
        hThread = pvVar3;
        if (pvVar3 == (HANDLE)0x0) {
          hThread = GetCurrentThread();
        }
        SetThreadAffinityMask(hThread,1 << ((byte)(iVar4 % param_3) & 0x1f));
      }
      piVar2[iVar4 + 1] = (int)pvVar3;
      iVar4 = iVar4 + 1;
    } while (iVar4 < param_2);
  }
  return piVar2 + 1;
}



void FUN_100148e0(int param_1,CThreadSyncObject **param_2,int param_3,uint param_4)

{
  CThreadSyncObject::WaitForMultiple(param_1,param_2,param_3 != 0,param_4);
  return;
}



// public: void * __thiscall GenericThreadLocals::CThreadLocalBase::Get(void)const 

void * __thiscall GenericThreadLocals::CThreadLocalBase::Get(CThreadLocalBase *this)

{
  LPVOID pvVar1;
  
                    // 0x14900  104  ?Get@CThreadLocalBase@GenericThreadLocals@@QBEPAXXZ
  if (*(DWORD *)this != 0xffffffff) {
    pvVar1 = TlsGetValue(*(DWORD *)this);
    return pvVar1;
  }
  return (void *)0x0;
}



// public: class CThreadEvent & __thiscall CWorkerThread::GetCallHandle(void)

CThreadEvent * __thiscall CWorkerThread::GetCallHandle(CWorkerThread *this)

{
                    // 0x14920  109  ?GetCallHandle@CWorkerThread@@QAEAAVCThreadEvent@@XZ
  return (CThreadEvent *)(this + 0x68);
}



// public: unsigned int __thiscall CWorkerThread::GetCallParam(void)const 

uint __thiscall CWorkerThread::GetCallParam(CWorkerThread *this)

{
                    // 0x14930  110  ?GetCallParam@CWorkerThread@@QBEIXZ
                    // 0x14930  131  ?GetParent@CVProfNode@@QAEPAV1@XZ
  return *(uint *)(this + 0x78);
}



// public: static class CThread * __cdecl CThread::GetCurrentCThread(void)

CThread * __cdecl CThread::GetCurrentCThread(void)

{
  CThread *pCVar1;
  
                    // 0x14940  120  ?GetCurrentCThread@CThread@@SAPAV1@XZ
  if (DAT_10833d3c != 0xffffffff) {
    pCVar1 = (CThread *)TlsGetValue(DAT_10833d3c);
    return pCVar1;
  }
  return (CThread *)0x0;
}



// public: char const * __thiscall CThread::GetName(void)

char * __thiscall CThread::GetName(CThread *this)

{
  short *psVar1;
  
                    // 0x14960  127  ?GetName@CThread@@QAEPBDXZ
  CThreadMutex::Lock((CThreadMutex *)(LPCRITICAL_SECTION)(this + 4));
  if (this[0x38] == (CThread)0x0) {
    FUN_1002169d((char *)(this + 0x38),0x1f,(byte *)"Thread(%p/%p)");
    this[0x57] = (CThread)0x0;
  }
  psVar1 = (short *)(this + 0x20);
  *psVar1 = *psVar1 + -1;
  if (*psVar1 == 0) {
    if (this[0x22] != (CThread)0x0) {
      Msg((byte *)"Thread %u releasing lock 0x%p\n");
    }
    *(undefined4 *)(this + 0x1c) = 0;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 4));
  return (char *)(this + 0x38);
}



// public: int __thiscall CThread::GetPriority(void)const 

int __thiscall CThread::GetPriority(CThread *this)

{
  int iVar1;
  
                    // 0x149d0  140  ?GetPriority@CThread@@QBEHXZ
  iVar1 = GetThreadPriority(*(HANDLE *)(this + 0x2c));
  return iVar1;
}



// public: int __thiscall CThread::GetResult(void)

int __thiscall CThread::GetResult(CThread *this)

{
                    // 0x149e0  141  ?GetResult@CThread@@QAEHXZ
  return *(int *)(this + 0x34);
}



// protected: struct ThreadHandle_t__ * __thiscall CThread::GetThreadHandle(void)const 

ThreadHandle_t__ * __thiscall CThread::GetThreadHandle(CThread *this)

{
                    // 0x149f0  147  ?GetThreadHandle@CThread@@IBEQAUThreadHandle_t__@@XZ
                    // 0x149f0  148  ?GetThreadHandle@CThread@@QAEPAUThreadHandle_t__@@XZ
  return *(ThreadHandle_t__ **)(this + 0x2c);
}



// protected: virtual unsigned long (__stdcall*__thiscall CThread::GetThreadProc(void))(void *)

FuncDef2 * __thiscall CThread::GetThreadProc(CThread *this)

{
                    // 0x14a00  150  ?GetThreadProc@CThread@@MAEP6GKPAX@ZXZ
  return ThreadProc;
}



uint __cdecl FUN_10014a10(int param_1,int **param_2,int **param_3)

{
  int *piVar1;
  int *piVar2;
  
  *param_3 = (int *)&DAT_10833d30;
  piVar1 = DAT_10833d30;
  *param_2 = DAT_10833d30;
  piVar2 = DAT_10833d30;
  while( true ) {
    if (piVar2 == (int *)0x0) {
      return (uint)piVar1 & 0xffffff00;
    }
    piVar1 = *param_2;
    if (*piVar1 == param_1) break;
    *param_3 = piVar1 + 2;
    piVar1 = (int *)(*param_2)[2];
    *param_2 = piVar1;
    piVar2 = piVar1;
  }
  return CONCAT31((int3)((uint)piVar1 >> 8),1);
}



// public: bool __thiscall CThread::IsAlive(void)

bool __thiscall CThread::IsAlive(CThread *this)

{
  BOOL BVar1;
  CThread *local_8;
  
                    // 0x14a60  161  ?IsAlive@CThread@@QAE_NXZ
  if (*(HANDLE *)(this + 0x2c) != (HANDLE)0x0) {
    local_8 = this;
    BVar1 = GetExitCodeThread(*(HANDLE *)(this + 0x2c),(LPDWORD)&local_8);
    if ((BVar1 != 0) && (local_8 == (CThread *)0x103)) {
      return true;
    }
  }
  return false;
}



// protected: virtual bool __thiscall CThread::IsThreadRunning(void)

bool __thiscall CThread::IsThreadRunning(CThread *this)

{
  HANDLE hThread;
  BOOL BVar1;
  bool bVar2;
  CThread *local_8;
  
                    // 0x14a90  167  ?IsThreadRunning@CThread@@MAE_NXZ
  bVar2 = true;
  local_8 = this;
  hThread = OpenThread(0x40,0,*(DWORD *)(this + 0x30));
  if (hThread != (HANDLE)0x0) {
    BVar1 = GetExitCodeThread(hThread,(LPDWORD)&local_8);
    if ((BVar1 == 0) || (local_8 != (CThread *)0x103)) {
      bVar2 = false;
    }
    CloseHandle(hThread);
    return bVar2;
  }
  return false;
}



// public: bool __thiscall CThread::Join(unsigned int)

bool __thiscall CThread::Join(CThread *this,uint param_1)

{
  DWORD DVar1;
  
                    // 0x14ae0  168  ?Join@CThread@@QAE_NI@Z
  if (*(HANDLE *)(this + 0x2c) != (HANDLE)0x0) {
    DVar1 = WaitForSingleObject(*(HANDLE *)(this + 0x2c),param_1);
    if (DVar1 == 0x102) {
      return false;
    }
    if (((DVar1 != 0) && (DVar1 != 0xffffffff)) && (DVar1 = GetLastError(), DVar1 != 0)) {
      return false;
    }
  }
  return true;
}



void __cdecl FUN_10014b20(int param_1)

{
  int iVar1;
  HANDLE pvVar2;
  DWORD DVar3;
  int iVar4;
  
  iVar4 = 0;
  iVar1 = *(int *)(param_1 + -4);
  if (0 < iVar1) {
    do {
      pvVar2 = *(HANDLE *)(param_1 + iVar4 * 4);
      if ((((pvVar2 != (HANDLE)0x0) &&
           (DVar3 = WaitForSingleObject(pvVar2,0xffffffff), DVar3 != 0x102)) && (DVar3 != 0)) &&
         (DVar3 != 0xffffffff)) {
        GetLastError();
      }
      pvVar2 = *(HANDLE *)(param_1 + iVar4 * 4);
      CloseHandle(pvVar2);
      FUN_10014f90((int)pvVar2);
      iVar4 = iVar4 + 1;
    } while (iVar4 < iVar1);
  }
  FID_conflict__free((int *)(param_1 + -4));
  return;
}



// private: void __thiscall CThreadFastMutex::Lock(unsigned int,unsigned int)volatile 

void __thiscall CThreadFastMutex::Lock(CThreadFastMutex *this,uint param_1,uint param_2)

{
  int iVar1;
  uint uVar2;
  HANDLE hThread;
  int iVar3;
  uint uVar4;
  
                    // 0x14ba0  169  ?Lock@CThreadFastMutex@@ACEXII@Z
  if (param_2 == 0xffffffff) {
    do {
      if (param_1 == *(uint *)this) break;
      iVar3 = 0;
      LOCK();
      if (*(int *)this == 0) {
        *(uint *)this = param_1;
      }
      else {
        iVar3 = *(int *)this;
      }
    } while (iVar3 != 0);
    *(int *)(this + 4) = *(int *)(this + 4) + 1;
    return;
  }
  iVar3 = 0x2000;
  do {
    if (param_1 == *(uint *)this) {
LAB_10014ccd:
      *(int *)(this + 4) = *(int *)(this + 4) + 1;
      return;
    }
    iVar1 = 0;
    LOCK();
    if (*(int *)this == 0) {
      *(uint *)this = param_1;
    }
    else {
      iVar1 = *(int *)this;
    }
    if (iVar1 == 0) goto LAB_10014ccd;
    iVar3 = iVar3 + -1;
  } while (iVar3 != 0);
  uVar4 = 0x2000;
  do {
    if (param_1 == *(uint *)this) goto LAB_10014cc3;
    iVar3 = 0;
    LOCK();
    if (*(int *)this == 0) {
      *(uint *)this = param_1;
    }
    else {
      iVar3 = *(int *)this;
    }
    if (iVar3 == 0) goto LAB_10014cc3;
    uVar2 = uVar4 & 0x800003ff;
    if ((int)uVar2 < 0) {
      uVar2 = (uVar2 - 1 | 0xfffffc00) + 1;
    }
    if (uVar2 == 0) {
      if (DAT_10833dfc == '\0') {
        DAT_10833dfc = '\x01';
        timeBeginPeriod(1);
      }
      Sleep(0);
    }
    uVar4 = uVar4 - 1;
  } while (uVar4 != 0);
  if (param_2 == 0) {
    hThread = GetCurrentThread();
    iVar3 = GetThreadPriority(hThread);
    if (iVar3 < 1) goto LAB_10014c90;
    param_2 = 1;
  }
  iVar3 = 0x2000;
  do {
    if (param_1 == *(uint *)this) goto LAB_10014cc3;
    iVar1 = 0;
    LOCK();
    if (*(int *)this == 0) {
      *(uint *)this = param_1;
    }
    else {
      iVar1 = *(int *)this;
    }
    if (iVar1 == 0) goto LAB_10014cc3;
    if (DAT_10833dfc == '\0') {
      DAT_10833dfc = '\x01';
      timeBeginPeriod(1);
    }
    Sleep(0);
    iVar3 = iVar3 + -1;
  } while (iVar3 != 0);
LAB_10014c90:
  while (param_1 != *(uint *)this) {
    iVar3 = 0;
    LOCK();
    if (*(int *)this == 0) {
      *(uint *)this = param_1;
    }
    else {
      iVar3 = *(int *)this;
    }
    if (iVar3 == 0) break;
    if (DAT_10833dfc == '\0') {
      DAT_10833dfc = '\x01';
      timeBeginPeriod(1);
    }
    Sleep(param_2);
  }
LAB_10014cc3:
  *(int *)(this + 4) = *(int *)(this + 4) + 1;
  return;
}



// public: void __thiscall CThreadRWLock::LockForWrite(void)

void __thiscall CThreadRWLock::LockForWrite(CThreadRWLock *this)

{
  bool bVar1;
  DWORD DVar2;
  int iVar3;
  
                    // 0x14d00  178  ?LockForWrite@CThreadRWLock@@QAEXXZ
  DVar2 = GetCurrentThreadId();
  if (DVar2 != *(DWORD *)this) {
    iVar3 = 0;
    LOCK();
    if (*(int *)this == 0) {
      *(DWORD *)this = DVar2;
    }
    else {
      iVar3 = *(int *)this;
    }
    if (iVar3 != 0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)this,DVar2,0);
      goto LAB_10014d2c;
    }
  }
  *(int *)(this + 4) = *(int *)(this + 4) + 1;
LAB_10014d2c:
  if ((*(int *)(this + 0x18) == 0) && (*(int *)(this + 0x1c) == 0)) {
    bVar1 = false;
  }
  else {
    bVar1 = true;
  }
  *(int *)(this + 0x18) = *(int *)(this + 0x18) + 1;
  ResetEvent(*(HANDLE *)(this + 0x10));
  *(int *)(this + 4) = *(int *)(this + 4) + -1;
  if (*(int *)(this + 4) == 0) {
    *(undefined4 *)this = 0;
  }
  if (bVar1) {
    WaitForSingleObject(*(HANDLE *)(this + 8),0xffffffff);
  }
  return;
}



HANDLE __cdecl FUN_10014d70(HANDLE param_1)

{
  bool bVar1;
  HANDLE *ppvVar2;
  HANDLE pvVar3;
  DWORD DVar4;
  float10 fVar5;
  float10 fVar6;
  
  if ((param_1 == (HANDLE)0x0) || (pvVar3 = GetCurrentThread(), param_1 == pvVar3)) {
    pvVar3 = (HANDLE)GetCurrentThreadId();
    return pvVar3;
  }
  fVar5 = Plat_FloatTime();
  fVar6 = Plat_FloatTime();
  fVar6 = fVar6 - (float10)(float)fVar5;
  do {
    if (2.0 <= (double)fVar6) {
      Warning((byte *)"LookupThreadIDFromHandle couldn\'t find thread ID for handle.");
      return (HANDLE)0x0;
    }
    DVar4 = GetCurrentThreadId();
    if (((DAT_10833d6e != '\0') && (DAT_10833d68 != 0)) && (DAT_10833d68 != DVar4)) {
      GetCurrentThreadId();
      Msg((byte *)"Thread %u about to wait for lock %p owned by %u\n");
    }
    EnterCriticalSection((LPCRITICAL_SECTION)&DAT_10833d50);
    ppvVar2 = DAT_10833d30;
    if ((DAT_10833d6c == 0) && (DAT_10833d68 = DVar4, DAT_10833d6e != '\0')) {
      Msg((byte *)"Thread %u now owns lock 0x%p\n");
      ppvVar2 = DAT_10833d30;
    }
    for (; ppvVar2 != (HANDLE *)0x0; ppvVar2 = (HANDLE *)ppvVar2[2]) {
      if (*ppvVar2 == param_1) {
        bVar1 = true;
        goto LAB_10014e61;
      }
    }
    bVar1 = false;
LAB_10014e61:
    if (DAT_10833d6c == 0) {
      if (DAT_10833d6e != '\0') {
        Msg((byte *)"Thread %u releasing lock 0x%p\n");
      }
      DAT_10833d68 = 0;
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_10833d50);
    if (bVar1) {
      return ppvVar2[1];
    }
    if (DAT_10833dfc == '\0') {
      DAT_10833dfc = '\x01';
      timeBeginPeriod(1);
    }
    Sleep(1);
    fVar6 = Plat_FloatTime();
    fVar6 = fVar6 - (float10)(float)fVar5;
  } while( true );
}



// public: bool __thiscall CWorkerThread::PeekCall(unsigned int *)

bool __thiscall CWorkerThread::PeekCall(CWorkerThread *this,uint *param_1)

{
  DWORD DVar1;
  
                    // 0x14f30  194  ?PeekCall@CWorkerThread@@QAE_NPAI@Z
  DVar1 = WaitForSingleObject(*(HANDLE *)(this + 0x68),0);
  if (DVar1 != 0) {
    return false;
  }
  if (param_1 != (uint *)0x0) {
    *param_1 = *(uint *)(this + 0x78);
  }
  return true;
}



// public: bool __thiscall CThreadFullMutex::Release(void)

bool __thiscall CThreadFullMutex::Release(CThreadFullMutex *this)

{
  BOOL BVar1;
  
                    // 0x14f60  198  ?Release@CThreadFullMutex@@QAE_NXZ
  BVar1 = ReleaseMutex(*(HANDLE *)this);
  return BVar1 != 0;
}



// public: bool __thiscall CThreadSemaphore::Release(int,int *)

bool __thiscall CThreadSemaphore::Release(CThreadSemaphore *this,int param_1,int *param_2)

{
  BOOL BVar1;
  
                    // 0x14f70  199  ?Release@CThreadSemaphore@@QAE_NHPAH@Z
  BVar1 = ReleaseSemaphore(*(HANDLE *)this,param_1,param_2);
  return BVar1 != 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_10014f90(int param_1)

{
  uint uVar1;
  int *local_c;
  int *local_8;
  
  if (param_1 != 0) {
    CThreadMutex::Lock((CThreadMutex *)&DAT_10833d50);
    if (_DAT_10833df8 < 1) {
      Error((byte *)"ThreadHandleToIDMap underflow.");
    }
    uVar1 = FUN_10014a10(param_1,&local_8,&local_c);
    if ((char)uVar1 != '\0') {
      *local_c = local_8[2];
      FID_conflict__free(local_8);
      _DAT_10833df8 = _DAT_10833df8 + -1;
    }
    DAT_10833d6c = DAT_10833d6c + -1;
    if (DAT_10833d6c == 0) {
      if (DAT_10833d6e != '\0') {
        Msg((byte *)"Thread %u releasing lock 0x%p\n");
      }
      DAT_10833d68 = 0;
    }
    LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_10833d50);
  }
  return;
}



// public: void __thiscall CWorkerThread::Reply(unsigned int)

void __thiscall CWorkerThread::Reply(CWorkerThread *this,uint param_1)

{
                    // 0x15040  201  ?Reply@CWorkerThread@@QAEXI@Z
  *(undefined4 *)(this + 0x78) = 0;
  *(uint *)(this + 0x7c) = param_1;
  ResetEvent(*(HANDLE *)(this + 0x68));
  SetEvent(*(HANDLE *)(this + 0x70));
  return;
}



// public: bool __thiscall CThreadEvent::Reset(void)

bool __thiscall CThreadEvent::Reset(CThreadEvent *this)

{
  BOOL BVar1;
  
                    // 0x15070  203  ?Reset@CThreadEvent@@QAE_NXZ
  BVar1 = ResetEvent(*(HANDLE *)this);
  return BVar1 != 0;
}



// public: unsigned int __thiscall CThread::Resume(void)

uint __thiscall CThread::Resume(CThread *this)

{
  DWORD DVar1;
  
                    // 0x15080  209  ?Resume@CThread@@QAEIXZ
  DVar1 = WaitForSingleObject(*(HANDLE *)(this + 0x60),0);
  if (DVar1 == 0) {
    DevWarning("Called Resume() on a thread that is not suspended!\n");
  }
  SetEvent(*(HANDLE *)(this + 0x60));
  return 0;
}



// public: bool __thiscall CThreadEvent::Set(void)

bool __thiscall CThreadEvent::Set(CThreadEvent *this)

{
  BOOL BVar1;
  
                    // 0x150b0  213  ?Set@CThreadEvent@@QAE_NXZ
  BVar1 = SetEvent(*(HANDLE *)this);
  return BVar1 != 0;
}



// public: void __thiscall GenericThreadLocals::CThreadLocalBase::Set(void *)

void __thiscall GenericThreadLocals::CThreadLocalBase::Set(CThreadLocalBase *this,void *param_1)

{
                    // 0x150c0  214  ?Set@CThreadLocalBase@GenericThreadLocals@@QAEXPAX@Z
  if (*(DWORD *)this != 0xffffffff) {
    TlsSetValue(*(DWORD *)this,param_1);
  }
  return;
}



// public: void __thiscall CThread::SetName(char const *)

void __thiscall CThread::SetName(CThread *this,char *param_1)

{
  short *psVar1;
  
                    // 0x150e0  218  ?SetName@CThread@@QAEXPBD@Z
  CThreadMutex::Lock((CThreadMutex *)(LPCRITICAL_SECTION)(this + 4));
  _strncpy((char *)(this + 0x38),param_1,0x1f);
  this[0x57] = (CThread)0x0;
  psVar1 = (short *)(this + 0x20);
  *psVar1 = *psVar1 + -1;
  if (*psVar1 == 0) {
    if (this[0x22] != (CThread)0x0) {
      Msg((byte *)"Thread %u releasing lock 0x%p\n");
    }
    *(undefined4 *)(this + 0x1c) = 0;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 4));
  return;
}



// public: bool __thiscall CThread::SetPriority(int)

bool __thiscall CThread::SetPriority(CThread *this,int param_1)

{
  HANDLE hThread;
  BOOL BVar1;
  
                    // 0x15140  219  ?SetPriority@CThread@@QAE_NH@Z
  hThread = *(HANDLE *)(this + 0x2c);
  if (hThread == (HANDLE)0x0) {
    hThread = GetCurrentThread();
  }
  BVar1 = SetThreadPriority(hThread,param_1);
  return BVar1 != 0;
}



// public: void __thiscall CThreadSpinRWLock::SpinLockForRead(void)

void __thiscall CThreadSpinRWLock::SpinLockForRead(CThreadSpinRWLock *this)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  bool bVar5;
  int local_8;
  
                    // 0x15170  225  ?SpinLockForRead@CThreadSpinRWLock@@QAEXXZ
  iVar4 = 0x2000;
  do {
    if ((*(uint *)this & 0x10000) == 0) {
      uVar2 = *(uint *)this & 0xffff;
      LOCK();
      if (uVar2 == *(uint *)this) {
        *(uint *)this = uVar2 + 1;
        uVar3 = uVar2;
      }
      else {
        uVar3 = *(uint *)this;
      }
      if (uVar3 == uVar2) {
        return;
      }
    }
    iVar4 = iVar4 + -1;
  } while (iVar4 != 0);
  uVar2 = 0x2000;
  do {
    if ((*(uint *)this & 0x10000) == 0) {
      uVar3 = *(uint *)this & 0xffff;
      LOCK();
      if (uVar3 == *(uint *)this) {
        *(uint *)this = uVar3 + 1;
        uVar1 = uVar3;
      }
      else {
        uVar1 = *(uint *)this;
      }
      if (uVar1 == uVar3) {
        return;
      }
    }
    uVar3 = uVar2 & 0x800003ff;
    bVar5 = uVar3 == 0;
    if ((int)uVar3 < 0) {
      bVar5 = (uVar3 - 1 | 0xfffffc00) == 0xffffffff;
    }
    if (bVar5) {
      if (DAT_10833dfc == '\0') {
        DAT_10833dfc = '\x01';
        timeBeginPeriod(1);
      }
      Sleep(0);
    }
    uVar2 = uVar2 - 1;
  } while (uVar2 != 0);
  local_8 = 0x8000;
  do {
    if ((*(uint *)this & 0x10000) == 0) {
      uVar2 = *(uint *)this & 0xffff;
      LOCK();
      if (uVar2 == *(uint *)this) {
        *(uint *)this = uVar2 + 1;
        uVar3 = uVar2;
      }
      else {
        uVar3 = *(uint *)this;
      }
      if (uVar3 == uVar2) {
        return;
      }
    }
    if (DAT_10833dfc == '\0') {
      DAT_10833dfc = '\x01';
      timeBeginPeriod(1);
    }
    Sleep(0);
    local_8 = local_8 + -1;
    if (local_8 == 0) {
      do {
        if ((*(uint *)this & 0x10000) == 0) {
          uVar2 = *(uint *)this & 0xffff;
          LOCK();
          if (uVar2 == *(uint *)this) {
            *(uint *)this = uVar2 + 1;
            uVar3 = uVar2;
          }
          else {
            uVar3 = *(uint *)this;
          }
          if (uVar3 == uVar2) {
            return;
          }
        }
        if (DAT_10833dfc == '\0') {
          DAT_10833dfc = '\x01';
          timeBeginPeriod(1);
        }
        Sleep(1);
      } while( true );
    }
  } while( true );
}



// public: void __thiscall CThreadSpinRWLock::SpinLockForWrite(void)

void __thiscall CThreadSpinRWLock::SpinLockForWrite(CThreadSpinRWLock *this)

{
  int iVar1;
  DWORD DVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  bool bVar6;
  int local_8;
  
                    // 0x152a0  226  ?SpinLockForWrite@CThreadSpinRWLock@@QAEXXZ
  if ((*(uint *)this & 0x10000) == 0) {
    iVar1 = 0;
    LOCK();
    if (*(int *)this == 0) {
      *(undefined4 *)this = 0x10000;
    }
    else {
      iVar1 = *(int *)this;
    }
    if (iVar1 == 0) {
LAB_100152bf:
      DVar2 = GetCurrentThreadId();
      *(DWORD *)(this + 4) = DVar2;
      return;
    }
  }
  iVar1 = 0x2000;
  do {
    if ((*(uint *)this & 0x10000) == 0) {
      iVar3 = 0;
      LOCK();
      if (*(int *)this == 0) {
        *(undefined4 *)this = 0x10000;
      }
      else {
        iVar3 = *(int *)this;
      }
      if (iVar3 == 0) goto LAB_100152bf;
    }
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  uVar5 = 0x2000;
  do {
    if ((*(uint *)this & 0x10000) == 0) {
      iVar1 = 0;
      LOCK();
      if (*(int *)this == 0) {
        *(undefined4 *)this = 0x10000;
      }
      else {
        iVar1 = *(int *)this;
      }
      if (iVar1 == 0) goto LAB_100153cb;
    }
    uVar4 = uVar5 & 0x800003ff;
    bVar6 = uVar4 == 0;
    if ((int)uVar4 < 0) {
      bVar6 = (uVar4 - 1 | 0xfffffc00) == 0xffffffff;
    }
    if (bVar6) {
      if (DAT_10833dfc == '\0') {
        DAT_10833dfc = '\x01';
        timeBeginPeriod(1);
      }
      Sleep(0);
    }
    uVar5 = uVar5 - 1;
  } while (uVar5 != 0);
  local_8 = 0x8000;
  do {
    if ((*(uint *)this & 0x10000) == 0) {
      iVar1 = 0;
      LOCK();
      if (*(int *)this == 0) {
        *(undefined4 *)this = 0x10000;
      }
      else {
        iVar1 = *(int *)this;
      }
      if (iVar1 == 0) goto LAB_100153cb;
    }
    if (DAT_10833dfc == '\0') {
      DAT_10833dfc = '\x01';
      timeBeginPeriod(1);
    }
    Sleep(0);
    local_8 = local_8 + -1;
  } while (local_8 != 0);
  do {
    if ((*(uint *)this & 0x10000) == 0) {
      iVar1 = 0;
      LOCK();
      if (*(int *)this == 0) {
        *(undefined4 *)this = 0x10000;
      }
      else {
        iVar1 = *(int *)this;
      }
      if (iVar1 == 0) {
LAB_100153cb:
        DVar2 = GetCurrentThreadId();
        *(DWORD *)(this + 4) = DVar2;
        return;
      }
    }
    if (DAT_10833dfc == '\0') {
      DAT_10833dfc = '\x01';
      timeBeginPeriod(1);
    }
    Sleep(1);
  } while( true );
}



// public: virtual bool __thiscall CThread::Start(unsigned int,enum ThreadPriorityEnum_t)

bool __thiscall CThread::Start(CThread *this,uint param_1,ThreadPriorityEnum_t param_2)

{
  short *psVar1;
  char cVar2;
  BOOL BVar3;
  undefined8 *lpParameter;
  uint dwCreationFlags;
  LPTHREAD_START_ROUTINE lpStartAddress;
  HANDLE hThread;
  bool bVar4;
  LPDWORD lpThreadId;
  HANDLE local_14;
  char local_10;
  DWORD local_c;
  char local_5;
  
                    // 0x153e0  227  ?Start@CThread@@UAE_NIW4ThreadPriorityEnum_t@@@Z
  CThreadMutex::Lock((CThreadMutex *)(LPCRITICAL_SECTION)(this + 4));
  if (((*(HANDLE *)(this + 0x2c) != (HANDLE)0x0) &&
      (BVar3 = GetExitCodeThread(*(HANDLE *)(this + 0x2c),&local_c), BVar3 != 0)) &&
     (local_c == 0x103)) {
    bVar4 = false;
    goto LAB_100154eb;
  }
  local_5 = '\0';
  local_14 = (HANDLE)0x0;
  local_10 = 0;
  local_14 = CreateEventA((LPSECURITY_ATTRIBUTES)0x0,0,0,(LPCSTR)0x0);
  local_10 = '\x01';
  lpParameter = (undefined8 *)FUN_1001f8b3(0xc);
  if (lpParameter == (undefined8 *)0x0) {
    lpParameter = (undefined8 *)0x0;
  }
  else {
    *lpParameter = CONCAT44(&local_14,this);
    *(char **)(lpParameter + 1) = &local_5;
  }
  lpThreadId = (LPDWORD)(this + 0x30);
  dwCreationFlags = -(uint)(param_1 != 0) & 0x10000;
  lpStartAddress = (LPTHREAD_START_ROUTINE)(**(code **)(*(int *)this + 0x18))();
  hThread = CreateThread((LPSECURITY_ATTRIBUTES)0x0,param_1,lpStartAddress,lpParameter,
                         dwCreationFlags,lpThreadId);
  *(HANDLE *)(this + 0x2c) = hThread;
  if (param_2 != 0) {
    SetThreadPriority(hThread,param_2);
  }
  if (*(int *)(this + 0x2c) == 0) {
LAB_100154d8:
    bVar4 = false;
  }
  else {
    cVar2 = (**(code **)(*(int *)this + 0x14))(&local_14);
    if ((cVar2 == '\0') || (local_5 == '\0')) {
      Msg((byte *)"Thread failed to initialize\n");
      CloseHandle(*(HANDLE *)(this + 0x2c));
      *(undefined4 *)(this + 0x2c) = 0;
      goto LAB_100154d8;
    }
    if (*(int *)(this + 0x2c) == 0) {
      Msg((byte *)"Thread exited immediately\n");
    }
    FUN_10014520(*(int *)(this + 0x2c),*(int *)(this + 0x30));
    bVar4 = *(int *)(this + 0x2c) != 0;
  }
  if ((local_14 != (HANDLE)0x0) && (local_10 != '\0')) {
    CloseHandle(local_14);
  }
LAB_100154eb:
  psVar1 = (short *)(this + 0x20);
  *psVar1 = *psVar1 + -1;
  if (*psVar1 == 0) {
    if (this[0x22] != (CThread)0x0) {
      Msg((byte *)"Thread %u releasing lock 0x%p\n");
    }
    *(undefined4 *)(this + 0x1c) = 0;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(this + 4));
  return bVar4;
}



// public: void __thiscall CThread::Stop(int)

void __thiscall CThread::Stop(CThread *this,int param_1)

{
  code *pcVar1;
  BOOL BVar2;
  CThread *pCVar3;
  CThread *local_8;
  
                    // 0x15560  229  ?Stop@CThread@@QAEXH@Z
  if (*(HANDLE *)(this + 0x2c) != (HANDLE)0x0) {
    local_8 = this;
    BVar2 = GetExitCodeThread(*(HANDLE *)(this + 0x2c),(LPDWORD)&local_8);
    if ((BVar2 != 0) && (local_8 == (CThread *)0x103)) {
      if (DAT_10833d3c == 0xffffffff) {
        pCVar3 = (CThread *)0x0;
      }
      else {
        pCVar3 = (CThread *)TlsGetValue(DAT_10833d3c);
      }
      if (pCVar3 == this) {
        *(int *)(this + 0x34) = param_1;
        if (((byte)this[0x5c] & 1) != 0) {
          FUN_1002364d(&param_1,&DAT_1003f698);
          pcVar1 = (code *)swi(3);
          (*pcVar1)();
          return;
        }
        (**(code **)(*(int *)this + 0x10))();
        if (DAT_10833d3c != 0xffffffff) {
          TlsSetValue(DAT_10833d3c,(LPVOID)0x0);
        }
        CloseHandle(*(HANDLE *)(this + 0x2c));
        FUN_10014f90(*(int *)(this + 0x2c));
        *(undefined4 *)(this + 0x2c) = 0;
      }
    }
  }
  return;
}



// public: unsigned int __thiscall CThread::Suspend(void)

uint __thiscall CThread::Suspend(CThread *this)

{
  code *pcVar1;
  bool bVar2;
  DWORD DVar3;
  uint uVar4;
  
                    // 0x15600  233  ?Suspend@CThread@@QAEIXZ
  DVar3 = GetCurrentThreadId();
  if (DVar3 != *(DWORD *)(this + 0x30)) {
    bVar2 = Plat_IsInDebugSession();
    if (bVar2) {
      pcVar1 = (code *)swi(3);
      uVar4 = (*pcVar1)();
      return uVar4;
    }
  }
  ResetEvent(*(HANDLE *)(this + 0x60));
  WaitForSingleObject(*(HANDLE *)(this + 0x60),0xffffffff);
  return 0;
}



// public: bool __thiscall CThread::Terminate(int)

bool __thiscall CThread::Terminate(CThread *this,int param_1)

{
  BOOL BVar1;
  
                    // 0x15630  235  ?Terminate@CThread@@QAE_NH@Z
  BVar1 = TerminateThread(*(HANDLE *)(this + 0x2c),param_1);
  if (BVar1 == 0) {
    return false;
  }
  CloseHandle(*(HANDLE *)(this + 0x2c));
  FUN_10014f90(*(int *)(this + 0x2c));
  *(undefined4 *)(this + 0x2c) = 0;
  return true;
}



// protected: static unsigned long __stdcall CThread::ThreadProc(void *)

ulong CThread::ThreadProc(void *param_1)

{
  short *psVar1;
  LPVOID lpTlsValue;
  ulong uVar2;
  char cVar3;
  bool bVar4;
  undefined4 uVar5;
  undefined4 *in_FS_OFFSET;
  undefined4 local_10;
  code *pcStack12;
  undefined4 local_8;
  
                    // 0x15670  236  ?ThreadProc@CThread@@KGKPAX@Z
  local_8 = 0xffffffff;
  pcStack12 = FUN_10034fb0;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_10;
  AllocateThreadID();
                    // WARNING: Load size is inaccurate
  lpTlsValue = *param_1;
  if (DAT_10833d3c != 0xffffffff) {
    TlsSetValue(DAT_10833d3c,lpTlsValue);
  }
  *(uint *)((int)lpTlsValue + 0x58) = (uint)&stack0x00000fe3 & 0xfffff000;
                    // WARNING: Load size is inaccurate
  *(undefined4 *)(*param_1 + 0x34) = 0xffffffff;
  if (*(undefined **)((int)param_1 + 8) != (undefined *)0x0) {
    **(undefined **)((int)param_1 + 8) = 0;
  }
  local_8 = 0;
                    // WARNING: Load size is inaccurate
  cVar3 = (**(code **)(**param_1 + 8))();
  local_8 = 0xffffffff;
  if (*(char **)((int)param_1 + 8) != (char *)0x0) {
    **(char **)((int)param_1 + 8) = cVar3;
  }
  SetEvent(**(HANDLE **)((int)param_1 + 4));
  if (cVar3 == '\0') {
    FID_conflict__free(param_1);
    *in_FS_OFFSET = local_10;
    return 0;
  }
  bVar4 = Plat_IsInDebugSession();
                    // WARNING: Load size is inaccurate
  if ((bVar4) || ((*(byte *)(*param_1 + 0x5c) & 1) == 0)) {
    CatchAndWriteMiniDumpForVoidPtrFn((int)ThreadProcRunWithMinidumpHandler,param_1,'\0');
  }
  else {
    local_8 = 2;
                    // WARNING: Load size is inaccurate
    uVar5 = (**(code **)(**param_1 + 0xc))();
                    // WARNING: Load size is inaccurate
    *(undefined4 *)(*param_1 + 0x34) = uVar5;
    local_8 = 0xffffffff;
  }
                    // WARNING: Load size is inaccurate
  (**(code **)(**param_1 + 0x10))();
  if (DAT_10833d3c != 0xffffffff) {
    TlsSetValue(DAT_10833d3c,(LPVOID)0x0);
  }
  FreeThreadID();
  CThreadMutex::Lock((CThreadMutex *)(LPCRITICAL_SECTION)((int)lpTlsValue + 4));
  CloseHandle(*(HANDLE *)((int)lpTlsValue + 0x2c));
  FUN_10014f90(*(int *)((int)lpTlsValue + 0x2c));
  *(undefined4 *)((int)lpTlsValue + 0x2c) = 0;
  SetEvent(*(HANDLE *)((int)lpTlsValue + 0x24));
                    // WARNING: Load size is inaccurate
  uVar2 = *(ulong *)(*param_1 + 0x34);
  psVar1 = (short *)((int)lpTlsValue + 0x20);
  *psVar1 = *psVar1 + -1;
  if (*psVar1 == 0) {
    if (*(char *)((int)lpTlsValue + 0x22) != '\0') {
      Msg((byte *)"Thread %u releasing lock 0x%p\n");
    }
    *(undefined4 *)((int)lpTlsValue + 0x1c) = 0;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)((int)lpTlsValue + 4));
  FID_conflict__free(param_1);
  *in_FS_OFFSET = local_10;
  return uVar2;
}



undefined * Catch_10015753(void)

{
  return &DAT_10015759;
}



void Catch_10015824(void)

{
  code *pcVar1;
  int unaff_EBP;
  
  SetEvent(**(HANDLE **)(*(int *)(unaff_EBP + 8) + 4));
  FUN_1002364d((int *)0x0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



undefined4 FUN_10015840(undefined **param_1)

{
  code *pcVar1;
  undefined *puVar2;
  undefined4 uVar3;
  
  pcVar1 = (code *)*param_1;
  puVar2 = param_1[1];
  AllocateThreadID();
  FID_conflict__free(param_1);
  uVar3 = (*pcVar1)(puVar2);
  FreeThreadID();
  return uVar3;
}



// protected: static void __cdecl CThread::ThreadProcRunWithMinidumpHandler(void *)

void __cdecl CThread::ThreadProcRunWithMinidumpHandler(void *param_1)

{
  undefined4 uVar1;
  
                    // 0x15870  237  ?ThreadProcRunWithMinidumpHandler@CThread@@KAXPAX@Z
                    // WARNING: Load size is inaccurate
  uVar1 = (**(code **)(**param_1 + 0xc))();
                    // WARNING: Load size is inaccurate
  *(undefined4 *)(*param_1 + 0x34) = uVar1;
  return;
}



// public: bool __thiscall CThreadMutex::TryLock(void)

bool __thiscall CThreadMutex::TryLock(CThreadMutex *this)

{
  DWORD DVar1;
  int iVar2;
  
                    // 0x15890  239  ?TryLock@CThreadMutex@@QAE_NXZ
  DVar1 = GetCurrentThreadId();
  if (((this[0x1e] != (CThreadMutex)0x0) && (*(DWORD *)(this + 0x18) != 0)) &&
     (*(DWORD *)(this + 0x18) != DVar1)) {
    GetCurrentThreadId();
    Msg((byte *)"Thread %u about to try-wait for lock %p owned by %u\n");
  }
  if (DAT_10833d70 != (code *)0x0) {
    iVar2 = (*DAT_10833d70)(this);
    if (iVar2 != 0) {
      if ((*(short *)(this + 0x1c) == 0) &&
         (*(DWORD *)(this + 0x18) = DVar1, this[0x1e] != (CThreadMutex)0x0)) {
        Msg((byte *)"Thread %u now owns lock %p\n");
      }
      *(short *)(this + 0x1c) = *(short *)(this + 0x1c) + 1;
      return true;
    }
    return false;
  }
  Lock(this);
  return true;
}



// public: void __thiscall CThreadRWLock::UnlockWrite(void)

void __thiscall CThreadRWLock::UnlockWrite(CThreadRWLock *this)

{
  int *piVar1;
  DWORD DVar2;
  int iVar3;
  HANDLE hEvent;
  
                    // 0x15910  255  ?UnlockWrite@CThreadRWLock@@QAEXXZ
  DVar2 = GetCurrentThreadId();
  if (DVar2 == *(DWORD *)this) {
LAB_10015939:
    *(int *)(this + 4) = *(int *)(this + 4) + 1;
  }
  else {
    iVar3 = 0;
    LOCK();
    if (*(int *)this == 0) {
      *(DWORD *)this = DVar2;
    }
    else {
      iVar3 = *(int *)this;
    }
    if (iVar3 == 0) goto LAB_10015939;
    CThreadFastMutex::Lock((CThreadFastMutex *)this,DVar2,0);
  }
  piVar1 = (int *)(this + 0x18);
  *piVar1 = *piVar1 + -1;
  if (*piVar1 == 0) {
    if (*(int *)(this + 0x20) == 0) goto LAB_10015955;
    hEvent = *(HANDLE *)(this + 0x10);
  }
  else {
    hEvent = *(HANDLE *)(this + 8);
  }
  SetEvent(hEvent);
LAB_10015955:
  *(int *)(this + 4) = *(int *)(this + 4) + -1;
  if (*(int *)(this + 4) == 0) {
    *(undefined4 *)this = 0;
  }
  return;
}



// public: bool __thiscall CThreadEvent::Wait(unsigned int)

bool __thiscall CThreadEvent::Wait(CThreadEvent *this,uint param_1)

{
  DWORD DVar1;
  
                    // 0x15970  262  ?Wait@CThreadEvent@@QAE_NI@Z
                    // 0x15970  263  ?Wait@CThreadSyncObject@@QAE_NI@Z
  DVar1 = WaitForSingleObject(*(HANDLE *)this,param_1);
  return (bool)('\x01' - (DVar1 != 0));
}



// public: bool __thiscall CWorkerThread::WaitForCall(unsigned int,unsigned int *)

bool __thiscall CWorkerThread::WaitForCall(CWorkerThread *this,uint param_1,uint *param_2)

{
  DWORD DVar1;
  
                    // 0x15990  264  ?WaitForCall@CWorkerThread@@QAE_NIPAI@Z
  DVar1 = WaitForSingleObject(*(HANDLE *)(this + 0x68),param_1);
  if (param_2 != (uint *)0x0) {
    *param_2 = *(uint *)(this + 0x78);
  }
  return DVar1 == 0;
}



// public: bool __thiscall CWorkerThread::WaitForCall(unsigned int *)

bool __thiscall CWorkerThread::WaitForCall(CWorkerThread *this,uint *param_1)

{
  DWORD DVar1;
  
                    // 0x159c0  265  ?WaitForCall@CWorkerThread@@QAE_NPAI@Z
  DVar1 = WaitForSingleObject(*(HANDLE *)(this + 0x68),0xffffffff);
  if (param_1 != (uint *)0x0) {
    *param_1 = *(uint *)(this + 0x78);
  }
  return DVar1 == 0;
}



// protected: virtual bool __thiscall CThread::WaitForCreateComplete(class CThreadEvent *)

bool __thiscall CThread::WaitForCreateComplete(CThread *this,CThreadEvent *param_1)

{
  DWORD DVar1;
  
                    // 0x159f0  266  ?WaitForCreateComplete@CThread@@MAE_NPAVCThreadEvent@@@Z
  DVar1 = WaitForSingleObject(*(HANDLE *)param_1,60000);
  return DVar1 == 0;
}



// public: static unsigned int __cdecl CThreadEvent::WaitForMultiple(int,class CThreadEvent *
// *,bool,unsigned int)

uint __cdecl
CThreadEvent::WaitForMultiple(int param_1,CThreadEvent **param_2,bool param_3,uint param_4)

{
  uint uVar1;
  
                    // 0x15a10  267  ?WaitForMultiple@CThreadEvent@@SAIHPAPAV1@_NI@Z
  uVar1 = CThreadSyncObject::WaitForMultiple(param_1,(CThreadSyncObject **)param_2,param_3,param_4);
  return uVar1;
}



// public: static unsigned int __cdecl CThreadEvent::WaitForMultiple(int,class CThreadEvent
// *,bool,unsigned int)

uint __cdecl
CThreadEvent::WaitForMultiple(int param_1,CThreadEvent *param_2,bool param_3,uint param_4)

{
  uint uVar1;
  
                    // 0x15a20  268  ?WaitForMultiple@CThreadEvent@@SAIHPAV1@_NI@Z
  uVar1 = CThreadSyncObject::WaitForMultiple(param_1,(CThreadSyncObject *)param_2,param_3,param_4);
  return uVar1;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Unable to track spacebase fully for stack
// public: static unsigned int __cdecl CThreadSyncObject::WaitForMultiple(int,class
// CThreadSyncObject * *,bool,unsigned int)

uint __cdecl
CThreadSyncObject::WaitForMultiple
          (int param_1,CThreadSyncObject **param_2,bool param_3,uint param_4)

{
  int iVar1;
  int iVar2;
  uint uVar3;
  undefined3 in_stack_0000000d;
  int aiStack32 [2];
  CThreadSyncObject *pCStack24;
  uint auStack20 [2];
  
                    // 0x15a30  269  ?WaitForMultiple@CThreadSyncObject@@SAIHPAPAV1@_NI@Z
  auStack20[1] = 0x10015a47;
  iVar1 = -(param_1 * 8 + 0xfU & 0xfffffff0);
  iVar2 = 0;
  if (0 < param_1) {
    do {
      *(undefined4 *)(&stack0xfffffff4 + iVar2 * 8 + iVar1) = *(undefined4 *)param_2[iVar2];
      iVar2 = iVar2 + 1;
    } while (iVar2 < param_1);
  }
  *(uint *)((int)auStack20 + iVar1 + 4) = param_4;
  *(undefined4 *)((int)auStack20 + iVar1) = _param_3;
  *(undefined **)((int)&pCStack24 + iVar1) = &stack0xfffffff4 + iVar1;
  *(int *)((int)aiStack32 + iVar1 + 4) = param_1;
  *(undefined4 *)((int)aiStack32 + iVar1) = 0x10015a6c;
  uVar3 = WaitForMultiple(*(int *)((int)aiStack32 + iVar1 + 4),
                          *(CThreadSyncObject **)((int)&pCStack24 + iVar1),
                          *(bool *)((int)auStack20 + iVar1),*(uint *)((int)auStack20 + iVar1 + 4));
  return uVar3;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Unable to track spacebase fully for stack
// public: static unsigned int __cdecl CThreadSyncObject::WaitForMultiple(int,class
// CThreadSyncObject *,bool,unsigned int)

uint __cdecl
CThreadSyncObject::WaitForMultiple(int param_1,CThreadSyncObject *param_2,bool param_3,uint param_4)

{
  int iVar1;
  uint uVar2;
  int iVar3;
  undefined *puVar4;
  DWORD aDStack32 [2];
  uint auStack24 [3];
  
                    // 0x15a80  270  ?WaitForMultiple@CThreadSyncObject@@SAIHPAV1@_NI@Z
  auStack24[2] = 0x10015a97;
  iVar1 = -(param_1 * 4 + 0xfU & 0xfffffff0);
  iVar3 = 0;
  if (0 < param_1) {
    do {
      *(undefined4 *)(&stack0xfffffff4 + iVar3 * 4 + iVar1) = *(undefined4 *)(param_2 + iVar3 * 8);
      iVar3 = iVar3 + 1;
    } while (iVar3 < param_1);
  }
  *(uint *)((int)auStack24 + iVar1 + 8) = param_4;
  *(uint *)((int)auStack24 + iVar1 + 4) = (uint)param_3;
  *(undefined **)((int)auStack24 + iVar1) = &stack0xfffffff4 + iVar1;
  *(int *)((int)aDStack32 + iVar1 + 4) = param_1;
  puVar4 = (undefined *)((int)aDStack32 + iVar1);
  *(undefined4 *)((int)aDStack32 + iVar1) = 0x10015abf;
  uVar2 = WaitForMultipleObjects
                    (*(DWORD *)((int)aDStack32 + iVar1 + 4),*(HANDLE **)((int)auStack24 + iVar1),
                     *(BOOL *)((int)auStack24 + iVar1 + 4),*(DWORD *)((int)auStack24 + iVar1 + 8));
  if (uVar2 != 0x102) {
    if ((uint)param_1 <= uVar2) {
      if ((0x7f < uVar2) && (uVar2 - 0x80 < (uint)param_1)) {
        *(char **)(puVar4 + -4) = "Unhandled WAIT_ABANDONED in WaitForMultipleObjects";
        *(undefined4 *)(puVar4 + -8) = 0x10015aed;
        Error(*(byte **)(puVar4 + -4));
        return 0;
      }
      if (uVar2 == 0xffffffff) {
        return 0xffffffff;
      }
      *(uint *)(puVar4 + -4) = uVar2;
      *(char **)(puVar4 + -8) = "Unknown return value (%lu) from WaitForMultipleObjects";
      *(undefined4 *)(puVar4 + -0xc) = 0x10015b12;
      Error(*(byte **)(puVar4 + -8));
      uVar2 = 0;
    }
    return uVar2;
  }
  return 0x102;
}



// private: void __thiscall CThreadRWLock::WaitForRead(void)

void __thiscall CThreadRWLock::WaitForRead(CThreadRWLock *this)

{
  DWORD DVar1;
  int iVar2;
  
                    // 0x15b20  271  ?WaitForRead@CThreadRWLock@@AAEXXZ
  *(int *)(this + 0x20) = *(int *)(this + 0x20) + 1;
  do {
    *(int *)(this + 4) = *(int *)(this + 4) + -1;
    if (*(int *)(this + 4) == 0) {
      *(undefined4 *)this = 0;
    }
    WaitForSingleObject(*(HANDLE *)(this + 0x10),0xffffffff);
    DVar1 = GetCurrentThreadId();
    if (DVar1 == *(DWORD *)this) {
LAB_10015b6a:
      *(int *)(this + 4) = *(int *)(this + 4) + 1;
    }
    else {
      iVar2 = 0;
      LOCK();
      if (*(int *)this == 0) {
        *(DWORD *)this = DVar1;
      }
      else {
        iVar2 = *(int *)this;
      }
      if (iVar2 == 0) goto LAB_10015b6a;
      CThreadFastMutex::Lock((CThreadFastMutex *)this,DVar1,0);
    }
    if (*(int *)(this + 0x18) == 0) {
      *(int *)(this + 0x20) = *(int *)(this + 0x20) + -1;
      return;
    }
  } while( true );
}



// protected: int __thiscall CWorkerThread::WaitForReply(unsigned int,unsigned int
// (__cdecl*)(unsigned int,class CThreadEvent * *,int,unsigned int))

int __thiscall CWorkerThread::WaitForReply(CWorkerThread *this,uint param_1,FuncDef3 *param_2)

{
  bool bVar1;
  uint uVar2;
  uint uVar3;
  CWorkerThread *local_c;
  CWorkerThread *local_8;
  
                    // 0x15b80  272
                    // ?WaitForReply@CWorkerThread@@IAEHIP6AIIPAPAVCThreadEvent@@HI@Z@Z
  if (param_2 == (FuncDef3 *)0x0) {
    param_2 = FUN_100148e0;
  }
  local_c = this + 0x70;
  local_8 = this + 0x24;
  bVar1 = Plat_IsInDebugSession();
  uVar2 = param_1;
  if (param_1 == 0xffffffff) {
    uVar2 = 30000;
  }
  do {
    if (*(int *)(this + 0x2c) == 0) goto LAB_10015c16;
    uVar3 = (*param_2)(2,(CThreadEvent **)&local_c,0,uVar2);
  } while (((bVar1) && (param_1 == 0xffffffff)) && (uVar3 == 0x102));
  if (uVar3 != 0) {
    if (uVar3 != 0x102) {
      if (uVar3 != 1) {
        ResetEvent(*(HANDLE *)(this + 0x68));
        *(undefined4 *)(this + 0x7c) = 0xfffffffd;
        return *(int *)(this + 0x7c);
      }
LAB_10015c16:
      DevMsg(2,(byte *)"Thread failed to respond, probably exited\n");
      ResetEvent(*(HANDLE *)(this + 0x68));
    }
    *(undefined4 *)(this + 0x7c) = 0xfffffffe;
  }
  return *(int *)(this + 0x7c);
}



// public: int __thiscall CWorkerThread::WaitForReply(unsigned int)

int __thiscall CWorkerThread::WaitForReply(CWorkerThread *this,uint param_1)

{
  int iVar1;
  
                    // 0x15c50  273  ?WaitForReply@CWorkerThread@@QAEHI@Z
  iVar1 = WaitForReply(this,param_1,(FuncDef3 *)0x0);
  return iVar1;
}



// public: static void __cdecl CThread::Yield(void)

void __cdecl CThread::Yield(void)

{
                    // 0x15c70  274  ?Yield@CThread@@SAXXZ
  ::Sleep(0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

DWORD AllocateThreadID(void)

{
  DWORD DVar1;
  DWORD DVar2;
  DWORD DVar3;
  LPVOID lpTlsValue;
  
                    // 0x15c80  278  AllocateThreadID
  DVar2 = GetCurrentThreadId();
  if (DVar2 != DAT_10833d48) {
    DVar3 = 0;
    LOCK();
    DVar1 = DVar2;
    if (DAT_10833d48 != 0) {
      DVar3 = DAT_10833d48;
      DVar1 = DAT_10833d48;
    }
    DAT_10833d48 = DVar1;
    if (DVar3 != 0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)&DAT_10833d48,DVar2,0);
      goto LAB_10015cb6;
    }
  }
  _DAT_10833d4c = _DAT_10833d4c + 1;
LAB_10015cb6:
  lpTlsValue = (LPVOID)0x1;
  do {
    if (*(char *)((int)lpTlsValue + 0x10833d78) == '\0') {
      DVar2 = _g_nThreadID;
      if (_g_nThreadID != 0xffffffff) {
        DVar2 = TlsSetValue(_g_nThreadID,lpTlsValue);
      }
      *(undefined *)((int)lpTlsValue + 0x10833d78) = 1;
      goto LAB_10015cfa;
    }
    lpTlsValue = (LPVOID)((int)lpTlsValue + 1);
  } while ((int)lpTlsValue < 0x80);
  DVar2 = Error((byte *)
                "Out of thread ids. Decrease the number of threads or increase MAX_THREAD_IDS\n");
LAB_10015cfa:
  DVar3 = DAT_10833d48;
  _DAT_10833d4c = _DAT_10833d4c + -1;
  if (_DAT_10833d4c == 0) {
    DAT_10833d48 = 0;
    DVar2 = DVar3;
  }
  return DVar2;
}



HANDLE __cdecl CreateSimpleThread(undefined4 param_1,undefined4 param_2,SIZE_T param_3)

{
  undefined4 *lpParameter;
  HANDLE pvVar1;
  DWORD local_8;
  
                    // 0x15d10  293  CreateSimpleThread
  lpParameter = (undefined4 *)FUN_1001f8b3(8);
  if (lpParameter == (undefined4 *)0x0) {
    lpParameter = (undefined4 *)0x0;
  }
  else {
    *lpParameter = param_1;
    lpParameter[1] = param_2;
  }
  pvVar1 = CreateThread((LPSECURITY_ATTRIBUTES)0x0,param_3,FUN_10015840,lpParameter,
                        -(uint)(param_3 != 0) & 0x10000,&local_8);
  FUN_10014520((int)pvVar1,local_8);
  return pvVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void DeclareCurrentThreadIsMainThread(void)

{
                    // 0x15d70  294  DeclareCurrentThreadIsMainThread
  _DAT_10833d74 = GetCurrentThreadId();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

LPVOID FreeThreadID(void)

{
  LPVOID pvVar1;
  LPVOID pvVar2;
  LPVOID pvVar3;
  
                    // 0x15d80  330  FreeThreadID
  pvVar2 = (LPVOID)GetCurrentThreadId();
  if (pvVar2 != DAT_10833d48) {
    pvVar3 = (LPVOID)0x0;
    LOCK();
    pvVar1 = pvVar2;
    if (DAT_10833d48 != (LPVOID)0x0) {
      pvVar3 = DAT_10833d48;
      pvVar1 = DAT_10833d48;
    }
    DAT_10833d48 = pvVar1;
    if (pvVar3 != (LPVOID)0x0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)&DAT_10833d48,(uint)pvVar2,0);
      goto LAB_10015db6;
    }
  }
  _DAT_10833d4c = _DAT_10833d4c + 1;
LAB_10015db6:
  pvVar2 = _g_nThreadID;
  if ((_g_nThreadID != (LPVOID)0xffffffff) &&
     (pvVar2 = TlsGetValue((DWORD)_g_nThreadID), pvVar2 != (LPVOID)0x0)) {
    *(undefined *)((int)pvVar2 + 0x10833d78) = 0;
  }
  pvVar3 = DAT_10833d48;
  _DAT_10833d4c = _DAT_10833d4c + -1;
  if (_DAT_10833d4c == 0) {
    DAT_10833d48 = (LPVOID)0x0;
    pvVar2 = pvVar3;
  }
  return pvVar2;
}



undefined4 GetThreadedLoadLibraryFunc(void)

{
                    // 0x15de0  342  GetThreadedLoadLibraryFunc
  return DAT_10833e00;
}



uint __cdecl ReleaseThreadHandle(HANDLE param_1)

{
  BOOL BVar1;
  uint uVar2;
  
                    // 0x15df0  434  ReleaseThreadHandle
  BVar1 = CloseHandle(param_1);
  uVar2 = FUN_10014f90((int)param_1);
  return uVar2 & 0xffffff00 | (uint)(BVar1 != 0);
}



void __cdecl SetThreadedLoadLibraryFunc(undefined4 param_1)

{
  DAT_10833e00 = param_1;
                    // 0x15e20  450  SetThreadedLoadLibraryFunc
  return;
}



HANDLE ThreadGetCurrentHandle(void)

{
  HANDLE pvVar1;
  
                    // WARNING: Could not recover jumptable at 0x10015e30. Too many branches
                    // WARNING: Treating indirect jump as call
                    // 0x15e30  456  ThreadGetCurrentHandle
  pvVar1 = GetCurrentThread();
  return pvVar1;
}



void __cdecl ThreadGetPriority(HANDLE param_1)

{
                    // 0x15e40  457  ThreadGetPriority
  if (param_1 == (HANDLE)0x0) {
    param_1 = GetCurrentThread();
  }
  GetThreadPriority(param_1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint ThreadInMainThread(void)

{
  DWORD DVar1;
  
                    // 0x15e60  458  ThreadInMainThread
  DVar1 = GetCurrentThreadId();
  return DVar1 & 0xffffff00 | (uint)(DVar1 == _DAT_10833d74);
}



longlong __cdecl ThreadInterlockedAnd64(longlong *param_1,uint param_2,uint param_3)

{
  longlong lVar1;
  longlong lVar2;
  longlong lVar3;
  
  do {
    do {
      lVar2 = *param_1;
      lVar1 = *param_1;
      lVar3 = ThreadInterlockedCompareExchange64
                        (param_1,CONCAT44(*(uint *)((int)param_1 + 4) & param_3,
                                          *(uint *)param_1 & param_2),*(uint *)param_1,
                         *(uint *)((int)param_1 + 4));
    } while (lVar3 != lVar2);
  } while (false);
  return lVar1;
}



undefined8 __cdecl
ThreadInterlockedAssignIf64
          (longlong *param_1,longlong param_2,undefined4 param_3,undefined4 param_4)

{
  bool bVar1;
  
                    // 0x15ec0  460  ThreadInterlockedAssignIf64
  LOCK();
  bVar1 = CONCAT44(param_4,param_3) == *param_1;
  if (bVar1) {
    *param_1 = param_2;
  }
  else {
    param_4 = (undefined4)((ulonglong)*param_1 >> 0x20);
  }
  return CONCAT44(param_4,(uint)bVar1);
}



undefined8 __cdecl
ThreadInterlockedCompareExchange64
          (longlong *param_1,longlong param_2,undefined4 param_3,undefined4 param_4)

{
                    // 0x15ef0  461  ThreadInterlockedCompareExchange64
  LOCK();
  if (CONCAT44(param_4,param_3) == *param_1) {
    *param_1 = param_2;
  }
  else {
    param_4 = (undefined4)((ulonglong)*param_1 >> 0x20);
    param_3 = *(undefined4 *)param_1;
  }
  return CONCAT44(param_4,param_3);
}



undefined8 __cdecl ThreadInterlockedDecrement64(longlong *param_1)

{
  int iVar1;
  int iVar2;
  longlong lVar3;
  longlong lVar4;
  
  do {
    do {
      iVar1 = *(int *)param_1;
      iVar2 = *(int *)((int)param_1 + 4);
      lVar3 = *param_1;
      lVar4 = ThreadInterlockedCompareExchange64
                        (param_1,CONCAT44(iVar2 - (uint)(iVar1 == 0),iVar1 + -1),iVar1,iVar2);
    } while (lVar4 != lVar3);
  } while (false);
  return CONCAT44(iVar2 - (uint)(iVar1 == 0),iVar1 + -1);
}



longlong __cdecl
ThreadInterlockedExchange64(longlong *param_1,undefined4 param_2,undefined4 param_3)

{
  longlong lVar1;
  longlong lVar2;
  longlong lVar3;
  
  do {
    do {
      lVar2 = *param_1;
      lVar1 = *param_1;
      lVar3 = ThreadInterlockedCompareExchange64
                        (param_1,CONCAT44(param_3,param_2),*(undefined4 *)param_1,
                         *(undefined4 *)((int)param_1 + 4));
    } while (lVar3 != lVar2);
  } while (false);
  return lVar1;
}



longlong __cdecl ThreadInterlockedExchangeAdd64(longlong *param_1,uint param_2,int param_3)

{
  uint uVar1;
  longlong lVar2;
  longlong lVar3;
  longlong lVar4;
  
  do {
    do {
      uVar1 = *(uint *)param_1;
      lVar3 = *param_1;
      lVar2 = *param_1;
      lVar4 = ThreadInterlockedCompareExchange64
                        (param_1,CONCAT44(*(int *)((int)param_1 + 4) + param_3 +
                                          (uint)CARRY4(uVar1,param_2),uVar1 + param_2),uVar1,
                         *(int *)((int)param_1 + 4));
    } while (lVar4 != lVar3);
  } while (false);
  return lVar2;
}



undefined8 __cdecl ThreadInterlockedIncrement64(longlong *param_1)

{
  uint uVar1;
  int iVar2;
  longlong lVar3;
  longlong lVar4;
  
  do {
    do {
      uVar1 = *(uint *)param_1;
      iVar2 = *(int *)((int)param_1 + 4);
      lVar3 = *param_1;
      lVar4 = ThreadInterlockedCompareExchange64
                        (param_1,CONCAT44(iVar2 + (uint)(0xfffffffe < uVar1),uVar1 + 1),uVar1,iVar2)
      ;
    } while (lVar4 != lVar3);
  } while (false);
  return CONCAT44(iVar2 + (uint)(0xfffffffe < uVar1),uVar1 + 1);
}



longlong __cdecl ThreadInterlockedOr64(longlong *param_1,uint param_2,uint param_3)

{
  longlong lVar1;
  longlong lVar2;
  longlong lVar3;
  
  do {
    do {
      lVar2 = *param_1;
      lVar1 = *param_1;
      lVar3 = ThreadInterlockedCompareExchange64
                        (param_1,CONCAT44(*(uint *)((int)param_1 + 4) | param_3,
                                          *(uint *)param_1 | param_2),*(uint *)param_1,
                         *(uint *)((int)param_1 + 4));
    } while (lVar3 != lVar2);
  } while (false);
  return lVar1;
}



uint __cdecl ThreadJoin(HANDLE param_1,DWORD param_2)

{
                    // 0x16080  467  ThreadJoin
  if (param_1 != (HANDLE)0x0) {
    param_1 = (HANDLE)WaitForSingleObject(param_1,param_2);
    if (param_1 != (HANDLE)0x102) {
      if ((param_1 != (HANDLE)0x0) && (param_1 != (HANDLE)0xffffffff)) {
        param_1 = (HANDLE)GetLastError();
        if (param_1 != (HANDLE)0x0) goto LAB_1001608a;
      }
      return CONCAT31((int3)((uint)param_1 >> 8),1);
    }
  }
LAB_1001608a:
  return (uint)param_1 & 0xffffff00;
}



void __cdecl ThreadNanoSleep(int param_1)

{
                    // 0x160c0  468  ThreadNanoSleep
  Sleep((param_1 + 999U) / 1000);
  return;
}



void __cdecl ThreadSetAffinity(HANDLE param_1,DWORD_PTR param_2)

{
                    // 0x160e0  469  ThreadSetAffinity
  if (param_1 == (HANDLE)0x0) {
    param_1 = GetCurrentThread();
  }
  SetThreadAffinityMask(param_1,param_2);
  return;
}



void __cdecl ThreadSetDebugName(HANDLE param_1,undefined4 param_2)

{
  bool bVar1;
  undefined4 *in_FS_OFFSET;
  ULONG_PTR local_2c;
  undefined4 local_28;
  HANDLE local_24;
  undefined4 local_20;
  undefined *local_1c;
  undefined4 local_14;
  code *pcStack16;
  undefined *puStack12;
  undefined4 local_8;
  
                    // 0x16100  470  ThreadSetDebugName
  local_8 = 0xffffffff;
  puStack12 = &DAT_1003f600;
  pcStack16 = FUN_100213a8;
  local_14 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_14;
  local_1c = &stack0xffffffc8;
  bVar1 = Plat_IsInDebugSession();
  if (bVar1) {
    local_2c = 0x1000;
    local_28 = param_2;
    local_24 = FUN_10014d70(param_1);
    if (local_24 != (HANDLE)0x0) {
      local_20 = 0;
      local_8 = 0;
      RaiseException(0x406d1388,0,4,&local_2c);
    }
  }
  *in_FS_OFFSET = local_14;
  return;
}



bool __cdecl ThreadSetPriority(HANDLE param_1,int param_2)

{
  BOOL BVar1;
  
                    // 0x16190  471  ThreadSetPriority
  if (param_1 == (HANDLE)0x0) {
    param_1 = GetCurrentThread();
  }
  BVar1 = SetThreadPriority(param_1,param_2);
  return BVar1 != 0;
}



void __cdecl ThreadSleep(DWORD param_1)

{
                    // 0x161c0  472  ThreadSleep
  if (DAT_10833dfc == '\0') {
    DAT_10833dfc = '\x01';
    timeBeginPeriod(1);
  }
  Sleep(param_1);
  return;
}



int __cdecl V_tier0_snprintf(char *param_1,uint param_2,byte *param_3)

{
  int iVar1;
  
                    // 0x161f0  476  V_tier0_snprintf
  iVar1 = FUN_10021749(param_1,param_2,param_3,(int **)&stack0x00000010);
  if ((iVar1 < 0) || ((0 < (int)param_2 && ((int)param_2 <= iVar1)))) {
    iVar1 = param_2 - 1;
    param_1[param_2 - 1] = '\0';
  }
  return iVar1;
}



uint __cdecl V_tier0_stricmp(byte *param_1,byte *param_2)

{
  uint uVar1;
  uint uVar2;
  bool bVar3;
  
                    // 0x16230  477  V_tier0_stricmp
  bVar3 = param_1 == param_2;
  do {
    if (bVar3) {
      return 0;
    }
    while( true ) {
      uVar1 = (uint)*param_1;
      uVar2 = (uint)*param_2;
      if (uVar1 == uVar2) {
        if (uVar1 == 0) {
          return 0;
        }
      }
      else {
        if (uVar2 == 0) {
          return uVar1;
        }
        if (uVar1 - 0x41 < 0x1a) {
          uVar1 = uVar1 + 0x20;
        }
        if (uVar2 - 0x41 < 0x1a) {
          uVar2 = uVar2 + 0x20;
        }
        if (uVar1 != uVar2) goto LAB_100162a7;
      }
      uVar1 = (uint)param_1[1];
      param_1 = param_1 + 2;
      uVar2 = (uint)param_2[1];
      param_2 = param_2 + 2;
      if (uVar1 == uVar2) break;
      if (uVar2 == 0) {
        return uVar1;
      }
      if (uVar1 - 0x41 < 0x1a) {
        uVar1 = uVar1 + 0x20;
      }
      if (uVar2 - 0x41 < 0x1a) {
        uVar2 = uVar2 + 0x20;
      }
      if (uVar1 != uVar2) {
LAB_100162a7:
        return uVar1 - uVar2;
      }
    }
    bVar3 = uVar1 == 0;
  } while( true );
}



char * __cdecl V_tier0_strncat(char *param_1,char *param_2,int param_3,size_t param_4)

{
  char cVar1;
  char *pcVar2;
  size_t _Count;
  char *pcVar3;
  
                    // 0x162b0  478  V_tier0_strncat
  pcVar3 = param_1;
  do {
    cVar1 = *pcVar3;
    pcVar3 = pcVar3 + 1;
  } while (cVar1 != '\0');
  pcVar2 = param_2;
  do {
    cVar1 = *pcVar2;
    pcVar2 = pcVar2 + 1;
  } while (cVar1 != '\0');
  _Count = (int)pcVar2 - (int)(param_2 + 1);
  if ((-1 < (int)param_4) && ((int)param_4 < (int)_Count)) {
    _Count = param_4;
  }
  if (param_3 <= (int)(((int)pcVar3 - (int)(param_1 + 1)) + _Count)) {
    _Count = (param_3 - ((int)pcVar3 - (int)(param_1 + 1))) - 1;
  }
  if ((int)_Count < 1) {
    return param_1;
  }
  pcVar3 = _strncat(param_1,param_2,_Count);
  return pcVar3;
}



void __cdecl V_tier0_strncpy(char *param_1,int param_2,int param_3)

{
  int iVar1;
  char *pcVar2;
  
                    // 0x16310  479  V_tier0_strncpy
  pcVar2 = param_1 + param_3 + -1;
  if (param_1 < pcVar2) {
    iVar1 = param_2 - (int)param_1;
    do {
      if (param_1[iVar1] == '\0') break;
      *param_1 = param_1[iVar1];
      param_1 = param_1 + 1;
    } while (param_1 < pcVar2);
  }
  *param_1 = '\0';
  return;
}



int __cdecl V_tier0_vsnprintf(char *param_1,uint param_2,byte *param_3,int **param_4)

{
  int iVar1;
  
                    // 0x16340  480  V_tier0_vsnprintf
  iVar1 = FUN_10021749(param_1,param_2,param_3,param_4);
  if ((iVar1 < 0) || ((0 < (int)param_2 && ((int)param_2 <= iVar1)))) {
    iVar1 = param_2 - 1;
    param_1[param_2 - 1] = '\0';
  }
  return iVar1;
}



undefined4 * __fastcall FUN_10016380(undefined4 *param_1)

{
  code *pcVar1;
  undefined4 *puVar2;
  int iVar3;
  
  param_1[4] = 0;
  if (((uint)(param_1 + 6) & 7) != 0) {
    Error((byte *)"CTSListBase: Misaligned list\n");
    pcVar1 = (code *)swi(3);
    puVar2 = (undefined4 *)(*pcVar1)();
    return puVar2;
  }
  param_1[6] = 0;
  param_1[7] = 0;
  if (((uint)param_1 & 7) != 0) {
    Error((byte *)"CTSQueue: Misaligned queue\n");
    pcVar1 = (code *)swi(3);
    puVar2 = (undefined4 *)(*pcVar1)();
    return puVar2;
  }
  if (false) {
    Error((byte *)"CTSQueue: Misaligned queue\n");
    pcVar1 = (code *)swi(3);
    puVar2 = (undefined4 *)(*pcVar1)();
    return puVar2;
  }
  param_1[4] = 0;
  param_1[3] = 0;
  param_1[1] = 0;
  iVar3 = (***(code ***)g_pMemAlloc)
                    (0x13,"d:\\projects\\ti\\release\\ti_rel\\src\\public\\tier0\\tslist.h",0x2a3);
  if (iVar3 != 0) {
    puVar2 = (undefined4 *)(iVar3 + 0xbU & 0xfffffff8);
    puVar2[-1] = iVar3;
    param_1[2] = puVar2;
    *param_1 = puVar2;
    *puVar2 = param_1;
    return param_1;
  }
  param_1[2] = 0;
  *param_1 = 0;
  puRam00000000 = param_1;
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

bool FUN_10016430(void)

{
  return _DAT_10833e2c == 0;
}



bool FUN_10016440(void)

{
  return (bool)('\x01' - (DAT_10833e58 != 0));
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe
// WARNING: Unable to track spacebase fully for stack

void __cdecl FUN_10016450(char param_1)

{
  int iVar1;
  undefined *puVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  HANDLE pvStackY44;
  undefined4 uStack36;
  char *pcStack32;
  HANDLE local_10;
  int local_c;
  undefined *local_8;
  
  pcStack32 = "distributed...";
  if (param_1 == '\0') {
    pcStack32 = "no affinity...";
  }
  uStack36 = DAT_10833e18;
  pvStackY44 = (HANDLE)0x1001647b;
  Msg((byte *)"%s test: multithread push, multithread pop, %s");
  pcStack32 = (char *)0x10016483;
  FUN_10017b80();
  iVar3 = 0;
  pcStack32 = (char *)0x1001649a;
  iVar1 = -(DAT_10833e08 * 4 + 0xfU & 0xfffffff0);
  local_8 = &stack0xffffffe4 + iVar1;
  iVar5 = 0;
  local_c = 0;
  iVar4 = iVar3;
  puVar2 = &stack0xffffffe4 + iVar1;
  if (0 < DAT_10833e08 / 2) {
    do {
      local_8 = puVar2;
      *(undefined4 *)((int)&pcStack32 + iVar1) = 0;
      *(undefined4 *)(&stack0xffffffdc + iVar1) = 0;
      *(code **)(&stack0xffffffd8 + iVar1) = FUN_10016880;
      *(undefined4 *)((int)&pvStackY44 + iVar1) = 0x100164be;
      local_10 = CreateSimpleThread(*(undefined4 *)(&stack0xffffffd8 + iVar1),
                                    *(undefined4 *)(&stack0xffffffdc + iVar1),
                                    *(SIZE_T *)((int)&pcStack32 + iVar1));
      *(HANDLE *)(local_8 + iVar5 * 4) = local_10;
      iVar5 = iVar5 + 1;
      iVar3 = iVar4;
      if (param_1 != '\0') {
        iVar3 = iVar4 + 1;
        *(int *)((int)&pcStack32 + iVar1) = 1 << ((byte)(iVar4 % DAT_100466c4) & 0x1f);
        *(HANDLE *)(&stack0xffffffdc + iVar1) = local_10;
        *(undefined4 *)(&stack0xffffffd8 + iVar1) = 0x100164ef;
        ThreadSetAffinity(*(HANDLE *)(&stack0xffffffdc + iVar1),
                          *(DWORD_PTR *)((int)&pcStack32 + iVar1));
      }
      local_c = local_c + 1;
      iVar4 = iVar3;
      puVar2 = local_8;
    } while (local_c < DAT_10833e08 / 2);
  }
  local_c = 0;
  if (0 < DAT_10833e08 / 2) {
    do {
      *(undefined4 *)((int)&pcStack32 + iVar1) = 0;
      *(undefined4 *)(&stack0xffffffdc + iVar1) = 0;
      *(code **)(&stack0xffffffd8 + iVar1) = FUN_10016de0;
      *(undefined4 *)((int)&pvStackY44 + iVar1) = 0x1001652e;
      local_10 = CreateSimpleThread(*(undefined4 *)(&stack0xffffffd8 + iVar1),
                                    *(undefined4 *)(&stack0xffffffdc + iVar1),
                                    *(SIZE_T *)((int)&pcStack32 + iVar1));
      *(HANDLE *)(local_8 + iVar5 * 4) = local_10;
      iVar5 = iVar5 + 1;
      iVar4 = iVar3;
      if (param_1 != '\0') {
        iVar4 = iVar3 + 1;
        *(int *)((int)&pcStack32 + iVar1) = 1 << ((byte)(iVar3 % DAT_100466c4) & 0x1f);
        *(HANDLE *)(&stack0xffffffdc + iVar1) = local_10;
        *(undefined4 *)(&stack0xffffffd8 + iVar1) = 0x1001655f;
        ThreadSetAffinity(*(HANDLE *)(&stack0xffffffdc + iVar1),
                          *(DWORD_PTR *)((int)&pcStack32 + iVar1));
      }
      local_c = local_c + 1;
      iVar3 = iVar4;
    } while (local_c < DAT_10833e08 / 2);
  }
  if (DAT_10833e24 < DAT_10833e08) {
    do {
      *(undefined4 *)((int)&pcStack32 + iVar1) = 0;
      *(undefined4 *)(&stack0xffffffdc + iVar1) = 0x10016589;
      ThreadSleep(*(DWORD *)((int)&pcStack32 + iVar1));
    } while (DAT_10833e24 < DAT_10833e08);
  }
  DAT_10833e0c = 1;
  while (0 < DAT_10833e24) {
    *(undefined4 *)((int)&pcStack32 + iVar1) = 0;
    *(undefined4 *)(&stack0xffffffdc + iVar1) = 0x100165b7;
    ThreadSleep(*(DWORD *)((int)&pcStack32 + iVar1));
  }
  *(undefined4 *)((int)&pcStack32 + iVar1) = 1;
  *(undefined4 *)(&stack0xffffffdc + iVar1) = 0x100165ca;
  FUN_10017ad0(*(char *)((int)&pcStack32 + iVar1));
  iVar3 = 0;
  if (0 < iVar5) {
    do {
      *(undefined4 *)((int)&pcStack32 + iVar1) = *(undefined4 *)(local_8 + iVar3 * 4);
      *(undefined4 *)(&stack0xffffffdc + iVar1) = 0x100165de;
      ReleaseThreadHandle(*(HANDLE *)((int)&pcStack32 + iVar1));
      iVar3 = iVar3 + 1;
    } while (iVar3 < iVar5);
  }
  return;
}



longlong __fastcall FUN_100165f0(longlong *param_1)

{
  int iVar1;
  longlong **pplVar2;
  longlong *plVar3;
  longlong *plVar4;
  undefined8 uVar5;
  
  while( true ) {
    while( true ) {
      while( true ) {
        do {
          do {
            iVar1 = *(int *)((int)param_1 + 4);
            pplVar2 = *(longlong ***)param_1;
            plVar3 = *pplVar2;
          } while (plVar3 == (longlong *)0x0);
        } while (iVar1 != *(int *)((int)param_1 + 4));
        if (plVar3 != (longlong *)0xdeadbeef) break;
        Msg((byte *)"Bad node link detected\n");
      }
      if (pplVar2 == *(longlong ***)(param_1 + 1)) break;
      if (plVar3 != param_1) {
        plVar4 = *(longlong **)((int)plVar3 + 4);
        uVar5 = ThreadInterlockedAssignIf64(param_1,CONCAT44(iVar1 + 1,plVar3),pplVar2,iVar1);
        if ((char)uVar5 != '\0') {
          *pplVar2 = (longlong *)0xdeadbeef;
          plVar3 = param_1 + 2;
          LOCK();
          iVar1 = *(int *)plVar3;
          *(int *)plVar3 = *(int *)plVar3 + -1;
          pplVar2[1] = plVar4;
          return CONCAT44(iVar1,pplVar2);
        }
      }
    }
    if (plVar3 == param_1) break;
    ThreadInterlockedAssignIf64
              (param_1 + 1,CONCAT44(*(int *)((int)param_1 + 0xc) + 1,plVar3),pplVar2,
               *(int *)((int)param_1 + 0xc));
  }
  return ZEXT48(param_1 + 1) << 0x20;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 __fastcall FUN_100166e0(undefined4 param_1,uint param_2,undefined4 *param_3)

{
  DWORD DVar1;
  DWORD DVar2;
  uint uVar3;
  uint extraout_EDX;
  ulonglong uVar4;
  
  if (DAT_10833e74 != '\0') {
    param_2 = GetCurrentThreadId();
    if (param_2 != DAT_10833e38) {
      DVar2 = 0;
      LOCK();
      DVar1 = param_2;
      if (DAT_10833e38 != 0) {
        DVar2 = DAT_10833e38;
        DVar1 = DAT_10833e38;
      }
      DAT_10833e38 = DVar1;
      if (DVar2 != 0) {
        CThreadFastMutex::Lock((CThreadFastMutex *)&DAT_10833e38,param_2,0);
        param_2 = extraout_EDX;
        goto LAB_10016722;
      }
    }
    _DAT_10833e3c = _DAT_10833e3c + 1;
  }
LAB_10016722:
  uVar4 = FUN_10016840((longlong *)&DAT_10833e28,param_2);
  DVar2 = DAT_10833e38;
  uVar3 = (uint)uVar4;
  if (uVar3 == 0) {
    if ((DAT_10833e74 != '\0') && (_DAT_10833e3c = _DAT_10833e3c + -1, _DAT_10833e3c == 0)) {
      DAT_10833e38 = 0;
      uVar3 = DVar2;
    }
    return uVar3 & 0xffffff00;
  }
  *param_3 = *(undefined4 *)(uVar3 + 4);
  (**(code **)(*(int *)g_pMemAlloc + 0x14))(*(undefined4 *)((uVar3 & 0xfffffffc) - 4));
  if ((DAT_10833e74 != '\0') && (_DAT_10833e3c = _DAT_10833e3c + -1, _DAT_10833e3c == 0)) {
    DAT_10833e38 = 0;
  }
  LOCK();
  uVar3 = (uint)DAT_10833e70 >> 8;
  DAT_10833e70 = DAT_10833e70 + 1;
  return CONCAT31((int3)uVar3,1);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulonglong FUN_10016790(undefined4 *param_1)

{
  uint uVar1;
  undefined4 *puVar2;
  undefined4 *puVar3;
  undefined4 *puVar4;
  ulonglong uVar5;
  
  if (DAT_10833e74 != '\0') {
    puVar3 = (undefined4 *)GetCurrentThreadId();
    if (puVar3 != DAT_10833e38) {
      puVar4 = (undefined4 *)0x0;
      LOCK();
      puVar2 = puVar3;
      if (DAT_10833e38 != (undefined4 *)0x0) {
        puVar4 = DAT_10833e38;
        puVar2 = DAT_10833e38;
      }
      DAT_10833e38 = puVar2;
      if (puVar4 != (undefined4 *)0x0) {
        CThreadFastMutex::Lock((CThreadFastMutex *)&DAT_10833e38,(uint)puVar3,0);
        goto LAB_100167d2;
      }
    }
    _DAT_10833e3c = _DAT_10833e3c + 1;
  }
LAB_100167d2:
  uVar5 = FUN_100165f0((longlong *)&DAT_10833e48);
  puVar3 = DAT_10833e38;
  puVar4 = (undefined4 *)uVar5;
  if (puVar4 == (undefined4 *)0x0) {
    if ((DAT_10833e74 != '\0') && (_DAT_10833e3c = _DAT_10833e3c + -1, _DAT_10833e3c == 0)) {
      DAT_10833e38 = (undefined4 *)0x0;
      puVar4 = puVar3;
    }
    return uVar5 & 0xffffffff00000000 | (ulonglong)((uint)puVar4 & 0xffffff00);
  }
  *param_1 = puVar4[1];
  uVar5 = FUN_1000da50(&DAT_10833e60,puVar4);
  if ((DAT_10833e74 != '\0') && (_DAT_10833e3c = _DAT_10833e3c + -1, _DAT_10833e3c == 0)) {
    DAT_10833e38 = (undefined4 *)0x0;
  }
  LOCK();
  uVar1 = (uint)DAT_10833e70 >> 8;
  DAT_10833e70 = DAT_10833e70 + 1;
  return uVar5 & 0xffffffff00000000 | (ulonglong)CONCAT31((int3)uVar1,1);
}



ulonglong __fastcall FUN_10016840(longlong *param_1,uint param_2)

{
  undefined4 *puVar1;
  int iVar2;
  ulonglong uVar3;
  
  uVar3 = (ulonglong)param_2 << 0x20;
  puVar1 = *(undefined4 **)param_1;
  iVar2 = *(int *)((int)param_1 + 4);
  while( true ) {
    if (puVar1 == (undefined4 *)0x0) {
      return uVar3 & 0xffffffff00000000;
    }
    uVar3 = ThreadInterlockedAssignIf64(param_1,CONCAT44(iVar2 + -1,*puVar1),puVar1,iVar2);
    if ((char)uVar3 != '\0') break;
    puVar1 = *(undefined4 **)param_1;
    iVar2 = *(int *)((int)param_1 + 4);
  }
  return uVar3 & 0xffffffff00000000 | ZEXT48(puVar1);
}



undefined4 FUN_10016880(void)

{
  char cVar1;
  undefined local_8 [4];
  
  LOCK();
  DAT_10833e68 = DAT_10833e68 + 1;
  LOCK();
  DAT_10833e24 = DAT_10833e24 + 1;
  if (DAT_10833e0c == '\0') {
    do {
      ThreadSleep(1);
    } while (DAT_10833e0c == '\0');
  }
  do {
    do {
      cVar1 = (**(code **)(*DAT_10833e1c + 4))(local_8);
    } while (cVar1 != '\0');
    ThreadSleep(0);
  } while (DAT_10833e6c != 0);
  cVar1 = (**(code **)(*DAT_10833e1c + 4))(local_8);
  while (cVar1 != '\0') {
    ThreadSleep(0);
    cVar1 = (**(code **)(*DAT_10833e1c + 4))(local_8);
  }
  LOCK();
  LOCK();
  DAT_10833e24 = DAT_10833e24 + -1;
  DAT_10833e68 = DAT_10833e68 + -1;
  return 0;
}



void __fastcall FUN_10016940(longlong *param_1)

{
  longlong *plVar1;
  undefined4 *puVar2;
  int iVar3;
  uint uVar4;
  longlong lVar5;
  undefined8 uVar6;
  
  lVar5 = FUN_100165f0(param_1);
  uVar4 = (uint)lVar5;
  while (uVar4 != 0) {
    (**(code **)(*(int *)g_pMemAlloc + 0x14))(*(undefined4 *)((uVar4 & 0xfffffffc) - 4));
    lVar5 = FUN_100165f0(param_1);
    uVar4 = (uint)lVar5;
  }
  plVar1 = param_1 + 3;
  do {
    puVar2 = *(undefined4 **)plVar1;
    iVar3 = *(int *)((int)param_1 + 0x1c);
    while( true ) {
      if (puVar2 == (undefined4 *)0x0) {
        *(undefined4 *)((int)param_1 + 4) = 0;
        *(undefined4 *)((int)param_1 + 0xc) = 0;
        return;
      }
      uVar6 = ThreadInterlockedAssignIf64(plVar1,CONCAT44(iVar3 + -1,*puVar2),puVar2,iVar3);
      if ((char)uVar6 != '\0') break;
      puVar2 = *(undefined4 **)plVar1;
      iVar3 = *(int *)((int)param_1 + 0x1c);
    }
    (**(code **)(*(int *)g_pMemAlloc + 0x14))(*(undefined4 *)(((uint)puVar2 & 0xfffffffc) - 4));
  } while( true );
}



undefined8 __thiscall FUN_100169d0(void *this,int *param_1)

{
  int iVar1;
  int **ppiVar2;
  int *piVar3;
  
  *param_1 = (int)this;
  iVar1 = *(int *)((int)this + 0xc);
  ppiVar2 = *(int ***)((int)this + 8);
  LOCK();
  if ((int *)this == *ppiVar2) {
    *ppiVar2 = param_1;
    piVar3 = (int *)this;
  }
  else {
    piVar3 = *ppiVar2;
  }
  while (piVar3 != (int *)this) {
    ThreadInterlockedAssignIf64
              ((longlong *)((int)this + 8),CONCAT44(iVar1 + 1,*ppiVar2),ppiVar2,iVar1);
    iVar1 = *(int *)((int)this + 0xc);
    ppiVar2 = *(int ***)(longlong *)((int)this + 8);
    LOCK();
    if ((int *)this == *ppiVar2) {
      *ppiVar2 = param_1;
      piVar3 = (int *)this;
    }
    else {
      piVar3 = *ppiVar2;
    }
  }
  ThreadInterlockedAssignIf64((longlong *)((int)this + 8),CONCAT44(iVar1 + 1,param_1),ppiVar2,iVar1)
  ;
  piVar3 = (int *)((int)this + 0x10);
  LOCK();
  iVar1 = *piVar3;
  *piVar3 = *piVar3 + 1;
  return CONCAT44(iVar1,ppiVar2);
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulonglong FUN_10016a50(undefined4 param_1)

{
  ulonglong uVar1;
  DWORD DVar2;
  DWORD DVar3;
  DWORD DVar4;
  int iVar5;
  undefined4 *puVar6;
  ulonglong uVar7;
  
  if (DAT_10833e74 != '\0') {
    DVar3 = GetCurrentThreadId();
    if (DVar3 != DAT_10833e38) {
      DVar4 = 0;
      LOCK();
      DVar2 = DVar3;
      if (DAT_10833e38 != 0) {
        DVar4 = DAT_10833e38;
        DVar2 = DAT_10833e38;
      }
      DAT_10833e38 = DVar2;
      if (DVar4 != 0) {
        CThreadFastMutex::Lock((CThreadFastMutex *)&DAT_10833e38,DVar3,0);
        goto LAB_10016a91;
      }
    }
    _DAT_10833e3c = _DAT_10833e3c + 1;
  }
LAB_10016a91:
  iVar5 = (***(code ***)g_pMemAlloc)
                    (0x13,"d:\\projects\\ti\\release\\ti_rel\\src\\public\\tier0\\tslist.h",0x1bb);
  if (iVar5 == 0) {
    puVar6 = (undefined4 *)0x0;
  }
  else {
    puVar6 = (undefined4 *)(iVar5 + 0xbU & 0xfffffff8);
    puVar6[-1] = iVar5;
    puVar6[1] = param_1;
  }
  uVar7 = FUN_1000da50(&DAT_10833e28,puVar6);
  LOCK();
  uVar1 = (ulonglong)DAT_10833e44;
  DAT_10833e44 = DAT_10833e44 + 1;
  return uVar7 & 0xffffffff00000000 | uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

ulonglong __fastcall FUN_10016ae0(undefined4 param_1,uint param_2,undefined param_3)

{
  ulonglong uVar1;
  DWORD DVar2;
  DWORD DVar3;
  uint extraout_EDX;
  ulonglong uVar4;
  
  if (DAT_10833e74 != '\0') {
    param_2 = GetCurrentThreadId();
    if (param_2 != DAT_10833e38) {
      DVar3 = 0;
      LOCK();
      DVar2 = param_2;
      if (DAT_10833e38 != 0) {
        DVar3 = DAT_10833e38;
        DVar2 = DAT_10833e38;
      }
      DAT_10833e38 = DVar2;
      if (DVar3 != 0) {
        CThreadFastMutex::Lock((CThreadFastMutex *)&DAT_10833e38,param_2,0);
        param_2 = extraout_EDX;
        goto LAB_10016b22;
      }
    }
    _DAT_10833e3c = _DAT_10833e3c + 1;
  }
LAB_10016b22:
  uVar4 = FUN_10016b60(&DAT_10833e48,param_2,(int *)&param_3);
  if ((DAT_10833e74 != '\0') && (_DAT_10833e3c = _DAT_10833e3c + -1, _DAT_10833e3c == 0)) {
    DAT_10833e38 = 0;
  }
  LOCK();
  uVar1 = (ulonglong)DAT_10833e44;
  DAT_10833e44 = DAT_10833e44 + 1;
  return uVar4 & 0xffffffff00000000 | uVar1;
}



undefined8 __fastcall FUN_10016b60(void *param_1,uint param_2,int *param_3)

{
  int iVar1;
  int *piVar2;
  ulonglong uVar3;
  undefined8 uVar4;
  
  uVar3 = FUN_10016840((longlong *)((int)param_1 + 0x18),param_2);
  piVar2 = (int *)uVar3;
  if (piVar2 != (int *)0x0) {
    piVar2[1] = *param_3;
    uVar4 = FUN_100169d0(param_1,piVar2);
    return uVar4;
  }
  iVar1 = (***(code ***)g_pMemAlloc)
                    (0x13,"d:\\projects\\ti\\release\\ti_rel\\src\\public\\tier0\\tslist.h",0x2a3);
  if (iVar1 != 0) {
    piVar2 = (int *)(iVar1 + 0xbU & 0xfffffff8);
    piVar2[-1] = iVar1;
    piVar2[1] = *param_3;
    uVar4 = FUN_100169d0(param_1,piVar2);
    return uVar4;
  }
  uVar4 = FUN_100169d0(param_1,(int *)0x0);
  return uVar4;
}



void __fastcall FUN_10016be0(int param_1)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  char cVar4;
  uint uVar5;
  bool bVar6;
  int local_8;
  
  local_8 = param_1;
LAB_10016bf0:
  do {
    uVar5 = FUN_100244dd();
    iVar3 = DAT_10833e40;
    uVar5 = uVar5 & 0x80000001;
    bVar6 = uVar5 == 0;
    if ((int)uVar5 < 0) {
      bVar6 = (uVar5 - 1 | 0xfffffffe) == 0xffffffff;
    }
    if (bVar6) {
      LOCK();
      iVar2 = DAT_10833e40 + 1;
      local_8 = DAT_10833e40;
      bVar6 = DAT_10833e40 < DAT_100466bc;
      DAT_10833e40 = iVar2;
      if (bVar6) {
        (**(code **)*DAT_10833e1c)(iVar3);
        if (local_8 < DAT_100466bc) {
          piVar1 = (int *)(DAT_10833e10 + local_8 * 4);
          LOCK();
          *piVar1 = *piVar1 + 1;
        }
        goto LAB_10016bf0;
      }
    }
    cVar4 = (**(code **)(*DAT_10833e1c + 4))(&local_8);
    if (cVar4 == '\0') {
      if (DAT_100466bc <= DAT_10833e40) {
        return;
      }
    }
    else if (local_8 < DAT_100466bc) {
      piVar1 = (int *)(DAT_10833e10 + local_8 * 4);
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
  } while( true );
}



undefined4 FUN_10016c90(void)

{
  int iVar1;
  int extraout_ECX;
  int extraout_ECX_00;
  
  ThreadSetDebugName((HANDLE)0x0,"PushPopThread");
  LOCK();
  DAT_10833e24 = DAT_10833e24 + 1;
  iVar1 = extraout_ECX;
  while (DAT_10833e0c == '\0') {
    ThreadSleep(0);
    iVar1 = extraout_ECX_00;
  }
  FUN_10016be0(iVar1);
  LOCK();
  DAT_10833e24 = DAT_10833e24 + -1;
  return 0;
}



void FUN_10016ce0(void)

{
  int iVar1;
  char cVar2;
  int local_8;
  
  Msg((byte *)"%s test: single thread push/pop, in order... ");
  FUN_10021290(DAT_10833e10,0,DAT_100466bc << 2);
  DAT_10833e40 = 0;
  if (0 < DAT_100466bc) {
    do {
      iVar1 = DAT_10833e40;
      LOCK();
      local_8 = DAT_10833e40;
      DAT_10833e40 = DAT_10833e40 + 1;
      (**(code **)*DAT_10833e1c)(iVar1);
      if (local_8 < DAT_100466bc) {
        LOCK();
        DAT_10833e10[local_8] = DAT_10833e10[local_8] + 1;
      }
    } while (DAT_10833e40 < DAT_100466bc);
  }
  (**(code **)(*DAT_10833e1c + 8))();
  cVar2 = (**(code **)(*DAT_10833e1c + 4))(&local_8);
  while (cVar2 != '\0') {
    if (local_8 < DAT_100466bc) {
      LOCK();
      DAT_10833e10[local_8] = DAT_10833e10[local_8] - 1;
    }
    cVar2 = (**(code **)(*DAT_10833e1c + 4))(&local_8);
  }
  FUN_10017ad0('\x01');
  return;
}



undefined4 FUN_10016de0(void)

{
  int iVar1;
  int iVar2;
  
  LOCK();
  DAT_10833e6c = DAT_10833e6c + 1;
  LOCK();
  DAT_10833e24 = DAT_10833e24 + 1;
  if (DAT_10833e0c == '\0') {
    do {
      ThreadSleep(0);
    } while (DAT_10833e0c == '\0');
  }
  LOCK();
  iVar1 = DAT_10833e40 + 1;
  iVar2 = DAT_10833e40 + 1;
  DAT_10833e40 = iVar1;
  if (iVar2 <= DAT_100466bc) {
    do {
      (**(code **)*DAT_10833e1c)(DAT_10833e40);
      LOCK();
      iVar1 = DAT_10833e40 + 1;
      iVar2 = DAT_10833e40 + 1;
      DAT_10833e40 = iVar1;
    } while (iVar2 <= DAT_100466bc);
  }
  LOCK();
  LOCK();
  DAT_10833e24 = DAT_10833e24 + -1;
  DAT_10833e6c = DAT_10833e6c + -1;
  return 0;
}



void __cdecl FUN_10016e80(int param_1)

{
  code *pcVar1;
  char cVar2;
  bool bVar3;
  undefined *puVar4;
  int *piVar5;
  HANDLE pvVar6;
  int extraout_ECX;
  int iVar7;
  uint uVar8;
  ulonglong uVar9;
  undefined local_c [4];
  undefined local_8 [4];
  
  puVar4 = GetCPUInformation();
  DAT_100466c4 = (uint)(byte)puVar4[4];
  DAT_100466c0 = DAT_100466c4 * 2;
  DAT_10833e10 = (uint *)FUN_1001f8b3(-(uint)((int)((ulonglong)DAT_100466bc * 4 >> 0x20) != 0) |
                                      (uint)((ulonglong)DAT_100466bc * 4));
  iVar7 = DAT_100466c0;
  if (param_1 != 0) {
    do {
      param_1 = param_1 + -1;
      DAT_10833e08 = 2;
      if (1 < iVar7) {
        do {
          Msg((byte *)"\nTesting %d threads:\n");
          FUN_10016ce0();
          Msg((byte *)"%s test: single thread push/pop, interleaved... ");
          uVar9 = Plat_MSTime();
          FUN_100244fe((ulong)uVar9);
          DAT_10833e40 = 0;
          FUN_10021290(DAT_10833e10,0,DAT_100466bc << 2);
          FUN_10016be0(extraout_ECX);
          FUN_10017ad0('\x01');
          Msg((byte *)"%s test: sequential push, multithread pop, %s");
          DAT_10833e40 = 0;
          DAT_10833e24 = 0;
          DAT_10833e6c = 0;
          DAT_10833e68 = 0;
          DAT_10833e0c = 0;
          DAT_10833e44 = 0;
          DAT_10833e70 = 0;
          FUN_10021290(DAT_10833e10,0,DAT_100466bc << 2);
          LOCK();
          iVar7 = DAT_10833e40 + 1;
          bVar3 = DAT_10833e40 < (int)DAT_100466bc;
          DAT_10833e40 = iVar7;
          if (bVar3) {
            do {
              (**(code **)*DAT_10833e1c)(DAT_10833e40);
              LOCK();
              iVar7 = DAT_10833e40 + 1;
              bVar3 = DAT_10833e40 < (int)DAT_100466bc;
              DAT_10833e40 = iVar7;
            } while (bVar3);
          }
          piVar5 = FUN_10014820(FUN_10016880,DAT_10833e08,0);
          if (DAT_10833e24 < DAT_10833e08) {
            do {
              ThreadSleep(0);
            } while (DAT_10833e24 < DAT_10833e08);
          }
          DAT_10833e0c = 1;
          while (0 < DAT_10833e24) {
            ThreadSleep(0);
          }
          FUN_10017ad0('\x01');
          FUN_10014b20((int)piVar5);
          Msg((byte *)"%s test: single thread push, multithread pop, %s");
          DAT_10833e40 = 0;
          DAT_10833e24 = 0;
          DAT_10833e6c = 0;
          DAT_10833e68 = 0;
          DAT_10833e0c = 0;
          DAT_10833e44 = 0;
          DAT_10833e70 = 0;
          FUN_10021290(DAT_10833e10,0,DAT_100466bc << 2);
          pvVar6 = CreateSimpleThread(FUN_10016de0,0,0);
          piVar5 = FUN_10014820(FUN_10016880,DAT_10833e08 + -1,0);
          if (DAT_10833e24 < DAT_10833e08) {
            do {
              ThreadSleep(0);
            } while (DAT_10833e24 < DAT_10833e08);
          }
          DAT_10833e0c = 1;
          while (0 < DAT_10833e24) {
            ThreadSleep(0);
          }
          FUN_10017ad0('\x01');
          FUN_10014b20((int)piVar5);
          ThreadJoin(pvVar6,0xffffffff);
          ReleaseThreadHandle(pvVar6);
          Msg((byte *)"%s test: multithread push, sequential pop, %s");
          DAT_10833e40 = 0;
          DAT_10833e24 = 0;
          DAT_10833e6c = 0;
          DAT_10833e68 = 0;
          DAT_10833e0c = 0;
          DAT_10833e44 = 0;
          DAT_10833e70 = 0;
          FUN_10021290(DAT_10833e10,0,DAT_100466bc << 2);
          piVar5 = FUN_10014820(FUN_10016de0,DAT_10833e08,0);
          if (DAT_10833e24 < DAT_10833e08) {
            do {
              ThreadSleep(0);
            } while (DAT_10833e24 < DAT_10833e08);
          }
          DAT_10833e0c = 1;
          while (0 < DAT_10833e24) {
            ThreadSleep(0);
          }
          (**(code **)(*DAT_10833e1c + 8))();
          uVar8 = 0;
          cVar2 = (**(code **)(*DAT_10833e1c + 4))(local_8);
          while (cVar2 != '\0') {
            uVar8 = uVar8 + 1;
            cVar2 = (**(code **)(*DAT_10833e1c + 4))(local_8);
          }
          if (uVar8 != DAT_100466bc) {
            Msg((byte *)"Pops != pushes?\n");
            bVar3 = Plat_IsInDebugSession();
            if (bVar3) {
              pcVar1 = (code *)swi(3);
              (*pcVar1)();
              return;
            }
          }
          FUN_10017ad0('\x01');
          FUN_10014b20((int)piVar5);
          Msg((byte *)"%s test: multithread push, single thread pop, %s");
          DAT_10833e40 = 0;
          DAT_10833e24 = 0;
          DAT_10833e6c = 0;
          DAT_10833e68 = 0;
          DAT_10833e0c = 0;
          DAT_10833e44 = 0;
          DAT_10833e70 = 0;
          FUN_10021290(DAT_10833e10,0,DAT_100466bc << 2);
          pvVar6 = CreateSimpleThread(FUN_10016880,0,0);
          piVar5 = FUN_10014820(FUN_10016de0,DAT_10833e08 + -1,0);
          if (DAT_10833e24 < DAT_10833e08) {
            do {
              ThreadSleep(0);
            } while (DAT_10833e24 < DAT_10833e08);
          }
          DAT_10833e0c = 1;
          while (0 < DAT_10833e24) {
            ThreadSleep(0);
          }
          FUN_10017ad0('\x01');
          FUN_10014b20((int)piVar5);
          ThreadJoin(pvVar6,0xffffffff);
          ReleaseThreadHandle(pvVar6);
          FUN_10016450('\0');
          Msg((byte *)"%s test: multithread interleaved push/pop, %s");
          uVar9 = Plat_MSTime();
          FUN_100244fe((ulong)uVar9);
          DAT_10833e40 = 0;
          DAT_10833e24 = 0;
          DAT_10833e6c = 0;
          DAT_10833e68 = 0;
          DAT_10833e0c = 0;
          DAT_10833e44 = 0;
          DAT_10833e70 = 0;
          FUN_10021290(DAT_10833e10,0,DAT_100466bc << 2);
          piVar5 = FUN_10014820(FUN_10016c90,DAT_10833e08,0);
          if (DAT_10833e24 < DAT_10833e08) {
            do {
              ThreadSleep(0);
            } while (DAT_10833e24 < DAT_10833e08);
          }
          DAT_10833e0c = 1;
          while (0 < DAT_10833e24) {
            ThreadSleep(0);
          }
          FUN_10017ad0('\x01');
          FUN_10014b20((int)piVar5);
          if (1 < (int)DAT_100466c4) {
            Msg((byte *)"%s test: sequential push, multithread pop, %s");
            DAT_10833e40 = 0;
            DAT_10833e24 = 0;
            DAT_10833e6c = 0;
            DAT_10833e68 = 0;
            DAT_10833e0c = 0;
            DAT_10833e44 = 0;
            DAT_10833e70 = 0;
            FUN_10021290(DAT_10833e10,0,DAT_100466bc << 2);
            LOCK();
            iVar7 = DAT_10833e40 + 1;
            bVar3 = DAT_10833e40 < (int)DAT_100466bc;
            DAT_10833e40 = iVar7;
            if (bVar3) {
              do {
                (**(code **)*DAT_10833e1c)(DAT_10833e40);
                LOCK();
                iVar7 = DAT_10833e40 + 1;
                bVar3 = DAT_10833e40 < (int)DAT_100466bc;
                DAT_10833e40 = iVar7;
              } while (bVar3);
            }
            piVar5 = FUN_10014820(FUN_10016880,DAT_10833e08,DAT_100466c4);
            if (DAT_10833e24 < DAT_10833e08) {
              do {
                ThreadSleep(0);
              } while (DAT_10833e24 < DAT_10833e08);
            }
            DAT_10833e0c = 1;
            while (0 < DAT_10833e24) {
              ThreadSleep(0);
            }
            FUN_10017ad0('\x01');
            FUN_10014b20((int)piVar5);
            Msg((byte *)"%s test: single thread push, multithread pop, %s");
            DAT_10833e40 = 0;
            DAT_10833e24 = 0;
            DAT_10833e6c = 0;
            DAT_10833e68 = 0;
            DAT_10833e0c = 0;
            DAT_10833e44 = 0;
            DAT_10833e70 = 0;
            FUN_10021290(DAT_10833e10,0,DAT_100466bc << 2);
            pvVar6 = CreateSimpleThread(FUN_10016de0,0,0);
            piVar5 = FUN_10014820(FUN_10016880,DAT_10833e08 + -1,DAT_100466c4);
            if (DAT_10833e24 < DAT_10833e08) {
              do {
                ThreadSleep(0);
              } while (DAT_10833e24 < DAT_10833e08);
            }
            DAT_10833e0c = 1;
            while (0 < DAT_10833e24) {
              ThreadSleep(0);
            }
            FUN_10017ad0('\x01');
            FUN_10014b20((int)piVar5);
            ThreadJoin(pvVar6,0xffffffff);
            ReleaseThreadHandle(pvVar6);
            Msg((byte *)"%s test: multithread push, sequential pop, %s");
            DAT_10833e40 = 0;
            DAT_10833e24 = 0;
            DAT_10833e6c = 0;
            DAT_10833e68 = 0;
            DAT_10833e0c = 0;
            DAT_10833e44 = 0;
            DAT_10833e70 = 0;
            FUN_10021290(DAT_10833e10,0,DAT_100466bc << 2);
            piVar5 = FUN_10014820(FUN_10016de0,DAT_10833e08,DAT_100466c4);
            if (DAT_10833e24 < DAT_10833e08) {
              do {
                ThreadSleep(0);
              } while (DAT_10833e24 < DAT_10833e08);
            }
            DAT_10833e0c = 1;
            while (0 < DAT_10833e24) {
              ThreadSleep(0);
            }
            (**(code **)(*DAT_10833e1c + 8))();
            uVar8 = 0;
            cVar2 = (**(code **)(*DAT_10833e1c + 4))(local_c);
            while (cVar2 != '\0') {
              uVar8 = uVar8 + 1;
              cVar2 = (**(code **)(*DAT_10833e1c + 4))(local_c);
            }
            if (uVar8 != DAT_100466bc) {
              Msg((byte *)"Pops != pushes?\n");
              bVar3 = Plat_IsInDebugSession();
              if (bVar3) {
                pcVar1 = (code *)swi(3);
                (*pcVar1)();
                return;
              }
            }
            FUN_10017ad0('\x01');
            FUN_10014b20((int)piVar5);
            Msg((byte *)"%s test: multithread push, single thread pop, %s");
            DAT_10833e40 = 0;
            DAT_10833e24 = 0;
            DAT_10833e6c = 0;
            DAT_10833e68 = 0;
            DAT_10833e0c = 0;
            DAT_10833e44 = 0;
            DAT_10833e70 = 0;
            FUN_10021290(DAT_10833e10,0,DAT_100466bc << 2);
            pvVar6 = CreateSimpleThread(FUN_10016880,0,0);
            piVar5 = FUN_10014820(FUN_10016de0,DAT_10833e08 + -1,DAT_100466c4);
            if (DAT_10833e24 < DAT_10833e08) {
              do {
                ThreadSleep(0);
              } while (DAT_10833e24 < DAT_10833e08);
            }
            DAT_10833e0c = 1;
            while (0 < DAT_10833e24) {
              ThreadSleep(0);
            }
            FUN_10017ad0('\x01');
            FUN_10014b20((int)piVar5);
            ThreadJoin(pvVar6,0xffffffff);
            ReleaseThreadHandle(pvVar6);
            FUN_10016450('\x01');
            Msg((byte *)"%s test: multithread interleaved push/pop, %s");
            uVar9 = Plat_MSTime();
            FUN_100244fe((ulong)uVar9);
            DAT_10833e40 = 0;
            DAT_10833e24 = 0;
            DAT_10833e6c = 0;
            DAT_10833e68 = 0;
            DAT_10833e0c = 0;
            DAT_10833e44 = 0;
            DAT_10833e70 = 0;
            FUN_10021290(DAT_10833e10,0,DAT_100466bc << 2);
            piVar5 = FUN_10014820(FUN_10016c90,DAT_10833e08,DAT_100466c4);
            if (DAT_10833e24 < DAT_10833e08) {
              do {
                ThreadSleep(0);
              } while (DAT_10833e24 < DAT_10833e08);
            }
            DAT_10833e0c = 1;
            while (0 < DAT_10833e24) {
              ThreadSleep(0);
            }
            FUN_10017ad0('\x01');
            FUN_10014b20((int)piVar5);
          }
          DAT_10833e08 = DAT_10833e08 * 2;
          iVar7 = DAT_100466c0;
        } while (DAT_10833e08 <= DAT_100466c0);
      }
    } while (param_1 != 0);
  }
  FID_conflict__free(DAT_10833e10);
  return;
}



void __cdecl FUN_10017ad0(char param_1)

{
  code *pcVar1;
  bool bVar2;
  char cVar3;
  int iVar4;
  
  iVar4 = 0;
  if (0 < DAT_100466bc) {
    do {
      if (*(int *)(DAT_10833e10 + iVar4 * 4) != 0) {
        Msg((byte *)"Test bucket %d has an invalid value %d\n");
        bVar2 = Plat_IsInDebugSession();
        if (bVar2) {
          pcVar1 = (code *)swi(3);
          (*pcVar1)();
          return;
        }
        break;
      }
      iVar4 = iVar4 + 1;
    } while (iVar4 < DAT_100466bc);
  }
  if (DAT_10833e70 != DAT_10833e44) {
    Msg((byte *)"FAIL: Not all items popped\n");
    return;
  }
  cVar3 = (**(code **)(*DAT_10833e1c + 8))();
  if (cVar3 == '\0') {
    Msg((byte *)"FAIL: !Validate()\n");
    return;
  }
  if ((param_1 != '\0') && (cVar3 = (**(code **)(*DAT_10833e1c + 0xc))(), cVar3 == '\0')) {
    Msg((byte *)"FAIL: !IsEmpty()\n");
    return;
  }
  Msg((byte *)"pass\n");
  return;
}



void FUN_10017b80(void)

{
  DAT_10833e40 = 0;
  DAT_10833e24 = 0;
  DAT_10833e6c = 0;
  DAT_10833e68 = 0;
  DAT_10833e0c = 0;
  DAT_10833e44 = 0;
  DAT_10833e70 = 0;
  FUN_10021290(DAT_10833e10,0,DAT_100466bc << 2);
  return;
}



// public: bool __thiscall CThreadFullMutex::AssertOwnedByCurrentThread(void)

bool __thiscall CThreadFullMutex::AssertOwnedByCurrentThread(CThreadFullMutex *this)

{
                    // 0x17c00  72  ?AssertOwnedByCurrentThread@CThreadFullMutex@@QAE_NXZ
                    // 0x17c00  160  ?Init@CThread@@MAE_NXZ
                    // 0x17c00  387  Plat_FastVerifyHardwareKey
                    // 0x17c00  408  Plat_NoPerforce
                    // 0x17c00  418  Plat_VerifyHardwareKey
                    // 0x17c00  419  Plat_VerifyHardwareKeyDriver
                    // 0x17c00  420  Plat_VerifyHardwareKeyPrompt
  return true;
}



uint __cdecl RunTSListTests(int param_1,int param_2)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  uint uVar3;
  undefined4 uVar4;
  uint extraout_EDX;
  ulonglong uVar5;
  
                    // 0x17c10  439  RunTSListTests
  DAT_100466bc = param_1;
  if (0xffff < param_1) {
    uVar3 = Msg((byte *)"TSList cannot hold more that %d nodes\n");
    return uVar3 & 0xffffff00;
  }
  DAT_10833e1c = &PTR_vftable_100466cc;
  DAT_10833e18 = "CTSList";
  FUN_10016e80(param_2);
  Msg((byte *)"Tests done, purging test memory...");
  uVar5 = FUN_1000c560((longlong *)&DAT_10833e28,extraout_EDX);
  puVar2 = (undefined4 *)uVar5;
  while (puVar2 != (undefined4 *)0x0) {
    puVar1 = (undefined4 *)*puVar2;
    (**(code **)(*(int *)g_pMemAlloc + 0x14))(*(undefined4 *)(((uint)puVar2 & 0xfffffffc) - 4));
    puVar2 = puVar1;
  }
  uVar4 = Msg((byte *)"done\n");
  return CONCAT31((int3)((uint)uVar4 >> 8),1);
}



undefined4 __cdecl RunTSQueueTests(undefined4 param_1,int param_2)

{
  undefined4 uVar1;
  
                    // 0x17ca0  440  RunTSQueueTests
  DAT_100466bc = param_1;
  DAT_10833e1c = &PTR_vftable_100466c8;
  DAT_10833e18 = "CTSQueue";
  FUN_10016e80(param_2);
  Msg((byte *)"Tests done, purging test memory...");
  FUN_10016940((longlong *)&DAT_10833e48);
  uVar1 = Msg((byte *)"done\n");
  return CONCAT31((int3)((uint)uVar1 >> 8),1);
}



// public: __thiscall CTestCase::CTestCase(class CTestCase const &)

CTestCase * __thiscall CTestCase::CTestCase(CTestCase *this,CTestCase *param_1)

{
                    // 0x17cf0  8  ??0CTestCase@@QAE@ABV0@@Z
  *(undefined ***)this = _vftable_;
  *(undefined4 *)(this + 4) = *(undefined4 *)(param_1 + 4);
  return this;
}



// public: __thiscall CTestCase::CTestCase(char const *,class ITestSuite *)

CTestCase * __thiscall CTestCase::CTestCase(CTestCase *this,char *param_1,ITestSuite *param_2)

{
  char cVar1;
  char *pcVar2;
  
                    // 0x17d10  9  ??0CTestCase@@QAE@PBDPAVITestSuite@@@Z
  *(undefined ***)this = _vftable_;
  pcVar2 = param_1;
  do {
    cVar1 = *pcVar2;
    pcVar2 = pcVar2 + 1;
  } while (cVar1 != '\0');
  pcVar2 = (char *)FUN_1001f8b3((size_t)(pcVar2 + (1 - (int)(param_1 + 1))));
  *(char **)(this + 4) = pcVar2;
  do {
    cVar1 = *param_1;
    param_1 = param_1 + 1;
    *pcVar2 = cVar1;
    pcVar2 = pcVar2 + 1;
  } while (cVar1 != '\0');
  if (param_2 != (ITestSuite *)0x0) {
    (**(code **)(*(int *)param_2 + 8))();
    return this;
  }
  UnitTestInstallTestCase(this);
  return this;
}



// public: __thiscall CTestSuite::CTestSuite(class CTestSuite const &)

CTestSuite * __thiscall CTestSuite::CTestSuite(CTestSuite *this,CTestSuite *param_1)

{
                    // 0x17d80  10  ??0CTestSuite@@QAE@ABV0@@Z
  *(undefined ***)this = _vftable_;
  *(undefined4 *)(this + 4) = *(undefined4 *)(param_1 + 4);
  *(undefined4 *)(this + 8) = *(undefined4 *)(param_1 + 8);
  *(undefined4 *)(this + 0xc) = *(undefined4 *)(param_1 + 0xc);
  return this;
}



// public: __thiscall CTestSuite::CTestSuite(char const *,class ITestSuite *)

CTestSuite * __thiscall CTestSuite::CTestSuite(CTestSuite *this,char *param_1,ITestSuite *param_2)

{
  char cVar1;
  char *pcVar2;
  
                    // 0x17db0  11  ??0CTestSuite@@QAE@PBDPAVITestSuite@@@Z
  *(undefined ***)this = _vftable_;
  *(undefined4 *)(this + 4) = 0;
  *(undefined4 *)(this + 8) = 0;
  pcVar2 = param_1;
  do {
    cVar1 = *pcVar2;
    pcVar2 = pcVar2 + 1;
  } while (cVar1 != '\0');
  pcVar2 = (char *)FUN_1001f8b3((size_t)(pcVar2 + (1 - (int)(param_1 + 1))));
  *(char **)(this + 0xc) = pcVar2;
  do {
    cVar1 = *param_1;
    param_1 = param_1 + 1;
    *pcVar2 = cVar1;
    pcVar2 = pcVar2 + 1;
  } while (cVar1 != '\0');
  if (param_2 != (ITestSuite *)0x0) {
    (**(code **)(*(int *)param_2 + 8))();
    return this;
  }
  UnitTestInstallTestCase(this);
  return this;
}



// public: __thiscall CTestCase::~CTestCase(void)

void __thiscall CTestCase::_CTestCase(CTestCase *this)

{
                    // 0x17e30  30  ??1CTestCase@@QAE@XZ
  *(undefined ***)this = _vftable_;
  if (*(void **)(this + 4) != (void *)0x0) {
    FID_conflict__free(*(void **)(this + 4));
  }
  return;
}



// public: __thiscall CTestSuite::~CTestSuite(void)

void __thiscall CTestSuite::_CTestSuite(CTestSuite *this)

{
                    // 0x17e50  31  ??1CTestSuite@@QAE@XZ
  *(undefined ***)this = _vftable_;
  if (*(int *)(this + 8) != 0) {
    (**(code **)(*(int *)g_pMemAlloc + 0x14))(*(int *)(this + 8));
  }
  if (*(void **)(this + 0xc) != (void *)0x0) {
    FID_conflict__free(*(void **)(this + 0xc));
  }
  return;
}



// public: class CTestCase & __thiscall CTestCase::operator=(class CTestCase const &)

CTestCase * __thiscall CTestCase::operator_(CTestCase *this,CTestCase *param_1)

{
                    // 0x17e80  50  ??4CTestCase@@QAEAAV0@ABV0@@Z
  *(undefined4 *)(this + 4) = *(undefined4 *)(param_1 + 4);
  return this;
}



// public: virtual void __thiscall CTestSuite::AddTest(class ITestCase *)

void __thiscall CTestSuite::AddTest(CTestSuite *this,ITestCase *param_1)

{
  int iVar1;
  
                    // 0x17ea0  71  ?AddTest@CTestSuite@@UAEXPAVITestCase@@@Z
  if (*(int *)(this + 8) == 0) {
    iVar1 = (**(code **)(*(int *)g_pMemAlloc + 4))(4);
  }
  else {
    iVar1 = (**(code **)(*(int *)g_pMemAlloc + 0xc))
                      (*(undefined4 *)(this + 8),*(int *)(this + 4) * 4 + 4);
  }
  *(int *)(this + 8) = iVar1;
  *(ITestCase **)(iVar1 + *(int *)(this + 4) * 4) = param_1;
  *(int *)(this + 4) = *(int *)(this + 4) + 1;
  return;
}



// public: virtual char const * __thiscall CTestSuite::GetName(void)

char * __thiscall CTestSuite::GetName(CTestSuite *this)

{
                    // 0x17ef0  126  ?GetName@CTestSuite@@UAEPBDXZ
  return *(char **)(this + 0xc);
}



// public: virtual void __thiscall CTestSuite::RunTest(void)

void __thiscall CTestSuite::RunTest(CTestSuite *this)

{
  int iVar1;
  
                    // 0x17f00  212  ?RunTest@CTestSuite@@UAEXXZ
  iVar1 = 0;
  if (0 < *(int *)(this + 4)) {
    do {
      (**(code **)(**(int **)(*(int *)(this + 8) + iVar1 * 4) + 4))();
      iVar1 = iVar1 + 1;
    } while (iVar1 < *(int *)(this + 4));
  }
  return;
}



undefined4 __cdecl GetUnitTest(int param_1)

{
                    // 0x17f30  343  GetUnitTest
  return *(undefined4 *)(DAT_10833e84 + param_1 * 4);
}



undefined4 UnitTestCount(void)

{
                    // 0x17f40  474  UnitTestCount
  return DAT_10833e7c;
}



void __cdecl UnitTestInstallTestCase(undefined4 param_1)

{
                    // 0x17f50  475  UnitTestInstallTestCase
  if (DAT_10833e7c != DAT_10833e80) {
    *(undefined4 *)(DAT_10833e84 + DAT_10833e7c * 4) = param_1;
    DAT_10833e7c = DAT_10833e7c + 1;
    return;
  }
  if (DAT_10833e84 == 0) {
    DAT_10833e84 = (**(code **)(*(int *)g_pMemAlloc + 4))(0x40);
    DAT_10833e80 = 0x10;
    *(undefined4 *)(DAT_10833e84 + DAT_10833e7c * 4) = param_1;
    DAT_10833e7c = DAT_10833e7c + 1;
    return;
  }
  DAT_10833e84 = (**(code **)(*(int *)g_pMemAlloc + 0xc))(DAT_10833e84,DAT_10833e80 << 3);
  DAT_10833e80 = DAT_10833e80 * 2;
  *(undefined4 *)(DAT_10833e84 + DAT_10833e7c * 4) = param_1;
  DAT_10833e7c = DAT_10833e7c + 1;
  return;
}



undefined * __cdecl GetVAtom(uint param_1)

{
                    // 0x18000  344  GetVAtom
  if (0xf < param_1) {
    ConMsg("*******************************************************************\n                      ***  ERROR  ***                              \nVATOM index %d out of range, recompile tier0 with larger atom table\n*******************************************************************\n"
           ,param_1);
    return (undefined *)0x0;
  }
  return &DAT_10833e88 + param_1 * 4;
}



void __cdecl
FUN_10018030(int param_1,int param_2,int param_3,undefined4 *param_4,undefined *param_5)

{
  int iVar1;
  undefined4 *puVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  char cVar6;
  undefined4 *puVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  
  iVar10 = param_2 * 2;
  iVar1 = param_2;
  while (iVar9 = iVar10 + 2, iVar9 < param_3) {
    iVar8 = iVar9 * 0x20 + param_1;
    cVar6 = (*(code *)param_5)(iVar8,iVar8 + -0x20);
    if (cVar6 != '\0') {
      iVar9 = iVar10 + 1;
    }
    puVar7 = (undefined4 *)(iVar9 * 0x20 + param_1);
    uVar3 = puVar7[1];
    uVar4 = puVar7[2];
    uVar5 = puVar7[3];
    puVar2 = (undefined4 *)(iVar1 * 0x20 + param_1);
    *puVar2 = *puVar7;
    puVar2[1] = uVar3;
    puVar2[2] = uVar4;
    puVar2[3] = uVar5;
    puVar7 = (undefined4 *)(iVar9 * 0x20 + 0x10 + param_1);
    uVar3 = puVar7[1];
    uVar4 = puVar7[2];
    uVar5 = puVar7[3];
    puVar2 = (undefined4 *)(iVar1 * 0x20 + 0x10 + param_1);
    *puVar2 = *puVar7;
    puVar2[1] = uVar3;
    puVar2[2] = uVar4;
    puVar2[3] = uVar5;
    iVar1 = iVar9;
    iVar10 = iVar9 * 2;
  }
  if (iVar9 == param_3) {
    puVar2 = (undefined4 *)(param_3 * 0x20 + -0x20 + param_1);
    uVar3 = puVar2[1];
    uVar4 = puVar2[2];
    uVar5 = puVar2[3];
    puVar7 = (undefined4 *)(iVar1 * 0x20 + param_1);
    *puVar7 = *puVar2;
    puVar7[1] = uVar3;
    puVar7[2] = uVar4;
    puVar7[3] = uVar5;
    puVar7 = (undefined4 *)(param_3 * 0x20 + -0x10 + param_1);
    uVar3 = puVar7[1];
    uVar4 = puVar7[2];
    uVar5 = puVar7[3];
    puVar2 = (undefined4 *)(iVar1 * 0x20 + 0x10 + param_1);
    *puVar2 = *puVar7;
    puVar2[1] = uVar3;
    puVar2[2] = uVar4;
    puVar2[3] = uVar5;
    iVar1 = param_3 + -1;
  }
  while (param_2 < iVar1) {
    iVar10 = (iVar1 + -1) / 2;
    puVar7 = (undefined4 *)(iVar10 * 0x20 + param_1);
    cVar6 = (*(code *)param_5)(puVar7,param_4);
    if (cVar6 == '\0') break;
    uVar3 = puVar7[1];
    uVar4 = puVar7[2];
    uVar5 = puVar7[3];
    puVar2 = (undefined4 *)(iVar1 * 0x20 + param_1);
    *puVar2 = *puVar7;
    puVar2[1] = uVar3;
    puVar2[2] = uVar4;
    puVar2[3] = uVar5;
    uVar3 = puVar7[5];
    uVar4 = puVar7[6];
    uVar5 = puVar7[7];
    puVar2 = (undefined4 *)(iVar1 * 0x20 + 0x10 + param_1);
    *puVar2 = puVar7[4];
    puVar2[1] = uVar3;
    puVar2[2] = uVar4;
    puVar2[3] = uVar5;
    iVar1 = iVar10;
  }
  uVar3 = param_4[1];
  uVar4 = param_4[2];
  uVar5 = param_4[3];
  puVar7 = (undefined4 *)(iVar1 * 0x20 + param_1);
  *puVar7 = *param_4;
  puVar7[1] = uVar3;
  puVar7[2] = uVar4;
  puVar7[3] = uVar5;
  uVar3 = param_4[5];
  uVar4 = param_4[6];
  uVar5 = param_4[7];
  puVar7 = (undefined4 *)(iVar1 * 0x20 + 0x10 + param_1);
  *puVar7 = param_4[4];
  puVar7[1] = uVar3;
  puVar7[2] = uVar4;
  puVar7[3] = uVar5;
  return;
}



undefined4 * __thiscall FUN_10018130(void *this,undefined4 *param_1)

{
  undefined4 *puVar1;
  undefined4 *in_FS_OFFSET;
  undefined4 local_10;
  code *pcStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  pcStack12 = FUN_10034fc0;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_10;
  puVar1 = FUN_1001b2e0((undefined4 *)this);
  *(undefined2 *)(puVar1 + 3) = 0;
  if (puVar1 + 4 != (undefined4 *)0x0) {
    puVar1[4] = *param_1;
    *(undefined8 *)(puVar1 + 6) = *(undefined8 *)(param_1 + 2);
  }
  *in_FS_OFFSET = local_10;
  return puVar1;
}



void Catch_1001819c(void)

{
  code *pcVar1;
  int unaff_EBP;
  
  FID_conflict__free(*(void **)(unaff_EBP + -0x14));
  FUN_1002364d((int *)0x0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



undefined4 * __thiscall FUN_100181c0(void *this,undefined4 *param_1)

{
  undefined4 *puVar1;
  undefined4 *in_FS_OFFSET;
  undefined4 local_10;
  code *pcStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  pcStack12 = FUN_10034fd0;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_10;
  puVar1 = FUN_1001b370((undefined4 *)this);
  *(undefined2 *)(puVar1 + 3) = 0;
  if (puVar1 + 4 != (undefined4 *)0x0) {
    puVar1[4] = *param_1;
    puVar1[5] = param_1[1];
  }
  *in_FS_OFFSET = local_10;
  return puVar1;
}



void Catch_10018228(void)

{
  code *pcVar1;
  int unaff_EBP;
  
  FID_conflict__free(*(void **)(unaff_EBP + -0x14));
  FUN_1002364d((int *)0x0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void __cdecl FUN_10018240(undefined4 *param_1,undefined4 *param_2,undefined4 *param_3)

{
  undefined4 *puVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  
  if (param_1 != param_2) {
    do {
      uVar2 = param_1[1];
      uVar3 = param_1[2];
      uVar4 = param_1[3];
      *param_3 = *param_1;
      param_3[1] = uVar2;
      param_3[2] = uVar3;
      param_3[3] = uVar4;
      puVar1 = param_1 + 4;
      uVar2 = param_1[5];
      uVar3 = param_1[6];
      uVar4 = param_1[7];
      param_1 = param_1 + 8;
      param_3[4] = *puVar1;
      param_3[5] = uVar2;
      param_3[6] = uVar3;
      param_3[7] = uVar4;
      param_3 = param_3 + 8;
    } while (param_1 != param_2);
  }
  return;
}



void __thiscall
FUN_10018270(void *this,int **param_1,char param_2,int **param_3,undefined4 param_4,int *param_5)

{
  char cVar1;
  int **ppiVar2;
  int iVar3;
  code *pcVar4;
  int *piVar5;
  int *piVar6;
  int *piVar7;
  int **ppiVar8;
  
  if (0x7fffffd < *(uint *)((int)this + 4)) {
    FID_conflict__free(param_5);
    FUN_10034d68("map/set<T> too long");
    pcVar4 = (code *)swi(3);
    (*pcVar4)();
    return;
  }
  *(uint *)((int)this + 4) = *(uint *)((int)this + 4) + 1;
  param_5[1] = (int)param_3;
                    // WARNING: Load size is inaccurate
  if (param_3 == *this) {
    (*this)[1] = param_5;
                    // WARNING: Load size is inaccurate
    **this = param_5;
                    // WARNING: Load size is inaccurate
    *(int **)(*this + 8) = param_5;
  }
  else if (param_2 == '\0') {
    param_3[2] = param_5;
                    // WARNING: Load size is inaccurate
    if (param_3 == *(int ***)(*this + 8)) {
      *(int **)(*this + 8) = param_5;
    }
  }
  else {
    *param_3 = param_5;
                    // WARNING: Load size is inaccurate
    if (param_3 == (int **)**this) {
      **this = param_5;
    }
  }
  cVar1 = *(char *)(param_5[1] + 0xc);
  piVar5 = param_5;
  do {
    if (cVar1 != '\0') {
                    // WARNING: Load size is inaccurate
      *(undefined *)(*(int *)(*this + 4) + 0xc) = 1;
      *param_1 = param_5;
      return;
    }
    piVar7 = (int *)piVar5[1];
    piVar6 = *(int **)piVar7[1];
    if (piVar7 == piVar6) {
      piVar6 = ((int **)piVar7[1])[2];
      if (*(char *)(piVar6 + 3) != '\0') {
        if (piVar5 == (int *)piVar7[2]) {
          ppiVar8 = (int **)piVar7[2];
          piVar7[2] = (int)*ppiVar8;
          if (*(char *)((int)*ppiVar8 + 0xd) == '\0') {
            (*ppiVar8)[1] = (int)piVar7;
          }
          ppiVar8[1] = (int *)piVar7[1];
                    // WARNING: Load size is inaccurate
          if (piVar7 == *(int **)(*this + 4)) {
            *(int ***)(*this + 4) = ppiVar8;
          }
          else {
            ppiVar2 = (int **)piVar7[1];
            if (piVar7 == *ppiVar2) {
              *ppiVar2 = (int *)ppiVar8;
            }
            else {
              ppiVar2[2] = (int *)ppiVar8;
            }
          }
          *ppiVar8 = piVar7;
          piVar7[1] = (int)ppiVar8;
          piVar5 = piVar7;
        }
        *(undefined *)(piVar5[1] + 0xc) = 1;
        *(undefined *)(*(int *)(piVar5[1] + 4) + 0xc) = 0;
        piVar7 = *(int **)(piVar5[1] + 4);
        ppiVar8 = (int **)*piVar7;
        *piVar7 = (int)ppiVar8[2];
        if (*(char *)((int)ppiVar8[2] + 0xd) == '\0') {
          *(int **)((int)ppiVar8[2] + 4) = piVar7;
        }
        ppiVar8[1] = (int *)piVar7[1];
                    // WARNING: Load size is inaccurate
        if (piVar7 == *(int **)(*this + 4)) {
          *(int ***)(*this + 4) = ppiVar8;
          ppiVar8[2] = piVar7;
        }
        else {
          piVar6 = (int *)piVar7[1];
          if (piVar7 == (int *)piVar6[2]) {
            piVar6[2] = (int)ppiVar8;
            ppiVar8[2] = piVar7;
          }
          else {
            *piVar6 = (int)ppiVar8;
            ppiVar8[2] = piVar7;
          }
        }
        goto LAB_1001843f;
      }
LAB_10018396:
      *(undefined *)(piVar7 + 3) = 1;
      *(undefined *)(piVar6 + 3) = 1;
      *(undefined *)(*(int *)(piVar5[1] + 4) + 0xc) = 0;
      piVar5 = *(int **)(piVar5[1] + 4);
    }
    else {
      if (*(char *)(piVar6 + 3) == '\0') goto LAB_10018396;
      if (piVar5 == (int *)*piVar7) {
        iVar3 = *piVar7;
        *piVar7 = *(int *)(iVar3 + 8);
        if (*(char *)(*(int *)(iVar3 + 8) + 0xd) == '\0') {
          *(int **)(*(int *)(iVar3 + 8) + 4) = piVar7;
        }
        *(int *)(iVar3 + 4) = piVar7[1];
                    // WARNING: Load size is inaccurate
        if (piVar7 == *(int **)(*this + 4)) {
          *(int *)(*this + 4) = iVar3;
        }
        else {
          piVar5 = (int *)piVar7[1];
          if (piVar7 == (int *)piVar5[2]) {
            piVar5[2] = iVar3;
          }
          else {
            *piVar5 = iVar3;
          }
        }
        *(int **)(iVar3 + 8) = piVar7;
        piVar7[1] = iVar3;
        piVar5 = piVar7;
      }
      *(undefined *)(piVar5[1] + 0xc) = 1;
      *(undefined *)(*(int *)(piVar5[1] + 4) + 0xc) = 0;
      piVar7 = *(int **)(piVar5[1] + 4);
      ppiVar8 = (int **)piVar7[2];
      piVar7[2] = (int)*ppiVar8;
      if (*(char *)((int)*ppiVar8 + 0xd) == '\0') {
        (*ppiVar8)[1] = (int)piVar7;
      }
      ppiVar8[1] = (int *)piVar7[1];
                    // WARNING: Load size is inaccurate
      if (piVar7 == *(int **)(*this + 4)) {
        *(int ***)(*this + 4) = ppiVar8;
      }
      else {
        ppiVar2 = (int **)piVar7[1];
        if (piVar7 == *ppiVar2) {
          *ppiVar2 = (int *)ppiVar8;
        }
        else {
          ppiVar2[2] = (int *)ppiVar8;
        }
      }
      *ppiVar8 = piVar7;
LAB_1001843f:
      piVar7[1] = (int)ppiVar8;
    }
    cVar1 = *(char *)(piVar5[1] + 0xc);
  } while( true );
}



void __thiscall
FUN_10018480(void *this,int **param_1,char param_2,int **param_3,undefined4 param_4,int *param_5)

{
  char cVar1;
  int **ppiVar2;
  int iVar3;
  code *pcVar4;
  int *piVar5;
  int *piVar6;
  int *piVar7;
  int **ppiVar8;
  
  if (0xaaaaaa8 < *(uint *)((int)this + 4)) {
    FID_conflict__free(param_5);
    FUN_10034d68("map/set<T> too long");
    pcVar4 = (code *)swi(3);
    (*pcVar4)();
    return;
  }
  *(uint *)((int)this + 4) = *(uint *)((int)this + 4) + 1;
  param_5[1] = (int)param_3;
                    // WARNING: Load size is inaccurate
  if (param_3 == *this) {
    (*this)[1] = param_5;
                    // WARNING: Load size is inaccurate
    **this = param_5;
                    // WARNING: Load size is inaccurate
    *(int **)(*this + 8) = param_5;
  }
  else if (param_2 == '\0') {
    param_3[2] = param_5;
                    // WARNING: Load size is inaccurate
    if (param_3 == *(int ***)(*this + 8)) {
      *(int **)(*this + 8) = param_5;
    }
  }
  else {
    *param_3 = param_5;
                    // WARNING: Load size is inaccurate
    if (param_3 == (int **)**this) {
      **this = param_5;
    }
  }
  cVar1 = *(char *)(param_5[1] + 0xc);
  piVar5 = param_5;
  do {
    if (cVar1 != '\0') {
                    // WARNING: Load size is inaccurate
      *(undefined *)(*(int *)(*this + 4) + 0xc) = 1;
      *param_1 = param_5;
      return;
    }
    piVar7 = (int *)piVar5[1];
    piVar6 = *(int **)piVar7[1];
    if (piVar7 == piVar6) {
      piVar6 = ((int **)piVar7[1])[2];
      if (*(char *)(piVar6 + 3) != '\0') {
        if (piVar5 == (int *)piVar7[2]) {
          ppiVar8 = (int **)piVar7[2];
          piVar7[2] = (int)*ppiVar8;
          if (*(char *)((int)*ppiVar8 + 0xd) == '\0') {
            (*ppiVar8)[1] = (int)piVar7;
          }
          ppiVar8[1] = (int *)piVar7[1];
                    // WARNING: Load size is inaccurate
          if (piVar7 == *(int **)(*this + 4)) {
            *(int ***)(*this + 4) = ppiVar8;
          }
          else {
            ppiVar2 = (int **)piVar7[1];
            if (piVar7 == *ppiVar2) {
              *ppiVar2 = (int *)ppiVar8;
            }
            else {
              ppiVar2[2] = (int *)ppiVar8;
            }
          }
          *ppiVar8 = piVar7;
          piVar7[1] = (int)ppiVar8;
          piVar5 = piVar7;
        }
        *(undefined *)(piVar5[1] + 0xc) = 1;
        *(undefined *)(*(int *)(piVar5[1] + 4) + 0xc) = 0;
        piVar7 = *(int **)(piVar5[1] + 4);
        ppiVar8 = (int **)*piVar7;
        *piVar7 = (int)ppiVar8[2];
        if (*(char *)((int)ppiVar8[2] + 0xd) == '\0') {
          *(int **)((int)ppiVar8[2] + 4) = piVar7;
        }
        ppiVar8[1] = (int *)piVar7[1];
                    // WARNING: Load size is inaccurate
        if (piVar7 == *(int **)(*this + 4)) {
          *(int ***)(*this + 4) = ppiVar8;
          ppiVar8[2] = piVar7;
        }
        else {
          piVar6 = (int *)piVar7[1];
          if (piVar7 == (int *)piVar6[2]) {
            piVar6[2] = (int)ppiVar8;
            ppiVar8[2] = piVar7;
          }
          else {
            *piVar6 = (int)ppiVar8;
            ppiVar8[2] = piVar7;
          }
        }
        goto LAB_1001864f;
      }
LAB_100185a6:
      *(undefined *)(piVar7 + 3) = 1;
      *(undefined *)(piVar6 + 3) = 1;
      *(undefined *)(*(int *)(piVar5[1] + 4) + 0xc) = 0;
      piVar5 = *(int **)(piVar5[1] + 4);
    }
    else {
      if (*(char *)(piVar6 + 3) == '\0') goto LAB_100185a6;
      if (piVar5 == (int *)*piVar7) {
        iVar3 = *piVar7;
        *piVar7 = *(int *)(iVar3 + 8);
        if (*(char *)(*(int *)(iVar3 + 8) + 0xd) == '\0') {
          *(int **)(*(int *)(iVar3 + 8) + 4) = piVar7;
        }
        *(int *)(iVar3 + 4) = piVar7[1];
                    // WARNING: Load size is inaccurate
        if (piVar7 == *(int **)(*this + 4)) {
          *(int *)(*this + 4) = iVar3;
        }
        else {
          piVar5 = (int *)piVar7[1];
          if (piVar7 == (int *)piVar5[2]) {
            piVar5[2] = iVar3;
          }
          else {
            *piVar5 = iVar3;
          }
        }
        *(int **)(iVar3 + 8) = piVar7;
        piVar7[1] = iVar3;
        piVar5 = piVar7;
      }
      *(undefined *)(piVar5[1] + 0xc) = 1;
      *(undefined *)(*(int *)(piVar5[1] + 4) + 0xc) = 0;
      piVar7 = *(int **)(piVar5[1] + 4);
      ppiVar8 = (int **)piVar7[2];
      piVar7[2] = (int)*ppiVar8;
      if (*(char *)((int)*ppiVar8 + 0xd) == '\0') {
        (*ppiVar8)[1] = (int)piVar7;
      }
      ppiVar8[1] = (int *)piVar7[1];
                    // WARNING: Load size is inaccurate
      if (piVar7 == *(int **)(*this + 4)) {
        *(int ***)(*this + 4) = ppiVar8;
      }
      else {
        ppiVar2 = (int **)piVar7[1];
        if (piVar7 == *ppiVar2) {
          *ppiVar2 = (int *)ppiVar8;
        }
        else {
          ppiVar2[2] = (int *)ppiVar8;
        }
      }
      *ppiVar8 = piVar7;
LAB_1001864f:
      piVar7[1] = (int)ppiVar8;
    }
    cVar1 = *(char *)(piVar5[1] + 0xc);
  } while( true );
}



void __thiscall FUN_10018690(void *this,undefined4 *param_1,char param_2,int **param_3,int *param_4)

{
  int **ppiVar1;
  undefined4 *puVar2;
  int **ppiVar3;
  int **ppiVar4;
  undefined4 *in_FS_OFFSET;
  bool local_18;
  undefined4 local_10;
  code *pcStack12;
  undefined4 local_8;
  
  ppiVar1 = param_3;
  pcStack12 = FUN_10034fe0;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_10;
  local_8 = 0;
                    // WARNING: Load size is inaccurate
  local_18 = true;
  ppiVar3 = (int **)(*this)[1];
  ppiVar4 = *this;
  while (*(char *)((int)ppiVar3 + 0xd) == '\0') {
    if (param_2 == '\0') {
      local_18 = *param_3 < ppiVar3[4];
    }
    else {
      local_18 = *param_3 <= ppiVar3[4];
    }
    ppiVar4 = ppiVar3;
    if (local_18 == false) {
      ppiVar3 = (int **)ppiVar3[2];
    }
    else {
      ppiVar3 = (int **)*ppiVar3;
    }
  }
  _param_2 = ppiVar4;
  if (local_18 != false) {
                    // WARNING: Load size is inaccurate
    if (ppiVar4 == (int **)**this) {
      local_18 = true;
      goto LAB_10018717;
    }
    FUN_10019970((int **)&param_2);
  }
  ppiVar3 = _param_2;
  if (*ppiVar1 <= _param_2[4]) {
    FID_conflict__free(param_4);
    *param_1 = ppiVar3;
    *(undefined *)(param_1 + 1) = 0;
    *in_FS_OFFSET = local_10;
    return;
  }
LAB_10018717:
  puVar2 = (undefined4 *)FUN_10018270(this,(int **)&param_2,local_18,ppiVar4,ppiVar1,param_4);
  *param_1 = *puVar2;
  *(undefined *)(param_1 + 1) = 1;
  *in_FS_OFFSET = local_10;
  return;
}



void Catch_10018781(void)

{
  code *pcVar1;
  int unaff_EBP;
  
  FID_conflict__free(*(void **)(unaff_EBP + 0x14));
  FUN_1002364d((int *)0x0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void __thiscall FUN_100187a0(void *this,undefined4 *param_1,char param_2,int **param_3,int *param_4)

{
  int **ppiVar1;
  undefined4 *puVar2;
  int **ppiVar3;
  int **ppiVar4;
  undefined4 *in_FS_OFFSET;
  bool local_18;
  undefined4 local_10;
  code *pcStack12;
  undefined4 local_8;
  
  ppiVar1 = param_3;
  pcStack12 = FUN_10034ff0;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_10;
  local_8 = 0;
                    // WARNING: Load size is inaccurate
  local_18 = true;
  ppiVar3 = (int **)(*this)[1];
  ppiVar4 = *this;
  while (*(char *)((int)ppiVar3 + 0xd) == '\0') {
    if (param_2 == '\0') {
      local_18 = *param_3 < ppiVar3[4];
    }
    else {
      local_18 = *param_3 <= ppiVar3[4];
    }
    ppiVar4 = ppiVar3;
    if (local_18 == false) {
      ppiVar3 = (int **)ppiVar3[2];
    }
    else {
      ppiVar3 = (int **)*ppiVar3;
    }
  }
  _param_2 = ppiVar4;
  if (local_18 != false) {
                    // WARNING: Load size is inaccurate
    if (ppiVar4 == (int **)**this) {
      local_18 = true;
      goto LAB_10018827;
    }
    FUN_10019970((int **)&param_2);
  }
  ppiVar3 = _param_2;
  if (*ppiVar1 <= _param_2[4]) {
    FID_conflict__free(param_4);
    *param_1 = ppiVar3;
    *(undefined *)(param_1 + 1) = 0;
    *in_FS_OFFSET = local_10;
    return;
  }
LAB_10018827:
  puVar2 = (undefined4 *)FUN_10018480(this,(int **)&param_2,local_18,ppiVar4,ppiVar1,param_4);
  *param_1 = *puVar2;
  *(undefined *)(param_1 + 1) = 1;
  *in_FS_OFFSET = local_10;
  return;
}



void Catch_10018891(void)

{
  code *pcVar1;
  int unaff_EBP;
  
  FID_conflict__free(*(void **)(unaff_EBP + 0x14));
  FUN_1002364d((int *)0x0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void __cdecl FUN_100188b0(undefined4 *param_1,undefined4 *param_2,undefined *param_3)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  char cVar6;
  undefined4 *puVar7;
  undefined4 local_28;
  undefined4 uStack36;
  undefined4 uStack32;
  undefined4 uStack28;
  undefined4 local_18;
  undefined4 uStack20;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 *local_8;
  
  if ((param_1 != param_2) && (puVar7 = param_1 + 8, puVar7 != param_2)) {
    local_8 = param_1;
    do {
      local_28 = *puVar7;
      uStack36 = puVar7[1];
      uStack32 = puVar7[2];
      uStack28 = puVar7[3];
      local_18 = puVar7[4];
      uStack20 = puVar7[5];
      uStack16 = puVar7[6];
      uStack12 = puVar7[7];
      cVar6 = (*(code *)param_3)(&local_28,param_1);
      puVar5 = local_8;
      puVar4 = puVar7;
      if (cVar6 == '\0') {
        cVar6 = (*(code *)param_3)(&local_28,local_8);
        while (cVar6 != '\0') {
          uVar1 = puVar5[1];
          uVar2 = puVar5[2];
          uVar3 = puVar5[3];
          *puVar4 = *puVar5;
          puVar4[1] = uVar1;
          puVar4[2] = uVar2;
          puVar4[3] = uVar3;
          uVar1 = puVar5[5];
          uVar2 = puVar5[6];
          uVar3 = puVar5[7];
          puVar4[4] = puVar5[4];
          puVar4[5] = uVar1;
          puVar4[6] = uVar2;
          puVar4[7] = uVar3;
          cVar6 = (*(code *)param_3)(&local_28,puVar5 + -8);
          puVar4 = puVar5;
          puVar5 = puVar5 + -8;
        }
        *puVar4 = local_28;
        puVar4[1] = uStack36;
        puVar4[2] = uStack32;
        puVar4[3] = uStack28;
        puVar4[4] = local_18;
        puVar4[5] = uStack20;
        puVar4[6] = uStack16;
        puVar4[7] = uStack12;
      }
      else {
        for (; param_1 != puVar4; puVar4 = puVar4 + -8) {
          *puVar4 = puVar4[-8];
          puVar4[1] = puVar4[-7];
          puVar4[2] = puVar4[-6];
          puVar4[3] = puVar4[-5];
          puVar4[4] = puVar4[-4];
          puVar4[5] = puVar4[-3];
          puVar4[6] = puVar4[-2];
          puVar4[7] = puVar4[-1];
        }
        *param_1 = local_28;
        param_1[1] = uStack36;
        param_1[2] = uStack32;
        param_1[3] = uStack28;
        param_1[4] = local_18;
        param_1[5] = uStack20;
        param_1[6] = uStack16;
        param_1[7] = uStack12;
      }
      local_8 = local_8 + 8;
      puVar7 = puVar7 + 8;
    } while (puVar7 != param_2);
  }
  return;
}



void __cdecl FUN_100189b0(int param_1,int param_2,undefined *param_3)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  char cVar6;
  int iVar7;
  int iVar8;
  int iVar9;
  int iVar10;
  int iVar11;
  undefined4 local_2c;
  undefined4 uStack40;
  undefined4 uStack36;
  undefined4 uStack32;
  undefined4 local_1c;
  undefined4 uStack24;
  undefined4 uStack20;
  undefined4 uStack16;
  int local_c;
  int local_8;
  
  iVar7 = param_2 - param_1 >> 5;
  iVar9 = iVar7 - (param_2 - param_1 >> 0x1f) >> 1;
  if (0 < iVar9) {
    local_8 = iVar9 * 2 + 2;
    local_c = iVar9 * 0x20 + param_1;
    do {
      local_2c = *(undefined4 *)(local_c + -0x20);
      uStack40 = *(undefined4 *)(local_c + -0x1c);
      uStack36 = *(undefined4 *)(local_c + -0x18);
      uStack32 = *(undefined4 *)(local_c + -0x14);
      iVar9 = iVar9 + -1;
      local_1c = *(undefined4 *)(local_c + -0x10);
      uStack24 = *(undefined4 *)(local_c + -0xc);
      uStack20 = *(undefined4 *)(local_c + -8);
      uStack16 = *(undefined4 *)(local_c + -4);
      local_8 = local_8 + -2;
      local_c = local_c + -0x20;
      iVar8 = local_8;
      iVar11 = iVar9;
      while (iVar10 = iVar8, iVar10 < iVar7) {
        iVar8 = iVar10 * 0x20 + param_1;
        cVar6 = (*(code *)param_3)(iVar8,iVar8 + -0x20);
        if (cVar6 != '\0') {
          iVar10 = iVar10 + -1;
        }
        puVar1 = (undefined4 *)(iVar10 * 0x20 + param_1);
        uVar3 = puVar1[1];
        uVar4 = puVar1[2];
        uVar5 = puVar1[3];
        puVar2 = (undefined4 *)(iVar11 * 0x20 + param_1);
        *puVar2 = *puVar1;
        puVar2[1] = uVar3;
        puVar2[2] = uVar4;
        puVar2[3] = uVar5;
        puVar1 = (undefined4 *)(iVar10 * 0x20 + 0x10 + param_1);
        uVar3 = puVar1[1];
        uVar4 = puVar1[2];
        uVar5 = puVar1[3];
        puVar2 = (undefined4 *)(iVar11 * 0x20 + 0x10 + param_1);
        *puVar2 = *puVar1;
        puVar2[1] = uVar3;
        puVar2[2] = uVar4;
        puVar2[3] = uVar5;
        iVar11 = iVar10;
        iVar8 = iVar10 * 2 + 2;
      }
      if (iVar10 == iVar7) {
        puVar2 = (undefined4 *)(iVar7 * 0x20 + -0x20 + param_1);
        uVar3 = puVar2[1];
        uVar4 = puVar2[2];
        uVar5 = puVar2[3];
        puVar1 = (undefined4 *)(iVar11 * 0x20 + param_1);
        *puVar1 = *puVar2;
        puVar1[1] = uVar3;
        puVar1[2] = uVar4;
        puVar1[3] = uVar5;
        puVar1 = (undefined4 *)(iVar7 * 0x20 + -0x10 + param_1);
        uVar3 = puVar1[1];
        uVar4 = puVar1[2];
        uVar5 = puVar1[3];
        puVar2 = (undefined4 *)(iVar11 * 0x20 + 0x10 + param_1);
        *puVar2 = *puVar1;
        puVar2[1] = uVar3;
        puVar2[2] = uVar4;
        puVar2[3] = uVar5;
        iVar11 = iVar7 + -1;
      }
      FUN_10018c10(param_1,iVar11,iVar9,&local_2c,param_3);
    } while (0 < iVar9);
  }
  return;
}



void __cdecl
FUN_10018ac0(undefined4 *param_1,undefined4 *param_2,undefined4 *param_3,undefined *param_4)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  char cVar12;
  
  cVar12 = (*(code *)param_4)(param_2,param_1);
  if (cVar12 != '\0') {
    uVar1 = param_1[1];
    uVar2 = param_1[2];
    uVar3 = param_1[3];
    uVar4 = *param_2;
    uVar5 = param_2[1];
    uVar6 = param_2[2];
    uVar7 = param_2[3];
    uVar8 = param_2[4];
    uVar9 = param_2[5];
    uVar10 = param_2[6];
    uVar11 = param_2[7];
    *param_2 = *param_1;
    param_2[1] = uVar1;
    param_2[2] = uVar2;
    param_2[3] = uVar3;
    uVar1 = param_1[5];
    uVar2 = param_1[6];
    uVar3 = param_1[7];
    param_2[4] = param_1[4];
    param_2[5] = uVar1;
    param_2[6] = uVar2;
    param_2[7] = uVar3;
    *param_1 = uVar4;
    param_1[1] = uVar5;
    param_1[2] = uVar6;
    param_1[3] = uVar7;
    param_1[4] = uVar8;
    param_1[5] = uVar9;
    param_1[6] = uVar10;
    param_1[7] = uVar11;
  }
  cVar12 = (*(code *)param_4)(param_3,param_2);
  if (cVar12 != '\0') {
    uVar1 = param_2[1];
    uVar2 = param_2[2];
    uVar3 = param_2[3];
    uVar4 = *param_3;
    uVar5 = param_3[1];
    uVar6 = param_3[2];
    uVar7 = param_3[3];
    uVar8 = param_3[4];
    uVar9 = param_3[5];
    uVar10 = param_3[6];
    uVar11 = param_3[7];
    *param_3 = *param_2;
    param_3[1] = uVar1;
    param_3[2] = uVar2;
    param_3[3] = uVar3;
    uVar1 = param_2[5];
    uVar2 = param_2[6];
    uVar3 = param_2[7];
    param_3[4] = param_2[4];
    param_3[5] = uVar1;
    param_3[6] = uVar2;
    param_3[7] = uVar3;
    *param_2 = uVar4;
    param_2[1] = uVar5;
    param_2[2] = uVar6;
    param_2[3] = uVar7;
    param_2[4] = uVar8;
    param_2[5] = uVar9;
    param_2[6] = uVar10;
    param_2[7] = uVar11;
    cVar12 = (*(code *)param_4)(param_2,param_1);
    if (cVar12 != '\0') {
      uVar1 = param_1[1];
      uVar2 = param_1[2];
      uVar3 = param_1[3];
      uVar4 = *param_2;
      uVar5 = param_2[1];
      uVar6 = param_2[2];
      uVar7 = param_2[3];
      uVar8 = param_2[4];
      uVar9 = param_2[5];
      uVar10 = param_2[6];
      uVar11 = param_2[7];
      *param_2 = *param_1;
      param_2[1] = uVar1;
      param_2[2] = uVar2;
      param_2[3] = uVar3;
      uVar1 = param_1[5];
      uVar2 = param_1[6];
      uVar3 = param_1[7];
      param_2[4] = param_1[4];
      param_2[5] = uVar1;
      param_2[6] = uVar2;
      param_2[7] = uVar3;
      *param_1 = uVar4;
      param_1[1] = uVar5;
      param_1[2] = uVar6;
      param_1[3] = uVar7;
      param_1[4] = uVar8;
      param_1[5] = uVar9;
      param_1[6] = uVar10;
      param_1[7] = uVar11;
    }
  }
  return;
}



void __cdecl
FUN_10018b70(undefined4 *param_1,undefined4 *param_2,undefined4 *param_3,undefined *param_4)

{
  int iVar1;
  
  iVar1 = (int)param_3 - (int)param_1 >> 5;
  if (0x28 < iVar1) {
    iVar1 = iVar1 + 1;
    iVar1 = (int)((iVar1 >> 0x1f & 7U) + iVar1) >> 3;
    FUN_10018ac0(param_1,param_1 + iVar1 * 8,param_1 + iVar1 * 0x10,param_4);
    FUN_10018ac0(param_2 + iVar1 * -8,param_2,param_2 + iVar1 * 8,param_4);
    FUN_10018ac0(param_3 + iVar1 * -0x10,param_3 + iVar1 * -8,param_3,param_4);
    FUN_10018ac0(param_1 + iVar1 * 8,param_2,param_3 + iVar1 * -8,param_4);
    return;
  }
  FUN_10018ac0(param_1,param_2,param_3,param_4);
  return;
}



void __cdecl
FUN_10018c10(int param_1,int param_2,int param_3,undefined4 *param_4,undefined *param_5)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  char cVar4;
  undefined4 *puVar5;
  undefined4 *puVar6;
  int iVar7;
  
  if (param_3 < param_2) {
    do {
      iVar7 = (param_2 + -1) / 2;
      puVar5 = (undefined4 *)(iVar7 * 0x20 + param_1);
      cVar4 = (*(code *)param_5)(puVar5,param_4);
      if (cVar4 == '\0') break;
      uVar1 = puVar5[1];
      uVar2 = puVar5[2];
      uVar3 = puVar5[3];
      puVar6 = (undefined4 *)(param_2 * 0x20 + param_1);
      *puVar6 = *puVar5;
      puVar6[1] = uVar1;
      puVar6[2] = uVar2;
      puVar6[3] = uVar3;
      uVar1 = puVar5[5];
      uVar2 = puVar5[6];
      uVar3 = puVar5[7];
      puVar6[4] = puVar5[4];
      puVar6[5] = uVar1;
      puVar6[6] = uVar2;
      puVar6[7] = uVar3;
      param_2 = iVar7;
    } while (param_3 < iVar7);
  }
  puVar5 = (undefined4 *)(param_2 * 0x20 + param_1);
  uVar1 = param_4[1];
  uVar2 = param_4[2];
  uVar3 = param_4[3];
  *puVar5 = *param_4;
  puVar5[1] = uVar1;
  puVar5[2] = uVar2;
  puVar5[3] = uVar3;
  uVar1 = param_4[5];
  uVar2 = param_4[6];
  uVar3 = param_4[7];
  puVar5[4] = param_4[4];
  puVar5[5] = uVar1;
  puVar5[6] = uVar2;
  puVar5[7] = uVar3;
  return;
}



void __cdecl FUN_10018c90(undefined4 *param_1,undefined4 *param_2,int param_3,undefined *param_4)

{
  int iVar1;
  undefined4 *local_c;
  undefined4 *local_8;
  
  iVar1 = (int)param_2 - (int)param_1;
  do {
    iVar1 = iVar1 >> 5;
    if (iVar1 < 0x21) {
LAB_10018d20:
      if (1 < iVar1) {
        FUN_100188b0(param_1,param_2,param_4);
      }
      return;
    }
    if (param_3 < 1) {
      if (0x20 < iVar1) {
        if (0x20 < (int)((int)param_2 - (int)param_1 & 0xffffffe0U)) {
          FUN_100189b0((int)param_1,(int)param_2,param_4);
        }
        FUN_10018d70(param_1,(int)param_2,param_4);
        return;
      }
      goto LAB_10018d20;
    }
    FUN_10018e50(&local_c,param_1,param_2,param_4);
    param_3 = param_3 / 2 + (param_3 / 2) / 2;
    if ((int)((int)local_c - (int)param_1 & 0xffffffe0U) <
        (int)((int)param_2 - (int)local_8 & 0xffffffe0U)) {
      FUN_10018c90(param_1,local_c,param_3,param_4);
      param_1 = local_8;
    }
    else {
      FUN_10018c90(local_8,param_2,param_3,param_4);
      param_2 = local_c;
    }
    iVar1 = (int)param_2 - (int)param_1;
  } while( true );
}



void __cdecl FUN_10018d70(undefined4 *param_1,int param_2,undefined *param_3)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  uint uVar4;
  undefined4 *puVar5;
  undefined4 local_24;
  undefined4 uStack32;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 local_14;
  undefined4 uStack16;
  undefined4 uStack12;
  undefined4 uStack8;
  
  uVar4 = param_2 - (int)param_1;
  if (0x20 < (int)(uVar4 & 0xffffffe0)) {
    puVar5 = (undefined4 *)(param_2 + -0x20);
    do {
      local_24 = *puVar5;
      uStack32 = puVar5[1];
      uStack28 = puVar5[2];
      uStack24 = puVar5[3];
      local_14 = puVar5[4];
      uStack16 = puVar5[5];
      uStack12 = puVar5[6];
      uStack8 = puVar5[7];
      uVar1 = param_1[1];
      uVar2 = param_1[2];
      uVar3 = param_1[3];
      *puVar5 = *param_1;
      puVar5[1] = uVar1;
      puVar5[2] = uVar2;
      puVar5[3] = uVar3;
      uVar1 = param_1[5];
      uVar2 = param_1[6];
      uVar3 = param_1[7];
      puVar5[4] = param_1[4];
      puVar5[5] = uVar1;
      puVar5[6] = uVar2;
      puVar5[7] = uVar3;
      FUN_10018030((int)param_1,0,(int)(uVar4 - 0x20) >> 5,&local_24,param_3);
      puVar5 = puVar5 + -8;
      uVar4 = (int)puVar5 + (0x20 - (int)param_1);
    } while (0x20 < (int)(uVar4 & 0xffffffe0));
  }
  return;
}



void FUN_10018df0(undefined4 *param_1,undefined4 *param_2,undefined4 *param_3)

{
  FUN_100190f0(param_1,param_2,param_3);
  return;
}



void FUN_10018e20(undefined4 *param_1,undefined4 *param_2,undefined4 *param_3)

{
  FUN_100190f0(param_1,param_2,param_3);
  return;
}



void __cdecl
FUN_10018e50(undefined4 *param_1,undefined4 *param_2,undefined4 *param_3,undefined *param_4)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  char cVar12;
  undefined4 *puVar13;
  undefined4 *puVar14;
  undefined4 *puVar15;
  undefined4 *puVar16;
  undefined4 *puVar17;
  undefined4 *puVar18;
  undefined4 *local_10;
  undefined4 *local_c;
  undefined4 *local_8;
  
  puVar14 = param_2 + (((int)param_3 - (int)param_2 >> 5) - ((int)param_3 - (int)param_2 >> 0x1f) >>
                      1) * 8;
  FUN_10018b70(param_2,puVar14,param_3 + -8,param_4);
  puVar17 = puVar14;
  while (puVar16 = puVar17, param_2 < puVar16) {
    puVar17 = puVar16 + -8;
    cVar12 = (*(code *)param_4)(puVar17,puVar16);
    if ((cVar12 != '\0') || (cVar12 = (*(code *)param_4)(puVar16,puVar17), cVar12 != '\0')) break;
  }
  do {
    puVar14 = puVar14 + 8;
    puVar17 = puVar14;
    local_10 = puVar14;
    local_c = puVar14;
    local_8 = puVar16;
    if (param_3 <= puVar14) break;
    cVar12 = (*(code *)param_4)(puVar14,puVar16);
    if ((cVar12 != '\0') || (cVar12 = (*(code *)param_4)(puVar16,puVar14), cVar12 != '\0')) break;
  } while( true );
LAB_10018ef2:
  puVar13 = local_8;
  puVar18 = local_10;
  if (puVar17 < param_3) {
    local_10 = puVar14 + -8;
    local_c = puVar14;
    do {
      cVar12 = (*(code *)param_4)(puVar16,puVar17);
      puVar14 = local_c;
      puVar18 = local_10;
      if (cVar12 == '\0') {
        cVar12 = (*(code *)param_4)(puVar17,puVar16);
        puVar18 = puVar17;
        if (cVar12 != '\0') break;
        puVar18 = local_10 + 8;
        puVar14 = local_c + 8;
        if (local_c != puVar17) {
          uVar1 = puVar17[1];
          uVar2 = puVar17[2];
          uVar3 = puVar17[3];
          uVar4 = *puVar18;
          uVar5 = local_10[9];
          uVar6 = local_10[10];
          uVar7 = local_10[0xb];
          uVar8 = local_10[0xc];
          uVar9 = local_10[0xd];
          uVar10 = local_10[0xe];
          uVar11 = local_10[0xf];
          *puVar18 = *puVar17;
          local_10[9] = uVar1;
          local_10[10] = uVar2;
          local_10[0xb] = uVar3;
          uVar1 = puVar17[5];
          uVar2 = puVar17[6];
          uVar3 = puVar17[7];
          local_10[0xc] = puVar17[4];
          local_10[0xd] = uVar1;
          local_10[0xe] = uVar2;
          local_10[0xf] = uVar3;
          *puVar17 = uVar4;
          puVar17[1] = uVar5;
          puVar17[2] = uVar6;
          puVar17[3] = uVar7;
          puVar17[4] = uVar8;
          puVar17[5] = uVar9;
          puVar17[6] = uVar10;
          puVar17[7] = uVar11;
        }
      }
      local_10 = puVar18;
      puVar17 = puVar17 + 8;
      local_c = puVar14;
      puVar18 = puVar17;
    } while (puVar17 < param_3);
  }
  do {
    local_10 = puVar18;
    puVar18 = puVar17;
    if (local_8 <= param_2) break;
    puVar15 = puVar13 + -8;
    cVar12 = (*(code *)param_4)(puVar15,puVar16);
    puVar17 = puVar16;
    puVar14 = local_c;
    if (cVar12 == '\0') {
      cVar12 = (*(code *)param_4)(puVar16,puVar15);
      puVar18 = local_10;
      if (cVar12 != '\0') break;
      puVar17 = puVar16 + -8;
      if (puVar17 != puVar15) {
        uVar1 = puVar13[-7];
        uVar2 = puVar13[-6];
        uVar3 = puVar13[-5];
        uVar4 = *puVar17;
        uVar5 = puVar16[-7];
        uVar6 = puVar16[-6];
        uVar7 = puVar16[-5];
        uVar8 = puVar16[-4];
        uVar9 = puVar16[-3];
        uVar10 = puVar16[-2];
        uVar11 = puVar16[-1];
        *puVar17 = *puVar15;
        puVar16[-7] = uVar1;
        puVar16[-6] = uVar2;
        puVar16[-5] = uVar3;
        uVar1 = puVar13[-3];
        uVar2 = puVar13[-2];
        uVar3 = puVar13[-1];
        puVar16[-4] = puVar13[-4];
        puVar16[-3] = uVar1;
        puVar16[-2] = uVar2;
        puVar16[-1] = uVar3;
        *puVar15 = uVar4;
        puVar13[-7] = uVar5;
        puVar13[-6] = uVar6;
        puVar13[-5] = uVar7;
        puVar13[-4] = uVar8;
        puVar13[-3] = uVar9;
        puVar13[-2] = uVar10;
        puVar13[-1] = uVar11;
      }
    }
    local_8 = local_8 + -8;
    puVar16 = puVar17;
    puVar17 = local_10;
    puVar13 = puVar15;
    puVar18 = local_10;
  } while( true );
  if (local_8 == param_2) {
    if (puVar18 == param_3) {
      *param_1 = puVar16;
      param_1[1] = puVar14;
      return;
    }
    if (puVar14 != puVar18) {
      uVar1 = puVar14[1];
      uVar2 = puVar14[2];
      uVar3 = puVar14[3];
      uVar4 = *puVar16;
      uVar5 = puVar16[1];
      uVar6 = puVar16[2];
      uVar7 = puVar16[3];
      uVar8 = puVar16[4];
      uVar9 = puVar16[5];
      uVar10 = puVar16[6];
      uVar11 = puVar16[7];
      *puVar16 = *puVar14;
      puVar16[1] = uVar1;
      puVar16[2] = uVar2;
      puVar16[3] = uVar3;
      uVar1 = puVar14[5];
      uVar2 = puVar14[6];
      uVar3 = puVar14[7];
      puVar16[4] = puVar14[4];
      puVar16[5] = uVar1;
      puVar16[6] = uVar2;
      puVar16[7] = uVar3;
      *puVar14 = uVar4;
      puVar14[1] = uVar5;
      puVar14[2] = uVar6;
      puVar14[3] = uVar7;
      puVar14[4] = uVar8;
      puVar14[5] = uVar9;
      puVar14[6] = uVar10;
      puVar14[7] = uVar11;
    }
    puVar14 = puVar14 + 8;
    uVar1 = puVar18[1];
    uVar2 = puVar18[2];
    uVar3 = puVar18[3];
    uVar4 = *puVar16;
    uVar5 = puVar16[1];
    uVar6 = puVar16[2];
    uVar7 = puVar16[3];
    uVar8 = puVar16[4];
    uVar9 = puVar16[5];
    uVar10 = puVar16[6];
    uVar11 = puVar16[7];
    *puVar16 = *puVar18;
    puVar16[1] = uVar1;
    puVar16[2] = uVar2;
    puVar16[3] = uVar3;
    uVar1 = puVar18[5];
    uVar2 = puVar18[6];
    uVar3 = puVar18[7];
    puVar16[4] = puVar18[4];
    puVar16[5] = uVar1;
    puVar16[6] = uVar2;
    puVar16[7] = uVar3;
    *puVar18 = uVar4;
    puVar18[1] = uVar5;
    puVar18[2] = uVar6;
    puVar18[3] = uVar7;
    puVar18[4] = uVar8;
    puVar18[5] = uVar9;
    puVar18[6] = uVar10;
    puVar18[7] = uVar11;
    puVar16 = puVar16 + 8;
    puVar17 = puVar18 + 8;
    local_10 = puVar18 + 8;
    local_c = puVar14;
  }
  else {
    puVar13 = local_8 + -8;
    if (puVar18 == param_3) {
      puVar17 = puVar16 + -8;
      if (puVar13 != puVar17) {
        uVar1 = puVar16[-7];
        uVar2 = puVar16[-6];
        uVar3 = puVar16[-5];
        uVar4 = *puVar13;
        uVar5 = local_8[-7];
        uVar6 = local_8[-6];
        uVar7 = local_8[-5];
        uVar8 = local_8[-4];
        uVar9 = local_8[-3];
        uVar10 = local_8[-2];
        uVar11 = local_8[-1];
        *puVar13 = *puVar17;
        local_8[-7] = uVar1;
        local_8[-6] = uVar2;
        local_8[-5] = uVar3;
        uVar1 = puVar16[-3];
        uVar2 = puVar16[-2];
        uVar3 = puVar16[-1];
        local_8[-4] = puVar16[-4];
        local_8[-3] = uVar1;
        local_8[-2] = uVar2;
        local_8[-1] = uVar3;
        *puVar17 = uVar4;
        puVar16[-7] = uVar5;
        puVar16[-6] = uVar6;
        puVar16[-5] = uVar7;
        puVar16[-4] = uVar8;
        puVar16[-3] = uVar9;
        puVar16[-2] = uVar10;
        puVar16[-1] = uVar11;
      }
      uVar1 = puVar14[-7];
      uVar2 = puVar14[-6];
      uVar3 = puVar14[-5];
      local_c = puVar14 + -8;
      uVar4 = *puVar17;
      uVar5 = puVar16[-7];
      uVar6 = puVar16[-6];
      uVar7 = puVar16[-5];
      uVar8 = puVar16[-4];
      uVar9 = puVar16[-3];
      uVar10 = puVar16[-2];
      uVar11 = puVar16[-1];
      *puVar17 = puVar14[-8];
      puVar16[-7] = uVar1;
      puVar16[-6] = uVar2;
      puVar16[-5] = uVar3;
      uVar1 = puVar14[-3];
      uVar2 = puVar14[-2];
      uVar3 = puVar14[-1];
      puVar16[-4] = puVar14[-4];
      puVar16[-3] = uVar1;
      puVar16[-2] = uVar2;
      puVar16[-1] = uVar3;
      *local_c = uVar4;
      puVar14[-7] = uVar5;
      puVar14[-6] = uVar6;
      puVar14[-5] = uVar7;
      puVar14[-4] = uVar8;
      puVar14[-3] = uVar9;
      puVar14[-2] = uVar10;
      puVar14[-1] = uVar11;
      puVar14 = local_c;
      puVar16 = puVar17;
      puVar17 = puVar18;
      local_8 = puVar13;
    }
    else {
      uVar1 = local_8[-7];
      uVar2 = local_8[-6];
      uVar3 = local_8[-5];
      uVar4 = *puVar18;
      uVar5 = puVar18[1];
      uVar6 = puVar18[2];
      uVar7 = puVar18[3];
      uVar8 = puVar18[4];
      uVar9 = puVar18[5];
      uVar10 = puVar18[6];
      uVar11 = puVar18[7];
      *puVar18 = *puVar13;
      puVar18[1] = uVar1;
      puVar18[2] = uVar2;
      puVar18[3] = uVar3;
      uVar1 = local_8[-3];
      uVar2 = local_8[-2];
      uVar3 = local_8[-1];
      puVar18[4] = local_8[-4];
      puVar18[5] = uVar1;
      puVar18[6] = uVar2;
      puVar18[7] = uVar3;
      *puVar13 = uVar4;
      local_8[-7] = uVar5;
      local_8[-6] = uVar6;
      local_8[-5] = uVar7;
      local_8[-4] = uVar8;
      local_8[-3] = uVar9;
      local_8[-2] = uVar10;
      local_8[-1] = uVar11;
      puVar17 = puVar18 + 8;
      local_10 = puVar18 + 8;
      local_8 = puVar13;
    }
  }
  goto LAB_10018ef2;
}



undefined4 * __cdecl FUN_100190f0(undefined4 *param_1,undefined4 *param_2,undefined4 *param_3)

{
  undefined4 *in_FS_OFFSET;
  undefined4 local_10;
  code *pcStack12;
  undefined4 local_8;
  
  pcStack12 = FUN_10035000;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_10;
  local_8 = 0;
  for (; param_1 != param_2; param_1 = param_1 + 8) {
    FUN_10019160(param_3,param_1);
    param_3 = param_3 + 8;
  }
  *in_FS_OFFSET = local_10;
  return param_3;
}



void Catch_10019156(void)

{
  code *pcVar1;
  
  FUN_1002364d((int *)0x0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void FUN_10019160(undefined4 *param_1,undefined4 *param_2)

{
  undefined4 uVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  
  if (param_1 != (undefined4 *)0x0) {
    uVar1 = param_2[1];
    uVar2 = param_2[2];
    uVar3 = param_2[3];
    *param_1 = *param_2;
    param_1[1] = uVar1;
    param_1[2] = uVar2;
    param_1[3] = uVar3;
    uVar1 = param_2[5];
    uVar2 = param_2[6];
    uVar3 = param_2[7];
    param_1[4] = param_2[4];
    param_1[5] = uVar1;
    param_1[6] = uVar2;
    param_1[7] = uVar3;
  }
  return;
}



undefined4 __fastcall FUN_10019190(undefined4 param_1)

{
  return param_1;
}



// public: __thiscall CVProfile::CVProfile(void)

CVProfile * __thiscall CVProfile::CVProfile(CVProfile *this)

{
  uint *puVar1;
  DWORD DVar2;
  undefined4 uVar3;
  int iVar4;
  
                    // 0x191a0  23  ??0CVProfile@@QAE@XZ
  *(undefined4 *)(this + 0x100c) = 0;
  this[0x1010] = (CVProfile)0x1;
  *(CVProfNode **)(this + 0x1014) = (CVProfNode *)(this + 0x1018);
  CVProfNode::CVProfNode((CVProfNode *)(this + 0x1018),"Root",0,(CVProfNode *)0x0,"Unaccounted",0);
  *(undefined4 *)(this + 0x10a8) = 0;
  *(undefined4 *)(this + 0x10b0) = 0;
  *(undefined4 *)(this + 0x1008) = 1;
  *(undefined4 *)(this + 8) = 0;
  DVar2 = GetCurrentThreadId();
  *(DWORD *)(this + 0x19cc) = DVar2;
  uVar3 = FUN_10023b7a(0x100);
  *(undefined4 *)(this + 0x10b4) = uVar3;
  *(undefined4 *)(this + 0x10bc) = 0;
  *(undefined4 *)(this + 0x10b8) = 0x20;
  iVar4 = FindBudgetGroupName(this,"Unaccounted");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Unaccounted",6);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 6;
  }
  iVar4 = FindBudgetGroupName(this,"World Rendering");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"World Rendering",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Displacement_Rendering");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Displacement_Rendering",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Game");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Game",6);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 6;
  }
  iVar4 = FindBudgetGroupName(this,"Player");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Player",6);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 6;
  }
  iVar4 = FindBudgetGroupName(this,"NPCs");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"NPCs",6);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 6;
  }
  iVar4 = FindBudgetGroupName(this,"Server Animation");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Server Animation",6);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 6;
  }
  iVar4 = FindBudgetGroupName(this,"Client_Animation");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Client_Animation",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Physics");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Physics",6);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 6;
  }
  iVar4 = FindBudgetGroupName(this,"Static_Prop_Rendering");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Static_Prop_Rendering",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Other_Model_Rendering");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Other_Model_Rendering",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Fast Path Model Rendering");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Fast Path Model Rendering",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Light_Cache");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Light_Cache",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Brush_Model_Rendering");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Brush_Model_Rendering",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Shadow_Rendering");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Shadow_Rendering",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Detail_Prop_Rendering");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Detail_Prop_Rendering",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Particle/Effect_Rendering");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Particle/Effect_Rendering",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Ropes");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Ropes",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Dynamic_Light_Rendering");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Dynamic_Light_Rendering",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Networking");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Networking",6);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 6;
  }
  iVar4 = FindBudgetGroupName(this,"Sound");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Sound",6);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 6;
  }
  iVar4 = FindBudgetGroupName(this,"VGUI");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"VGUI",6);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 6;
  }
  iVar4 = FindBudgetGroupName(this,"FileSystem");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"FileSystem",6);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 6;
  }
  iVar4 = FindBudgetGroupName(this,"Prediction");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Prediction",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Interpolation");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Interpolation",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Swap_Buffers");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Swap_Buffers",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Occlusion");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Occlusion",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Overlays");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Overlays",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Tools");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Tools",5);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 5;
  }
  iVar4 = FindBudgetGroupName(this,"Texture_Cache");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Texture_Cache",1);
  }
  else {
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
    *puVar1 = *puVar1 | 1;
  }
  iVar4 = FindBudgetGroupName(this,"Replay");
  if (iVar4 == -1) {
    AddBudgetGroupName(this,"Replay",2);
    *(undefined2 *)(this + 0x10c4) = 0;
    return this;
  }
  puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar4 * 8);
  *puVar1 = *puVar1 | 2;
  *(undefined2 *)(this + 0x10c4) = 0;
  return this;
}



// public: __thiscall CVProfNode::~CVProfNode(void)

void __thiscall CVProfNode::_CVProfNode(CVProfNode *this)

{
                    // 0x197e0  40  ??1CVProfNode@@QAE@XZ
  FUN_10011330((int)(this + 0x20));
  return;
}



// public: __thiscall CVProfile::~CVProfile(void)

void __thiscall CVProfile::_CVProfile(CVProfile *this)

{
                    // 0x197f0  41  ??1CVProfile@@QAE@XZ
  Term(this);
  FUN_10011330((int)(this + 0x1038));
  return;
}



int * __thiscall FUN_10019810(void *this,int *param_1)

{
  undefined4 *_Memory;
  uint uVar1;
  undefined4 *puVar2;
  undefined4 uVar3;
  uint uVar4;
  undefined4 *in_FS_OFFSET;
  undefined4 local_10;
  code *pcStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  pcStack12 = FUN_10035010;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_10;
  if ((int *)this != param_1) {
    puVar2 = (undefined4 *)*param_1;
    if (puVar2 == (undefined4 *)param_1[1]) {
                    // WARNING: Load size is inaccurate
      puVar2 = *this;
    }
    else {
      uVar1 = (int)(undefined4 *)param_1[1] - (int)puVar2 >> 5;
                    // WARNING: Load size is inaccurate
      _Memory = *this;
      uVar4 = *(int *)((int)this + 4) - (int)_Memory >> 5;
      if (uVar4 < uVar1) {
        if ((uint)(*(int *)((int)this + 8) - (int)_Memory >> 5) < uVar1) {
          if (_Memory != (undefined4 *)0x0) {
            FID_conflict__free(_Memory);
          }
          uVar1 = FUN_1001b150(this,param_1[1] - *param_1 >> 5);
          if ((char)uVar1 != '\0') {
            local_8 = 0;
                    // WARNING: Load size is inaccurate
            uVar3 = FUN_10018df0((undefined4 *)*param_1,(undefined4 *)param_1[1],*this);
            *(undefined4 *)((int)this + 4) = uVar3;
          }
          goto LAB_1001984b;
        }
        FUN_10018240(puVar2,puVar2 + uVar4 * 8,_Memory);
        puVar2 = FUN_100190f0(puVar2 + uVar4 * 8,(undefined4 *)param_1[1],
                              *(undefined4 **)((int)this + 4));
      }
      else {
        FUN_10018240(puVar2,(undefined4 *)param_1[1],_Memory);
                    // WARNING: Load size is inaccurate
        puVar2 = (undefined4 *)((param_1[1] - *param_1 & 0xffffffe0U) + *this);
      }
    }
    *(undefined4 **)((int)this + 4) = puVar2;
  }
LAB_1001984b:
  *in_FS_OFFSET = local_10;
  return (int *)this;
}



void Catch_1001990a(void)

{
  code *pcVar1;
  int unaff_EBP;
  
  FUN_1001b650(*(void ***)(unaff_EBP + -0x14));
  FUN_1002364d((int *)0x0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



int ** __fastcall FUN_10019920(int **param_1)

{
  char cVar1;
  int *piVar2;
  int **ppiVar3;
  int **ppiVar4;
  
  piVar2 = *param_1;
  if (*(char *)((int)piVar2 + 0xd) == '\0') {
    ppiVar3 = (int **)piVar2[2];
    if (*(char *)((int)ppiVar3 + 0xd) == '\0') {
      cVar1 = *(char *)((int)*ppiVar3 + 0xd);
      ppiVar4 = (int **)*ppiVar3;
      while (cVar1 == '\0') {
        cVar1 = *(char *)((int)*ppiVar4 + 0xd);
        ppiVar3 = ppiVar4;
        ppiVar4 = (int **)*ppiVar4;
      }
      *param_1 = (int *)ppiVar3;
      return param_1;
    }
    piVar2 = (int *)piVar2[1];
    cVar1 = *(char *)((int)piVar2 + 0xd);
    while ((cVar1 == '\0' && (*param_1 == (int *)piVar2[2]))) {
      *param_1 = piVar2;
      piVar2 = (int *)piVar2[1];
      cVar1 = *(char *)((int)piVar2 + 0xd);
    }
    *param_1 = piVar2;
  }
  return param_1;
}



int ** __fastcall FUN_10019970(int **param_1)

{
  char cVar1;
  int **ppiVar2;
  int *piVar3;
  int *piVar4;
  int **ppiVar5;
  
  ppiVar2 = (int **)*param_1;
  if (*(char *)((int)ppiVar2 + 0xd) != '\0') {
    *param_1 = ppiVar2[2];
    return param_1;
  }
  ppiVar5 = (int **)*ppiVar2;
  if (*(char *)((int)ppiVar5 + 0xd) == '\0') {
    piVar3 = ppiVar5[2];
    if (*(char *)((int)ppiVar5[2] + 0xd) == '\0') {
      do {
        piVar4 = piVar3;
        piVar3 = (int *)piVar4[2];
      } while (*(char *)((int)piVar3 + 0xd) == '\0');
      *param_1 = piVar4;
      return param_1;
    }
  }
  else {
    ppiVar5 = (int **)ppiVar2[1];
    cVar1 = *(char *)((int)ppiVar5 + 0xd);
    while ((cVar1 == '\0' && (*param_1 == *ppiVar5))) {
      *param_1 = (int *)ppiVar5;
      ppiVar5 = (int **)ppiVar5[1];
      cVar1 = *(char *)((int)ppiVar5 + 0xd);
    }
    if (*(char *)((int)*param_1 + 0xd) != '\0') {
      return param_1;
    }
  }
  *param_1 = (int *)ppiVar5;
  return param_1;
}



// protected: int __thiscall CVProfile::AddBudgetGroupName(char const *,int)

int __thiscall CVProfile::AddBudgetGroupName(CVProfile *this,char *param_1,int param_2)

{
  char cVar1;
  int iVar2;
  int iVar3;
  uint uVar4;
  char *pcVar5;
  uint uVar6;
  int iVar7;
  int iVar8;
  
                    // 0x199d0  70  ?AddBudgetGroupName@CVProfile@@IAEHPBDH@Z
  pcVar5 = param_1;
  do {
    cVar1 = *pcVar5;
    pcVar5 = pcVar5 + 1;
  } while (cVar1 != '\0');
  iVar3 = FUN_10023b7a((size_t)(pcVar5 + (1 - (int)(param_1 + 1))));
  iVar7 = iVar3 - (int)param_1;
  do {
    cVar1 = *param_1;
    param_1 = param_1 + 1;
    param_1[iVar7 + -1] = cVar1;
  } while (cVar1 != '\0');
  if (*(int *)(this + 0x10b8) < *(int *)(this + 0x10bc) + 1) {
    uVar6 = *(int *)(this + 0x10bc) + 6;
    uVar4 = *(int *)(this + 0x10b8) * 2;
    if ((int)uVar4 < (int)uVar6) {
      uVar4 = uVar6;
    }
    *(uint *)(this + 0x10b8) = uVar4;
    iVar7 = FUN_10023b7a(-(uint)((int)((ulonglong)uVar4 * 8 >> 0x20) != 0) |
                         (uint)((ulonglong)uVar4 * 8));
    iVar8 = 0;
    if (0 < *(int *)(this + 0x10bc)) {
      do {
        iVar2 = *(int *)(this + 0x10b4);
        *(undefined4 *)(iVar7 + iVar8 * 8) = *(undefined4 *)(iVar2 + iVar8 * 8);
        *(undefined4 *)(iVar7 + 4 + iVar8 * 8) = *(undefined4 *)(iVar2 + 4 + iVar8 * 8);
        iVar8 = iVar8 + 1;
      } while (iVar8 < *(int *)(this + 0x10bc));
    }
    FID_conflict__free(*(void **)(this + 0x10b4));
    *(int *)(this + 0x10b4) = iVar7;
  }
  *(int *)(*(int *)(this + 0x10b4) + *(int *)(this + 0x10bc) * 8) = iVar3;
  *(int *)(*(int *)(this + 0x10b4) + 4 + *(int *)(this + 0x10bc) * 8) = param_2;
  *(int *)(this + 0x10bc) = *(int *)(this + 0x10bc) + 1;
  if (*(code **)(this + 0x10c0) != (code *)0x0) {
    (**(code **)(this + 0x10c0))();
  }
  return *(int *)(this + 0x10bc) + -1;
}



bool __cdecl FUN_10019ae0(int param_1,int param_2)

{
  int iVar1;
  double dVar2;
  double dVar3;
  
  dVar2 = 0.0;
  iVar1 = *(int *)(param_1 + 4);
  dVar3 = dVar2;
  if (iVar1 != 0) {
    dVar3 = *(double *)(param_1 + 8) / ((double)iVar1 + (double)(&DAT_100366d0)[-(iVar1 >> 0x1f)]);
  }
  iVar1 = *(int *)(param_2 + 4);
  if (iVar1 != 0) {
    dVar2 = *(double *)(param_2 + 8) / ((double)iVar1 + (double)(&DAT_100366d0)[-(iVar1 >> 0x1f)]);
  }
  return dVar2 < dVar3;
}



bool __cdecl FUN_10019b50(int param_1,int param_2)

{
  int iVar1;
  double dVar2;
  double dVar3;
  
  dVar2 = 0.0;
  iVar1 = *(int *)(param_1 + 4);
  dVar3 = dVar2;
  if (iVar1 != 0) {
    dVar3 = *(double *)(param_1 + 0x10) /
            ((double)iVar1 + (double)(&DAT_100366d0)[-(iVar1 >> 0x1f)]);
  }
  iVar1 = *(int *)(param_2 + 4);
  if (iVar1 != 0) {
    dVar2 = *(double *)(param_2 + 0x10) /
            ((double)iVar1 + (double)(&DAT_100366d0)[-(iVar1 >> 0x1f)]);
  }
  return dVar2 < dVar3;
}



// public: int __thiscall CVProfile::BudgetGroupNameToBudgetGroupID(char const *)

int __thiscall CVProfile::BudgetGroupNameToBudgetGroupID(CVProfile *this,char *param_1)

{
  uint *puVar1;
  int iVar2;
  
                    // 0x19bc0  77  ?BudgetGroupNameToBudgetGroupID@CVProfile@@QAEHPBD@Z
  iVar2 = FindBudgetGroupName(this,param_1);
  if (iVar2 == -1) {
    iVar2 = AddBudgetGroupName(this,param_1,4);
    return iVar2;
  }
  puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + iVar2 * 8);
  *puVar1 = *puVar1 | 4;
  return iVar2;
}



// public: int __thiscall CVProfile::BudgetGroupNameToBudgetGroupID(char const *,int)

int __thiscall CVProfile::BudgetGroupNameToBudgetGroupID(CVProfile *this,char *param_1,int param_2)

{
  uint *puVar1;
  int iVar2;
  
                    // 0x19c00  78  ?BudgetGroupNameToBudgetGroupID@CVProfile@@QAEHPBDH@Z
  iVar2 = FindBudgetGroupName(this,param_1);
  if (iVar2 == -1) {
    iVar2 = AddBudgetGroupName(this,param_1,param_2);
    return iVar2;
  }
  puVar1 = (uint *)(*(int *)(this + 0x10b4) + iVar2 * 8 + 4);
  *puVar1 = *puVar1 | param_2;
  return iVar2;
}



// protected: void __thiscall CVProfile::DumpNodes(class CVProfNode *,int,bool)

void __thiscall CVProfile::DumpNodes(CVProfile *this,CVProfNode *param_1,int param_2,bool param_3)

{
  CVProfNode *pCVar1;
  int iVar2;
  undefined3 in_stack_0000000d;
  char *pcVar3;
  int local_c;
  char local_5;
  
                    // 0x19c40  93  ?DumpNodes@CVProfile@@IAEXPAVCVProfNode@@H_N@Z
  iVar2 = param_2;
  if (param_1 != (CVProfNode *)0x0) {
    do {
      pCVar1 = param_1;
      local_5 = param_1 == (CVProfNode *)(this + 0x1018);
      if (((bool)local_5) || (param_1 == DAT_10833ed4)) {
        if (param_3 == false) {
          Msg((byte *)"       Sum (ms)            Avg Time/Frame (ms)     Avg Time/Call (ms)\n");
          Msg((byte *)
              "[ func+child      func ]  [ func+child   func ]  [ func+child   func ]    Count   Peak\n"
             );
          pcVar3 = 
          "  ---------- ---------      ---------- ------      ---------- ------   -------- ------\n"
          ;
        }
        else {
          Msg((byte *)" Avg Time/Frame (ms)\n");
          Msg((byte *)"[ func+child      func ]       Count\n");
          pcVar3 = "  ---------- ---------      --------\n";
        }
        Msg((byte *)pcVar3);
        if (local_5 == '\0') goto LAB_10019cc0;
      }
      else {
LAB_10019cc0:
        FUN_1001b9e0(&DAT_108358d0,&local_c,(uint *)&param_1);
        if (param_3 == false) {
          if (*(int *)(pCVar1 + 0x60) != 0) {
            FUN_10001a1e(*(undefined4 *)(pCVar1 + 0x68),*(uint *)(pCVar1 + 0x6c));
            FUN_10001a1e(*(undefined4 *)(pCVar1 + 0x68),*(uint *)(pCVar1 + 0x6c));
          }
          FUN_10001a1e(*(undefined4 *)(pCVar1 + 0x70),*(uint *)(pCVar1 + 0x74));
          FUN_10001a1e(*(undefined4 *)(pCVar1 + 0x68),*(uint *)(pCVar1 + 0x6c));
          Msg((byte *)"  %10.3f %9.2f      %10.3f %6.2f      %10.3f %6.2f   %8d %6.2f");
        }
        else {
          if (*(int *)(pCVar1 + 0x60) != 0) {
            FUN_10001a1e(*(undefined4 *)(pCVar1 + 0x68),*(uint *)(pCVar1 + 0x6c));
          }
          Msg((byte *)"  %10.3f %9.2f      %8d");
        }
        Msg(&DAT_10039058);
        if (1 < param_2) {
          iVar2 = param_2 + -1;
          do {
            Msg(&DAT_1003905c);
            iVar2 = iVar2 + -1;
          } while (iVar2 != 0);
        }
        Msg(&DAT_10039060);
        iVar2 = param_2;
      }
      if (*(CVProfNode **)(pCVar1 + 0x7c) != (CVProfNode *)0x0) {
        DumpNodes(this,*(CVProfNode **)(pCVar1 + 0x7c),iVar2 + 1,SUB41(_param_3,0));
      }
    } while (((local_5 == '\0') && (pCVar1 != DAT_10833ed4)) &&
            (param_1 = *(CVProfNode **)(pCVar1 + 0x80), param_1 != (CVProfNode *)0x0));
  }
  return;
}



void FUN_10019f40(undefined4 param_1,double param_2,undefined *param_3,uint param_4)

{
  uint uVar1;
  undefined4 *_Memory;
  uint uVar2;
  undefined4 *local_10;
  undefined4 *local_c;
  undefined4 local_8;
  
  local_10 = (undefined4 *)0x0;
  local_c = (undefined4 *)0x0;
  local_8 = 0;
  FUN_10019810(&local_10,&DAT_10833ef0);
  _Memory = local_10;
  uVar2 = (int)local_c - (int)local_10 >> 5;
  FUN_10018c90(local_10,local_c,uVar2,param_3);
  Msg(&DAT_10039060);
  Msg((byte *)
      "  Scope                                                      Calls Calls/Frame  Time+Child    Pct        Time    Pct   Avg/Frame    Avg/Call Avg-NoChild        Peak\n"
     );
  Msg((byte *)
      "  ---------------------------------------------------- ----------- ----------- ----------- ------ ----------- ------ ----------- ----------- ----------- -----------\n"
     );
  uVar1 = 0;
  if (uVar2 != 0) {
    do {
      _Memory = local_10;
      if (param_4 <= uVar1) break;
      Msg((byte *)"  %52.52s%12d%12.3f%12.3f%7.2f%12.3f%7.2f%12.3f%12.3f%12.3f%12.3f\n");
      uVar1 = uVar1 + 1;
      _Memory = local_10;
    } while (uVar1 < uVar2);
  }
  if (_Memory != (undefined4 *)0x0) {
    FID_conflict__free(_Memory);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// public: void __thiscall CVProfNode::EnterScope(void)

void __thiscall CVProfNode::EnterScope(CVProfNode *this)

{
  int iVar1;
  undefined8 uVar2;
  
                    // 0x1a110  95  ?EnterScope@CVProfNode@@QAEXXZ
  iVar1 = *(int *)(this + 0x40);
  *(int *)(this + 0x44) = *(int *)(this + 0x44) + 1;
  *(int *)(this + 0x40) = iVar1 + 1;
  if (iVar1 == 0) {
    uVar2 = rdtsc();
    *(int *)(this + 8) = (int)uVar2;
    *(int *)(this + 0xc) = (int)((ulonglong)uVar2 >> 0x20);
    if ((DAT_10834fc4 != '\0') && (DAT_10834fc5 != '\0')) {
      FUN_100113f0((int)(this + 0x20));
    }
    iVar1 = *(int *)(this + 0x84);
    *(int *)(&DAT_10833f08 + DAT_10834f08 * 4) = iVar1;
    DAT_10834f08 = DAT_10834f08 + 1;
    if (((*(int *)(&g_VProfCurrentProfile + DAT_10834f08 * 4) != iVar1) &&
        (g_VProfCurrentProfile != '\0')) && (iVar1 == _DAT_10833f04)) {
      vtune('\x01');
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// public: bool __thiscall CVProfNode::ExitScope(void)

bool __thiscall CVProfNode::ExitScope(CVProfNode *this)

{
  int *piVar1;
  uint *puVar2;
  uint uVar3;
  undefined8 uVar4;
  uint uVar5;
  int iVar6;
  
                    // 0x1a190  98  ?ExitScope@CVProfNode@@QAE_NXZ
  piVar1 = (int *)(this + 0x40);
  *piVar1 = *piVar1 + -1;
  if ((*piVar1 == 0) && (*(int *)(this + 0x44) != 0)) {
    uVar4 = rdtsc();
    uVar3 = *(uint *)(this + 8);
    uVar5 = (uint)uVar4 - *(uint *)(this + 8);
    *(uint *)(this + 8) = uVar5;
    iVar6 = ((int)((ulonglong)uVar4 >> 0x20) - *(int *)(this + 0xc)) - (uint)((uint)uVar4 < uVar3);
    *(int *)(this + 0xc) = iVar6;
    puVar2 = (uint *)(this + 0x48);
    uVar3 = *puVar2;
    *puVar2 = *puVar2 + uVar5;
    *(uint *)(this + 0x4c) = *(int *)(this + 0x4c) + iVar6 + (uint)CARRY4(uVar3,uVar5);
    if ((DAT_10834fc4 != '\0') && (DAT_10834fc5 != '\0')) {
      FUN_10011380((int)(this + 0x20));
      *(int *)(this + 0x14) = *(int *)(this + 0x14) + *(int *)(this + 0x38);
    }
    DAT_10834f08 = DAT_10834f08 + -1;
    if (((*(int *)(&DAT_10833f08 + DAT_10834f08 * 4) != *(int *)(&DAT_10833f0c + DAT_10834f08 * 4))
        && (g_VProfCurrentProfile != '\0')) &&
       (*(int *)(&DAT_10833f0c + DAT_10834f08 * 4) == _DAT_10833f04)) {
      vtune('\0');
    }
  }
  return *(int *)(this + 0x40) == 0;
}



// protected: int __thiscall CVProfile::FindBudgetGroupName(char const *)

int __thiscall CVProfile::FindBudgetGroupName(CVProfile *this,char *param_1)

{
  int iVar1;
  int iVar2;
  
                    // 0x1a220  100  ?FindBudgetGroupName@CVProfile@@IAEHPBD@Z
  iVar2 = 0;
  if (0 < *(int *)(this + 0x10bc)) {
    do {
      iVar1 = FUN_1001f9b6((byte *)param_1,*(byte **)(*(int *)(this + 0x10b4) + iVar2 * 8));
      if (iVar1 == 0) {
        return iVar2;
      }
      iVar2 = iVar2 + 1;
    } while (iVar2 < *(int *)(this + 0x10bc));
  }
  return -1;
}



// public: class CVProfNode * __thiscall CVProfile::FindNode(class CVProfNode *,char const *)

CVProfNode * __thiscall CVProfile::FindNode(CVProfile *this,CVProfNode *param_1,char *param_2)

{
  int iVar1;
  CVProfNode *pCVar2;
  
                    // 0x1a270  101  ?FindNode@CVProfile@@QAEPAVCVProfNode@@PAV2@PBD@Z
  iVar1 = FUN_10023a9c(*(byte **)param_1,(byte *)param_2);
  pCVar2 = param_1;
  if (iVar1 != 0) {
    pCVar2 = (CVProfNode *)0x0;
    if (((*(CVProfNode **)(param_1 + 0x80) == (CVProfNode *)0x0) ||
        (pCVar2 = FindNode(this,*(CVProfNode **)(param_1 + 0x80),param_2),
        pCVar2 == (CVProfNode *)0x0)) && (*(CVProfNode **)(param_1 + 0x7c) != (CVProfNode *)0x0)) {
      pCVar2 = FindNode(this,*(CVProfNode **)(param_1 + 0x7c),param_2);
      return pCVar2;
    }
  }
  return pCVar2;
}



// public: int * __thiscall CVProfile::FindOrCreateCounter(char const *,enum CounterGroup_t)

int * __thiscall
CVProfile::FindOrCreateCounter(CVProfile *this,char *param_1,CounterGroup_t param_2)

{
  char cVar1;
  DWORD DVar2;
  byte **ppbVar3;
  int iVar4;
  char *pcVar5;
  int iVar6;
  
                    // 0x1a2d0  102  ?FindOrCreateCounter@CVProfile@@QAEPAHPBDW4CounterGroup_t@@@Z
  if (*(int *)(this + 0x19c8) + 1 < 0x100) {
    DVar2 = GetCurrentThreadId();
    if (*(DWORD *)(this + 0x19cc) == DVar2) {
      iVar6 = 0;
      if (0 < *(int *)(this + 0x19c8)) {
        ppbVar3 = (byte **)(this + 0x15c8);
        do {
          iVar4 = FUN_1001f9b6(*ppbVar3,(byte *)param_1);
          if (iVar4 == 0) {
            return (int *)(this + iVar6 * 4 + 0x10c8);
          }
          iVar6 = iVar6 + 1;
          ppbVar3 = ppbVar3 + 1;
        } while (iVar6 < *(int *)(this + 0x19c8));
      }
      pcVar5 = param_1;
      do {
        cVar1 = *pcVar5;
        pcVar5 = pcVar5 + 1;
      } while (cVar1 != '\0');
      iVar6 = FUN_10023b7a((size_t)(pcVar5 + (1 - (int)(param_1 + 1))));
      iVar4 = iVar6 - (int)param_1;
      do {
        cVar1 = *param_1;
        param_1 = param_1 + 1;
        param_1[iVar4 + -1] = cVar1;
      } while (cVar1 != '\0');
      *(undefined4 *)(this + *(int *)(this + 0x19c8) * 4 + 0x10c8) = 0;
      this[*(int *)(this + 0x19c8) + 0x14c8] = param_2._0_1_;
      *(int *)(this + *(int *)(this + 0x19c8) * 4 + 0x15c8) = iVar6;
      *(int *)(this + 0x19c8) = *(int *)(this + 0x19c8) + 1;
      return (int *)(this + (*(int *)(this + 0x19c8) + 0x431) * 4);
    }
  }
  return (int *)&DAT_108358dc;
}



// protected: void __thiscall CVProfile::FreeNodes_R(class CVProfNode *)

void __thiscall CVProfile::FreeNodes_R(CVProfile *this,CVProfNode *param_1)

{
  CVProfNode *pCVar1;
  CVProfNode *pCVar2;
  
                    // 0x1a3d0  103  ?FreeNodes_R@CVProfile@@IAEXPAVCVProfNode@@@Z
  pCVar2 = *(CVProfNode **)(param_1 + 0x7c);
  while (pCVar2 != (CVProfNode *)0x0) {
    pCVar1 = *(CVProfNode **)(pCVar2 + 0x80);
    FreeNodes_R(this,pCVar2);
    pCVar2 = pCVar1;
  }
  if (param_1 == (CVProfNode *)(this + 0x1018)) {
    *(undefined4 *)(param_1 + 0x7c) = 0;
    return;
  }
  FUN_10011330((int)(param_1 + 0x20));
  FID_conflict__free(param_1);
  return;
}



// public: void __thiscall CVProfile::GetBudgetGroupColor(int,int &,int &,int &,int &)

void __thiscall
CVProfile::GetBudgetGroupColor
          (CVProfile *this,int param_1,int *param_2,int *param_3,int *param_4,int *param_5)

{
  uint uVar1;
  
                    // 0x1a430  105  ?GetBudgetGroupColor@CVProfile@@QAEXHAAH000@Z
  uVar1 = param_1 & 0x8000003f;
  if ((int)uVar1 < 0) {
    uVar1 = (uVar1 - 1 | 0xffffffc0) + 1;
  }
  *param_2 = *(int *)(&DAT_100466d0 + ((int)uVar1 >> 4 & 2U | uVar1 & 1) * 4);
  *param_3 = *(int *)(&DAT_100466d0 + ((int)((int)uVar1 >> 2 & 4U | uVar1 & 2) >> 1) * 4);
  *param_4 = *(int *)(&DAT_100466d0 + ((int)uVar1 >> 2 & 3U) * 4);
  *param_5 = 0xff;
  return;
}



// public: enum CounterGroup_t __thiscall CVProfile::GetCounterGroup(int)const 

CounterGroup_t __thiscall CVProfile::GetCounterGroup(CVProfile *this,int param_1)

{
                    // 0x1a4a0  113  ?GetCounterGroup@CVProfile@@QBE?AW4CounterGroup_t@@H@Z
  return (int)(char)this[param_1 + 0x14c8];
}



// public: char const * __thiscall CVProfile::GetCounterName(int)const 

char * __thiscall CVProfile::GetCounterName(CVProfile *this,int param_1)

{
                    // 0x1a4c0  114  ?GetCounterName@CVProfile@@QBEPBDH@Z
  return *(char **)(this + param_1 * 4 + 0x15c8);
}



// public: char const * __thiscall CVProfile::GetCounterNameAndValue(int,int &)const 

char * __thiscall CVProfile::GetCounterNameAndValue(CVProfile *this,int param_1,int *param_2)

{
                    // 0x1a4e0  115  ?GetCounterNameAndValue@CVProfile@@QBEPBDHAAH@Z
  *param_2 = *(int *)(this + param_1 * 4 + 0x10c8);
  return *(char **)(this + param_1 * 4 + 0x15c8);
}



// public: int __thiscall CVProfile::GetCounterValue(int)const 

int __thiscall CVProfile::GetCounterValue(CVProfile *this,int param_1)

{
                    // 0x1a500  116  ?GetCounterValue@CVProfile@@QBEHH@Z
  return *(int *)(this + param_1 * 4 + 0x10c8);
}



// public: int __thiscall CVProfile::GetNumBudgetGroups(void)

int __thiscall CVProfile::GetNumBudgetGroups(CVProfile *this)

{
                    // 0x1a520  129  ?GetNumBudgetGroups@CVProfile@@QAEHXZ
  return *(int *)(this + 0x10bc);
}



// public: int __thiscall CVProfile::GetNumCounters(void)const 

int __thiscall CVProfile::GetNumCounters(CVProfile *this)

{
                    // 0x1a530  130  ?GetNumCounters@CVProfile@@QBEHXZ
  return *(int *)(this + 0x19c8);
}



// public: class CVProfNode * __thiscall CVProfNode::GetSubNode(char const *,int,char const *)

CVProfNode * __thiscall
CVProfNode::GetSubNode(CVProfNode *this,char *param_1,int param_2,char *param_3)

{
  CVProfNode *pCVar1;
  
                    // 0x1a540  144  ?GetSubNode@CVProfNode@@QAEPAV1@PBDH0@Z
  pCVar1 = GetSubNode(this,param_1,param_2,param_3,4);
  return pCVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// public: class CVProfNode * __thiscall CVProfNode::GetSubNode(char const *,int,char const *,int)

CVProfNode * __thiscall
CVProfNode::GetSubNode(CVProfNode *this,char *param_1,int param_2,char *param_3,int param_4)

{
  char **ppcVar1;
  CVProfNode *pCVar2;
  
                    // 0x1a560  145  ?GetSubNode@CVProfNode@@QAEPAV1@PBDH0H@Z
  for (ppcVar1 = *(char ***)(this + 0x7c); ppcVar1 != (char **)0x0; ppcVar1 = (char **)ppcVar1[0x20]
      ) {
    if (*ppcVar1 == param_1) {
      return (CVProfNode *)ppcVar1;
    }
  }
  pCVar2 = (CVProfNode *)FUN_1001f8b3(0x90);
  if (pCVar2 == (CVProfNode *)0x0) {
    _DAT_00000080 = *(undefined4 *)(this + 0x7c);
    *(undefined4 *)(this + 0x7c) = 0;
    return (CVProfNode *)0x0;
  }
  pCVar2 = (CVProfNode *)CVProfNode(pCVar2,param_1,param_2,this,param_3,param_4);
  *(undefined4 *)(pCVar2 + 0x80) = *(undefined4 *)(this + 0x7c);
  *(CVProfNode **)(this + 0x7c) = pCVar2;
  return pCVar2;
}



// public: void __thiscall CVProfile::HideBudgetGroup(int,bool)

void __thiscall CVProfile::HideBudgetGroup(CVProfile *this,int param_1,bool param_2)

{
  uint *puVar1;
  
                    // 0x1a5d0  157  ?HideBudgetGroup@CVProfile@@QAEXH_N@Z
  if (param_1 != -1) {
    if (param_2 != false) {
      puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + param_1 * 8);
      *puVar1 = *puVar1 | 0x8000;
      return;
    }
    puVar1 = (uint *)(*(int *)(this + 0x10b4) + 4 + param_1 * 8);
    *puVar1 = *puVar1 & 0xffff7fff;
  }
  return;
}



// public: void __thiscall CVProfNode::MarkFrame(void)

void __thiscall CVProfNode::MarkFrame(CVProfNode *this)

{
  uint *puVar1;
  uint uVar2;
  bool bVar3;
  
  do {
    *(int *)(this + 0x60) = *(int *)(this + 0x60) + *(int *)(this + 0x44);
    *(undefined4 *)(this + 0x58) = *(undefined4 *)(this + 0x48);
    *(undefined4 *)(this + 0x5c) = *(undefined4 *)(this + 0x4c);
    *(undefined4 *)(this + 0x10) = *(undefined4 *)(this + 0x14);
    *(int *)(this + 0x50) = *(int *)(this + 0x44);
    puVar1 = (uint *)(this + 0x68);
    uVar2 = *puVar1;
    *puVar1 = *puVar1 + *(uint *)(this + 0x48);
    *(uint *)(this + 0x6c) =
         *(int *)(this + 0x6c) + *(int *)(this + 0x4c) + (uint)CARRY4(uVar2,*(uint *)(this + 0x48));
    uVar2 = *(uint *)(this + 0x74);
    bVar3 = uVar2 < *(uint *)(this + 0x4c);
    if ((bVar3 || uVar2 == *(uint *)(this + 0x4c)) &&
       ((bVar3 || (*(uint *)(this + 0x70) < *(uint *)(this + 0x48))))) {
      *(undefined4 *)(this + 0x70) = *(undefined4 *)(this + 0x48);
      *(undefined4 *)(this + 0x74) = *(undefined4 *)(this + 0x4c);
    }
    *(int *)(this + 0x18) = *(int *)(this + 0x18) + *(int *)(this + 0x14);
    *(undefined4 *)(this + 0x48) = 0;
    *(undefined4 *)(this + 0x4c) = 0;
    *(undefined4 *)(this + 0x44) = 0;
    *(undefined4 *)(this + 0x14) = 0;
    if (*(CVProfNode **)(this + 0x7c) != (CVProfNode *)0x0) {
      MarkFrame(*(CVProfNode **)(this + 0x7c));
    }
    this = *(CVProfNode **)(this + 0x80);
  } while (this != (CVProfNode *)0x0);
  return;
}



// public: void __thiscall CVProfile::OutputReport(int,char const *,int)

void __thiscall CVProfile::OutputReport(CVProfile *this,int param_1,char *param_2,int param_3)

{
  CVProfNode *pCVar1;
  int iVar2;
  float10 extraout_ST0;
  double in_XMM0_Qa;
  double dVar3;
  code *pcVar4;
  int iVar5;
  
                    // 0x1a690  189  ?OutputReport@CVProfile@@QAEXHPBDH@Z
  Msg((byte *)"******** BEGIN VPROF REPORT ********\n");
  DAT_10833ed0 = 1;
  if (1 < *(int *)(this + 0x10a8) + -1) {
    DAT_10833ed0 = *(int *)(this + 0x10a8) + -1;
  }
  if (*(int *)(this + 0x10a8) != 0) {
    FUN_10001a1e(*(undefined4 *)(this + 0x1080),*(uint *)(this + 0x1084));
    in_XMM0_Qa = in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
    if (in_XMM0_Qa != 0.0) {
      if ((param_1 & 1U) != 0) {
        Msg((byte *)"-- Summary --\n");
        FUN_10001a1e(*(undefined4 *)(this + 0x1080),*(uint *)(this + 0x1084));
        dVar3 = in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier * 0.001;
        Msg((byte *)"%d frames sampled for %.2f seconds\n");
        FUN_10001a1e(*(undefined4 *)(this + 0x1080),*(uint *)(this + 0x1084));
        dVar3 = (dVar3 * g_ClockSpeedMillisecondsMultiplier) / (double)DAT_10833ed0;
        Msg((byte *)"Average %.2f fps, %.2f ms per frame\n");
        FUN_10001a1e(*(undefined4 *)(this + 0x1088),*(uint *)(this + 0x108c));
        dVar3 = dVar3 * g_ClockSpeedMillisecondsMultiplier;
        Msg((byte *)"Peak %.2f ms frame\n");
        CVProfNode::GetTotalTimeLessChildren((CVProfNode *)(this + 0x1018));
        FUN_10001a1e(*(undefined4 *)(this + 0x1080),*(uint *)(this + 0x1084));
        in_XMM0_Qa = 100.0;
        dVar3 = (double)((float10)100.0 -
                        extraout_ST0 / (float10)(dVar3 * g_ClockSpeedMillisecondsMultiplier));
        if (dVar3 <= 100.0) {
          in_XMM0_Qa = (double)((ulonglong)dVar3 & 0xffffffff |
                               (ulonglong)SUB164(ZEXT816((ulonglong)dVar3) >> 0x20,0) << 0x20);
        }
        Msg((byte *)"%.0f pct of time accounted for\n");
        Msg(&DAT_100392c0);
      }
      if (param_2 == (char *)0x0) {
        param_2 = *(char **)(this + 0x1018);
      }
      SumTimes(this,param_2,param_3);
      if ((param_1 & 2U) != 0) {
        Msg((byte *)"-- Hierarchical Call Graph --\n");
        pCVar1 = (CVProfNode *)param_2;
        if (((CVProfNode *)param_2 == (CVProfNode *)0x0) ||
           (pCVar1 = FindNode(this,(CVProfNode *)(this + 0x1018),param_2), DAT_10833ed4 = pCVar1,
           pCVar1 == (CVProfNode *)0x0)) {
          DAT_10833ed4 = pCVar1;
          pCVar1 = (CVProfNode *)(this + 0x1018);
        }
        DumpNodes(this,pCVar1,0,false);
        Msg(&DAT_100392c0);
      }
      if ((param_1 & 4U) != 0) {
        Msg((byte *)"-- Hierarchical Call Graph --\n");
        pCVar1 = (CVProfNode *)param_2;
        if (((CVProfNode *)param_2 == (CVProfNode *)0x0) ||
           (pCVar1 = FindNode(this,(CVProfNode *)(this + 0x1018),param_2), DAT_10833ed4 = pCVar1,
           pCVar1 == (CVProfNode *)0x0)) {
          DAT_10833ed4 = pCVar1;
          pCVar1 = (CVProfNode *)(this + 0x1018);
        }
        DumpNodes(this,pCVar1,0,true);
        Msg(&DAT_100392c0);
      }
      iVar2 = (-(uint)((param_1 & 0x200U) != 0) & 0xfff0bdda) + 999999;
      if ((param_1 & 8U) != 0) {
        pcVar4 = FUN_1001b110;
        iVar5 = iVar2;
        FUN_10001a1e(*(undefined4 *)(this + 0x1080),*(uint *)(this + 0x1084));
        in_XMM0_Qa = in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
        FUN_10019f40("-- Profile scopes sorted by time (including children) --",in_XMM0_Qa,pcVar4,
                     iVar5);
        Msg(&DAT_100392c0);
      }
      if ((param_1 & 0x10U) != 0) {
        pcVar4 = FUN_1001b130;
        iVar5 = iVar2;
        FUN_10001a1e(*(undefined4 *)(this + 0x1080),*(uint *)(this + 0x1084));
        in_XMM0_Qa = in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
        FUN_10019f40("-- Profile scopes sorted by time (without children) --",in_XMM0_Qa,pcVar4,
                     iVar5);
        Msg(&DAT_100392c0);
      }
      if ((param_1 & 0x20U) != 0) {
        pcVar4 = FUN_10019ae0;
        iVar5 = iVar2;
        FUN_10001a1e(*(undefined4 *)(this + 0x1080),*(uint *)(this + 0x1084));
        in_XMM0_Qa = in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
        FUN_10019f40("-- Profile scopes sorted by average time (including children) --",in_XMM0_Qa,
                     pcVar4,iVar5);
        Msg(&DAT_100392c0);
      }
      if ((param_1 & 0x40U) != 0) {
        pcVar4 = FUN_10019b50;
        iVar5 = iVar2;
        FUN_10001a1e(*(undefined4 *)(this + 0x1080),*(uint *)(this + 0x1084));
        in_XMM0_Qa = in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
        FUN_10019f40("-- Profile scopes sorted by average time (without children) --",in_XMM0_Qa,
                     pcVar4,iVar5);
        Msg(&DAT_100392c0);
      }
      if ((char)param_1 < '\0') {
        pcVar4 = FUN_1001ab60;
        iVar5 = iVar2;
        FUN_10001a1e(*(undefined4 *)(this + 0x1080),*(uint *)(this + 0x1084));
        in_XMM0_Qa = in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier;
        FUN_10019f40("-- Profile scopes sorted by peak --",in_XMM0_Qa,pcVar4,iVar5);
        Msg(&DAT_100392c0);
      }
      if ((param_1 & 0x100U) != 0) {
        pcVar4 = FUN_1001ab80;
        FUN_10001a1e(*(undefined4 *)(this + 0x1080),*(uint *)(this + 0x1084));
        FUN_10019f40("-- Profile scopes sorted by peak over average (including children) --",
                     in_XMM0_Qa * g_ClockSpeedMillisecondsMultiplier,pcVar4,iVar2);
        Msg(&DAT_100392c0);
      }
      FUN_1001b680(&DAT_108358d0);
      FUN_1001b680(&DAT_10833ee8);
      DAT_10833ef4 = DAT_10833ef0;
      Msg((byte *)"******** END VPROF REPORT ********\n");
      return;
    }
  }
  Msg((byte *)"No samples\n");
  Msg((byte *)"******** END VPROF REPORT ********\n");
  return;
}



// public: void __thiscall CVProfNode::Pause(void)

void __thiscall CVProfNode::Pause(CVProfNode *this)

{
  uint *puVar1;
  uint uVar2;
  undefined8 uVar3;
  uint uVar4;
  int iVar5;
  
  do {
    if (0 < *(int *)(this + 0x40)) {
      uVar3 = rdtsc();
      uVar2 = *(uint *)(this + 8);
      uVar4 = (uint)uVar3 - *(uint *)(this + 8);
      *(uint *)(this + 8) = uVar4;
      iVar5 = ((int)((ulonglong)uVar3 >> 0x20) - *(int *)(this + 0xc)) - (uint)((uint)uVar3 < uVar2)
      ;
      *(int *)(this + 0xc) = iVar5;
      puVar1 = (uint *)(this + 0x48);
      uVar2 = *puVar1;
      *puVar1 = *puVar1 + uVar4;
      *(uint *)(this + 0x4c) = *(int *)(this + 0x4c) + iVar5 + (uint)CARRY4(uVar2,uVar4);
      if ((DAT_10834fc4 != '\0') && (DAT_10834fc5 != '\0')) {
        FUN_10011380((int)(this + 0x20));
        *(int *)(this + 0x14) = *(int *)(this + 0x14) + *(int *)(this + 0x38);
      }
    }
    if (*(CVProfNode **)(this + 0x7c) != (CVProfNode *)0x0) {
      Pause(*(CVProfNode **)(this + 0x7c));
    }
    this = *(CVProfNode **)(this + 0x80);
  } while (this != (CVProfNode *)0x0);
  return;
}



bool __cdecl FUN_1001ab60(int param_1,int param_2)

{
  return *(double *)(param_2 + 0x18) <= *(double *)(param_1 + 0x18) &&
         *(double *)(param_1 + 0x18) != *(double *)(param_2 + 0x18);
}



bool __cdecl FUN_1001ab80(int param_1,int param_2)

{
  int iVar1;
  double dVar2;
  double dVar3;
  double dVar4;
  
  dVar3 = 0.0;
  iVar1 = *(int *)(param_1 + 4);
  dVar2 = dVar3;
  if (iVar1 != 0) {
    dVar2 = *(double *)(param_1 + 8) / ((double)iVar1 + (double)(&DAT_100366d0)[-(iVar1 >> 0x1f)]);
  }
  iVar1 = *(int *)(param_2 + 4);
  dVar4 = dVar3;
  if (iVar1 != 0) {
    dVar4 = *(double *)(param_2 + 8) / ((double)iVar1 + (double)(&DAT_100366d0)[-(iVar1 >> 0x1f)]);
  }
  if (dVar2 == 0.0) {
    dVar2 = 0.0;
  }
  else {
    dVar2 = *(double *)(param_1 + 0x18) / dVar2;
  }
  if (dVar4 != 0.0) {
    dVar3 = *(double *)(param_2 + 0x18) / dVar4;
  }
  return dVar3 < dVar2;
}



// public: void __thiscall CVProfile::RegisterNumBudgetGroupsChangedCallBack(void (__cdecl*)(void))

void __thiscall CVProfile::RegisterNumBudgetGroupsChangedCallBack(CVProfile *this,FuncDef4 *param_1)

{
                    // 0x1ac20  197  ?RegisterNumBudgetGroupsChangedCallBack@CVProfile@@QAEXP6AXXZ@Z
  *(FuncDef4 **)(this + 0x10c0) = param_1;
  return;
}



// public: void __thiscall CVProfNode::Reset(void)

void __thiscall CVProfNode::Reset(CVProfNode *this)

{
  do {
    *(undefined4 *)(this + 0x50) = 0;
    *(undefined4 *)(this + 0x58) = 0;
    *(undefined4 *)(this + 0x5c) = 0;
    *(undefined4 *)(this + 0x44) = 0;
    *(undefined4 *)(this + 0x48) = 0;
    *(undefined4 *)(this + 0x4c) = 0;
    *(undefined4 *)(this + 0x60) = 0;
    *(undefined4 *)(this + 0x68) = 0;
    *(undefined4 *)(this + 0x6c) = 0;
    *(undefined4 *)(this + 0x70) = 0;
    *(undefined4 *)(this + 0x74) = 0;
    *(undefined4 *)(this + 0x10) = 0;
    *(undefined4 *)(this + 0x14) = 0;
    *(undefined4 *)(this + 0x18) = 0;
    if (*(CVProfNode **)(this + 0x7c) != (CVProfNode *)0x0) {
      Reset(*(CVProfNode **)(this + 0x7c));
    }
    this = *(CVProfNode **)(this + 0x80);
  } while (this != (CVProfNode *)0x0);
  return;
}



// public: void __thiscall CVProfile::ResetCounters(enum CounterGroup_t)

void __thiscall CVProfile::ResetCounters(CVProfile *this,CounterGroup_t param_1)

{
  int iVar1;
  undefined4 *puVar2;
  
                    // 0x1acb0  206  ?ResetCounters@CVProfile@@QAEXW4CounterGroup_t@@@Z
  iVar1 = 0;
  if (0 < *(int *)(this + 0x19c8)) {
    puVar2 = (undefined4 *)(this + 0x10c8);
    do {
      if ((int)(char)this[iVar1 + 0x14c8] == param_1) {
        *puVar2 = 0;
      }
      iVar1 = iVar1 + 1;
      puVar2 = puVar2 + 1;
    } while (iVar1 < *(int *)(this + 0x19c8));
  }
  return;
}



// public: void __thiscall CVProfNode::ResetPeak(void)

void __thiscall CVProfNode::ResetPeak(CVProfNode *this)

{
  do {
    *(undefined4 *)(this + 0x70) = 0;
    *(undefined4 *)(this + 0x74) = 0;
    if (*(CVProfNode **)(this + 0x7c) != (CVProfNode *)0x0) {
      ResetPeak(*(CVProfNode **)(this + 0x7c));
    }
    this = *(CVProfNode **)(this + 0x80);
  } while (this != (CVProfNode *)0x0);
  return;
}



// public: void __thiscall CVProfNode::Resume(void)

void __thiscall CVProfNode::Resume(CVProfNode *this)

{
  undefined8 uVar1;
  
  do {
    if (0 < *(int *)(this + 0x40)) {
      uVar1 = rdtsc();
      *(int *)(this + 8) = (int)uVar1;
      *(int *)(this + 0xc) = (int)((ulonglong)uVar1 >> 0x20);
      if ((DAT_10834fc4 != '\0') && (DAT_10834fc5 != '\0')) {
        FUN_100113f0((int)(this + 0x20));
      }
    }
    if (*(CVProfNode **)(this + 0x7c) != (CVProfNode *)0x0) {
      Resume(*(CVProfNode **)(this + 0x7c));
    }
    this = *(CVProfNode **)(this + 0x80);
  } while (this != (CVProfNode *)0x0);
  return;
}



// public: void __thiscall CVProfNode::SetCurFrameTime(unsigned long)

void __thiscall CVProfNode::SetCurFrameTime(CVProfNode *this,ulong param_1)

{
  ulonglong uVar1;
  
                    // 0x1ad80  217  ?SetCurFrameTime@CVProfNode@@QAEXK@Z
  if (0.0 < g_ClockSpeedMillisecondsMultiplier) {
    uVar1 = FUN_10001900();
    *(int *)(this + 0x48) = (int)uVar1;
    *(int *)(this + 0x4c) = (int)(uVar1 >> 0x20);
    return;
  }
  *(undefined4 *)(this + 0x48) = 0;
  *(undefined4 *)(this + 0x4c) = 0;
  return;
}



// protected: void __thiscall CVProfile::SumTimes(class CVProfNode *,int)

void __thiscall CVProfile::SumTimes(CVProfile *this,CVProfNode *param_1,int param_2)

{
  bool bVar1;
  int iVar2;
  int *piVar3;
  int iVar4;
  double dVar5;
  double local_30;
  undefined4 local_28;
  undefined4 local_24;
  double local_20;
  double local_18;
  undefined8 local_10;
  CVProfile *local_8;
  
                    // 0x1ade0  231  ?SumTimes@CVProfile@@IAEXPAVCVProfNode@@H@Z
  if (param_1 == (CVProfNode *)0x0) {
    return;
  }
  local_8 = this;
  if ((DAT_10833ed4 == (CVProfNode *)0x0) &&
     (iVar2 = FUN_10023a9c(*(byte **)param_1,DAT_10833ed8), iVar2 == 0)) {
    DAT_10833ed4 = param_1;
    bVar1 = true;
  }
  else {
    bVar1 = false;
  }
  iVar2 = param_2;
  if (this + 0x1018 != (CVProfile *)param_1) {
    if (DAT_10833ed4 != (CVProfNode *)0x0) {
      if ((*(int *)(param_1 + 0x60) != 0) &&
         ((param_2 == 0xffffffff || (*(uint *)(param_1 + 0x84) == param_2)))) {
        dVar5 = CVProfNode::GetTotalTimeLessChildren(param_1);
        local_18 = (double)((ulonglong)local_18 & 0xffffffff00000000 | ZEXT48(param_1));
        local_30 = dVar5;
        local_10 = dVar5;
        piVar3 = FUN_10018130(&DAT_108358d0,(undefined4 *)&local_18);
        FUN_10018690(&DAT_108358d0,(undefined4 *)&local_10,'\0',(int **)(piVar3 + 4),piVar3);
        param_2 = *(int *)param_1;
        piVar3 = (int *)FUN_1001b9e0(&DAT_10833ee8,(int *)((int)&local_10 + 4),(uint *)&param_2);
        if (*piVar3 == DAT_10833ee8) {
          local_28 = *(undefined4 *)param_1;
          local_24 = *(undefined4 *)(param_1 + 0x60);
          FUN_10001a1e(*(undefined4 *)(param_1 + 0x68),*(uint *)(param_1 + 0x6c));
          local_20 = dVar5 * g_ClockSpeedMillisecondsMultiplier;
          local_18 = local_30;
          FUN_10001a1e(*(undefined4 *)(param_1 + 0x70),*(uint *)(param_1 + 0x74));
          local_10 = local_30 * g_ClockSpeedMillisecondsMultiplier;
          local_30 = (double)CONCAT44(DAT_10833ef4 - DAT_10833ef0 >> 5,*(undefined4 *)param_1);
          piVar3 = FUN_100181c0(&DAT_10833ee8,(undefined4 *)&local_30);
          FUN_100187a0(&DAT_10833ee8,(undefined4 *)&local_30,'\0',(int **)(piVar3 + 4),piVar3);
          FUN_1001ba30(&DAT_10833ef0,&local_28);
        }
        else {
          iVar4 = *(int *)(*piVar3 + 0x14) * 0x20 + DAT_10833ef0;
          *(int *)(iVar4 + 4) = *(int *)(iVar4 + 4) + *(int *)(param_1 + 0x60);
          FUN_10001a1e(*(undefined4 *)(param_1 + 0x68),*(uint *)(param_1 + 0x6c));
          *(double *)(iVar4 + 8) =
               dVar5 * g_ClockSpeedMillisecondsMultiplier + *(double *)(iVar4 + 8);
          dVar5 = *(double *)(iVar4 + 0x10) + local_30;
          *(double *)(iVar4 + 0x10) = dVar5;
          FUN_10001a1e(*(undefined4 *)(param_1 + 0x70),*(uint *)(param_1 + 0x74));
          dVar5 = dVar5 * g_ClockSpeedMillisecondsMultiplier;
          this = local_8;
          if (*(double *)(iVar4 + 0x18) <= dVar5 && dVar5 != *(double *)(iVar4 + 0x18)) {
            *(double *)(iVar4 + 0x18) = dVar5;
          }
        }
      }
      if ((DAT_10833ed4 != (CVProfNode *)0x0) && (param_1 == DAT_10833ed4)) goto LAB_1001afcc;
    }
    if (*(CVProfNode **)(param_1 + 0x80) != (CVProfNode *)0x0) {
      SumTimes(this,*(CVProfNode **)(param_1 + 0x80),iVar2);
    }
  }
LAB_1001afcc:
  if (*(CVProfNode **)(param_1 + 0x7c) != (CVProfNode *)0x0) {
    SumTimes(this,*(CVProfNode **)(param_1 + 0x7c),iVar2);
  }
  if (bVar1) {
    DAT_10833ed4 = (CVProfNode *)0x0;
  }
  return;
}



// protected: void __thiscall CVProfile::SumTimes(char const *,int)

void __thiscall CVProfile::SumTimes(CVProfile *this,char *param_1,int param_2)

{
                    // 0x1b000  232  ?SumTimes@CVProfile@@IAEXPBDH@Z
  if (*(int *)(this + 0x1094) != 0) {
    if (param_1 == (char *)0x0) {
      DAT_10833ed4 = this + 0x1018;
    }
    else {
      DAT_10833ed4 = (CVProfile *)0x0;
    }
    DAT_10833ed8 = param_1;
    SumTimes(this,(CVProfNode *)(this + 0x1018),param_2);
    DAT_10833ed4 = (CVProfile *)0x0;
  }
  return;
}



// public: void __thiscall CVProfile::Term(void)

void __thiscall CVProfile::Term(CVProfile *this)

{
  CVProfNode *pCVar1;
  CVProfNode *pCVar2;
  int iVar3;
  void **ppvVar4;
  
                    // 0x1b050  234  ?Term@CVProfile@@QAEXXZ
  iVar3 = 0;
  if (0 < *(int *)(this + 0x10bc)) {
    do {
      FID_conflict__free(*(void **)(*(int *)(this + 0x10b4) + iVar3 * 8));
      iVar3 = iVar3 + 1;
    } while (iVar3 < *(int *)(this + 0x10bc));
  }
  FID_conflict__free(*(void **)(this + 0x10b4));
  iVar3 = 0;
  *(undefined4 *)(this + 0x10b8) = 0;
  *(undefined4 *)(this + 0x10bc) = 0;
  *(undefined4 *)(this + 0x10b4) = 0;
  if (0 < *(int *)(this + 0x19c8)) {
    ppvVar4 = (void **)(this + 0x15c8);
    do {
      FID_conflict__free(*ppvVar4);
      *ppvVar4 = (void *)0x0;
      ppvVar4 = ppvVar4 + 1;
      iVar3 = iVar3 + 1;
    } while (iVar3 < *(int *)(this + 0x19c8));
  }
  *(undefined4 *)(this + 0x19c8) = 0;
  if (this != (CVProfile *)0xffffefe8) {
    pCVar2 = *(CVProfNode **)(this + 0x1094);
    while (pCVar2 != (CVProfNode *)0x0) {
      pCVar1 = *(CVProfNode **)(pCVar2 + 0x80);
      FreeNodes_R(this,pCVar2);
      pCVar2 = pCVar1;
    }
    *(undefined4 *)(this + 0x1094) = 0;
  }
  return;
}



bool __cdecl FUN_1001b110(int param_1,int param_2)

{
  return *(double *)(param_2 + 8) <= *(double *)(param_1 + 8) &&
         *(double *)(param_1 + 8) != *(double *)(param_2 + 8);
}



bool __cdecl FUN_1001b130(int param_1,int param_2)

{
  return *(double *)(param_2 + 0x10) <= *(double *)(param_1 + 0x10) &&
         *(double *)(param_1 + 0x10) != *(double *)(param_2 + 0x10);
}



uint __thiscall FUN_1001b150(void *this,uint param_1)

{
  code *pcVar1;
  uint in_EAX;
  int iVar2;
  uint uVar3;
  
  *(undefined4 *)this = 0;
  *(undefined4 *)((int)this + 4) = 0;
  *(undefined4 *)((int)this + 8) = 0;
  if (param_1 == 0) {
    return in_EAX & 0xffffff00;
  }
  if (param_1 < 0x8000000) {
    iVar2 = FUN_1001f8b3(param_1 * 0x20);
    if (iVar2 != 0) {
      *(int *)this = iVar2;
      *(int *)((int)this + 4) = iVar2;
      iVar2 = iVar2 + param_1 * 0x20;
      *(int *)((int)this + 8) = iVar2;
      return CONCAT31((int3)((uint)iVar2 >> 8),1);
    }
  }
  else {
    FUN_10034d68("vector<T> too long");
  }
  FUN_10034d37();
  pcVar1 = (code *)swi(3);
  uVar3 = (*pcVar1)();
  return uVar3;
}



void FUN_1001b1c0(void)

{
  int iVar1;
  undefined4 *in_FS_OFFSET;
  undefined4 local_10;
  code *pcStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  pcStack12 = FUN_10035020;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_10;
  iVar1 = FUN_1001f8b3(0x20);
  if (iVar1 == 0) {
    iVar1 = FUN_10034d37();
  }
  *(int *)iVar1 = iVar1;
  if ((int *)(iVar1 + 4) != (int *)0x0) {
    *(int *)(iVar1 + 4) = iVar1;
  }
  if ((int *)(iVar1 + 8) != (int *)0x0) {
    *(int *)(iVar1 + 8) = iVar1;
  }
  *(undefined2 *)(iVar1 + 0xc) = 0x101;
  *in_FS_OFFSET = local_10;
  return;
}



void Catch_1001b230(void)

{
  code *pcVar1;
  int unaff_EBP;
  
  FID_conflict__free(*(void **)(unaff_EBP + -0x14));
  FUN_1002364d((int *)0x0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void FUN_1001b250(void)

{
  int iVar1;
  undefined4 *in_FS_OFFSET;
  undefined4 local_10;
  code *pcStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  pcStack12 = FUN_10035030;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_10;
  iVar1 = FUN_1001f8b3(0x18);
  if (iVar1 == 0) {
    iVar1 = FUN_10034d37();
  }
  *(int *)iVar1 = iVar1;
  if ((int *)(iVar1 + 4) != (int *)0x0) {
    *(int *)(iVar1 + 4) = iVar1;
  }
  if ((int *)(iVar1 + 8) != (int *)0x0) {
    *(int *)(iVar1 + 8) = iVar1;
  }
  *(undefined2 *)(iVar1 + 0xc) = 0x101;
  *in_FS_OFFSET = local_10;
  return;
}



void Catch_1001b2c0(void)

{
  code *pcVar1;
  int unaff_EBP;
  
  FID_conflict__free(*(void **)(unaff_EBP + -0x14));
  FUN_1002364d((int *)0x0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



undefined4 * __fastcall FUN_1001b2e0(undefined4 *param_1)

{
  undefined4 *puVar1;
  undefined4 *extraout_EDX;
  undefined4 *in_FS_OFFSET;
  undefined4 local_10;
  code *pcStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  pcStack12 = FUN_10035040;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_10;
  puVar1 = (undefined4 *)FUN_1001f8b3(0x20);
  if (puVar1 == (undefined4 *)0x0) {
    FUN_10034d37();
    puVar1 = extraout_EDX;
  }
  *puVar1 = *param_1;
  if (puVar1 + 1 != (undefined4 *)0x0) {
    puVar1[1] = *param_1;
  }
  if (puVar1 + 2 != (undefined4 *)0x0) {
    puVar1[2] = *param_1;
  }
  *in_FS_OFFSET = local_10;
  return puVar1;
}



void Catch_1001b356(void)

{
  code *pcVar1;
  int unaff_EBP;
  
  FID_conflict__free(*(void **)(unaff_EBP + -0x14));
  FUN_1002364d((int *)0x0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



undefined4 * __fastcall FUN_1001b370(undefined4 *param_1)

{
  undefined4 *puVar1;
  undefined4 *extraout_EDX;
  undefined4 *in_FS_OFFSET;
  undefined4 local_10;
  code *pcStack12;
  undefined4 local_8;
  
  local_8 = 0xffffffff;
  pcStack12 = FUN_10035050;
  local_10 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_10;
  puVar1 = (undefined4 *)FUN_1001f8b3(0x18);
  if (puVar1 == (undefined4 *)0x0) {
    FUN_10034d37();
    puVar1 = extraout_EDX;
  }
  *puVar1 = *param_1;
  if (puVar1 + 1 != (undefined4 *)0x0) {
    puVar1[1] = *param_1;
  }
  if (puVar1 + 2 != (undefined4 *)0x0) {
    puVar1[2] = *param_1;
  }
  *in_FS_OFFSET = local_10;
  return puVar1;
}



void Catch_1001b3e6(void)

{
  code *pcVar1;
  int unaff_EBP;
  
  FID_conflict__free(*(void **)(unaff_EBP + -0x14));
  FUN_1002364d((int *)0x0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void FUN_1001b400(int *param_1)

{
  char cVar1;
  int *piVar2;
  
  cVar1 = *(char *)((int)param_1 + 0xd);
  while (cVar1 == '\0') {
    FUN_1001b400((int *)param_1[2]);
    piVar2 = (int *)*param_1;
    FID_conflict__free(param_1);
    param_1 = piVar2;
    cVar1 = *(char *)((int)piVar2 + 0xd);
  }
  return;
}



void __thiscall FUN_1001b440(void *this,int *param_1)

{
  int **ppiVar1;
  int **ppiVar2;
  
  ppiVar1 = (int **)param_1[2];
  param_1[2] = (int)*ppiVar1;
  if (*(char *)((int)*ppiVar1 + 0xd) == '\0') {
    (*ppiVar1)[1] = (int)param_1;
  }
  ppiVar1[1] = (int *)param_1[1];
                    // WARNING: Load size is inaccurate
  if (param_1 == *(int **)(*this + 4)) {
    *(int ***)(*this + 4) = ppiVar1;
    *ppiVar1 = param_1;
    param_1[1] = (int)ppiVar1;
    return;
  }
  ppiVar2 = (int **)param_1[1];
  if (param_1 == *ppiVar2) {
    *ppiVar2 = (int *)ppiVar1;
    *ppiVar1 = param_1;
    param_1[1] = (int)ppiVar1;
    return;
  }
  ppiVar2[2] = (int *)ppiVar1;
  *ppiVar1 = param_1;
  param_1[1] = (int)ppiVar1;
  return;
}



void Catch_1001b54d(void)

{
  code *pcVar1;
  int unaff_EBP;
  
  FID_conflict__free(*(void **)(unaff_EBP + -0x14));
  FUN_1002364d((int *)0x0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void __thiscall FUN_1001b570(void *this,uint param_1)

{
  void *_Memory;
  code *pcVar1;
  uint uVar2;
  int iVar3;
  uint uVar4;
  undefined4 *puVar5;
  undefined4 *in_FS_OFFSET;
  undefined4 *local_18;
  undefined4 uVar6;
  
  if (param_1 <= (uint)(*(int *)((int)this + 8) - *(int *)((int)this + 4) >> 5)) {
    return;
  }
                    // WARNING: Load size is inaccurate
  iVar3 = *(int *)((int)this + 4) - *this >> 5;
  if (param_1 <= 0x7ffffffU - iVar3) {
                    // WARNING: Load size is inaccurate
    uVar4 = iVar3 + param_1;
    uVar2 = *(int *)((int)this + 8) - *this >> 5;
    if (0x7ffffff - (uVar2 >> 1) < uVar2) {
      param_1 = 0;
      if (uVar4 != 0) {
        param_1 = uVar4;
      }
    }
    else {
      param_1 = uVar2 + (uVar2 >> 1);
      if (param_1 < uVar4) {
        param_1 = uVar4;
      }
    }
    uVar6 = *in_FS_OFFSET;
    *in_FS_OFFSET = &stack0xfffffff0;
    local_18 = (undefined4 *)0x0;
    puVar5 = (undefined4 *)0x0;
    if ((param_1 != 0) &&
       ((0x7ffffff < param_1 ||
        (local_18 = (undefined4 *)FUN_1001f8b3(param_1 << 5), puVar5 = local_18,
        local_18 == (undefined4 *)0x0)))) {
      FUN_10034d37();
      puVar5 = local_18;
    }
                    // WARNING: Load size is inaccurate
    FUN_10018e20(*this,*(undefined4 **)((int)this + 4),puVar5);
                    // WARNING: Load size is inaccurate
    _Memory = *this;
    iVar3 = *(int *)((int)this + 4);
    if (_Memory != (void *)0x0) {
      FID_conflict__free(_Memory);
    }
    *(undefined4 **)((int)this + 8) = puVar5 + param_1 * 8;
    *(uint *)((int)this + 4) = (iVar3 - (int)_Memory & 0xffffffe0U) + (int)puVar5;
    *(undefined4 **)this = puVar5;
    *in_FS_OFFSET = uVar6;
    return;
  }
  FUN_10034d68("vector<T> too long");
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void __thiscall FUN_1001b5f0(void *this,int *param_1)

{
  int iVar1;
  int *piVar2;
  
  iVar1 = *param_1;
  *param_1 = *(int *)(iVar1 + 8);
  if (*(char *)(*(int *)(iVar1 + 8) + 0xd) == '\0') {
    *(int **)(*(int *)(iVar1 + 8) + 4) = param_1;
  }
  *(int *)(iVar1 + 4) = param_1[1];
                    // WARNING: Load size is inaccurate
  if (param_1 == *(int **)(*this + 4)) {
    *(int *)(*this + 4) = iVar1;
    *(int **)(iVar1 + 8) = param_1;
    param_1[1] = iVar1;
    return;
  }
  piVar2 = (int *)param_1[1];
  if (param_1 == (int *)piVar2[2]) {
    piVar2[2] = iVar1;
    *(int **)(iVar1 + 8) = param_1;
    param_1[1] = iVar1;
    return;
  }
  *piVar2 = iVar1;
  *(int **)(iVar1 + 8) = param_1;
  param_1[1] = iVar1;
  return;
}



void __fastcall FUN_1001b650(void **param_1)

{
  if (*param_1 != (void *)0x0) {
    FID_conflict__free(*param_1);
    *param_1 = (void *)0x0;
    param_1[1] = (void *)0x0;
    param_1[2] = (void *)0x0;
  }
  return;
}



void __fastcall FUN_1001b680(int *param_1)

{
  char cVar1;
  int *piVar2;
  int *_Memory;
  
  cVar1 = *(char *)((int)*(int **)(*param_1 + 4) + 0xd);
  _Memory = *(int **)(*param_1 + 4);
  while (cVar1 == '\0') {
    FUN_1001b400((int *)_Memory[2]);
    piVar2 = (int *)*_Memory;
    FID_conflict__free(_Memory);
    _Memory = piVar2;
    cVar1 = *(char *)((int)piVar2 + 0xd);
  }
  *(int *)(*param_1 + 4) = *param_1;
  *(int *)*param_1 = *param_1;
  *(int *)(*param_1 + 8) = *param_1;
  param_1[1] = 0;
  return;
}



int ** __thiscall FUN_1001b6d0(void *this,int **param_1,int **param_2,int **param_3)

{
  char cVar1;
  int **ppiVar2;
  int **ppiVar3;
  int **ppiVar4;
  int *local_8;
  
                    // WARNING: Load size is inaccurate
  local_8 = (int *)this;
  if ((param_2 == (int **)**this) && (param_3 == *this)) {
    FUN_1001b680((int *)this);
                    // WARNING: Load size is inaccurate
    *param_1 = **this;
    return param_1;
  }
  if (param_2 != param_3) {
    do {
      ppiVar3 = param_2;
      if (*(char *)((int)param_2 + 0xd) == '\0') {
        ppiVar2 = (int **)param_2[2];
        if (*(char *)((int)ppiVar2 + 0xd) == '\0') {
          cVar1 = *(char *)((int)*ppiVar2 + 0xd);
          param_2 = ppiVar2;
          ppiVar2 = (int **)*ppiVar2;
          while (cVar1 == '\0') {
            cVar1 = *(char *)((int)*ppiVar2 + 0xd);
            param_2 = ppiVar2;
            ppiVar2 = (int **)*ppiVar2;
          }
        }
        else {
          cVar1 = *(char *)((int)param_2[1] + 0xd);
          ppiVar4 = (int **)param_2[1];
          ppiVar2 = param_2;
          while ((param_2 = ppiVar4, cVar1 == '\0' && (ppiVar2 == (int **)param_2[2]))) {
            cVar1 = *(char *)((int)param_2[1] + 0xd);
            ppiVar4 = (int **)param_2[1];
            ppiVar2 = param_2;
          }
        }
      }
      FUN_1001b770(this,&local_8,ppiVar3);
    } while (param_2 != param_3);
  }
  *param_1 = (int *)param_2;
  return param_1;
}



void __thiscall FUN_1001b770(void *this,int **param_1,int **param_2)

{
  undefined uVar1;
  char cVar2;
  int *piVar3;
  int **ppiVar4;
  int **_Memory;
  int **ppiVar5;
  int **ppiVar6;
  int **ppiVar7;
  int **ppiVar8;
  
  _Memory = param_2;
  FUN_10019920((int **)&param_2);
  ppiVar6 = (int **)*_Memory;
  if (*(char *)((int)ppiVar6 + 0xd) == '\0') {
    ppiVar8 = ppiVar6;
    if ((*(char *)((int)_Memory[2] + 0xd) == '\0') &&
       (ppiVar8 = (int **)param_2[2], param_2 != _Memory)) {
      ppiVar6[1] = (int *)param_2;
      *param_2 = *_Memory;
      ppiVar6 = param_2;
      if (param_2 != (int **)_Memory[2]) {
        ppiVar6 = (int **)param_2[1];
        if (*(char *)((int)ppiVar8 + 0xd) == '\0') {
          ppiVar8[1] = (int *)ppiVar6;
        }
        *ppiVar6 = (int *)ppiVar8;
        param_2[2] = _Memory[2];
        _Memory[2][1] = (int)param_2;
      }
                    // WARNING: Load size is inaccurate
      if (*(int ***)(*this + 4) == _Memory) {
        *(int ***)(*this + 4) = param_2;
      }
      else {
        piVar3 = _Memory[1];
        if ((int **)*piVar3 == _Memory) {
          *piVar3 = (int)param_2;
        }
        else {
          piVar3[2] = (int)param_2;
        }
      }
      param_2[1] = _Memory[1];
      uVar1 = *(undefined *)(param_2 + 3);
      *(undefined *)(param_2 + 3) = *(undefined *)(_Memory + 3);
      *(undefined *)(_Memory + 3) = uVar1;
      goto LAB_1001b895;
    }
  }
  else {
    ppiVar8 = (int **)_Memory[2];
  }
  ppiVar6 = (int **)_Memory[1];
  if (*(char *)((int)ppiVar8 + 0xd) == '\0') {
    ppiVar8[1] = (int *)ppiVar6;
  }
                    // WARNING: Load size is inaccurate
  if (*(int ***)(*this + 4) == _Memory) {
    *(int ***)(*this + 4) = ppiVar8;
  }
  else if ((int **)*ppiVar6 == _Memory) {
    *ppiVar6 = (int *)ppiVar8;
  }
  else {
    ppiVar6[2] = (int *)ppiVar8;
  }
                    // WARNING: Load size is inaccurate
  ppiVar5 = *this;
  if ((int **)*ppiVar5 == _Memory) {
    ppiVar7 = ppiVar6;
    if (*(char *)((int)ppiVar8 + 0xd) == '\0') {
      cVar2 = *(char *)((int)*ppiVar8 + 0xd);
      ppiVar5 = (int **)*ppiVar8;
      ppiVar7 = ppiVar8;
      while (ppiVar4 = ppiVar5, cVar2 == '\0') {
        ppiVar5 = (int **)*ppiVar4;
        cVar2 = *(char *)((int)ppiVar5 + 0xd);
        ppiVar7 = ppiVar4;
      }
                    // WARNING: Load size is inaccurate
      ppiVar5 = *this;
    }
    *ppiVar5 = (int *)ppiVar7;
  }
                    // WARNING: Load size is inaccurate
  if (*(int ***)(*this + 8) == _Memory) {
    if (*(char *)((int)ppiVar8 + 0xd) == '\0') {
      cVar2 = *(char *)((int)ppiVar8[2] + 0xd);
      ppiVar5 = (int **)ppiVar8[2];
      ppiVar7 = ppiVar8;
      while (ppiVar4 = ppiVar5, cVar2 == '\0') {
        ppiVar5 = (int **)ppiVar4[2];
        cVar2 = *(char *)((int)ppiVar5 + 0xd);
        ppiVar7 = ppiVar4;
      }
                    // WARNING: Load size is inaccurate
      *(int ***)(*this + 8) = ppiVar7;
    }
    else {
      *(int ***)(*this + 8) = ppiVar6;
    }
  }
LAB_1001b895:
  if (*(char *)(_Memory + 3) == '\x01') {
                    // WARNING: Load size is inaccurate
    if (ppiVar8 != *(int ***)(*this + 4)) {
      do {
        ppiVar5 = ppiVar6;
        if (*(char *)(ppiVar8 + 3) != '\x01') break;
        ppiVar6 = (int **)*ppiVar5;
        if (ppiVar8 == ppiVar6) {
          ppiVar6 = (int **)ppiVar5[2];
          if (*(char *)(ppiVar6 + 3) == '\0') {
            *(undefined *)(ppiVar6 + 3) = 1;
            *(undefined *)(ppiVar5 + 3) = 0;
            FUN_1001b440(this,(int *)ppiVar5);
            ppiVar6 = (int **)ppiVar5[2];
          }
          if (*(char *)((int)ppiVar6 + 0xd) == '\0') {
            if ((*(char *)(*ppiVar6 + 3) != '\x01') || (*(char *)(ppiVar6[2] + 3) != '\x01')) {
              if (*(char *)(ppiVar6[2] + 3) == '\x01') {
                *(undefined *)(*ppiVar6 + 3) = 1;
                *(undefined *)(ppiVar6 + 3) = 0;
                FUN_1001b5f0(this,(int *)ppiVar6);
                ppiVar6 = (int **)ppiVar5[2];
              }
              *(undefined *)(ppiVar6 + 3) = *(undefined *)(ppiVar5 + 3);
              *(undefined *)(ppiVar5 + 3) = 1;
              *(undefined *)(ppiVar6[2] + 3) = 1;
              FUN_1001b440(this,(int *)ppiVar5);
              break;
            }
LAB_1001b95f:
            *(undefined *)(ppiVar6 + 3) = 0;
          }
        }
        else {
          if (*(char *)(ppiVar6 + 3) == '\0') {
            *(undefined *)(ppiVar6 + 3) = 1;
            *(undefined *)(ppiVar5 + 3) = 0;
            FUN_1001b5f0(this,(int *)ppiVar5);
            ppiVar6 = (int **)*ppiVar5;
          }
          if (*(char *)((int)ppiVar6 + 0xd) == '\0') {
            if ((*(char *)(ppiVar6[2] + 3) == '\x01') && (*(char *)(*ppiVar6 + 3) == '\x01'))
            goto LAB_1001b95f;
            if (*(char *)(*ppiVar6 + 3) == '\x01') {
              *(undefined *)(ppiVar6[2] + 3) = 1;
              *(undefined *)(ppiVar6 + 3) = 0;
              FUN_1001b440(this,(int *)ppiVar6);
              ppiVar6 = (int **)*ppiVar5;
            }
            *(undefined *)(ppiVar6 + 3) = *(undefined *)(ppiVar5 + 3);
            *(undefined *)(ppiVar5 + 3) = 1;
            *(undefined *)(*ppiVar6 + 3) = 1;
            FUN_1001b5f0(this,(int *)ppiVar5);
            break;
          }
        }
                    // WARNING: Load size is inaccurate
        ppiVar6 = (int **)ppiVar5[1];
        ppiVar8 = ppiVar5;
      } while (ppiVar5 != *(int ***)(*this + 4));
    }
    *(undefined *)(ppiVar8 + 3) = 1;
  }
  FID_conflict__free(_Memory);
  if (*(int *)((int)this + 4) != 0) {
    *(int *)((int)this + 4) = *(int *)((int)this + 4) + -1;
  }
  *param_1 = (int *)param_2;
  return;
}



void __thiscall FUN_1001b9e0(void *this,int *param_1,uint *param_2)

{
  uint *puVar1;
  uint uVar2;
  uint **ppuVar3;
  uint *puVar4;
  uint **ppuVar5;
  
                    // WARNING: Load size is inaccurate
  puVar1 = *this;
  ppuVar5 = (uint **)puVar1;
  if (*(char *)((int)(uint *)puVar1[1] + 0xd) == '\0') {
    ppuVar3 = (uint **)(uint *)puVar1[1];
    do {
      if (ppuVar3[4] < *param_2) {
        puVar4 = ppuVar3[2];
      }
      else {
        puVar4 = *ppuVar3;
        ppuVar5 = ppuVar3;
      }
      ppuVar3 = (uint **)puVar4;
    } while (*(char *)((int)puVar4 + 0xd) == '\0');
  }
  if ((ppuVar5 == (uint **)puVar1) ||
     (uVar2 = *param_2, param_2 = (uint *)ppuVar5, uVar2 < ppuVar5[4])) {
    param_2 = puVar1;
  }
  *param_1 = (int)param_2;
  return;
}



void __thiscall FUN_1001ba30(void *this,undefined4 *param_1)

{
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 uVar3;
  undefined4 uVar4;
  undefined4 uVar5;
  
  puVar1 = *(undefined4 **)((int)this + 4);
                    // WARNING: Load size is inaccurate
  if ((param_1 < puVar1) && (puVar2 = *this, puVar2 <= param_1)) {
    if (puVar1 == *(undefined4 **)((int)this + 8)) {
      FUN_1001b570(this,1);
    }
                    // WARNING: Load size is inaccurate
    param_1 = (undefined4 *)(((int)param_1 - (int)puVar2 & 0xffffffe0U) + *this);
  }
  else if (puVar1 == *(undefined4 **)((int)this + 8)) {
    FUN_1001b570(this,1);
  }
  puVar1 = *(undefined4 **)((int)this + 4);
  if (puVar1 != (undefined4 *)0x0) {
    uVar3 = param_1[1];
    uVar4 = param_1[2];
    uVar5 = param_1[3];
    *puVar1 = *param_1;
    puVar1[1] = uVar3;
    puVar1[2] = uVar4;
    puVar1[3] = uVar5;
    uVar3 = param_1[5];
    uVar4 = param_1[6];
    uVar5 = param_1[7];
    puVar1[4] = param_1[4];
    puVar1[5] = uVar3;
    puVar1[6] = uVar4;
    puVar1[7] = uVar5;
  }
  *(int *)((int)this + 4) = *(int *)((int)this + 4) + 0x20;
  return;
}



void __cdecl InitWin32ConsoleColorContext(uint *param_1)

{
  HANDLE hConsoleOutput;
  PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo;
  undefined local_1c [24];
  
                    // 0x1ba90  346  InitWin32ConsoleColorContext
  lpConsoleScreenBufferInfo = (PCONSOLE_SCREEN_BUFFER_INFO)local_1c;
  hConsoleOutput = GetStdHandle(0xfffffff5);
  GetConsoleScreenBufferInfo(hConsoleOutput,lpConsoleScreenBufferInfo);
  *(short *)(param_1 + 1) = (short)(local_1c._8_4_ & 0xf);
  *param_1 = local_1c._8_4_ & 0xf;
  *(short *)(param_1 + 2) = (short)(local_1c._8_4_ & 0xf0);
  *(undefined2 *)((int)param_1 + 6) = 0;
  if ((local_1c._8_4_ & 0x40) != 0) {
    *(undefined2 *)((int)param_1 + 6) = 4;
  }
  if ((local_1c._8_4_ & 0x20) != 0) {
    *(ushort *)((int)param_1 + 6) = *(ushort *)((int)param_1 + 6) | 2;
  }
  if ((local_1c._8_4_ & 0x10) != 0) {
    *(ushort *)((int)param_1 + 6) = *(ushort *)((int)param_1 + 6) | 1;
  }
  if ((char)(local_1c._8_4_ & 0xf0) < '\0') {
    *(ushort *)((int)param_1 + 6) = *(ushort *)((int)param_1 + 6) | 8;
  }
  return;
}



void __cdecl RestoreWin32ConsoleColor(int param_1,ushort param_2)

{
  ushort wAttributes;
  HANDLE hConsoleOutput;
  
                    // 0x1bb00  438  RestoreWin32ConsoleColor
  wAttributes = *(ushort *)(param_1 + 8) | param_2;
  hConsoleOutput = GetStdHandle(0xfffffff5);
  SetConsoleTextAttribute(hConsoleOutput,wAttributes);
  *(ushort *)(param_1 + 4) = param_2;
  return;
}



undefined4 __cdecl
SetWin32ConsoleColor(undefined2 *param_1,int param_2,int param_3,int param_4,int param_5)

{
  undefined2 uVar1;
  HANDLE hConsoleOutput;
  undefined2 extraout_var;
  ushort wAttributes;
  
                    // 0x1bb30  451  SetWin32ConsoleColor
  uVar1 = param_1[2];
  param_1[2] = 0;
  if (param_2 != 0) {
    param_1[2] = 4;
  }
  if (param_3 != 0) {
    param_1[2] = param_1[2] | 2;
  }
  if (param_4 != 0) {
    param_1[2] = param_1[2] | 1;
  }
  if (param_5 != 0) {
    param_1[2] = param_1[2] | 8;
  }
  if (param_1[2] == param_1[3]) {
    param_1[2] = *param_1;
  }
  wAttributes = param_1[4] | param_1[2];
  hConsoleOutput = GetStdHandle(0xfffffff5);
  SetConsoleTextAttribute(hConsoleOutput,wAttributes);
  return CONCAT22(extraout_var,uVar1);
}



uint SetupWin32ConsoleIO(void)

{
  undefined *puVar1;
  undefined *puVar2;
  undefined *puVar3;
  undefined *puVar4;
  undefined *puVar5;
  undefined *puVar6;
  undefined *puVar7;
  undefined *puVar8;
  HANDLE pvVar9;
  uint uVar10;
  HMODULE hModule;
  FARPROC pFVar11;
  int iVar12;
  undefined4 *puVar13;
  undefined **ppuVar14;
  FILE *_File;
  byte bVar15;
  char *pcVar16;
  size_t sVar17;
  _Lockit local_8 [4];
  
                    // 0x1bbb0  452  SetupWin32ConsoleIO
  bVar15 = 0;
  pvVar9 = GetStdHandle(0xfffffff5);
  uVar10 = GetFileType(pvVar9);
  if (uVar10 != 0) goto LAB_1001bd3c;
  hModule = LoadLibraryA("kernel32.dll");
  pFVar11 = GetProcAddress(hModule,"AttachConsole");
  if (pFVar11 == (FARPROC)0x0) {
LAB_1001bbf6:
    bVar15 = 1;
    AllocConsole();
  }
  else {
    iVar12 = (*pFVar11)(0xffffffff);
    bVar15 = 0;
    if (iVar12 == 0) goto LAB_1001bbf6;
  }
  pcVar16 = "w";
  iVar12 = 0x4000;
  pvVar9 = GetStdHandle(0xfffffff5);
  uVar10 = __open_osfhandle((intptr_t)pvVar9,iVar12);
  puVar13 = FUN_10024684(uVar10,pcVar16);
  puVar1 = (undefined *)*puVar13;
  puVar2 = (undefined *)puVar13[1];
  puVar3 = (undefined *)puVar13[2];
  puVar4 = (undefined *)puVar13[3];
  puVar5 = (undefined *)puVar13[4];
  puVar6 = (undefined *)puVar13[5];
  puVar7 = (undefined *)puVar13[6];
  puVar8 = (undefined *)puVar13[7];
  ppuVar14 = FUN_100245a8();
  sVar17 = 0;
  iVar12 = 4;
  ppuVar14[8] = puVar1;
  ppuVar14[9] = puVar2;
  ppuVar14[10] = puVar3;
  ppuVar14[0xb] = puVar4;
  pcVar16 = (char *)0x0;
  ppuVar14[0xc] = puVar5;
  ppuVar14[0xd] = puVar6;
  ppuVar14[0xe] = puVar7;
  ppuVar14[0xf] = puVar8;
  ppuVar14 = FUN_100245a8();
  _setvbuf((FILE *)(ppuVar14 + 8),pcVar16,iVar12,sVar17);
  pcVar16 = "r";
  iVar12 = 0x4000;
  pvVar9 = GetStdHandle(0xfffffff6);
  uVar10 = __open_osfhandle((intptr_t)pvVar9,iVar12);
  puVar13 = FUN_10024684(uVar10,pcVar16);
  puVar1 = (undefined *)*puVar13;
  puVar2 = (undefined *)puVar13[1];
  puVar3 = (undefined *)puVar13[2];
  puVar4 = (undefined *)puVar13[3];
  puVar5 = (undefined *)puVar13[4];
  puVar6 = (undefined *)puVar13[5];
  puVar7 = (undefined *)puVar13[6];
  puVar8 = (undefined *)puVar13[7];
  ppuVar14 = FUN_100245a8();
  sVar17 = 0;
  iVar12 = 4;
  *ppuVar14 = puVar1;
  ppuVar14[1] = puVar2;
  ppuVar14[2] = puVar3;
  ppuVar14[3] = puVar4;
  pcVar16 = (char *)0x0;
  ppuVar14[4] = puVar5;
  ppuVar14[5] = puVar6;
  ppuVar14[6] = puVar7;
  ppuVar14[7] = puVar8;
  _File = (FILE *)FUN_100245a8();
  _setvbuf(_File,pcVar16,iVar12,sVar17);
  pcVar16 = "w";
  iVar12 = 0x4000;
  pvVar9 = GetStdHandle(0xfffffff4);
  uVar10 = __open_osfhandle((intptr_t)pvVar9,iVar12);
  puVar13 = FUN_10024684(uVar10,pcVar16);
  puVar1 = (undefined *)*puVar13;
  puVar2 = (undefined *)puVar13[1];
  puVar3 = (undefined *)puVar13[2];
  puVar4 = (undefined *)puVar13[3];
  puVar5 = (undefined *)puVar13[4];
  puVar6 = (undefined *)puVar13[5];
  puVar7 = (undefined *)puVar13[6];
  puVar8 = (undefined *)puVar13[7];
  ppuVar14 = FUN_100245a8();
  sVar17 = 0;
  iVar12 = 4;
  ppuVar14[0x10] = puVar1;
  ppuVar14[0x11] = puVar2;
  ppuVar14[0x12] = puVar3;
  ppuVar14[0x13] = puVar4;
  pcVar16 = (char *)0x0;
  ppuVar14[0x14] = puVar5;
  ppuVar14[0x15] = puVar6;
  ppuVar14[0x16] = puVar7;
  ppuVar14[0x17] = puVar8;
  ppuVar14 = FUN_100245a8();
  _setvbuf((FILE *)(ppuVar14 + 8),pcVar16,iVar12,sVar17);
  uVar10 = std::_Lockit::_Lockit(local_8,2);
  DAT_10047b14 = 1;
  std::_Lockit::__Lockit(local_8);
LAB_1001bd3c:
  return uVar10 & 0xffffff00 | (uint)bVar15;
}



void __cdecl FUN_1001bd50(uint *param_1,uint param_2,uint param_3,uint param_4)

{
  uint uVar1;
  int iVar2;
  code *pcVar3;
  undefined4 *puVar4;
  undefined4 *puVar5;
  bool bVar6;
  undefined4 *puVar7;
  uint uVar8;
  uint uVar9;
  uint *puVar10;
  uint uVar11;
  byte bVar12;
  uint uVar13;
  
  uVar1 = param_1[6];
  puVar10 = param_1 + 0x71;
  do {
    if ((*puVar10 <= uVar1) && (uVar1 < puVar10[1] + *puVar10)) break;
    puVar10 = (uint *)puVar10[2];
  } while (puVar10 != (uint *)0x0);
  puVar7 = (undefined4 *)(puVar10[1] + *puVar10);
  uVar8 = (int)puVar7 - 0x47U & 0xf;
  if (uVar8 != 0) {
    uVar8 = -uVar8 & 0xf;
  }
  uVar8 = (int)puVar7 + (uVar8 - 0x3f);
  if (uVar8 < uVar1 + 0x10) {
    uVar8 = uVar1;
  }
  uVar9 = param_2 - 8 & 0xf;
  if (uVar9 != 0) {
    uVar9 = -uVar9 & 0xf;
  }
  uVar11 = param_2 + uVar9;
  uVar9 = (param_3 - 0x38) - uVar9;
  param_1[6] = uVar11;
  param_1[3] = uVar9;
  *(uint *)(uVar11 + 4) = uVar9 | 1;
  uVar13 = DAT_10835ae4;
  *(undefined4 *)(uVar11 + 4 + uVar9) = 0x38;
  param_1[7] = uVar13;
  uVar9 = DAT_10835ad4;
  *(undefined4 *)(uVar8 + 4) = 0x23;
  *(uint *)(uVar8 + 0x20) = uVar9 ^ (uint)param_1;
  uVar9 = param_1[0x72];
  uVar13 = param_1[0x73];
  uVar11 = param_1[0x74];
  *(uint *)(uVar8 + 8) = param_1[0x71];
  *(uint *)(uVar8 + 0xc) = uVar9;
  *(uint *)(uVar8 + 0x10) = uVar13;
  *(uint *)(uVar8 + 0x14) = uVar11;
  param_1[0x71] = param_2;
  param_1[0x73] = (uint)(uint *)(uVar8 + 8);
  param_1[0x72] = param_3;
  param_1[0x74] = param_4;
  *(undefined4 *)(uVar8 + 0x24) = 7;
  puVar4 = (undefined4 *)(uVar8 + 0x24);
  for (puVar5 = (undefined4 *)(uVar8 + 0x28); puVar5 < puVar7; puVar5 = puVar5 + 1) {
    puVar4[1] = 7;
    puVar4 = puVar5;
  }
  if (uVar8 != uVar1) {
    uVar8 = uVar8 - uVar1;
    puVar10 = (uint *)(uVar8 + 4 + uVar1);
    *puVar10 = *puVar10 & 0xfffffffe;
    *(uint *)(uVar1 + 4) = uVar8 | 1;
    uVar9 = uVar8 >> 3;
    *(uint *)(uVar8 + uVar1) = uVar8;
    if (uVar9 < 0x20) {
      uVar8 = 1 << ((byte)uVar9 & 0x1f);
      puVar10 = param_1 + (uVar9 + 5) * 2;
      if ((uVar8 & *param_1) == 0) {
        *param_1 = *param_1 | uVar8;
        puVar10[2] = uVar1;
        puVar10[3] = uVar1;
        *(uint **)(uVar1 + 0xc) = puVar10;
        *(uint **)(uVar1 + 8) = puVar10;
        return;
      }
      uVar8 = puVar10[2];
      if (param_1[4] <= uVar8) {
        puVar10[2] = uVar1;
        *(uint *)(uVar8 + 0xc) = uVar1;
        *(uint **)(uVar1 + 0xc) = puVar10;
        *(uint *)(uVar1 + 8) = uVar8;
        return;
      }
      bVar6 = Plat_IsInDebugSession();
      if (bVar6) {
        pcVar3 = (code *)swi(3);
        (*pcVar3)();
        return;
      }
      _abort();
LAB_1001bfe0:
      pcVar3 = (code *)swi(3);
      (*pcVar3)();
      return;
    }
    uVar9 = uVar8 >> 8;
    if (uVar9 != 0) {
      if (uVar9 < 0x10000) {
        iVar2 = 0x1f;
        if (uVar9 != 0) {
          for (; uVar9 >> iVar2 == 0; iVar2 = iVar2 + -1) {
          }
        }
        uVar9 = (uVar8 >> ((char)iVar2 + 7U & 0x1f) & 1) + iVar2 * 2;
      }
      else {
        uVar9 = 0x1f;
      }
    }
    *(uint *)(uVar1 + 0x1c) = uVar9;
    *(undefined4 *)(uVar1 + 0x14) = 0;
    *(undefined4 *)(uVar1 + 0x10) = 0;
    uVar13 = 1 << ((byte)uVar9 & 0x1f);
    if ((uVar13 & param_1[1]) != 0) {
      if (uVar9 == 0x1f) {
        bVar12 = 0;
      }
      else {
        bVar12 = 0x19 - (char)(uVar9 >> 1);
      }
      uVar13 = *(uint *)(param_1[uVar9 + 0x4c] + 4);
      uVar9 = param_1[uVar9 + 0x4c];
      iVar2 = uVar8 << (bVar12 & 0x1f);
      do {
        if ((uVar13 & 0xfffffff8) == uVar8) {
          uVar8 = *(uint *)(uVar9 + 8);
          if ((param_1[4] <= uVar9) && (param_1[4] <= uVar8)) {
            *(uint *)(uVar8 + 0xc) = uVar1;
            *(uint *)(uVar9 + 8) = uVar1;
            *(uint *)(uVar1 + 8) = uVar8;
            *(uint *)(uVar1 + 0xc) = uVar9;
            *(undefined4 *)(uVar1 + 0x18) = 0;
            return;
          }
          bVar6 = Plat_IsInDebugSession();
          if (!bVar6) {
            _abort();
            pcVar3 = (code *)swi(3);
            (*pcVar3)();
            return;
          }
LAB_1001bfe6:
          pcVar3 = (code *)swi(3);
          (*pcVar3)();
          return;
        }
        puVar10 = (uint *)(uVar9 + (4 - (iVar2 >> 0x1f)) * 4);
        uVar11 = *puVar10;
        if (uVar11 == 0) {
          if ((uint *)param_1[4] <= puVar10) {
            *puVar10 = uVar1;
            *(uint *)(uVar1 + 0x18) = uVar9;
            *(uint *)(uVar1 + 0xc) = uVar1;
            *(uint *)(uVar1 + 8) = uVar1;
            return;
          }
          bVar6 = Plat_IsInDebugSession();
          if (bVar6) goto LAB_1001bfe0;
          _abort();
          goto LAB_1001bfe6;
        }
        uVar13 = *(uint *)(uVar11 + 4);
        uVar9 = uVar11;
        iVar2 = iVar2 * 2;
      } while( true );
    }
    param_1[1] = param_1[1] | uVar13;
    param_1[uVar9 + 0x4c] = uVar1;
    *(uint **)(uVar1 + 0x18) = param_1 + uVar9 + 0x4c;
    *(uint *)(uVar1 + 0xc) = uVar1;
    *(uint *)(uVar1 + 8) = uVar1;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_1001bff0(void)

{
  DWORD DVar1;
  uint uVar2;
  DWORD DVar3;
  DWORD DVar4;
  
  if (_DAT_10835ad8 != 0) {
    return 0;
  }
  _DAT_10835ae0 = 0x40000;
  DAT_10835ae4 = 0x200000;
  DAT_10835ae8 = 7;
  uVar2 = FUN_10022adf((undefined4 *)0x0);
  DVar3 = GetCurrentThreadId();
  if (DVar3 != DAT_108358e8) {
    DVar4 = 0;
    LOCK();
    DVar1 = DVar3;
    if (DAT_108358e8 != 0) {
      DVar4 = DAT_108358e8;
      DVar1 = DAT_108358e8;
    }
    DAT_108358e8 = DVar1;
    if (DVar4 != 0) {
      CThreadFastMutex::Lock((CThreadFastMutex *)&DAT_108358e8,DVar3,0);
      goto LAB_1001c06a;
    }
  }
  _DAT_108358ec = _DAT_108358ec + 1;
LAB_1001c06a:
  if (DAT_10835ad4 == 0) {
    _DAT_10835ab0 = DAT_10835ae8;
    DAT_10835ad4 = (uVar2 ^ 0x55555550) & 0xfffffff8 | 8;
  }
  _DAT_108358ec = _DAT_108358ec + -1;
  if (_DAT_108358ec == 0) {
    DAT_108358e8 = 0;
  }
  _DAT_10835ad8 = 0x10000;
  DAT_10835adc = 0x10000;
  return 0;
}



void __cdecl FUN_1001c0b0(int param_1,int param_2,int param_3)

{
  undefined4 uVar1;
  uint uVar2;
  int iVar3;
  
  uVar2 = param_2 - 8U & 0xf;
  if (uVar2 != 0) {
    uVar2 = -uVar2 & 0xf;
  }
  iVar3 = param_2 + uVar2;
  uVar2 = param_3 - uVar2;
  *(int *)(param_1 + 0x18) = iVar3;
  *(uint *)(param_1 + 0xc) = uVar2;
  *(uint *)(iVar3 + 4) = uVar2 | 1;
  uVar1 = DAT_10835ae4;
  *(undefined4 *)(iVar3 + 4 + uVar2) = 0x38;
  *(undefined4 *)(param_1 + 0x1c) = uVar1;
  return;
}



uint * __cdecl FUN_1001c0f0(uint param_1,uint param_2)

{
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  int iVar4;
  uint uVar5;
  uint *puVar6;
  
  uVar5 = param_1 - 8 & 0xf;
  if (uVar5 != 0) {
    uVar5 = -uVar5 & 0xf;
  }
  puVar6 = (uint *)(param_1 + 8 + uVar5);
  FUN_10021290(puVar6,0,0x1f0);
  uVar1 = DAT_10835ad4;
  puVar3 = puVar6 + 10;
  *(undefined4 *)(uVar5 + 4 + param_1) = 499;
  iVar4 = 0x20;
  puVar6[9] = uVar1;
  uVar5 = DAT_10835ae8 | 4;
  puVar6[4] = param_1;
  puVar6[0x71] = param_1;
  puVar6[0x6d] = param_2;
  puVar6[0x6c] = param_2;
  puVar6[0x72] = param_2;
  puVar6[8] = 0xff;
  puVar6[0x75] = 0;
  puVar6[0x76] = 0;
  puVar6[0x6e] = uVar5;
  do {
    puVar3[3] = (uint)puVar3;
    puVar3[2] = (uint)puVar3;
    puVar3 = puVar3 + 2;
    iVar4 = iVar4 + -1;
  } while (iVar4 != 0);
  iVar4 = ((puVar6[-1] & 0xfffffff8) - 8) + (int)puVar6;
  uVar5 = iVar4 - 8U & 0xf;
  if (uVar5 != 0) {
    uVar5 = -uVar5 & 0xf;
  }
  uVar1 = uVar5 + iVar4;
  uVar5 = (param_2 + ((param_1 - 0x38) - iVar4)) - uVar5;
  puVar6[3] = uVar5;
  puVar6[6] = uVar1;
  *(uint *)(uVar1 + 4) = uVar5 | 1;
  uVar2 = DAT_10835ae4;
  *(undefined4 *)(uVar1 + 4 + uVar5) = 0x38;
  puVar6[7] = uVar2;
  return puVar6;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int * __cdecl FUN_1001c1e0(int *param_1,int param_2)

{
  DWORD *this;
  uint uVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  DWORD DVar5;
  DWORD DVar6;
  uint *puVar7;
  uint uVar8;
  int iVar9;
  bool bVar10;
  int local_10;
  int local_8;
  
  bVar10 = _DAT_10835ad8 == 0;
  *param_1 = 0;
  param_1[1] = 0;
  param_1[2] = 0;
  param_1[3] = 0;
  param_1[4] = 0;
  param_1[5] = 0;
  param_1[6] = 0;
  param_1[7] = 0;
  param_1[8] = 0;
  param_1[9] = 0;
  if (((bVar10) && (iVar4 = FUN_1001bff0(), iVar4 != 0)) || ((*(byte *)(param_2 + 0x1b8) & 2) != 0))
  {
    this = (DWORD *)(param_2 + 0x1bc);
    DVar5 = GetCurrentThreadId();
    if (DVar5 != *this) {
      DVar6 = 0;
      LOCK();
      if (*this == 0) {
        *this = DVar5;
      }
      else {
        DVar6 = *this;
      }
      if (DVar6 != 0) {
        CThreadFastMutex::Lock((CThreadFastMutex *)this,DVar5,0);
        goto LAB_1001c283;
      }
    }
    *(int *)(param_2 + 0x1c0) = *(int *)(param_2 + 0x1c0) + 1;
  }
LAB_1001c283:
  if (*(int *)(param_2 + 0x18) != 0) {
    iVar4 = 1;
    iVar9 = *(int *)(param_2 + 0xc) + 0x38;
    local_8 = 1;
    local_10 = iVar9;
    for (puVar7 = (uint *)(param_2 + 0x1c4); puVar7 != (uint *)0x0; puVar7 = (uint *)puVar7[2]) {
      uVar1 = *puVar7;
      uVar8 = uVar1 - 8 & 0xf;
      if (uVar8 != 0) {
        uVar8 = -uVar8 & 0xf;
      }
      uVar8 = uVar1 + uVar8;
      if (uVar1 <= uVar8) {
        do {
          if (((puVar7[1] + uVar1 <= uVar8) || (uVar8 == *(uint *)(param_2 + 0x18))) ||
             (uVar2 = *(uint *)(uVar8 + 4), uVar2 == 7)) break;
          local_10 = local_10 + (uVar2 & 0xfffffff8);
          if ((uVar2 & 2) == 0) {
            iVar9 = iVar9 + (uVar2 & 0xfffffff8);
            local_8 = local_8 + 1;
          }
          uVar8 = uVar8 + (uVar2 & 0xfffffff8);
          iVar4 = local_8;
        } while (uVar1 <= uVar8);
      }
    }
    param_1[1] = iVar4;
    param_1[8] = iVar9;
    *param_1 = local_10;
    iVar4 = *(int *)(param_2 + 0x1b0);
    param_1[4] = iVar4 - local_10;
    param_1[5] = *(int *)(param_2 + 0x1b4);
    iVar3 = *(int *)(param_2 + 0xc);
    param_1[7] = iVar4 - iVar9;
    param_1[9] = iVar3;
  }
  if ((*(byte *)(param_2 + 0x1b8) & 2) != 0) {
    *(int *)(param_2 + 0x1c0) = *(int *)(param_2 + 0x1c0) + -1;
    if (*(int *)(param_2 + 0x1c0) == 0) {
      *(undefined4 *)(param_2 + 0x1bc) = 0;
    }
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint ** __cdecl FUN_1001c370(uint *param_1,uint *param_2,uint param_3)

{
  DWORD *this;
  uint *puVar1;
  code *pcVar2;
  bool bVar3;
  int iVar4;
  DWORD DVar5;
  DWORD DVar6;
  uint uVar7;
  uint **ppuVar8;
  uint uVar9;
  uint uVar10;
  uint *puVar11;
  uint uVar12;
  uint *puVar13;
  
  if (0xffffffbf < param_3) {
    return (uint **)0x0;
  }
  if (((_DAT_10835ad8 == 0) && (iVar4 = FUN_1001bff0(), iVar4 != 0)) ||
     ((*(byte *)(param_1 + 0x6e) & 2) != 0)) {
    this = param_1 + 0x6f;
    DVar5 = GetCurrentThreadId();
    if (DVar5 != *this) {
      DVar6 = 0;
      LOCK();
      if (*this == 0) {
        *this = DVar5;
      }
      else {
        DVar6 = *this;
      }
      if (DVar6 != 0) {
        CThreadFastMutex::Lock((CThreadFastMutex *)this,DVar5,0);
        goto LAB_1001c3d5;
      }
    }
    param_1[0x70] = param_1[0x70] + 1;
  }
LAB_1001c3d5:
  puVar13 = param_2 + -2;
  uVar7 = param_2[-1];
  uVar9 = uVar7 & 0xfffffff8;
  if (((puVar13 < (uint *)param_1[4]) || ((uVar7 & 2) == 0)) ||
     (((uint *)(uVar9 + (int)puVar13) <= puVar13 ||
      ((*(byte *)((uint *)(uVar9 + (int)puVar13) + 1) & 1) == 0)))) {
    bVar3 = Plat_IsInDebugSession();
    if (!bVar3) {
      _abort();
      pcVar2 = (code *)swi(3);
      ppuVar8 = (uint **)(*pcVar2)();
      return ppuVar8;
    }
    pcVar2 = (code *)swi(3);
    ppuVar8 = (uint **)(*pcVar2)();
    return ppuVar8;
  }
  if (param_3 < 7) {
    uVar12 = 0x10;
  }
  else {
    uVar12 = param_3 + 0x17 & 0xfffffff0;
  }
  uVar7 = uVar7 & 1;
  if ((uVar7 == 0) && ((*(byte *)puVar13 & 1) != 0)) {
    if (((uVar12 < 0x100) || (uVar9 < uVar12 + 4)) || ((uint)(DAT_10835adc * 2) < uVar9 - uVar12)) {
LAB_1001c4f5:
      puVar13 = (uint *)0x0;
    }
  }
  else if (uVar9 < uVar12) {
    if (((byte *)(uVar9 + (int)puVar13) != (byte *)param_1[6]) || (param_1[3] + uVar9 <= uVar12))
    goto LAB_1001c4f5;
    uVar10 = (param_1[3] - uVar12) + uVar9;
    puVar1 = (uint *)(uVar12 + (int)puVar13);
    param_2[-1] = uVar7 | uVar12 | 2;
    *puVar1 = DAT_10835ad4 ^ (uint)param_1;
    puVar1[1] = uVar10 | 1;
    param_1[3] = uVar10;
    param_1[6] = (uint)puVar1;
  }
  else {
    uVar10 = uVar9 - uVar12;
    if (0xf < uVar10) {
      puVar11 = (uint *)((int)puVar13 + uVar12);
      param_2[-1] = uVar7 | uVar12 | 2;
      puVar11[1] = puVar11[1] | 1;
      uVar7 = DAT_10835ad4 ^ (uint)param_1;
      *puVar11 = uVar7;
      puVar11[1] = puVar11[1] & 1 | uVar10 | 2;
      puVar1 = (uint *)((int)puVar11 + uVar10 + 4);
      *puVar1 = *puVar1 | 1;
      *(uint *)((int)puVar11 + uVar10) = uVar7;
      puVar11 = puVar11 + 2;
      goto LAB_1001c4f9;
    }
  }
  puVar11 = (uint *)0x0;
LAB_1001c4f9:
  if ((*(byte *)(param_1 + 0x6e) & 2) != 0) {
    param_1[0x70] = param_1[0x70] - 1;
    if (param_1[0x70] == 0) {
      param_1[0x6f] = 0;
    }
  }
  if (puVar13 != (uint *)0x0) {
    if (puVar11 != (uint *)0x0) {
      if (param_1 == &DAT_108358f8) {
        FUN_1001da20(puVar11);
        return (uint **)(puVar13 + 2);
      }
      FUN_1001e5c0(param_1,puVar11);
    }
    return (uint **)(puVar13 + 2);
  }
  if (param_1 == &DAT_108358f8) {
    ppuVar8 = (uint **)FUN_1001e1a0(param_3);
  }
  else {
    ppuVar8 = FUN_1001edb0(param_1,param_3);
  }
  if (ppuVar8 != (uint **)0x0) {
    if (uVar9 - 8 < param_3) {
      param_3 = uVar9 - 8;
    }
    FID_conflict__memcpy(ppuVar8,param_2,param_3);
    if (param_1 == &DAT_108358f8) {
      FUN_1001da20(param_2);
      return ppuVar8;
    }
    FUN_1001e5c0(param_1,param_2);
  }
  return ppuVar8;
}



uint * __cdecl FUN_1001c5d0(uint param_1,uint param_2)

{
  uint *puVar1;
  LPVOID pvVar2;
  uint uVar3;
  int iVar4;
  LPVOID pvVar5;
  uint uVar6;
  
  uVar6 = param_2 + 0x26 + DAT_10835adc & ~(DAT_10835adc - 1U);
  if (param_2 < uVar6) {
    pvVar2 = VirtualAlloc((LPVOID)0x0,uVar6,0x103000,4);
    pvVar5 = (LPVOID)0xffffffff;
    if (pvVar2 != (LPVOID)0x0) {
      pvVar5 = pvVar2;
    }
    if (pvVar5 != (LPVOID)0xffffffff) {
      uVar3 = (int)pvVar5 - 8U & 0xf;
      if (uVar3 != 0) {
        uVar3 = -uVar3 & 0xf;
      }
      iVar4 = uVar6 - uVar3;
      puVar1 = (uint *)(uVar3 + (int)pvVar5);
      *puVar1 = uVar3 | 1;
      puVar1[1] = iVar4 - 0x10U | 2;
      uVar3 = DAT_10835ad4 ^ param_1;
      *(undefined4 *)((int)puVar1 + iVar4 + -0xc) = 7;
      *(uint *)((int)puVar1 + iVar4 + -0x10) = uVar3;
      *(undefined4 *)((int)puVar1 + iVar4 + -8) = 0;
      if (pvVar5 < *(LPVOID *)(param_1 + 0x10)) {
        *(LPVOID *)(param_1 + 0x10) = pvVar5;
      }
      *(int *)(param_1 + 0x1b0) = *(int *)(param_1 + 0x1b0) + uVar6;
      uVar6 = *(uint *)(param_1 + 0x1b0);
      if (*(uint *)(param_1 + 0x1b4) <= uVar6 && uVar6 != *(uint *)(param_1 + 0x1b4)) {
        *(uint *)(param_1 + 0x1b4) = uVar6;
      }
      return puVar1 + 2;
    }
  }
  return (uint *)0x0;
}



int __cdecl FUN_1001c680(uint *param_1,int param_2,undefined4 *param_3,uint param_4)

{
  uint *puVar1;
  uint **ppuVar2;
  uint *puVar3;
  uint *puVar4;
  uint uVar5;
  int iVar6;
  code *pcVar7;
  undefined4 *puVar8;
  bool bVar9;
  byte bVar10;
  uint uVar11;
  uint uVar12;
  int iVar13;
  uint uVar14;
  uint uVar15;
  uint uVar16;
  
  uVar11 = param_2 - 8U & 0xf;
  if (uVar11 != 0) {
    uVar11 = -uVar11 & 0xf;
  }
  iVar13 = uVar11 + param_2;
  uVar11 = (uint)(param_3 + -2) & 0xf;
  if (uVar11 != 0) {
    uVar11 = -uVar11 & 0xf;
  }
  uVar11 = uVar11 + (int)param_3;
  puVar1 = (uint *)(iVar13 + param_4);
  uVar16 = (uVar11 - iVar13) - param_4;
  *(uint *)(iVar13 + 4) = param_4 | 3;
  *puVar1 = DAT_10835ad4 ^ (uint)param_1;
  if (uVar11 == param_1[6]) {
    param_1[3] = param_1[3] + uVar16;
    param_1[6] = (uint)puVar1;
    puVar1[1] = param_1[3] | 1;
    return iVar13 + 8;
  }
  if (uVar11 == param_1[5]) {
    param_1[2] = param_1[2] + uVar16;
    uVar11 = param_1[2];
    param_1[5] = (uint)puVar1;
    puVar1[1] = uVar11 | 1;
    *(uint *)(uVar11 + (int)puVar1) = uVar11;
    return iVar13 + 8;
  }
  uVar12 = *(uint *)(uVar11 + 4);
  if ((uVar12 & 2) == 0) {
    uVar14 = uVar12 >> 3;
    if (uVar14 < 0x20) {
      puVar3 = *(uint **)(uVar11 + 8);
      puVar4 = *(uint **)(uVar11 + 0xc);
      if (puVar3 == puVar4) {
        *param_1 = *param_1 & ~(1 << ((byte)uVar14 & 0x1f));
      }
      else {
        if (((puVar3 != param_1 + (uVar14 + 5) * 2) && (puVar3 < (uint *)param_1[4])) ||
           ((puVar4 != param_1 + (uVar14 + 5) * 2 && (puVar4 < (uint *)param_1[4])))) {
          bVar9 = Plat_IsInDebugSession();
          if (bVar9) {
            pcVar7 = (code *)swi(3);
            iVar13 = (*pcVar7)();
            return iVar13;
          }
          _abort();
LAB_1001caa2:
          pcVar7 = (code *)swi(3);
          iVar13 = (*pcVar7)();
          return iVar13;
        }
        puVar3[3] = (uint)puVar4;
        puVar4[2] = (uint)puVar3;
      }
    }
    else {
      uVar14 = *(uint *)(uVar11 + 0x18);
      uVar15 = *(uint *)(uVar11 + 0xc);
      if (uVar15 == uVar11) {
        uVar5 = *(uint *)(uVar11 + 0x14);
        puVar8 = (undefined4 *)(uVar11 + 0x14);
        if (*(uint *)(uVar11 + 0x14) == 0) {
          uVar15 = *(uint *)(uVar11 + 0x10);
          uVar5 = uVar15;
          puVar8 = (undefined4 *)(uVar11 + 0x10);
          if (uVar15 == 0) goto LAB_1001c860;
        }
        do {
          do {
            param_3 = puVar8;
            uVar15 = uVar5;
            uVar5 = *(uint *)(uVar15 + 0x14);
            puVar8 = (undefined4 *)(uVar15 + 0x14);
          } while (*(uint *)(uVar15 + 0x14) != 0);
          uVar5 = *(uint *)(uVar15 + 0x10);
          puVar8 = (undefined4 *)(uVar15 + 0x10);
        } while (*(uint *)(uVar15 + 0x10) != 0);
        if (param_3 < (undefined4 *)param_1[4]) {
          bVar9 = Plat_IsInDebugSession();
          if (bVar9) goto LAB_1001cac0;
          _abort();
          goto LAB_1001cac6;
        }
        *param_3 = 0;
      }
      else {
        uVar5 = *(uint *)(uVar11 + 8);
        if (uVar5 < param_1[4]) {
          bVar9 = Plat_IsInDebugSession();
          if (bVar9) goto LAB_1001caa2;
          _abort();
          goto LAB_1001caa8;
        }
        *(uint *)(uVar5 + 0xc) = uVar15;
        *(uint *)(uVar15 + 8) = uVar5;
      }
LAB_1001c860:
      if (uVar14 != 0) {
        if (uVar11 == param_1[*(int *)(uVar11 + 0x1c) + 0x4c]) {
          param_1[*(int *)(uVar11 + 0x1c) + 0x4c] = uVar15;
          if (uVar15 == 0) {
            param_1[1] = param_1[1] & ~(1 << ((byte)*(undefined4 *)(uVar11 + 0x1c) & 0x1f));
          }
          else {
LAB_1001c8bb:
            if (uVar15 < param_1[4]) {
              bVar9 = Plat_IsInDebugSession();
              if (!bVar9) {
                _abort();
LAB_1001caba:
                pcVar7 = (code *)swi(3);
                iVar13 = (*pcVar7)();
                return iVar13;
              }
LAB_1001cab4:
              pcVar7 = (code *)swi(3);
              iVar13 = (*pcVar7)();
              return iVar13;
            }
            *(uint *)(uVar15 + 0x18) = uVar14;
            uVar14 = *(uint *)(uVar11 + 0x10);
            if (uVar14 != 0) {
              if (uVar14 < param_1[4]) {
                bVar9 = Plat_IsInDebugSession();
                if (bVar9) {
LAB_1001caa8:
                  pcVar7 = (code *)swi(3);
                  iVar13 = (*pcVar7)();
                  return iVar13;
                }
                _abort();
                goto LAB_1001caae;
              }
              *(uint *)(uVar15 + 0x10) = uVar14;
              *(uint *)(uVar14 + 0x18) = uVar15;
            }
            uVar14 = *(uint *)(uVar11 + 0x14);
            if (uVar14 != 0) {
              if (uVar14 < param_1[4]) {
                bVar9 = Plat_IsInDebugSession();
                if (bVar9) {
LAB_1001caae:
                  pcVar7 = (code *)swi(3);
                  iVar13 = (*pcVar7)();
                  return iVar13;
                }
                _abort();
                goto LAB_1001cab4;
              }
              *(uint *)(uVar15 + 0x14) = uVar14;
              *(uint *)(uVar14 + 0x18) = uVar15;
            }
          }
        }
        else {
          if (uVar14 < param_1[4]) {
            bVar9 = Plat_IsInDebugSession();
            if (!bVar9) {
              _abort();
LAB_1001cac0:
              pcVar7 = (code *)swi(3);
              iVar13 = (*pcVar7)();
              return iVar13;
            }
            goto LAB_1001caba;
          }
          if (*(uint *)(uVar14 + 0x10) == uVar11) {
            *(uint *)(uVar14 + 0x10) = uVar15;
          }
          else {
            *(uint *)(uVar14 + 0x14) = uVar15;
          }
          if (uVar15 != 0) goto LAB_1001c8bb;
        }
      }
    }
    uVar11 = uVar11 + (uVar12 & 0xfffffff8);
    uVar16 = uVar16 + (uVar12 & 0xfffffff8);
  }
  *(uint *)(uVar11 + 4) = *(uint *)(uVar11 + 4) & 0xfffffffe;
  puVar1[1] = uVar16 | 1;
  *(uint *)(uVar16 + (int)puVar1) = uVar16;
  if (0x1f < uVar16 >> 3) {
    uVar11 = uVar16 >> 8;
    if (uVar11 == 0) {
      uVar11 = 0;
    }
    else if (uVar11 < 0x10000) {
      iVar6 = 0x1f;
      if (uVar11 != 0) {
        for (; uVar11 >> iVar6 == 0; iVar6 = iVar6 + -1) {
        }
      }
      uVar11 = (uVar16 >> ((char)iVar6 + 7U & 0x1f) & 1) + iVar6 * 2;
    }
    else {
      uVar11 = 0x1f;
    }
    puVar1[7] = uVar11;
    ppuVar2 = (uint **)(param_1 + uVar11 + 0x4c);
    puVar1[5] = 0;
    uVar12 = 1 << ((byte)uVar11 & 0x1f);
    puVar1[4] = 0;
    if ((param_1[1] & uVar12) == 0) {
      param_1[1] = param_1[1] | uVar12;
      *ppuVar2 = puVar1;
      puVar1[6] = (uint)ppuVar2;
      puVar1[3] = (uint)puVar1;
      puVar1[2] = (uint)puVar1;
      return iVar13 + 8;
    }
    if (uVar11 == 0x1f) {
      bVar10 = 0;
    }
    else {
      bVar10 = 0x19 - (char)(uVar11 >> 1);
    }
    uVar11 = (*ppuVar2)[1];
    puVar3 = *ppuVar2;
    iVar6 = uVar16 << (bVar10 & 0x1f);
    do {
      if ((uVar11 & 0xfffffff8) == uVar16) {
        puVar4 = (uint *)puVar3[2];
        if (((uint *)param_1[4] <= puVar3) && ((uint *)param_1[4] <= puVar4)) {
          puVar4[3] = (uint)puVar1;
          puVar3[2] = (uint)puVar1;
          puVar1[2] = (uint)puVar4;
          puVar1[3] = (uint)puVar3;
          puVar1[6] = 0;
          return iVar13 + 8;
        }
        bVar9 = Plat_IsInDebugSession();
        if (!bVar9) {
          _abort();
          pcVar7 = (code *)swi(3);
          iVar13 = (*pcVar7)();
          return iVar13;
        }
LAB_1001cad2:
        pcVar7 = (code *)swi(3);
        iVar13 = (*pcVar7)();
        return iVar13;
      }
      ppuVar2 = (uint **)(puVar3 + (4 - (iVar6 >> 0x1f)));
      puVar4 = *ppuVar2;
      if (puVar4 == (uint *)0x0) {
        if ((uint **)param_1[4] <= ppuVar2) {
          *ppuVar2 = puVar1;
          puVar1[6] = (uint)puVar3;
          puVar1[3] = (uint)puVar1;
          puVar1[2] = (uint)puVar1;
          return iVar13 + 8;
        }
        bVar9 = Plat_IsInDebugSession();
        if (bVar9) goto LAB_1001cacc;
        _abort();
        goto LAB_1001cad2;
      }
      uVar11 = puVar4[1];
      puVar3 = puVar4;
      iVar6 = iVar6 * 2;
    } while( true );
  }
  uVar11 = (int)param_1 + (uVar16 & 0xfffffff8) + 0x28;
  uVar16 = 1 << ((byte)(uVar16 >> 3) & 0x1f);
  if ((*param_1 & uVar16) == 0) {
    *param_1 = uVar16 | *param_1;
    *(uint **)(uVar11 + 8) = puVar1;
    *(uint **)(uVar11 + 0xc) = puVar1;
    puVar1[2] = uVar11;
    puVar1[3] = uVar11;
    return iVar13 + 8;
  }
  uVar16 = *(uint *)(uVar11 + 8);
  if (param_1[4] <= uVar16) {
    *(uint **)(uVar11 + 8) = puVar1;
    *(uint **)(uVar16 + 0xc) = puVar1;
    puVar1[2] = uVar16;
    puVar1[3] = uVar11;
    return iVar13 + 8;
  }
  bVar9 = Plat_IsInDebugSession();
  if (!bVar9) {
    _abort();
LAB_1001cacc:
    pcVar7 = (code *)swi(3);
    iVar13 = (*pcVar7)();
    return iVar13;
  }
LAB_1001cac6:
  pcVar7 = (code *)swi(3);
  iVar13 = (*pcVar7)();
  return iVar13;
}



int __cdecl FUN_1001cae0(int param_1)

{
  int **ppiVar1;
  LPCVOID pvVar2;
  LPCVOID pvVar3;
  LPCVOID *ppvVar4;
  uint uVar5;
  code *pcVar6;
  LPCVOID *ppvVar7;
  int *piVar8;
  int *piVar9;
  LPCVOID *ppvVar10;
  byte bVar11;
  bool bVar12;
  uint uVar13;
  int iVar14;
  uint uVar15;
  int *piVar16;
  int **ppiVar17;
  int iVar18;
  int *piVar19;
  int iVar20;
  uint uVar21;
  int *piVar22;
  
  iVar18 = 0;
  iVar20 = 0;
  ppvVar4 = *(LPCVOID **)(param_1 + 0x1cc);
  ppvVar10 = (LPCVOID *)(param_1 + 0x1c4);
  do {
    do {
      do {
        ppvVar7 = ppvVar10;
        ppvVar10 = ppvVar4;
        if (ppvVar10 == (LPCVOID *)0x0) {
          iVar14 = 0xff;
          if (0xff < iVar20) {
            iVar14 = iVar20;
          }
          *(int *)(param_1 + 0x20) = iVar14;
          return iVar18;
        }
        pvVar2 = *ppvVar10;
        iVar20 = iVar20 + 1;
        pvVar3 = ppvVar10[1];
        ppvVar4 = (LPCVOID *)ppvVar10[2];
      } while ((((uint)ppvVar10[3] & 1) == 0) || (((uint)ppvVar10[3] & 8) != 0));
      uVar13 = (int)pvVar2 - 8U & 0xf;
      if (uVar13 != 0) {
        uVar13 = -uVar13 & 0xf;
      }
      piVar19 = (int *)((int)pvVar2 + uVar13);
      uVar13 = piVar19[1];
      uVar21 = uVar13 & 0xfffffff8;
    } while (((uVar13 & 2) != 0) ||
            (uVar21 + (int)piVar19 < (uint)((int)pvVar2 + (int)pvVar3 + -0x38)));
    if (piVar19 == *(int **)(param_1 + 0x14)) {
      *(undefined4 *)(param_1 + 0x14) = 0;
      *(undefined4 *)(param_1 + 8) = 0;
    }
    else {
      piVar16 = (int *)piVar19[3];
      uVar15 = piVar19[6];
      if (piVar16 == piVar19) {
        piVar8 = (int *)piVar19[5];
        piVar9 = piVar19 + 5;
        if ((int *)piVar19[5] == (int *)0x0) {
          piVar16 = (int *)piVar19[4];
          piVar8 = piVar16;
          piVar9 = piVar19 + 4;
          if (piVar16 == (int *)0x0) goto LAB_1001cbef;
        }
        do {
          do {
            piVar22 = piVar9;
            piVar16 = piVar8;
            piVar8 = (int *)piVar16[5];
            piVar9 = piVar16 + 5;
          } while ((int *)piVar16[5] != (int *)0x0);
          piVar8 = (int *)piVar16[4];
          piVar9 = piVar16 + 4;
        } while ((int *)piVar16[4] != (int *)0x0);
        if (piVar22 < *(int **)(param_1 + 0x10)) {
          bVar12 = Plat_IsInDebugSession();
          if (!bVar12) {
            _abort();
            pcVar6 = (code *)swi(3);
            iVar18 = (*pcVar6)();
            return iVar18;
          }
          goto LAB_1001ce3f;
        }
        *piVar22 = 0;
      }
      else {
        uVar5 = piVar19[2];
        if (uVar5 < *(uint *)(param_1 + 0x10)) {
          bVar12 = Plat_IsInDebugSession();
          if (bVar12) {
            pcVar6 = (code *)swi(3);
            iVar18 = (*pcVar6)();
            return iVar18;
          }
          _abort();
          goto LAB_1001ce1b;
        }
        *(int **)(uVar5 + 0xc) = piVar16;
        piVar16[2] = uVar5;
      }
LAB_1001cbef:
      if (uVar15 != 0) {
        if (piVar19 == *(int **)(param_1 + 0x130 + piVar19[7] * 4)) {
          *(int **)(param_1 + 0x130 + piVar19[7] * 4) = piVar16;
          if (piVar16 == (int *)0x0) {
            *(uint *)(param_1 + 4) = *(uint *)(param_1 + 4) & ~(1 << ((byte)piVar19[7] & 0x1f));
          }
          else {
LAB_1001cc35:
            if (piVar16 < *(int **)(param_1 + 0x10)) {
              bVar12 = Plat_IsInDebugSession();
              if (!bVar12) {
                _abort();
LAB_1001ce2d:
                pcVar6 = (code *)swi(3);
                iVar18 = (*pcVar6)();
                return iVar18;
              }
LAB_1001ce27:
              pcVar6 = (code *)swi(3);
              iVar18 = (*pcVar6)();
              return iVar18;
            }
            piVar16[6] = uVar15;
            uVar15 = piVar19[4];
            if (uVar15 != 0) {
              if (uVar15 < *(uint *)(param_1 + 0x10)) {
                bVar12 = Plat_IsInDebugSession();
                if (bVar12) {
LAB_1001ce1b:
                  pcVar6 = (code *)swi(3);
                  iVar18 = (*pcVar6)();
                  return iVar18;
                }
                _abort();
                goto LAB_1001ce21;
              }
              piVar16[4] = uVar15;
              *(int **)(uVar15 + 0x18) = piVar16;
            }
            uVar15 = piVar19[5];
            if (uVar15 != 0) {
              if (uVar15 < *(uint *)(param_1 + 0x10)) {
                bVar12 = Plat_IsInDebugSession();
                if (bVar12) {
LAB_1001ce21:
                  pcVar6 = (code *)swi(3);
                  iVar18 = (*pcVar6)();
                  return iVar18;
                }
                _abort();
                goto LAB_1001ce27;
              }
              piVar16[5] = uVar15;
              *(int **)(uVar15 + 0x18) = piVar16;
            }
          }
        }
        else {
          if (uVar15 < *(uint *)(param_1 + 0x10)) {
            bVar12 = Plat_IsInDebugSession();
            if (!bVar12) {
              _abort();
LAB_1001ce33:
              pcVar6 = (code *)swi(3);
              iVar18 = (*pcVar6)();
              return iVar18;
            }
            goto LAB_1001ce2d;
          }
          if (*(int **)(uVar15 + 0x10) == piVar19) {
            *(int **)(uVar15 + 0x10) = piVar16;
          }
          else {
            *(int **)(uVar15 + 0x14) = piVar16;
          }
          if (piVar16 != (int *)0x0) goto LAB_1001cc35;
        }
      }
    }
    iVar14 = FUN_1001d900(pvVar2,(uint)pvVar3);
    if (iVar14 == 0) {
      iVar18 = iVar18 + (int)pvVar3;
      *(int *)(param_1 + 0x1b0) = *(int *)(param_1 + 0x1b0) - (int)pvVar3;
      ppvVar7[2] = ppvVar4;
      ppvVar10 = ppvVar7;
    }
    else {
      uVar13 = uVar13 >> 8;
      if (uVar13 == 0) {
        uVar13 = 0;
      }
      else if (uVar13 < 0x10000) {
        iVar14 = 0x1f;
        if (uVar13 != 0) {
          for (; uVar13 >> iVar14 == 0; iVar14 = iVar14 + -1) {
          }
        }
        uVar13 = (uVar21 >> ((char)iVar14 + 7U & 0x1f) & 1) + iVar14 * 2;
      }
      else {
        uVar13 = 0x1f;
      }
      piVar19[7] = uVar13;
      piVar19[5] = 0;
      piVar19[4] = 0;
      ppiVar17 = (int **)(param_1 + 0x130 + uVar13 * 4);
      uVar15 = 1 << ((byte)uVar13 & 0x1f);
      if ((*(uint *)(param_1 + 4) & uVar15) == 0) {
        *(uint *)(param_1 + 4) = uVar15 | *(uint *)(param_1 + 4);
        *ppiVar17 = piVar19;
LAB_1001ccfc:
        piVar19[6] = (int)ppiVar17;
        piVar19[3] = (int)piVar19;
        piVar19[2] = (int)piVar19;
      }
      else {
        if (uVar13 == 0x1f) {
          bVar11 = 0;
        }
        else {
          bVar11 = 0x19 - (char)(uVar13 >> 1);
        }
        uVar13 = (*ppiVar17)[1];
        ppiVar17 = (int **)*ppiVar17;
        iVar14 = uVar21 << (bVar11 & 0x1f);
        while ((uVar13 & 0xfffffff8) != uVar21) {
          ppiVar1 = (int **)((int *)ppiVar17 + (4 - (iVar14 >> 0x1f)));
          piVar16 = *ppiVar1;
          if (piVar16 == (int *)0x0) {
            if (*(int ***)(param_1 + 0x10) <= ppiVar1) {
              *ppiVar1 = piVar19;
              goto LAB_1001ccfc;
            }
            bVar12 = Plat_IsInDebugSession();
            if (bVar12) goto LAB_1001ce33;
            _abort();
            goto LAB_1001ce39;
          }
          ppiVar17 = (int **)piVar16;
          iVar14 = iVar14 * 2;
          uVar13 = piVar16[1];
        }
        piVar16 = (int *)((int *)ppiVar17)[2];
        if ((ppiVar17 < *(int **)(param_1 + 0x10)) || (piVar16 < *(int **)(param_1 + 0x10))) {
          bVar12 = Plat_IsInDebugSession();
          if (bVar12) {
LAB_1001ce39:
            pcVar6 = (code *)swi(3);
            iVar18 = (*pcVar6)();
            return iVar18;
          }
          _abort();
LAB_1001ce3f:
          pcVar6 = (code *)swi(3);
          iVar18 = (*pcVar6)();
          return iVar18;
        }
        piVar16[3] = (int)piVar19;
        ((int *)ppiVar17)[2] = (int)piVar19;
        piVar19[2] = (int)piVar16;
        piVar19[3] = (int)ppiVar17;
        piVar19[6] = 0;
      }
    }
  } while( true );
}



void __cdecl FUN_1001ce50(int param_1,uint param_2)

{
  uint *puVar1;
  
  puVar1 = (uint *)(param_1 + 0x1c4);
  while ((param_2 < *puVar1 || (puVar1[1] + *puVar1 <= param_2))) {
    puVar1 = (uint *)puVar1[2];
    if (puVar1 == (uint *)0x0) {
      return;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint * __cdecl FUN_1001ce80(uint *param_1,uint param_2)

{
  LPVOID *ppvVar1;
  undefined4 *puVar2;
  uint *puVar3;
  LPVOID pvVar4;
  int iVar5;
  LPVOID *ppvVar6;
  uint uVar7;
  LPVOID pvVar8;
  uint uVar9;
  
  FUN_1001bff0();
  if ((((*(byte *)(param_1 + 0x6e) & 1) == 0) || (param_2 < _DAT_10835ae0)) ||
     (puVar3 = FUN_1001c5d0((uint)param_1,param_2), puVar3 == (uint *)0x0)) {
    uVar7 = DAT_10835adc + 0x40 + param_2 & ~(DAT_10835adc - 1U);
    if (param_2 < uVar7) {
      pvVar4 = VirtualAlloc((LPVOID)0x0,uVar7,0x3000,4);
      pvVar8 = (LPVOID)0xffffffff;
      if (pvVar4 != (LPVOID)0x0) {
        pvVar8 = pvVar4;
      }
      if (pvVar8 != (LPVOID)0xffffffff) {
        param_1[0x6c] = param_1[0x6c] + uVar7;
        uVar9 = param_1[0x6c];
        if (param_1[0x6d] <= uVar9 && uVar9 != param_1[0x6d]) {
          param_1[0x6d] = uVar9;
        }
        uVar9 = DAT_10835ad4;
        if (param_1[6] == 0) {
          puVar3 = param_1 + 10;
          param_1[4] = (uint)pvVar8;
          iVar5 = 0x20;
          param_1[0x71] = (uint)pvVar8;
          param_1[0x72] = uVar7;
          param_1[0x74] = 1;
          param_1[9] = uVar9;
          param_1[8] = 0xff;
          do {
            puVar3[3] = (uint)puVar3;
            puVar3[2] = (uint)puVar3;
            puVar3 = puVar3 + 2;
            iVar5 = iVar5 + -1;
          } while (iVar5 != 0);
          if (param_1 == &DAT_108358f8) {
            FUN_1001c0b0((int)&DAT_108358f8,(int)pvVar8,uVar7 - 0x38);
          }
          else {
            iVar5 = (int)param_1 + ((param_1[-1] & 0xfffffff8) - 8);
            FUN_1001c0b0((int)param_1,iVar5,(int)pvVar8 + uVar7 + (-0x38 - iVar5));
          }
        }
        else {
          ppvVar6 = (LPVOID *)(param_1 + 0x71);
          for (ppvVar1 = ppvVar6; ppvVar1 != (LPVOID *)0x0; ppvVar1 = (LPVOID *)ppvVar1[2]) {
            if (pvVar8 == (LPVOID)((int)ppvVar1[1] + (int)*ppvVar1)) {
              if (((((uint)ppvVar1[3] & 8) == 0) && (((uint)ppvVar1[3] & 1) != 0)) &&
                 ((*ppvVar1 <= (LPVOID)param_1[6] &&
                  (param_1[6] < (uint)((int)*ppvVar1 + (int)ppvVar1[1]))))) {
                ppvVar1[1] = (LPVOID)((int)ppvVar1[1] + uVar7);
                FUN_1001c0b0((int)param_1,param_1[6],param_1[3] + uVar7);
                goto LAB_1001cfc8;
              }
              break;
            }
          }
          if (pvVar8 < (LPVOID)param_1[4]) {
            param_1[4] = (uint)pvVar8;
          }
          if (ppvVar6 != (LPVOID *)0x0) {
            do {
              if (*ppvVar6 == (LPVOID)((int)pvVar8 + uVar7)) {
                if ((((uint)ppvVar6[3] & 8) == 0) && (((uint)ppvVar6[3] & 1) != 0)) {
                  puVar2 = (undefined4 *)*ppvVar6;
                  ppvVar6[1] = (LPVOID)((int)ppvVar6[1] + uVar7);
                  *ppvVar6 = pvVar8;
                  puVar3 = (uint *)FUN_1001c680(param_1,(int)pvVar8,puVar2,param_2);
                  return puVar3;
                }
                break;
              }
              ppvVar6 = (LPVOID *)ppvVar6[2];
            } while (ppvVar6 != (LPVOID *)0x0);
          }
          FUN_1001bd50(param_1,(uint)pvVar8,uVar7,1);
        }
LAB_1001cfc8:
        if (param_2 < param_1[3]) {
          uVar7 = param_1[6];
          uVar9 = param_1[3] - param_2;
          param_1[3] = uVar9;
          puVar3 = (uint *)(uVar7 + param_2);
          param_1[6] = (uint)puVar3;
          puVar3[1] = uVar9 | 1;
          *(uint *)(uVar7 + 4) = param_2 | 3;
          *puVar3 = DAT_10835ad4 ^ (uint)param_1;
          return (uint *)(uVar7 + 8);
        }
      }
    }
    puVar3 = (uint *)0x0;
  }
  return puVar3;
}



bool __cdecl FUN_1001d070(int param_1,uint param_2)

{
  uint uVar1;
  uint uVar2;
  uint *puVar3;
  uint uVar4;
  int iVar5;
  uint uVar6;
  uint local_8;
  
  local_8 = 0;
  if ((param_2 < 0xffffffc0) && (*(uint *)(param_1 + 0x18) != 0)) {
    if (param_2 + 0x38 < *(uint *)(param_1 + 0xc)) {
      uVar6 = (((DAT_10835adc - 1) + (*(uint *)(param_1 + 0xc) - (param_2 + 0x38))) / DAT_10835adc -
              1) * DAT_10835adc;
      puVar3 = (uint *)FUN_1001ce50(param_1,*(uint *)(param_1 + 0x18));
      if ((((puVar3[3] & 8) == 0) && ((puVar3[3] & 1) != 0)) && (uVar1 = puVar3[1], uVar6 <= uVar1))
      {
        uVar2 = *puVar3;
        uVar4 = param_1 + 0x1c4;
        do {
          if ((uVar2 <= uVar4) && (uVar4 < uVar1 + uVar2)) goto LAB_1001d131;
          uVar4 = *(uint *)(uVar4 + 8);
        } while (uVar4 != 0);
        iVar5 = FUN_1001d900((LPCVOID)(uVar2 + (uVar1 - uVar6)),uVar6);
        if ((iVar5 == 0) && (local_8 = uVar6, uVar6 != 0)) {
          puVar3[1] = puVar3[1] - uVar6;
          *(int *)(param_1 + 0x1b0) = *(int *)(param_1 + 0x1b0) - uVar6;
          FUN_1001c0b0(param_1,*(int *)(param_1 + 0x18),*(int *)(param_1 + 0xc) - uVar6);
        }
      }
    }
LAB_1001d131:
    iVar5 = FUN_1001cae0(param_1);
    iVar5 = local_8 + iVar5;
    if ((iVar5 == 0) &&
       (*(uint *)(param_1 + 0x1c) <= *(uint *)(param_1 + 0xc) &&
        *(uint *)(param_1 + 0xc) != *(uint *)(param_1 + 0x1c))) {
      *(undefined4 *)(param_1 + 0x1c) = 0xffffffff;
      return false;
    }
  }
  else {
    iVar5 = 0;
  }
  return iVar5 != 0;
}



uint * __cdecl FUN_1001d170(uint *param_1,uint param_2)

{
  uint **ppuVar1;
  uint *puVar2;
  code *pcVar3;
  uint *puVar4;
  bool bVar5;
  byte bVar6;
  uint uVar7;
  uint uVar8;
  uint *puVar9;
  uint *puVar10;
  uint *puVar11;
  int iVar12;
  uint *puVar13;
  uint uVar14;
  uint *local_8;
  
  puVar11 = (uint *)0x0;
  uVar7 = param_2 >> 8;
  uVar14 = -param_2;
  if (uVar7 != 0) {
    if (uVar7 < 0x10000) {
      iVar12 = 0x1f;
      if (uVar7 != 0) {
        for (; uVar7 >> iVar12 == 0; iVar12 = iVar12 + -1) {
        }
      }
      uVar7 = (param_2 >> ((char)iVar12 + 7U & 0x1f) & 1) + iVar12 * 2;
    }
    else {
      uVar7 = 0x1f;
    }
  }
  puVar10 = (uint *)param_1[uVar7 + 0x4c];
  if (puVar10 == (uint *)0x0) {
LAB_1001d21b:
    uVar7 = (-1 << ((byte)uVar7 & 0x1f)) * 2 & param_1[1];
    puVar9 = puVar10;
    if (uVar7 != 0) {
      iVar12 = 0;
      if ((-uVar7 & uVar7) != 0) {
        for (; ((-uVar7 & uVar7) >> iVar12 & 1) == 0; iVar12 = iVar12 + 1) {
        }
      }
      puVar9 = (uint *)param_1[iVar12 + 0x4c];
    }
    while (puVar10 = puVar9, puVar10 != (uint *)0x0) {
LAB_1001d246:
      uVar7 = (puVar10[1] & 0xfffffff8) - param_2;
      if (uVar7 < uVar14) {
        puVar11 = puVar10;
        uVar14 = uVar7;
      }
      puVar9 = (uint *)puVar10[4];
      if ((uint *)puVar10[4] == (uint *)0x0) {
        puVar9 = (uint *)puVar10[5];
      }
    }
    if (puVar11 == (uint *)0x0) {
      return (uint *)0x0;
    }
  }
  else {
    if (uVar7 == 0x1f) {
      bVar6 = 0;
    }
    else {
      bVar6 = 0x19 - (char)(uVar7 >> 1);
    }
    iVar12 = param_2 << (bVar6 & 0x1f);
    local_8 = (uint *)0x0;
    puVar9 = puVar10;
    while ((uVar8 = (puVar9[1] & 0xfffffff8) - param_2, uVar14 <= uVar8 ||
           (puVar10 = puVar9, puVar11 = puVar9, uVar14 = uVar8, uVar8 != 0))) {
      puVar10 = (uint *)puVar9[5];
      puVar9 = (uint *)puVar9[4 - (iVar12 >> 0x1f)];
      if ((puVar10 != (uint *)0x0) && (puVar10 != puVar9)) {
        local_8 = puVar10;
      }
      puVar10 = local_8;
      if (puVar9 == (uint *)0x0) break;
      iVar12 = iVar12 * 2;
    }
    if (puVar10 != (uint *)0x0) goto LAB_1001d246;
    if (puVar11 == (uint *)0x0) goto LAB_1001d21b;
  }
  if (param_1[2] - param_2 <= uVar14) {
    return (uint *)0x0;
  }
  if ((puVar11 < (uint *)param_1[4]) ||
     (puVar10 = (uint *)((int)puVar11 + param_2), puVar10 <= puVar11)) {
    bVar5 = Plat_IsInDebugSession();
    if (!bVar5) {
      _abort();
      pcVar3 = (code *)swi(3);
      puVar11 = (uint *)(*pcVar3)();
      return puVar11;
    }
    goto LAB_1001d62e;
  }
  puVar9 = (uint *)puVar11[3];
  uVar7 = puVar11[6];
  if (puVar9 == puVar11) {
    puVar2 = (uint *)puVar11[5];
    puVar4 = puVar11 + 5;
    if ((uint *)puVar11[5] == (uint *)0x0) {
      puVar9 = (uint *)puVar11[4];
      puVar2 = puVar9;
      puVar4 = puVar11 + 4;
      if (puVar9 == (uint *)0x0) goto LAB_1001d32c;
    }
    do {
      do {
        puVar13 = puVar4;
        puVar9 = puVar2;
        puVar2 = (uint *)puVar9[5];
        puVar4 = puVar9 + 5;
      } while ((uint *)puVar9[5] != (uint *)0x0);
      puVar2 = (uint *)puVar9[4];
      puVar4 = puVar9 + 4;
    } while ((uint *)puVar9[4] != (uint *)0x0);
    if (puVar13 < (uint *)param_1[4]) {
      bVar5 = Plat_IsInDebugSession();
      if (!bVar5) {
        _abort();
LAB_1001d62e:
        pcVar3 = (code *)swi(3);
        puVar11 = (uint *)(*pcVar3)();
        return puVar11;
      }
      goto LAB_1001d628;
    }
    *puVar13 = 0;
  }
  else {
    uVar8 = puVar11[2];
    if (uVar8 < param_1[4]) {
      bVar5 = Plat_IsInDebugSession();
      if (bVar5) {
        pcVar3 = (code *)swi(3);
        puVar11 = (uint *)(*pcVar3)();
        return puVar11;
      }
      _abort();
      goto LAB_1001d5fe;
    }
    *(uint **)(uVar8 + 0xc) = puVar9;
    puVar9[2] = uVar8;
  }
LAB_1001d32c:
  if (uVar7 != 0) {
    if (puVar11 == (uint *)param_1[puVar11[7] + 0x4c]) {
      param_1[puVar11[7] + 0x4c] = (uint)puVar9;
      if (puVar9 == (uint *)0x0) {
        param_1[1] = param_1[1] & ~(1 << ((byte)puVar11[7] & 0x1f));
      }
      else {
LAB_1001d3a7:
        if (puVar9 < (uint *)param_1[4]) {
          bVar5 = Plat_IsInDebugSession();
          if (!bVar5) {
            _abort();
LAB_1001d610:
            pcVar3 = (code *)swi(3);
            puVar11 = (uint *)(*pcVar3)();
            return puVar11;
          }
LAB_1001d60a:
          pcVar3 = (code *)swi(3);
          puVar11 = (uint *)(*pcVar3)();
          return puVar11;
        }
        puVar9[6] = uVar7;
        uVar7 = puVar11[4];
        if (uVar7 != 0) {
          if (uVar7 < param_1[4]) {
            bVar5 = Plat_IsInDebugSession();
            if (bVar5) {
LAB_1001d5fe:
              pcVar3 = (code *)swi(3);
              puVar11 = (uint *)(*pcVar3)();
              return puVar11;
            }
            _abort();
            goto LAB_1001d604;
          }
          puVar9[4] = uVar7;
          *(uint **)(uVar7 + 0x18) = puVar9;
        }
        uVar7 = puVar11[5];
        if (uVar7 != 0) {
          if (uVar7 < param_1[4]) {
            bVar5 = Plat_IsInDebugSession();
            if (bVar5) {
LAB_1001d604:
              pcVar3 = (code *)swi(3);
              puVar11 = (uint *)(*pcVar3)();
              return puVar11;
            }
            _abort();
            goto LAB_1001d60a;
          }
          puVar9[5] = uVar7;
          *(uint **)(uVar7 + 0x18) = puVar9;
        }
      }
    }
    else {
      if (uVar7 < param_1[4]) {
        bVar5 = Plat_IsInDebugSession();
        if (bVar5) goto LAB_1001d610;
        _abort();
        goto LAB_1001d616;
      }
      if (*(uint **)(uVar7 + 0x10) == puVar11) {
        *(uint **)(uVar7 + 0x10) = puVar9;
      }
      else {
        *(uint **)(uVar7 + 0x14) = puVar9;
      }
      if (puVar9 != (uint *)0x0) goto LAB_1001d3a7;
    }
  }
  if (uVar14 < 0x10) {
    puVar11[1] = uVar14 + param_2 | 3;
    uVar7 = DAT_10835ad4;
    puVar9 = (uint *)((int)puVar11 + param_2 + uVar14);
    puVar10 = puVar9 + 1;
    *puVar10 = *puVar10 | 1;
    *puVar9 = uVar7 ^ (uint)param_1;
    return puVar11 + 2;
  }
  uVar7 = uVar14 >> 3;
  puVar11[1] = param_2 | 3;
  *puVar10 = DAT_10835ad4 ^ (uint)param_1;
  puVar10[1] = uVar14 | 1;
  *(uint *)((int)puVar10 + uVar14) = uVar14;
  if (0x1f < uVar7) {
    uVar7 = uVar14 >> 8;
    if (uVar7 == 0) {
      uVar7 = 0;
    }
    else if (uVar7 < 0x10000) {
      iVar12 = 0x1f;
      if (uVar7 != 0) {
        for (; uVar7 >> iVar12 == 0; iVar12 = iVar12 + -1) {
        }
      }
      uVar7 = (uVar14 >> ((char)iVar12 + 7U & 0x1f) & 1) + iVar12 * 2;
    }
    else {
      uVar7 = 0x1f;
    }
    puVar10[7] = uVar7;
    puVar10[5] = 0;
    puVar10[4] = 0;
    uVar8 = 1 << ((byte)uVar7 & 0x1f);
    if ((param_1[1] & uVar8) == 0) {
      param_1[1] = param_1[1] | uVar8;
      param_1[uVar7 + 0x4c] = (uint)puVar10;
      puVar10[6] = (uint)(param_1 + uVar7 + 0x4c);
      puVar10[3] = (uint)puVar10;
      puVar10[2] = (uint)puVar10;
      return puVar11 + 2;
    }
    if (uVar7 == 0x1f) {
      bVar6 = 0;
    }
    else {
      bVar6 = 0x19 - (char)(uVar7 >> 1);
    }
    uVar8 = ((uint *)param_1[uVar7 + 0x4c])[1];
    puVar9 = (uint *)param_1[uVar7 + 0x4c];
    iVar12 = uVar14 << (bVar6 & 0x1f);
    while ((uVar8 & 0xfffffff8) != uVar14) {
      ppuVar1 = (uint **)(puVar9 + (4 - (iVar12 >> 0x1f)));
      puVar2 = *ppuVar1;
      if (puVar2 == (uint *)0x0) {
        if ((uint **)param_1[4] <= ppuVar1) {
          *ppuVar1 = puVar10;
          puVar10[6] = (uint)puVar9;
          puVar10[3] = (uint)puVar10;
          puVar10[2] = (uint)puVar10;
          return puVar11 + 2;
        }
        bVar5 = Plat_IsInDebugSession();
        if (bVar5) goto LAB_1001d61c;
        _abort();
        goto LAB_1001d622;
      }
      puVar9 = puVar2;
      iVar12 = iVar12 * 2;
      uVar8 = puVar2[1];
    }
    puVar2 = (uint *)puVar9[2];
    if (((uint *)param_1[4] <= puVar9) && ((uint *)param_1[4] <= puVar2)) {
      puVar2[3] = (uint)puVar10;
      puVar9[2] = (uint)puVar10;
      puVar10[2] = (uint)puVar2;
      puVar10[3] = (uint)puVar9;
      puVar10[6] = 0;
      return puVar11 + 2;
    }
    bVar5 = Plat_IsInDebugSession();
    if (bVar5) {
LAB_1001d622:
      pcVar3 = (code *)swi(3);
      puVar11 = (uint *)(*pcVar3)();
      return puVar11;
    }
    _abort();
LAB_1001d628:
    pcVar3 = (code *)swi(3);
    puVar11 = (uint *)(*pcVar3)();
    return puVar11;
  }
  uVar14 = 1 << ((byte)uVar7 & 0x1f);
  puVar9 = param_1 + (uVar7 + 5) * 2;
  if ((uVar14 & *param_1) == 0) {
    *param_1 = *param_1 | uVar14;
    puVar9[2] = (uint)puVar10;
    puVar9[3] = (uint)puVar10;
    puVar10[3] = (uint)puVar9;
    puVar10[2] = (uint)puVar9;
    return puVar11 + 2;
  }
  uVar7 = puVar9[2];
  if (param_1[4] <= uVar7) {
    puVar9[2] = (uint)puVar10;
    *(uint **)(uVar7 + 0xc) = puVar10;
    puVar10[3] = (uint)puVar9;
    puVar10[2] = uVar7;
    return puVar11 + 2;
  }
  bVar5 = Plat_IsInDebugSession();
  if (!bVar5) {
    _abort();
LAB_1001d61c:
    pcVar3 = (code *)swi(3);
    puVar11 = (uint *)(*pcVar3)();
    return puVar11;
  }
LAB_1001d616:
  pcVar3 = (code *)swi(3);
  puVar11 = (uint *)(*pcVar3)();
  return puVar11;
}



uint * __cdecl FUN_1001d640(uint *param_1,uint param_2)

{
  int iVar1;
  code *pcVar2;
  uint *puVar3;
  bool bVar4;
  uint *puVar5;
  uint *puVar6;
  uint *puVar7;
  uint uVar8;
  uint uVar9;
  uint *puVar10;
  uint uVar11;
  uint *puVar12;
  
  iVar1 = 0;
  if ((-param_1[1] & param_1[1]) != 0) {
    for (; ((-param_1[1] & param_1[1]) >> iVar1 & 1) == 0; iVar1 = iVar1 + 1) {
    }
  }
  puVar7 = (uint *)param_1[iVar1 + 0x4c];
  uVar11 = (puVar7[1] & 0xfffffff8) - param_2;
  puVar5 = puVar7;
  while( true ) {
    puVar6 = (uint *)puVar7[4];
    if (puVar6 == (uint *)0x0) {
      puVar6 = (uint *)puVar7[5];
    }
    if (puVar6 == (uint *)0x0) break;
    uVar8 = (puVar6[1] & 0xfffffff8) - param_2;
    puVar7 = puVar6;
    if (uVar8 < uVar11) {
      uVar11 = uVar8;
      puVar5 = puVar6;
    }
  }
  if ((puVar5 < (uint *)param_1[4]) || (puVar7 = (uint *)((int)puVar5 + param_2), puVar7 <= puVar5))
  {
    bVar4 = Plat_IsInDebugSession();
    if (!bVar4) {
      _abort();
      pcVar2 = (code *)swi(3);
      puVar7 = (uint *)(*pcVar2)();
      return puVar7;
    }
    goto LAB_1001d8f2;
  }
  puVar6 = (uint *)puVar5[3];
  uVar8 = puVar5[6];
  if (puVar6 == puVar5) {
    puVar10 = (uint *)puVar5[5];
    puVar3 = puVar5 + 5;
    if ((uint *)puVar5[5] == (uint *)0x0) {
      puVar6 = (uint *)puVar5[4];
      puVar10 = puVar6;
      puVar3 = puVar5 + 4;
      if (puVar6 == (uint *)0x0) goto LAB_1001d735;
    }
    do {
      do {
        puVar12 = puVar3;
        puVar6 = puVar10;
        puVar10 = (uint *)puVar6[5];
        puVar3 = puVar6 + 5;
      } while ((uint *)puVar6[5] != (uint *)0x0);
      puVar10 = (uint *)puVar6[4];
      puVar3 = puVar6 + 4;
    } while ((uint *)puVar6[4] != (uint *)0x0);
    if (puVar12 < (uint *)param_1[4]) {
      bVar4 = Plat_IsInDebugSession();
      if (!bVar4) {
        _abort();
LAB_1001d8f2:
        pcVar2 = (code *)swi(3);
        puVar7 = (uint *)(*pcVar2)();
        return puVar7;
      }
      goto LAB_1001d8ec;
    }
    *puVar12 = 0;
  }
  else {
    uVar9 = puVar5[2];
    if (uVar9 < param_1[4]) {
      bVar4 = Plat_IsInDebugSession();
      if (bVar4) {
        pcVar2 = (code *)swi(3);
        puVar7 = (uint *)(*pcVar2)();
        return puVar7;
      }
      _abort();
      goto LAB_1001d8ce;
    }
    *(uint **)(uVar9 + 0xc) = puVar6;
    puVar6[2] = uVar9;
  }
LAB_1001d735:
  if (uVar8 != 0) {
    if (puVar5 == (uint *)param_1[puVar5[7] + 0x4c]) {
      param_1[puVar5[7] + 0x4c] = (uint)puVar6;
      if (puVar6 == (uint *)0x0) {
        param_1[1] = param_1[1] & ~(1 << ((byte)puVar5[7] & 0x1f));
      }
      else {
LAB_1001d7ad:
        if (puVar6 < (uint *)param_1[4]) {
          bVar4 = Plat_IsInDebugSession();
          if (!bVar4) {
            _abort();
LAB_1001d8e0:
            pcVar2 = (code *)swi(3);
            puVar7 = (uint *)(*pcVar2)();
            return puVar7;
          }
LAB_1001d8da:
          pcVar2 = (code *)swi(3);
          puVar7 = (uint *)(*pcVar2)();
          return puVar7;
        }
        puVar6[6] = uVar8;
        uVar8 = puVar5[4];
        if (uVar8 != 0) {
          if (uVar8 < param_1[4]) {
            bVar4 = Plat_IsInDebugSession();
            if (bVar4) {
LAB_1001d8ce:
              pcVar2 = (code *)swi(3);
              puVar7 = (uint *)(*pcVar2)();
              return puVar7;
            }
            _abort();
            goto LAB_1001d8d4;
          }
          puVar6[4] = uVar8;
          *(uint **)(uVar8 + 0x18) = puVar6;
        }
        uVar8 = puVar5[5];
        if (uVar8 != 0) {
          if (uVar8 < param_1[4]) {
            bVar4 = Plat_IsInDebugSession();
            if (bVar4) {
LAB_1001d8d4:
              pcVar2 = (code *)swi(3);
              puVar7 = (uint *)(*pcVar2)();
              return puVar7;
            }
            _abort();
            goto LAB_1001d8da;
          }
          puVar6[5] = uVar8;
          *(uint **)(uVar8 + 0x18) = puVar6;
        }
      }
    }
    else {
      if (uVar8 < param_1[4]) {
        bVar4 = Plat_IsInDebugSession();
        if (bVar4) goto LAB_1001d8e0;
        _abort();
        goto LAB_1001d8e6;
      }
      if (*(uint **)(uVar8 + 0x10) == puVar5) {
        *(uint **)(uVar8 + 0x10) = puVar6;
      }
      else {
        *(uint **)(uVar8 + 0x14) = puVar6;
      }
      if (puVar6 != (uint *)0x0) goto LAB_1001d7ad;
    }
  }
  if (uVar11 < 0x10) {
    puVar5[1] = uVar11 + param_2 | 3;
    puVar7 = (uint *)((int)puVar5 + param_2 + uVar11 + 4);
    *puVar7 = *puVar7 | 1;
    *(uint *)((int)puVar5 + param_2 + uVar11) = DAT_10835ad4 ^ (uint)param_1;
    return puVar5 + 2;
  }
  uVar8 = DAT_10835ad4 ^ (uint)param_1;
  puVar5[1] = param_2 | 3;
  *puVar7 = uVar8;
  puVar7[1] = uVar11 | 1;
  *(uint *)((int)puVar7 + uVar11) = uVar11;
  if (param_1[2] != 0) {
    uVar8 = param_1[5];
    uVar9 = param_1[2] >> 3;
    puVar6 = param_1 + (uVar9 + 5) * 2;
    uVar9 = 1 << ((byte)uVar9 & 0x1f);
    if ((uVar9 & *param_1) == 0) {
      *param_1 = *param_1 | uVar9;
      puVar10 = puVar6;
    }
    else {
      puVar10 = (uint *)puVar6[2];
      if (puVar10 < (uint *)param_1[4]) {
        bVar4 = Plat_IsInDebugSession();
        if (!bVar4) {
          _abort();
LAB_1001d8ec:
          pcVar2 = (code *)swi(3);
          puVar7 = (uint *)(*pcVar2)();
          return puVar7;
        }
LAB_1001d8e6:
        pcVar2 = (code *)swi(3);
        puVar7 = (uint *)(*pcVar2)();
        return puVar7;
      }
    }
    puVar6[2] = uVar8;
    puVar10[3] = uVar8;
    *(uint **)(uVar8 + 8) = puVar10;
    *(uint **)(uVar8 + 0xc) = puVar6;
  }
  param_1[2] = uVar11;
  param_1[5] = (uint)puVar7;
  return puVar5 + 2;
}



undefined4 __cdecl FUN_1001d900(LPCVOID param_1,uint param_2)

{
  SIZE_T SVar1;
  BOOL BVar2;
  _MEMORY_BASIC_INFORMATION local_20;
  
  if (param_2 != 0) {
    do {
      SVar1 = VirtualQuery(param_1,&local_20,0x1c);
      if ((((SVar1 == 0) || (local_20.BaseAddress != param_1)) ||
          (local_20.AllocationBase != param_1)) ||
         (((local_20.State != 0x1000 || (param_2 < local_20.RegionSize)) ||
          (BVar2 = VirtualFree(param_1,0,0x8000), BVar2 == 0)))) {
        return 0xffffffff;
      }
      param_1 = (LPCVOID)((int)param_1 + local_20.RegionSize);
      param_2 = param_2 - local_20.RegionSize;
    } while (param_2 != 0);
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint * __cdecl FUN_1001d980(uint param_1,int param_2)

{
  LPVOID pvVar1;
  uint *puVar2;
  int iVar3;
  LPVOID pvVar4;
  uint dwSize;
  
  FUN_1001bff0();
  if (-_DAT_10835ad8 - 0x228U <= param_1) {
    return (uint *)0x0;
  }
  iVar3 = DAT_10835adc;
  if (param_1 != 0) {
    iVar3 = param_1 + 0x228;
  }
  dwSize = DAT_10835adc + -1 + iVar3 & ~(DAT_10835adc - 1U);
  pvVar1 = VirtualAlloc((LPVOID)0x0,dwSize,0x3000,4);
  pvVar4 = (LPVOID)0xffffffff;
  if (pvVar1 != (LPVOID)0x0) {
    pvVar4 = pvVar1;
  }
  if (pvVar4 == (LPVOID)0xffffffff) {
    return (uint *)0x0;
  }
  puVar2 = FUN_1001c0f0((uint)pvVar4,dwSize);
  puVar2[0x74] = 1;
  if (param_2 == 0) {
    puVar2[0x6e] = puVar2[0x6e] & 0xfffffffd;
    return puVar2;
  }
  puVar2[0x6e] = puVar2[0x6e] | 2;
  return puVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_1001da20(uint *param_1)

{
  uint *puVar1;
  uint **ppuVar2;
  uint *puVar3;
  code *pcVar4;
  uint *puVar5;
  bool bVar6;
  byte bVar7;
  int iVar8;
  DWORD DVar9;
  uint uVar10;
  uint uVar11;
  uint *puVar12;
  uint uVar13;
  uint *puVar14;
  uint *puVar15;
  uint *puVar16;
  
  if (param_1 == (uint *)0x0) {
    return;
  }
  puVar16 = param_1 + -2;
  puVar14 = (uint *)(*(uint *)((param_1[-1] & 0xfffffff8) + (int)puVar16) ^ DAT_10835ad4);
  if (puVar14[9] != DAT_10835ad4) {
    bVar6 = Plat_IsInDebugSession();
    if (bVar6) {
      pcVar4 = (code *)swi(3);
      (*pcVar4)();
      return;
    }
    _abort();
    goto LAB_1001e133;
  }
  if (((_DAT_10835ad8 == 0) && (iVar8 = FUN_1001bff0(), iVar8 != 0)) ||
     ((*(byte *)(puVar14 + 0x6e) & 2) != 0)) {
    puVar1 = puVar14 + 0x6f;
    DVar9 = GetCurrentThreadId();
    if (DVar9 != *puVar1) {
      uVar10 = 0;
      LOCK();
      if (*puVar1 == 0) {
        *puVar1 = DVar9;
      }
      else {
        uVar10 = *puVar1;
      }
      if (uVar10 != 0) {
        CThreadFastMutex::Lock((CThreadFastMutex *)puVar1,DVar9,0);
        goto LAB_1001daab;
      }
    }
    puVar14[0x70] = puVar14[0x70] + 1;
  }
LAB_1001daab:
  if (((uint *)puVar14[4] <= puVar16) && (uVar10 = param_1[-1], (uVar10 & 2) != 0)) {
    uVar13 = uVar10 & 0xfffffff8;
    puVar1 = (uint *)(uVar13 + (int)puVar16);
    if ((uVar10 & 1) != 0) goto LAB_1001db3c;
    uVar10 = *puVar16;
    if ((uVar10 & 1) != 0) {
      uVar13 = uVar13 + 0x10 + (uVar10 & 0xfffffffe);
      iVar8 = FUN_1001d900((LPCVOID)((int)puVar16 - (uVar10 & 0xfffffffe)),uVar13);
      if (iVar8 == 0) {
        puVar14[0x6c] = puVar14[0x6c] - uVar13;
      }
      goto LAB_1001e0d1;
    }
    puVar16 = (uint *)((int)puVar16 - uVar10);
    uVar13 = uVar13 + uVar10;
    if (puVar16 < (uint *)puVar14[4]) goto LAB_1001e122;
    if (puVar16 == (uint *)puVar14[5]) {
      if (((byte)puVar1[1] & 3) == 3) {
        puVar14[2] = uVar13;
        puVar1[1] = puVar1[1] & 0xfffffffe;
        puVar16[1] = uVar13 | 1;
        *(uint *)((int)puVar16 + uVar13) = uVar13;
        goto LAB_1001e0d1;
      }
    }
    else {
      uVar10 = uVar10 >> 3;
      if (uVar10 < 0x20) {
        puVar12 = (uint *)puVar16[2];
        puVar3 = (uint *)puVar16[3];
        if (puVar12 == puVar3) {
          *puVar14 = *puVar14 & ~(1 << ((byte)uVar10 & 0x1f));
        }
        else {
          if (((puVar12 != puVar14 + (uVar10 + 5) * 2) && (puVar12 < (uint *)puVar14[4])) ||
             ((puVar3 != puVar14 + (uVar10 + 5) * 2 && (puVar3 < (uint *)puVar14[4])))) {
            bVar6 = Plat_IsInDebugSession();
            if (bVar6) {
LAB_1001e133:
              pcVar4 = (code *)swi(3);
              (*pcVar4)();
              return;
            }
            _abort();
LAB_1001e139:
            pcVar4 = (code *)swi(3);
            (*pcVar4)();
            return;
          }
          puVar12[3] = (uint)puVar3;
          puVar3[2] = (uint)puVar12;
        }
      }
      else {
        puVar12 = (uint *)puVar16[3];
        uVar10 = puVar16[6];
        if (puVar12 == puVar16) {
          puVar3 = (uint *)puVar16[5];
          puVar5 = puVar16 + 5;
          if ((uint *)puVar16[5] == (uint *)0x0) {
            puVar12 = (uint *)puVar16[4];
            puVar3 = puVar12;
            puVar5 = puVar16 + 4;
            if (puVar12 == (uint *)0x0) goto LAB_1001dc6c;
          }
          do {
            do {
              puVar15 = puVar5;
              puVar12 = puVar3;
              puVar3 = (uint *)puVar12[5];
              puVar5 = puVar12 + 5;
            } while ((uint *)puVar12[5] != (uint *)0x0);
            puVar3 = (uint *)puVar12[4];
            puVar5 = puVar12 + 4;
          } while ((uint *)puVar12[4] != (uint *)0x0);
          if (puVar15 < (uint *)puVar14[4]) {
            bVar6 = Plat_IsInDebugSession();
            if (bVar6) goto LAB_1001e157;
            _abort();
            goto LAB_1001e15d;
          }
          *puVar15 = 0;
        }
        else {
          uVar11 = puVar16[2];
          if (uVar11 < puVar14[4]) {
            bVar6 = Plat_IsInDebugSession();
            if (bVar6) goto LAB_1001e139;
            _abort();
            goto LAB_1001e13f;
          }
          *(uint **)(uVar11 + 0xc) = puVar12;
          puVar12[2] = uVar11;
        }
LAB_1001dc6c:
        if (uVar10 != 0) {
          if (puVar16 == (uint *)puVar14[puVar16[7] + 0x4c]) {
            puVar14[puVar16[7] + 0x4c] = (uint)puVar12;
            if (puVar12 == (uint *)0x0) {
              puVar14[1] = puVar14[1] & ~(1 << ((byte)puVar16[7] & 0x1f));
            }
            else {
LAB_1001dcc7:
              if (puVar12 < (uint *)puVar14[4]) {
                bVar6 = Plat_IsInDebugSession();
                if (!bVar6) {
                  _abort();
LAB_1001e151:
                  pcVar4 = (code *)swi(3);
                  (*pcVar4)();
                  return;
                }
LAB_1001e14b:
                pcVar4 = (code *)swi(3);
                (*pcVar4)();
                return;
              }
              puVar12[6] = uVar10;
              uVar10 = puVar16[4];
              if (uVar10 != 0) {
                if (uVar10 < puVar14[4]) {
                  bVar6 = Plat_IsInDebugSession();
                  if (bVar6) {
LAB_1001e13f:
                    pcVar4 = (code *)swi(3);
                    (*pcVar4)();
                    return;
                  }
                  _abort();
                  goto LAB_1001e145;
                }
                puVar12[4] = uVar10;
                *(uint **)(uVar10 + 0x18) = puVar12;
              }
              uVar10 = puVar16[5];
              if (uVar10 != 0) {
                if (uVar10 < puVar14[4]) {
                  bVar6 = Plat_IsInDebugSession();
                  if (bVar6) {
LAB_1001e145:
                    pcVar4 = (code *)swi(3);
                    (*pcVar4)();
                    return;
                  }
                  _abort();
                  goto LAB_1001e14b;
                }
                puVar12[5] = uVar10;
                *(uint **)(uVar10 + 0x18) = puVar12;
              }
            }
          }
          else {
            if (uVar10 < puVar14[4]) {
              bVar6 = Plat_IsInDebugSession();
              if (!bVar6) {
                _abort();
LAB_1001e157:
                pcVar4 = (code *)swi(3);
                (*pcVar4)();
                return;
              }
              goto LAB_1001e151;
            }
            if (*(uint **)(uVar10 + 0x10) == puVar16) {
              *(uint **)(uVar10 + 0x10) = puVar12;
            }
            else {
              *(uint **)(uVar10 + 0x14) = puVar12;
            }
            if (puVar12 != (uint *)0x0) goto LAB_1001dcc7;
          }
        }
      }
    }
LAB_1001db3c:
    if ((puVar16 < puVar1) && (uVar10 = puVar1[1], (uVar10 & 1) != 0)) {
      if ((uVar10 & 2) == 0) {
        if (puVar1 == (uint *)puVar14[6]) {
          puVar14[3] = puVar14[3] + uVar13;
          uVar10 = puVar14[3];
          puVar14[6] = (uint)puVar16;
          puVar16[1] = uVar10 | 1;
          if (puVar16 == (uint *)puVar14[5]) {
            puVar14[5] = 0;
            puVar14[2] = 0;
          }
          if (puVar14[7] <= uVar10 && uVar10 != puVar14[7]) {
            FUN_1001d070((int)puVar14,0);
          }
          goto LAB_1001e0d1;
        }
        if (puVar1 == (uint *)puVar14[5]) {
          puVar14[2] = puVar14[2] + uVar13;
          uVar10 = puVar14[2];
          puVar14[5] = (uint)puVar16;
          puVar16[1] = uVar10 | 1;
          *(uint *)(uVar10 + (int)puVar16) = uVar10;
          goto LAB_1001e0d1;
        }
        uVar13 = uVar13 + (uVar10 & 0xfffffff8);
        uVar10 = uVar10 >> 3;
        if (uVar10 < 0x20) {
          puVar12 = (uint *)puVar1[2];
          puVar1 = (uint *)puVar1[3];
          if (puVar12 == puVar1) {
            *puVar14 = *puVar14 & ~(1 << ((byte)uVar10 & 0x1f));
          }
          else {
            if (((puVar12 != puVar14 + (uVar10 + 5) * 2) && (puVar12 < (uint *)puVar14[4])) ||
               ((puVar1 != puVar14 + (uVar10 + 5) * 2 && (puVar1 < (uint *)puVar14[4])))) {
              bVar6 = Plat_IsInDebugSession();
              if (bVar6) {
LAB_1001e15d:
                pcVar4 = (code *)swi(3);
                (*pcVar4)();
                return;
              }
              _abort();
LAB_1001e163:
              pcVar4 = (code *)swi(3);
              (*pcVar4)();
              return;
            }
            puVar12[3] = (uint)puVar1;
            puVar1[2] = (uint)puVar12;
          }
        }
        else {
          uVar10 = puVar1[6];
          puVar12 = (uint *)puVar1[3];
          if (puVar12 == puVar1) {
            puVar3 = (uint *)puVar1[5];
            puVar5 = puVar1 + 5;
            if ((uint *)puVar1[5] == (uint *)0x0) {
              puVar12 = (uint *)puVar1[4];
              puVar3 = puVar12;
              puVar5 = puVar1 + 4;
              if (puVar12 == (uint *)0x0) goto LAB_1001de88;
            }
            do {
              do {
                param_1 = puVar5;
                puVar12 = puVar3;
                puVar3 = (uint *)puVar12[5];
                puVar5 = puVar12 + 5;
              } while ((uint *)puVar12[5] != (uint *)0x0);
              puVar3 = (uint *)puVar12[4];
              puVar5 = puVar12 + 4;
            } while ((uint *)puVar12[4] != (uint *)0x0);
            if (param_1 < (uint *)puVar14[4]) {
              bVar6 = Plat_IsInDebugSession();
              if (bVar6) goto LAB_1001e181;
              _abort();
              goto LAB_1001e187;
            }
            *param_1 = 0;
          }
          else {
            uVar11 = puVar1[2];
            if (uVar11 < puVar14[4]) {
              bVar6 = Plat_IsInDebugSession();
              if (bVar6) goto LAB_1001e163;
              _abort();
              goto LAB_1001e169;
            }
            *(uint **)(uVar11 + 0xc) = puVar12;
            puVar12[2] = uVar11;
          }
LAB_1001de88:
          if (uVar10 != 0) {
            if (puVar1 == (uint *)puVar14[puVar1[7] + 0x4c]) {
              puVar14[puVar1[7] + 0x4c] = (uint)puVar12;
              if (puVar12 == (uint *)0x0) {
                puVar14[1] = puVar14[1] & ~(1 << ((byte)puVar1[7] & 0x1f));
              }
              else {
LAB_1001dee3:
                if (puVar12 < (uint *)puVar14[4]) {
                  bVar6 = Plat_IsInDebugSession();
                  if (!bVar6) {
                    _abort();
LAB_1001e17b:
                    pcVar4 = (code *)swi(3);
                    (*pcVar4)();
                    return;
                  }
LAB_1001e175:
                  pcVar4 = (code *)swi(3);
                  (*pcVar4)();
                  return;
                }
                puVar12[6] = uVar10;
                uVar10 = puVar1[4];
                if (uVar10 != 0) {
                  if (uVar10 < puVar14[4]) {
                    bVar6 = Plat_IsInDebugSession();
                    if (bVar6) {
LAB_1001e169:
                      pcVar4 = (code *)swi(3);
                      (*pcVar4)();
                      return;
                    }
                    _abort();
                    goto LAB_1001e16f;
                  }
                  puVar12[4] = uVar10;
                  *(uint **)(uVar10 + 0x18) = puVar12;
                }
                uVar10 = puVar1[5];
                if (uVar10 != 0) {
                  if (uVar10 < puVar14[4]) {
                    bVar6 = Plat_IsInDebugSession();
                    if (bVar6) {
LAB_1001e16f:
                      pcVar4 = (code *)swi(3);
                      (*pcVar4)();
                      return;
                    }
                    _abort();
                    goto LAB_1001e175;
                  }
                  puVar12[5] = uVar10;
                  *(uint **)(uVar10 + 0x18) = puVar12;
                }
              }
            }
            else {
              if (uVar10 < puVar14[4]) {
                bVar6 = Plat_IsInDebugSession();
                if (!bVar6) {
                  _abort();
LAB_1001e181:
                  pcVar4 = (code *)swi(3);
                  (*pcVar4)();
                  return;
                }
                goto LAB_1001e17b;
              }
              if (*(uint **)(uVar10 + 0x10) == puVar1) {
                *(uint **)(uVar10 + 0x10) = puVar12;
              }
              else {
                *(uint **)(uVar10 + 0x14) = puVar12;
              }
              if (puVar12 != (uint *)0x0) goto LAB_1001dee3;
            }
          }
        }
        puVar16[1] = uVar13 | 1;
        *(uint *)(uVar13 + (int)puVar16) = uVar13;
        if (puVar16 == (uint *)puVar14[5]) {
          puVar14[2] = uVar13;
          goto LAB_1001e0d1;
        }
      }
      else {
        puVar1[1] = uVar10 & 0xfffffffe;
        puVar16[1] = uVar13 | 1;
        *(uint *)(uVar13 + (int)puVar16) = uVar13;
      }
      uVar10 = uVar13 >> 3;
      if (uVar10 < 0x20) {
        uVar13 = 1 << ((byte)uVar10 & 0x1f);
        puVar1 = puVar14 + (uVar10 + 5) * 2;
        if ((uVar13 & *puVar14) == 0) {
          *puVar14 = *puVar14 | uVar13;
          puVar1[2] = (uint)puVar16;
          puVar1[3] = (uint)puVar16;
          puVar16[2] = (uint)puVar1;
          puVar16[3] = (uint)puVar1;
        }
        else {
          uVar10 = puVar1[2];
          if (uVar10 < puVar14[4]) {
            bVar6 = Plat_IsInDebugSession();
            if (!bVar6) {
              _abort();
LAB_1001e18d:
              pcVar4 = (code *)swi(3);
              (*pcVar4)();
              return;
            }
LAB_1001e187:
            pcVar4 = (code *)swi(3);
            (*pcVar4)();
            return;
          }
          puVar1[2] = (uint)puVar16;
          *(uint **)(uVar10 + 0xc) = puVar16;
          puVar16[2] = uVar10;
          puVar16[3] = (uint)puVar1;
        }
      }
      else {
        uVar10 = uVar13 >> 8;
        if (uVar10 == 0) {
          uVar10 = 0;
        }
        else if (uVar10 < 0x10000) {
          iVar8 = 0x1f;
          if (uVar10 != 0) {
            for (; uVar10 >> iVar8 == 0; iVar8 = iVar8 + -1) {
            }
          }
          uVar10 = (uVar13 >> ((char)iVar8 + 7U & 0x1f) & 1) + iVar8 * 2;
        }
        else {
          uVar10 = 0x1f;
        }
        puVar16[7] = uVar10;
        uVar11 = 1 << ((byte)uVar10 & 0x1f);
        ppuVar2 = (uint **)(puVar14 + uVar10 + 0x4c);
        puVar16[5] = 0;
        puVar16[4] = 0;
        if ((uVar11 & puVar14[1]) == 0) {
          puVar14[1] = puVar14[1] | uVar11;
          *ppuVar2 = puVar16;
          puVar16[6] = (uint)ppuVar2;
          puVar16[3] = (uint)puVar16;
          puVar16[2] = (uint)puVar16;
        }
        else {
          if (uVar10 == 0x1f) {
            bVar7 = 0;
          }
          else {
            bVar7 = 0x19 - (char)(uVar10 >> 1);
          }
          uVar10 = (*ppuVar2)[1];
          puVar1 = *ppuVar2;
          iVar8 = uVar13 << (bVar7 & 0x1f);
          while ((uVar10 & 0xfffffff8) != uVar13) {
            ppuVar2 = (uint **)(puVar1 + (4 - (iVar8 >> 0x1f)));
            puVar12 = *ppuVar2;
            if (puVar12 == (uint *)0x0) {
              if ((uint **)puVar14[4] <= ppuVar2) {
                *ppuVar2 = puVar16;
                puVar16[6] = (uint)puVar1;
                puVar16[3] = (uint)puVar16;
                puVar16[2] = (uint)puVar16;
                goto LAB_1001e0c3;
              }
              bVar6 = Plat_IsInDebugSession();
              if (bVar6) goto LAB_1001e18d;
              _abort();
              goto LAB_1001e193;
            }
            puVar1 = puVar12;
            iVar8 = iVar8 * 2;
            uVar10 = puVar12[1];
          }
          puVar12 = (uint *)puVar1[2];
          if ((puVar1 < (uint *)puVar14[4]) || (puVar12 < (uint *)puVar14[4])) {
            bVar6 = Plat_IsInDebugSession();
            if (bVar6) {
LAB_1001e193:
              pcVar4 = (code *)swi(3);
              (*pcVar4)();
              return;
            }
            _abort();
            goto LAB_1001e199;
          }
          puVar12[3] = (uint)puVar16;
          puVar1[2] = (uint)puVar16;
          puVar16[2] = (uint)puVar12;
          puVar16[3] = (uint)puVar1;
          puVar16[6] = 0;
        }
LAB_1001e0c3:
        puVar16 = puVar14 + 8;
        *puVar16 = *puVar16 - 1;
        if (*puVar16 == 0) {
          FUN_1001cae0((int)puVar14);
        }
      }
LAB_1001e0d1:
      if ((*(byte *)(puVar14 + 0x6e) & 2) != 0) {
        puVar14[0x70] = puVar14[0x70] - 1;
        if (puVar14[0x70] == 0) {
          puVar14[0x6f] = 0;
        }
      }
      return;
    }
  }
LAB_1001e122:
  bVar6 = Plat_IsInDebugSession();
  if (!bVar6) {
    _abort();
    pcVar4 = (code *)swi(3);
    (*pcVar4)();
    return;
  }
LAB_1001e199:
  pcVar4 = (code *)swi(3);
  (*pcVar4)();
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint * __cdecl FUN_1001e1a0(uint param_1)

{
  int iVar1;
  code *pcVar2;
  DWORD DVar3;
  bool bVar4;
  int iVar5;
  DWORD DVar6;
  DWORD DVar7;
  undefined *puVar8;
  uint *puVar9;
  byte bVar10;
  int iVar11;
  uint *puVar12;
  uint uVar13;
  uint uVar14;
  uint uVar15;
  uint *puVar16;
  
  if (((_DAT_10835ad8 == 0) && (iVar5 = FUN_1001bff0(), iVar5 != 0)) || ((DAT_10835ab0 & 2) != 0)) {
    DVar6 = GetCurrentThreadId();
    if (DVar6 != DAT_10835ab4) {
      DVar7 = 0;
      LOCK();
      DVar3 = DVar6;
      if (DAT_10835ab4 != 0) {
        DVar7 = DAT_10835ab4;
        DVar3 = DAT_10835ab4;
      }
      DAT_10835ab4 = DVar3;
      if (DVar7 != 0) {
        CThreadFastMutex::Lock((CThreadFastMutex *)&DAT_10835ab4,DVar6,0);
        goto LAB_1001e1f9;
      }
    }
    _DAT_10835ab8 = _DAT_10835ab8 + 1;
  }
LAB_1001e1f9:
  if (param_1 < 0xe9) {
    if (param_1 < 7) {
      uVar15 = 0x10;
    }
    else {
      uVar15 = param_1 + 0x17 & 0xfffffff0;
    }
    bVar10 = (byte)(uVar15 >> 3);
    uVar14 = DAT_108358f8 >> (bVar10 & 0x1f);
    if ((uVar14 & 3) != 0) {
      iVar11 = (uVar15 >> 3) + (~uVar14 & 1);
      iVar5 = *(int *)(&DAT_10835928 + iVar11 * 8);
      puVar8 = *(undefined **)(iVar5 + 8);
      puVar9 = (uint *)(iVar5 + 8);
      if (&DAT_10835920 + iVar11 * 8 == puVar8) {
        DAT_108358f8 = DAT_108358f8 & ~(1 << ((byte)iVar11 & 0x1f));
      }
      else {
        if (puVar8 < _DAT_10835908) {
          bVar4 = Plat_IsInDebugSession();
          if (bVar4) {
            pcVar2 = (code *)swi(3);
            puVar9 = (uint *)(*pcVar2)();
            return puVar9;
          }
          _abort();
LAB_1001e509:
          pcVar2 = (code *)swi(3);
          puVar9 = (uint *)(*pcVar2)();
          return puVar9;
        }
        *(undefined **)(&DAT_10835928 + iVar11 * 8) = puVar8;
        *(undefined **)(puVar8 + 0xc) = &DAT_10835920 + iVar11 * 8;
      }
      *(uint *)(iVar5 + 4) = iVar11 * 8 | 3;
      puVar12 = (uint *)(iVar5 + 4 + iVar11 * 8);
      *puVar12 = *puVar12 | 1;
      *(uint *)(iVar5 + iVar11 * 8) = DAT_10835ad4 ^ 0x108358f8;
      uVar14 = DAT_10835900;
      puVar12 = DAT_1083590c;
      goto LAB_1001e4e0;
    }
    uVar13 = DAT_10835900;
    if (DAT_10835900 < uVar15) {
      if (uVar14 != 0) {
        uVar14 = uVar14 << (bVar10 & 0x1f) & (-1 << (bVar10 & 0x1f)) * 2;
        uVar14 = -uVar14 & uVar14;
        iVar5 = 0;
        if (uVar14 != 0) {
          for (; (uVar14 >> iVar5 & 1) == 0; iVar5 = iVar5 + 1) {
          }
        }
        iVar11 = iVar5 * 8;
        iVar1 = *(int *)(&DAT_10835928 + iVar11);
        puVar9 = (uint *)(iVar1 + 8);
        puVar8 = (undefined *)*puVar9;
        if (&DAT_10835920 + iVar11 == puVar8) {
          DAT_108358f8 = DAT_108358f8 & ~(1 << ((byte)iVar5 & 0x1f));
        }
        else {
          if (puVar8 < _DAT_10835908) {
            bVar4 = Plat_IsInDebugSession();
            if (!bVar4) {
              _abort();
              pcVar2 = (code *)swi(3);
              puVar9 = (uint *)(*pcVar2)();
              return puVar9;
            }
            goto LAB_1001e50f;
          }
          *(undefined **)(&DAT_10835928 + iVar11) = puVar8;
          *(undefined **)(puVar8 + 0xc) = &DAT_10835920 + iVar11;
        }
        uVar14 = iVar11 - uVar15;
        *(uint *)(iVar1 + 4) = uVar15 | 3;
        puVar12 = (uint *)(iVar1 + uVar15);
        *puVar12 = DAT_10835ad4 ^ 0x108358f8;
        puVar12[1] = uVar14 | 1;
        *(uint *)((int)puVar12 + uVar14) = uVar14;
        if (DAT_10835900 != 0) {
          uVar13 = 1 << ((byte)(DAT_10835900 >> 3) & 0x1f);
          uVar15 = DAT_10835900 & 0xfffffff8;
          if ((uVar13 & DAT_108358f8) == 0) {
            DAT_108358f8 = DAT_108358f8 | uVar13;
            puVar8 = &DAT_10835920 + uVar15;
          }
          else {
            puVar8 = *(undefined **)(&DAT_10835928 + uVar15);
            if (puVar8 < _DAT_10835908) {
              bVar4 = Plat_IsInDebugSession();
              if (!bVar4) {
                _abort();
LAB_1001e50f:
                pcVar2 = (code *)swi(3);
                puVar9 = (uint *)(*pcVar2)();
                return puVar9;
              }
              goto LAB_1001e509;
            }
          }
          *(uint **)(&DAT_10835928 + uVar15) = DAT_1083590c;
          *(uint **)(puVar8 + 0xc) = DAT_1083590c;
          DAT_1083590c[2] = (uint)puVar8;
          DAT_1083590c[3] = (uint)(&DAT_10835920 + uVar15);
        }
        goto LAB_1001e4e0;
      }
      if (_DAT_108358fc != 0) {
        puVar9 = FUN_1001d640(&DAT_108358f8,uVar15);
        goto LAB_1001e405;
      }
      goto LAB_1001e418;
    }
  }
  else {
    if (param_1 < 0xffffffc0) {
      uVar15 = param_1 + 0x17 & 0xfffffff0;
      if (_DAT_108358fc != 0) {
        puVar9 = FUN_1001d170(&DAT_108358f8,uVar15);
LAB_1001e405:
        uVar14 = DAT_10835900;
        puVar12 = DAT_1083590c;
        if (puVar9 != (uint *)0x0) goto LAB_1001e4e0;
      }
    }
    else {
      uVar15 = 0xffffffff;
    }
LAB_1001e418:
    puVar9 = DAT_10835910;
    uVar13 = DAT_10835900;
    if (DAT_10835900 < uVar15) {
      if (uVar15 < DAT_10835904) {
        DAT_10835904 = DAT_10835904 - uVar15;
        puVar12 = (uint *)((int)DAT_10835910 + uVar15);
        DAT_10835910 = puVar12;
        puVar12[1] = DAT_10835904 | 1;
        uVar14 = DAT_10835ad4 ^ 0x108358f8;
        puVar9[1] = uVar15 | 3;
        *puVar12 = uVar14;
        puVar9 = puVar9 + 2;
        uVar14 = DAT_10835900;
        puVar12 = DAT_1083590c;
      }
      else {
        puVar9 = FUN_1001ce80(&DAT_108358f8,uVar15);
        uVar14 = DAT_10835900;
        puVar12 = DAT_1083590c;
      }
      goto LAB_1001e4e0;
    }
  }
  puVar12 = DAT_1083590c;
  uVar14 = uVar13 - uVar15;
  if (uVar14 < 0x10) {
    DAT_10835900 = 0;
    DAT_1083590c = (uint *)0x0;
    puVar12[1] = uVar13 | 3;
    puVar9 = (uint *)(uVar13 + 4 + (int)puVar12);
    *puVar9 = *puVar9 | 1;
    *(uint *)(uVar13 + (int)puVar12) = DAT_10835ad4 ^ 0x108358f8;
    puVar9 = puVar12 + 2;
    uVar14 = DAT_10835900;
    puVar12 = DAT_1083590c;
  }
  else {
    puVar16 = (uint *)((int)DAT_1083590c + uVar15);
    puVar9 = DAT_1083590c + 2;
    DAT_10835900 = uVar14;
    DAT_1083590c = puVar16;
    puVar16[1] = uVar14 | 1;
    uVar13 = DAT_10835ad4;
    *(uint *)((int)puVar16 + uVar14) = uVar14;
    puVar12[1] = uVar15 | 3;
    *puVar16 = uVar13 ^ 0x108358f8;
    uVar14 = DAT_10835900;
    puVar12 = DAT_1083590c;
  }
LAB_1001e4e0:
  DAT_1083590c = puVar12;
  DAT_10835900 = uVar14;
  if (((DAT_10835ab0 & 2) != 0) && (_DAT_10835ab8 = _DAT_10835ab8 + -1, _DAT_10835ab8 == 0)) {
    DAT_10835ab4 = 0;
  }
  return puVar9;
}



int __cdecl FUN_1001e520(int param_1)

{
  if ((param_1 != 0) && ((*(uint *)(param_1 + -4) & 2) != 0)) {
    return (*(uint *)(param_1 + -4) & 0xfffffff8) - 8;
  }
  return 0;
}



void __cdecl FUN_1001e540(uint *param_1,uint param_2)

{
  code *pcVar1;
  bool bVar2;
  uint *puVar3;
  
  if (param_1 == (uint *)0x0) {
    FUN_1001e1a0(param_2);
    return;
  }
  puVar3 = (uint *)(*(uint *)(((param_1[-1] & 0xfffffff8) - 8) + (int)param_1) ^ DAT_10835ad4);
  if (puVar3[9] != DAT_10835ad4) {
    bVar2 = Plat_IsInDebugSession();
    if (bVar2) {
      pcVar1 = (code *)swi(3);
      (*pcVar1)();
      return;
    }
    _abort();
    return;
  }
  FUN_1001c370(puVar3,param_1,param_2);
  return;
}



uint __cdecl FUN_1001e590(int param_1)

{
  code *pcVar1;
  bool bVar2;
  undefined3 extraout_var;
  uint uVar3;
  
  if (*(int *)(param_1 + 0x24) == DAT_10835ad4) {
    return *(uint *)(param_1 + 0x1b0);
  }
  bVar2 = Plat_IsInDebugSession();
  uVar3 = CONCAT31(extraout_var,bVar2);
  if (bVar2) {
    pcVar1 = (code *)swi(3);
    uVar3 = (*pcVar1)();
    return uVar3;
  }
  _abort();
  return uVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_1001e5c0(undefined4 param_1,uint *param_2)

{
  uint *puVar1;
  uint **ppuVar2;
  uint *puVar3;
  code *pcVar4;
  uint *puVar5;
  bool bVar6;
  byte bVar7;
  int iVar8;
  DWORD DVar9;
  uint uVar10;
  uint uVar11;
  uint *puVar12;
  uint uVar13;
  uint *puVar14;
  uint *puVar15;
  uint *puVar16;
  
  if (param_2 == (uint *)0x0) {
    return;
  }
  puVar16 = param_2 + -2;
  puVar14 = (uint *)(*(uint *)((param_2[-1] & 0xfffffff8) + (int)puVar16) ^ DAT_10835ad4);
  if (puVar14[9] != DAT_10835ad4) {
    bVar6 = Plat_IsInDebugSession();
    if (bVar6) {
      pcVar4 = (code *)swi(3);
      (*pcVar4)();
      return;
    }
    _abort();
    goto LAB_1001ecd3;
  }
  if (((_DAT_10835ad8 == 0) && (iVar8 = FUN_1001bff0(), iVar8 != 0)) ||
     ((*(byte *)(puVar14 + 0x6e) & 2) != 0)) {
    puVar1 = puVar14 + 0x6f;
    DVar9 = GetCurrentThreadId();
    if (DVar9 != *puVar1) {
      uVar10 = 0;
      LOCK();
      if (*puVar1 == 0) {
        *puVar1 = DVar9;
      }
      else {
        uVar10 = *puVar1;
      }
      if (uVar10 != 0) {
        CThreadFastMutex::Lock((CThreadFastMutex *)puVar1,DVar9,0);
        goto LAB_1001e64b;
      }
    }
    puVar14[0x70] = puVar14[0x70] + 1;
  }
LAB_1001e64b:
  if (((uint *)puVar14[4] <= puVar16) && (uVar10 = param_2[-1], (uVar10 & 2) != 0)) {
    uVar13 = uVar10 & 0xfffffff8;
    puVar1 = (uint *)(uVar13 + (int)puVar16);
    if ((uVar10 & 1) != 0) goto LAB_1001e6dc;
    uVar10 = *puVar16;
    if ((uVar10 & 1) != 0) {
      uVar13 = uVar13 + 0x10 + (uVar10 & 0xfffffffe);
      iVar8 = FUN_1001d900((LPCVOID)((int)puVar16 - (uVar10 & 0xfffffffe)),uVar13);
      if (iVar8 == 0) {
        puVar14[0x6c] = puVar14[0x6c] - uVar13;
      }
      goto LAB_1001ec71;
    }
    puVar16 = (uint *)((int)puVar16 - uVar10);
    uVar13 = uVar13 + uVar10;
    if (puVar16 < (uint *)puVar14[4]) goto LAB_1001ecc2;
    if (puVar16 == (uint *)puVar14[5]) {
      if (((byte)puVar1[1] & 3) == 3) {
        puVar14[2] = uVar13;
        puVar1[1] = puVar1[1] & 0xfffffffe;
        puVar16[1] = uVar13 | 1;
        *(uint *)((int)puVar16 + uVar13) = uVar13;
        goto LAB_1001ec71;
      }
    }
    else {
      uVar10 = uVar10 >> 3;
      if (uVar10 < 0x20) {
        puVar12 = (uint *)puVar16[2];
        puVar3 = (uint *)puVar16[3];
        if (puVar12 == puVar3) {
          *puVar14 = *puVar14 & ~(1 << ((byte)uVar10 & 0x1f));
        }
        else {
          if (((puVar12 != puVar14 + (uVar10 + 5) * 2) && (puVar12 < (uint *)puVar14[4])) ||
             ((puVar3 != puVar14 + (uVar10 + 5) * 2 && (puVar3 < (uint *)puVar14[4])))) {
            bVar6 = Plat_IsInDebugSession();
            if (bVar6) {
LAB_1001ecd3:
              pcVar4 = (code *)swi(3);
              (*pcVar4)();
              return;
            }
            _abort();
LAB_1001ecd9:
            pcVar4 = (code *)swi(3);
            (*pcVar4)();
            return;
          }
          puVar12[3] = (uint)puVar3;
          puVar3[2] = (uint)puVar12;
        }
      }
      else {
        puVar12 = (uint *)puVar16[3];
        uVar10 = puVar16[6];
        if (puVar12 == puVar16) {
          puVar3 = (uint *)puVar16[5];
          puVar5 = puVar16 + 5;
          if ((uint *)puVar16[5] == (uint *)0x0) {
            puVar12 = (uint *)puVar16[4];
            puVar3 = puVar12;
            puVar5 = puVar16 + 4;
            if (puVar12 == (uint *)0x0) goto LAB_1001e80c;
          }
          do {
            do {
              puVar15 = puVar5;
              puVar12 = puVar3;
              puVar3 = (uint *)puVar12[5];
              puVar5 = puVar12 + 5;
            } while ((uint *)puVar12[5] != (uint *)0x0);
            puVar3 = (uint *)puVar12[4];
            puVar5 = puVar12 + 4;
          } while ((uint *)puVar12[4] != (uint *)0x0);
          if (puVar15 < (uint *)puVar14[4]) {
            bVar6 = Plat_IsInDebugSession();
            if (bVar6) goto LAB_1001ecf7;
            _abort();
            goto LAB_1001ecfd;
          }
          *puVar15 = 0;
        }
        else {
          uVar11 = puVar16[2];
          if (uVar11 < puVar14[4]) {
            bVar6 = Plat_IsInDebugSession();
            if (bVar6) goto LAB_1001ecd9;
            _abort();
            goto LAB_1001ecdf;
          }
          *(uint **)(uVar11 + 0xc) = puVar12;
          puVar12[2] = uVar11;
        }
LAB_1001e80c:
        if (uVar10 != 0) {
          if (puVar16 == (uint *)puVar14[puVar16[7] + 0x4c]) {
            puVar14[puVar16[7] + 0x4c] = (uint)puVar12;
            if (puVar12 == (uint *)0x0) {
              puVar14[1] = puVar14[1] & ~(1 << ((byte)puVar16[7] & 0x1f));
            }
            else {
LAB_1001e867:
              if (puVar12 < (uint *)puVar14[4]) {
                bVar6 = Plat_IsInDebugSession();
                if (!bVar6) {
                  _abort();
LAB_1001ecf1:
                  pcVar4 = (code *)swi(3);
                  (*pcVar4)();
                  return;
                }
LAB_1001eceb:
                pcVar4 = (code *)swi(3);
                (*pcVar4)();
                return;
              }
              puVar12[6] = uVar10;
              uVar10 = puVar16[4];
              if (uVar10 != 0) {
                if (uVar10 < puVar14[4]) {
                  bVar6 = Plat_IsInDebugSession();
                  if (bVar6) {
LAB_1001ecdf:
                    pcVar4 = (code *)swi(3);
                    (*pcVar4)();
                    return;
                  }
                  _abort();
                  goto LAB_1001ece5;
                }
                puVar12[4] = uVar10;
                *(uint **)(uVar10 + 0x18) = puVar12;
              }
              uVar10 = puVar16[5];
              if (uVar10 != 0) {
                if (uVar10 < puVar14[4]) {
                  bVar6 = Plat_IsInDebugSession();
                  if (bVar6) {
LAB_1001ece5:
                    pcVar4 = (code *)swi(3);
                    (*pcVar4)();
                    return;
                  }
                  _abort();
                  goto LAB_1001eceb;
                }
                puVar12[5] = uVar10;
                *(uint **)(uVar10 + 0x18) = puVar12;
              }
            }
          }
          else {
            if (uVar10 < puVar14[4]) {
              bVar6 = Plat_IsInDebugSession();
              if (!bVar6) {
                _abort();
LAB_1001ecf7:
                pcVar4 = (code *)swi(3);
                (*pcVar4)();
                return;
              }
              goto LAB_1001ecf1;
            }
            if (*(uint **)(uVar10 + 0x10) == puVar16) {
              *(uint **)(uVar10 + 0x10) = puVar12;
            }
            else {
              *(uint **)(uVar10 + 0x14) = puVar12;
            }
            if (puVar12 != (uint *)0x0) goto LAB_1001e867;
          }
        }
      }
    }
LAB_1001e6dc:
    if ((puVar16 < puVar1) && (uVar10 = puVar1[1], (uVar10 & 1) != 0)) {
      if ((uVar10 & 2) == 0) {
        if (puVar1 == (uint *)puVar14[6]) {
          puVar14[3] = puVar14[3] + uVar13;
          uVar10 = puVar14[3];
          puVar14[6] = (uint)puVar16;
          puVar16[1] = uVar10 | 1;
          if (puVar16 == (uint *)puVar14[5]) {
            puVar14[5] = 0;
            puVar14[2] = 0;
          }
          if (puVar14[7] <= uVar10 && uVar10 != puVar14[7]) {
            FUN_1001d070((int)puVar14,0);
          }
          goto LAB_1001ec71;
        }
        if (puVar1 == (uint *)puVar14[5]) {
          puVar14[2] = puVar14[2] + uVar13;
          uVar10 = puVar14[2];
          puVar14[5] = (uint)puVar16;
          puVar16[1] = uVar10 | 1;
          *(uint *)(uVar10 + (int)puVar16) = uVar10;
          goto LAB_1001ec71;
        }
        uVar13 = uVar13 + (uVar10 & 0xfffffff8);
        uVar10 = uVar10 >> 3;
        if (uVar10 < 0x20) {
          puVar12 = (uint *)puVar1[2];
          puVar1 = (uint *)puVar1[3];
          if (puVar12 == puVar1) {
            *puVar14 = *puVar14 & ~(1 << ((byte)uVar10 & 0x1f));
          }
          else {
            if (((puVar12 != puVar14 + (uVar10 + 5) * 2) && (puVar12 < (uint *)puVar14[4])) ||
               ((puVar1 != puVar14 + (uVar10 + 5) * 2 && (puVar1 < (uint *)puVar14[4])))) {
              bVar6 = Plat_IsInDebugSession();
              if (bVar6) {
LAB_1001ecfd:
                pcVar4 = (code *)swi(3);
                (*pcVar4)();
                return;
              }
              _abort();
LAB_1001ed03:
              pcVar4 = (code *)swi(3);
              (*pcVar4)();
              return;
            }
            puVar12[3] = (uint)puVar1;
            puVar1[2] = (uint)puVar12;
          }
        }
        else {
          uVar10 = puVar1[6];
          puVar12 = (uint *)puVar1[3];
          if (puVar12 == puVar1) {
            puVar3 = (uint *)puVar1[5];
            puVar5 = puVar1 + 5;
            if ((uint *)puVar1[5] == (uint *)0x0) {
              puVar12 = (uint *)puVar1[4];
              puVar3 = puVar12;
              puVar5 = puVar1 + 4;
              if (puVar12 == (uint *)0x0) goto LAB_1001ea28;
            }
            do {
              do {
                param_2 = puVar5;
                puVar12 = puVar3;
                puVar3 = (uint *)puVar12[5];
                puVar5 = puVar12 + 5;
              } while ((uint *)puVar12[5] != (uint *)0x0);
              puVar3 = (uint *)puVar12[4];
              puVar5 = puVar12 + 4;
            } while ((uint *)puVar12[4] != (uint *)0x0);
            if (param_2 < (uint *)puVar14[4]) {
              bVar6 = Plat_IsInDebugSession();
              if (bVar6) goto LAB_1001ed21;
              _abort();
              goto LAB_1001ed27;
            }
            *param_2 = 0;
          }
          else {
            uVar11 = puVar1[2];
            if (uVar11 < puVar14[4]) {
              bVar6 = Plat_IsInDebugSession();
              if (bVar6) goto LAB_1001ed03;
              _abort();
              goto LAB_1001ed09;
            }
            *(uint **)(uVar11 + 0xc) = puVar12;
            puVar12[2] = uVar11;
          }
LAB_1001ea28:
          if (uVar10 != 0) {
            if (puVar1 == (uint *)puVar14[puVar1[7] + 0x4c]) {
              puVar14[puVar1[7] + 0x4c] = (uint)puVar12;
              if (puVar12 == (uint *)0x0) {
                puVar14[1] = puVar14[1] & ~(1 << ((byte)puVar1[7] & 0x1f));
              }
              else {
LAB_1001ea83:
                if (puVar12 < (uint *)puVar14[4]) {
                  bVar6 = Plat_IsInDebugSession();
                  if (!bVar6) {
                    _abort();
LAB_1001ed1b:
                    pcVar4 = (code *)swi(3);
                    (*pcVar4)();
                    return;
                  }
LAB_1001ed15:
                  pcVar4 = (code *)swi(3);
                  (*pcVar4)();
                  return;
                }
                puVar12[6] = uVar10;
                uVar10 = puVar1[4];
                if (uVar10 != 0) {
                  if (uVar10 < puVar14[4]) {
                    bVar6 = Plat_IsInDebugSession();
                    if (bVar6) {
LAB_1001ed09:
                      pcVar4 = (code *)swi(3);
                      (*pcVar4)();
                      return;
                    }
                    _abort();
                    goto LAB_1001ed0f;
                  }
                  puVar12[4] = uVar10;
                  *(uint **)(uVar10 + 0x18) = puVar12;
                }
                uVar10 = puVar1[5];
                if (uVar10 != 0) {
                  if (uVar10 < puVar14[4]) {
                    bVar6 = Plat_IsInDebugSession();
                    if (bVar6) {
LAB_1001ed0f:
                      pcVar4 = (code *)swi(3);
                      (*pcVar4)();
                      return;
                    }
                    _abort();
                    goto LAB_1001ed15;
                  }
                  puVar12[5] = uVar10;
                  *(uint **)(uVar10 + 0x18) = puVar12;
                }
              }
            }
            else {
              if (uVar10 < puVar14[4]) {
                bVar6 = Plat_IsInDebugSession();
                if (!bVar6) {
                  _abort();
LAB_1001ed21:
                  pcVar4 = (code *)swi(3);
                  (*pcVar4)();
                  return;
                }
                goto LAB_1001ed1b;
              }
              if (*(uint **)(uVar10 + 0x10) == puVar1) {
                *(uint **)(uVar10 + 0x10) = puVar12;
              }
              else {
                *(uint **)(uVar10 + 0x14) = puVar12;
              }
              if (puVar12 != (uint *)0x0) goto LAB_1001ea83;
            }
          }
        }
        puVar16[1] = uVar13 | 1;
        *(uint *)(uVar13 + (int)puVar16) = uVar13;
        if (puVar16 == (uint *)puVar14[5]) {
          puVar14[2] = uVar13;
          goto LAB_1001ec71;
        }
      }
      else {
        puVar1[1] = uVar10 & 0xfffffffe;
        puVar16[1] = uVar13 | 1;
        *(uint *)(uVar13 + (int)puVar16) = uVar13;
      }
      uVar10 = uVar13 >> 3;
      if (uVar10 < 0x20) {
        uVar13 = 1 << ((byte)uVar10 & 0x1f);
        puVar1 = puVar14 + (uVar10 + 5) * 2;
        if ((uVar13 & *puVar14) == 0) {
          *puVar14 = *puVar14 | uVar13;
          puVar1[2] = (uint)puVar16;
          puVar1[3] = (uint)puVar16;
          puVar16[2] = (uint)puVar1;
          puVar16[3] = (uint)puVar1;
        }
        else {
          uVar10 = puVar1[2];
          if (uVar10 < puVar14[4]) {
            bVar6 = Plat_IsInDebugSession();
            if (!bVar6) {
              _abort();
LAB_1001ed2d:
              pcVar4 = (code *)swi(3);
              (*pcVar4)();
              return;
            }
LAB_1001ed27:
            pcVar4 = (code *)swi(3);
            (*pcVar4)();
            return;
          }
          puVar1[2] = (uint)puVar16;
          *(uint **)(uVar10 + 0xc) = puVar16;
          puVar16[2] = uVar10;
          puVar16[3] = (uint)puVar1;
        }
      }
      else {
        uVar10 = uVar13 >> 8;
        if (uVar10 == 0) {
          uVar10 = 0;
        }
        else if (uVar10 < 0x10000) {
          iVar8 = 0x1f;
          if (uVar10 != 0) {
            for (; uVar10 >> iVar8 == 0; iVar8 = iVar8 + -1) {
            }
          }
          uVar10 = (uVar13 >> ((char)iVar8 + 7U & 0x1f) & 1) + iVar8 * 2;
        }
        else {
          uVar10 = 0x1f;
        }
        puVar16[7] = uVar10;
        uVar11 = 1 << ((byte)uVar10 & 0x1f);
        ppuVar2 = (uint **)(puVar14 + uVar10 + 0x4c);
        puVar16[5] = 0;
        puVar16[4] = 0;
        if ((uVar11 & puVar14[1]) == 0) {
          puVar14[1] = puVar14[1] | uVar11;
          *ppuVar2 = puVar16;
          puVar16[6] = (uint)ppuVar2;
          puVar16[3] = (uint)puVar16;
          puVar16[2] = (uint)puVar16;
        }
        else {
          if (uVar10 == 0x1f) {
            bVar7 = 0;
          }
          else {
            bVar7 = 0x19 - (char)(uVar10 >> 1);
          }
          uVar10 = (*ppuVar2)[1];
          puVar1 = *ppuVar2;
          iVar8 = uVar13 << (bVar7 & 0x1f);
          while ((uVar10 & 0xfffffff8) != uVar13) {
            ppuVar2 = (uint **)(puVar1 + (4 - (iVar8 >> 0x1f)));
            puVar12 = *ppuVar2;
            if (puVar12 == (uint *)0x0) {
              if ((uint **)puVar14[4] <= ppuVar2) {
                *ppuVar2 = puVar16;
                puVar16[6] = (uint)puVar1;
                puVar16[3] = (uint)puVar16;
                puVar16[2] = (uint)puVar16;
                goto LAB_1001ec63;
              }
              bVar6 = Plat_IsInDebugSession();
              if (bVar6) goto LAB_1001ed2d;
              _abort();
              goto LAB_1001ed33;
            }
            puVar1 = puVar12;
            iVar8 = iVar8 * 2;
            uVar10 = puVar12[1];
          }
          puVar12 = (uint *)puVar1[2];
          if ((puVar1 < (uint *)puVar14[4]) || (puVar12 < (uint *)puVar14[4])) {
            bVar6 = Plat_IsInDebugSession();
            if (bVar6) {
LAB_1001ed33:
              pcVar4 = (code *)swi(3);
              (*pcVar4)();
              return;
            }
            _abort();
            goto LAB_1001ed39;
          }
          puVar12[3] = (uint)puVar16;
          puVar1[2] = (uint)puVar16;
          puVar16[2] = (uint)puVar12;
          puVar16[3] = (uint)puVar1;
          puVar16[6] = 0;
        }
LAB_1001ec63:
        puVar16 = puVar14 + 8;
        *puVar16 = *puVar16 - 1;
        if (*puVar16 == 0) {
          FUN_1001cae0((int)puVar14);
        }
      }
LAB_1001ec71:
      if ((*(byte *)(puVar14 + 0x6e) & 2) != 0) {
        puVar14[0x70] = puVar14[0x70] - 1;
        if (puVar14[0x70] == 0) {
          puVar14[0x6f] = 0;
        }
      }
      return;
    }
  }
LAB_1001ecc2:
  bVar6 = Plat_IsInDebugSession();
  if (!bVar6) {
    _abort();
    pcVar4 = (code *)swi(3);
    (*pcVar4)();
    return;
  }
LAB_1001ed39:
  pcVar4 = (code *)swi(3);
  (*pcVar4)();
  return;
}



int * __cdecl FUN_1001ed40(int *param_1,int param_2)

{
  code *pcVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  bool bVar5;
  int *piVar6;
  int local_2c [10];
  
  if (*(int *)(param_2 + 0x24) == DAT_10835ad4) {
    piVar6 = FUN_1001c1e0(local_2c,param_2);
    iVar2 = piVar6[1];
    iVar3 = piVar6[2];
    iVar4 = piVar6[3];
    *param_1 = *piVar6;
    param_1[1] = iVar2;
    param_1[2] = iVar3;
    param_1[3] = iVar4;
    iVar2 = piVar6[5];
    iVar3 = piVar6[6];
    iVar4 = piVar6[7];
    param_1[4] = piVar6[4];
    param_1[5] = iVar2;
    param_1[6] = iVar3;
    param_1[7] = iVar4;
    *(undefined8 *)(param_1 + 8) = *(undefined8 *)(piVar6 + 8);
    return param_1;
  }
  bVar5 = Plat_IsInDebugSession();
  if (bVar5) {
    pcVar1 = (code *)swi(3);
    piVar6 = (int *)(*pcVar1)();
    return piVar6;
  }
  _abort();
  pcVar1 = (code *)swi(3);
  piVar6 = (int *)(*pcVar1)();
  return piVar6;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint ** __cdecl FUN_1001edb0(uint *param_1,uint param_2)

{
  DWORD *this;
  uint *puVar1;
  uint uVar2;
  code *pcVar3;
  bool bVar4;
  int iVar5;
  DWORD DVar6;
  DWORD DVar7;
  uint *puVar8;
  uint **ppuVar9;
  byte bVar10;
  uint uVar11;
  uint uVar12;
  uint uVar13;
  uint uVar14;
  uint *puVar15;
  
  if (param_1[9] != DAT_10835ad4) {
    bVar4 = Plat_IsInDebugSession();
    if (bVar4) {
      pcVar3 = (code *)swi(3);
      ppuVar9 = (uint **)(*pcVar3)();
      return ppuVar9;
    }
    _abort();
    goto LAB_1001f0db;
  }
  if (((_DAT_10835ad8 == 0) && (iVar5 = FUN_1001bff0(), iVar5 != 0)) ||
     ((*(byte *)(param_1 + 0x6e) & 2) != 0)) {
    this = param_1 + 0x6f;
    DVar6 = GetCurrentThreadId();
    if (DVar6 != *this) {
      DVar7 = 0;
      LOCK();
      if (*this == 0) {
        *this = DVar6;
      }
      else {
        DVar7 = *this;
      }
      if (DVar7 != 0) {
        CThreadFastMutex::Lock((CThreadFastMutex *)this,DVar6,0);
        goto LAB_1001ee2f;
      }
    }
    param_1[0x70] = param_1[0x70] + 1;
  }
LAB_1001ee2f:
  uVar2 = DAT_10835ad4;
  if (param_2 < 0xe9) {
    if (param_2 < 7) {
      uVar14 = 0x10;
    }
    else {
      uVar14 = param_2 + 0x17 & 0xfffffff0;
    }
    bVar10 = (byte)(uVar14 >> 3);
    uVar12 = *param_1 >> (bVar10 & 0x1f);
    if ((uVar12 & 3) != 0) {
      iVar5 = (uVar14 >> 3) + (~uVar12 & 1);
      uVar14 = param_1[iVar5 * 2 + 0xc];
      ppuVar9 = (uint **)(uVar14 + 8);
      puVar15 = param_1 + iVar5 * 2 + 10;
      puVar1 = *ppuVar9;
      if (puVar15 == puVar1) {
        *param_1 = *param_1 & ~(1 << ((byte)iVar5 & 0x1f));
      }
      else {
        if (puVar1 < (uint *)param_1[4]) {
          bVar4 = Plat_IsInDebugSession();
          if (bVar4) {
LAB_1001f0db:
            pcVar3 = (code *)swi(3);
            ppuVar9 = (uint **)(*pcVar3)();
            return ppuVar9;
          }
          _abort();
LAB_1001f0e1:
          pcVar3 = (code *)swi(3);
          ppuVar9 = (uint **)(*pcVar3)();
          return ppuVar9;
        }
        puVar15[2] = (uint)puVar1;
        puVar1[3] = (uint)puVar15;
      }
      *(uint *)(uVar14 + 4) = iVar5 * 8 | 3;
      puVar15 = (uint *)(uVar14 + 4 + iVar5 * 8);
      *puVar15 = *puVar15 | 1;
      *(uint *)(uVar14 + iVar5 * 8) = uVar2 ^ (uint)param_1;
      goto LAB_1001f0ad;
    }
    if (param_1[2] <= uVar14 && uVar14 != param_1[2]) {
      if (uVar12 != 0) {
        uVar12 = uVar12 << (bVar10 & 0x1f) & (-1 << (bVar10 & 0x1f)) * 2;
        uVar12 = -uVar12 & uVar12;
        iVar5 = 0;
        if (uVar12 != 0) {
          for (; (uVar12 >> iVar5 & 1) == 0; iVar5 = iVar5 + 1) {
          }
        }
        puVar15 = param_1 + (iVar5 + 5) * 2;
        uVar12 = puVar15[2];
        ppuVar9 = (uint **)(uVar12 + 8);
        puVar1 = *ppuVar9;
        if (puVar15 == puVar1) {
          *param_1 = *param_1 & ~(1 << ((byte)iVar5 & 0x1f));
        }
        else {
          if (puVar1 < (uint *)param_1[4]) {
            bVar4 = Plat_IsInDebugSession();
            if (!bVar4) {
              _abort();
              pcVar3 = (code *)swi(3);
              ppuVar9 = (uint **)(*pcVar3)();
              return ppuVar9;
            }
            goto LAB_1001f0e7;
          }
          puVar15[2] = (uint)puVar1;
          puVar1[3] = (uint)puVar15;
        }
        uVar11 = iVar5 * 8 - uVar14;
        *(uint *)(uVar12 + 4) = uVar14 | 3;
        puVar15 = (uint *)(uVar14 + uVar12);
        *puVar15 = uVar2 ^ (uint)param_1;
        puVar15[1] = uVar11 | 1;
        *(uint *)((int)puVar15 + uVar11) = uVar11;
        if (param_1[2] != 0) {
          uVar2 = param_1[5];
          uVar14 = param_1[2] >> 3;
          uVar12 = 1 << ((byte)uVar14 & 0x1f);
          puVar1 = param_1 + (uVar14 + 5) * 2;
          if ((uVar12 & *param_1) == 0) {
            *param_1 = *param_1 | uVar12;
            puVar8 = puVar1;
          }
          else {
            puVar8 = (uint *)puVar1[2];
            if (puVar8 < (uint *)param_1[4]) {
              bVar4 = Plat_IsInDebugSession();
              if (!bVar4) {
                _abort();
LAB_1001f0e7:
                pcVar3 = (code *)swi(3);
                ppuVar9 = (uint **)(*pcVar3)();
                return ppuVar9;
              }
              goto LAB_1001f0e1;
            }
          }
          puVar1[2] = uVar2;
          puVar8[3] = uVar2;
          *(uint **)(uVar2 + 0xc) = puVar1;
          *(uint **)(uVar2 + 8) = puVar8;
        }
        param_1[2] = uVar11;
        param_1[5] = (uint)puVar15;
        goto LAB_1001f0ad;
      }
      if (param_1[1] != 0) {
        ppuVar9 = (uint **)FUN_1001d640(param_1,uVar14);
        goto LAB_1001effe;
      }
    }
  }
  else if (param_2 < 0xffffffc0) {
    uVar14 = param_2 + 0x17 & 0xfffffff0;
    if (param_1[1] != 0) {
      ppuVar9 = (uint **)FUN_1001d170(param_1,uVar14);
LAB_1001effe:
      if (ppuVar9 != (uint **)0x0) goto LAB_1001f0ad;
    }
  }
  else {
    uVar14 = 0xffffffff;
  }
  uVar12 = DAT_10835ad4;
  uVar2 = param_1[2];
  if (uVar2 < uVar14) {
    if (uVar14 < param_1[3]) {
      uVar2 = param_1[6];
      uVar11 = param_1[3] - uVar14;
      param_1[3] = uVar11;
      puVar15 = (uint *)(uVar2 + uVar14);
      param_1[6] = (uint)puVar15;
      puVar15[1] = uVar11 | 1;
      ppuVar9 = (uint **)(uVar2 + 8);
      *(uint *)(uVar2 + 4) = uVar14 | 3;
      *puVar15 = uVar12 ^ (uint)param_1;
    }
    else {
      ppuVar9 = (uint **)FUN_1001ce80(param_1,uVar14);
    }
  }
  else {
    uVar11 = param_1[5];
    uVar13 = uVar2 - uVar14;
    if (uVar13 < 0x10) {
      param_1[2] = 0;
      param_1[5] = 0;
      ppuVar9 = (uint **)(uVar11 + 8);
      *(uint *)(uVar11 + 4) = uVar2 | 3;
      puVar15 = (uint *)(uVar2 + 4 + uVar11);
      *puVar15 = *puVar15 | 1;
      *(uint *)(uVar2 + uVar11) = uVar12 ^ (uint)param_1;
    }
    else {
      puVar15 = (uint *)(uVar11 + uVar14);
      param_1[2] = uVar13;
      param_1[5] = (uint)puVar15;
      puVar15[1] = uVar13 | 1;
      *(uint *)((int)puVar15 + uVar13) = uVar13;
      *(uint *)(uVar11 + 4) = uVar14 | 3;
      *puVar15 = uVar12 ^ (uint)param_1;
      ppuVar9 = (uint **)(uVar11 + 8);
    }
  }
LAB_1001f0ad:
  if ((*(byte *)(param_1 + 0x6e) & 2) != 0) {
    param_1[0x70] = param_1[0x70] - 1;
    if (param_1[0x70] == 0) {
      param_1[0x6f] = 0;
    }
  }
  return ppuVar9;
}



uint __cdecl FUN_1001f0f0(int param_1)

{
  code *pcVar1;
  bool bVar2;
  undefined3 extraout_var;
  uint uVar3;
  
  if (*(int *)(param_1 + 0x24) == DAT_10835ad4) {
    return *(uint *)(param_1 + 0x1b4);
  }
  bVar2 = Plat_IsInDebugSession();
  uVar3 = CONCAT31(extraout_var,bVar2);
  if (bVar2) {
    pcVar1 = (code *)swi(3);
    uVar3 = (*pcVar1)();
    return uVar3;
  }
  _abort();
  return uVar3;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

bool __cdecl FUN_1001f120(int param_1,uint param_2)

{
  DWORD *this;
  code *pcVar1;
  bool bVar2;
  undefined uVar3;
  int iVar4;
  DWORD DVar5;
  DWORD DVar6;
  
  if (*(int *)(param_1 + 0x24) != DAT_10835ad4) {
    bVar2 = Plat_IsInDebugSession();
    if (!bVar2) {
      _abort();
      pcVar1 = (code *)swi(3);
      uVar3 = (*pcVar1)();
      return (bool)uVar3;
    }
    pcVar1 = (code *)swi(3);
    uVar3 = (*pcVar1)();
    return (bool)uVar3;
  }
  if (((_DAT_10835ad8 == 0) && (iVar4 = FUN_1001bff0(), iVar4 != 0)) ||
     ((*(byte *)(param_1 + 0x1b8) & 2) != 0)) {
    this = (DWORD *)(param_1 + 0x1bc);
    DVar5 = GetCurrentThreadId();
    if (DVar5 != *this) {
      DVar6 = 0;
      LOCK();
      if (*this == 0) {
        *this = DVar5;
      }
      else {
        DVar6 = *this;
      }
      if (DVar6 != 0) {
        CThreadFastMutex::Lock((CThreadFastMutex *)this,DVar5,0);
        goto LAB_1001f17e;
      }
    }
    *(int *)(param_1 + 0x1c0) = *(int *)(param_1 + 0x1c0) + 1;
  }
LAB_1001f17e:
  bVar2 = FUN_1001d070(param_1,param_2);
  if ((*(byte *)(param_1 + 0x1b8) & 2) != 0) {
    *(int *)(param_1 + 0x1c0) = *(int *)(param_1 + 0x1c0) + -1;
    if (*(int *)(param_1 + 0x1c0) == 0) {
      *(undefined4 *)(param_1 + 0x1bc) = 0;
    }
  }
  return bVar2;
}



// Library Function - Single Match
//  __errcode
// 
// Library: Visual Studio 2019 Release

int __cdecl __errcode(uint param_1)

{
  int iStack8;
  
  if ((param_1 & 0x20) == 0) {
    if ((param_1 & 8) != 0) {
      return 1;
    }
    if ((param_1 & 4) == 0) {
      if ((param_1 & 1) == 0) {
        return (param_1 & 2) * 2;
      }
      iStack8 = 3;
    }
    else {
      iStack8 = 2;
    }
  }
  else {
    iStack8 = 5;
  }
  return iStack8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __except1
// 
// Library: Visual Studio 2019 Release

void __cdecl __except1(uint param_1,int param_2,undefined8 param_3,double param_4,uint param_5)

{
  bool bVar1;
  undefined3 extraout_var;
  int iVar2;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar3;
  uint uVar4;
  undefined in_stack_ffffff64;
  uint local_90 [16];
  uint local_50;
  uint local_14;
  
  uVar4 = param_5;
  local_14 = DAT_10046c24 ^ (uint)&stack0xfffffff0;
  bVar1 = __handle_exc(param_1,&param_4,param_5);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    local_50 = local_50 & 0xfffffffe;
    FUN_1001f4b9(local_90,&param_5,param_1,param_2,&param_3,&param_4,0);
    uVar4 = param_5;
  }
  iVar2 = __errcode(param_1);
  if ((_DAT_10046c20 == 0) && (iVar2 != 0)) {
    __umatherr(iVar2,param_2);
    uVar3 = extraout_DL;
  }
  else {
    __set_errno_from_matherr(iVar2);
    __ctrlfp(uVar4,0xffff);
    uVar3 = extraout_DL_00;
  }
  FUN_1002534c(local_14 ^ (uint)&stack0xfffffff0,uVar3,in_stack_ffffff64);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __handle_exc
// 
// Library: Visual Studio 2019 Release

bool __cdecl __handle_exc(uint param_1,double *param_2,uint param_3)

{
  double dVar1;
  double dVar2;
  float10 fVar3;
  double dVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  bool bVar8;
  float10 fVar9;
  float10 fVar10;
  uint local_10;
  byte bStack12;
  undefined uStack11;
  ushort uStack10;
  
  uVar5 = param_1;
  uVar7 = param_1 & 0x1f;
  if (((param_1 & 8) != 0) && ((param_3 & 1) != 0)) {
    __set_statfp(1);
    uVar7 = uVar5 & 0x17;
    goto LAB_1001f475;
  }
  if (((param_1 & 4) != 0) && ((param_3 & 4) != 0)) {
    __set_statfp(4);
    uVar7 = uVar5 & 0x1b;
    goto LAB_1001f475;
  }
  if (((param_1 & 1) == 0) || ((param_3 & 8) == 0)) {
    if (((param_1 & 2) != 0) && ((param_3 & 0x10) != 0)) {
      bVar8 = (param_1 & 0x10) != 0;
      if (*param_2 == 0.0) {
        bVar8 = true;
      }
      else {
        fVar9 = (float10)__decomp(SUB84(*param_2,0),(uint)((ulonglong)*param_2 >> 0x20),
                                  (int *)&param_1);
        param_1 = param_1 - 0x600;
        dVar2 = (double)fVar9;
        local_10 = SUB84(dVar2,0);
        bStack12 = (byte)((ulonglong)dVar2 >> 0x20);
        uStack11 = (undefined)((ulonglong)dVar2 >> 0x28);
        uStack10 = (ushort)((ulonglong)dVar2 >> 0x30);
        fVar3 = (float10)0;
        if ((int)param_1 < -0x432) {
          fVar10 = fVar3 * fVar9;
          bVar8 = true;
        }
        else {
          uStack10 = uStack10 & 0xf | 0x10;
          if ((int)param_1 < -0x3fd) {
            iVar6 = -0x3fd - param_1;
            do {
              if (((local_10 & 1) != 0) && (!bVar8)) {
                bVar8 = true;
              }
              local_10 = local_10 >> 1;
              if ((bStack12 & 1) != 0) {
                local_10 = local_10 | 0x80000000;
              }
              uVar7 = CONCAT22(uStack10,CONCAT11(uStack11,bStack12)) >> 1;
              bStack12 = (byte)uVar7;
              uStack11 = (undefined)(uVar7 >> 8);
              uStack10 = uStack10 >> 1;
              iVar6 = iVar6 + -1;
            } while (iVar6 != 0);
          }
          fVar10 = (float10)(double)CONCAT26(uStack10,CONCAT15(uStack11,CONCAT14(bStack12,local_10))
                                            );
          if ((ushort)((ushort)(fVar3 < fVar9) << 8 | (ushort)(fVar3 == fVar9) << 0xe) == 0) {
            fVar10 = -fVar10;
          }
        }
        *param_2 = (double)fVar10;
      }
      if (bVar8) {
        __set_statfp(0x10);
      }
      uVar7 = uVar5 & 0x1d;
    }
    goto LAB_1001f475;
  }
  __set_statfp(8);
  uVar7 = param_3 & 0xc00;
  dVar2 = _DAT_10046a68;
  dVar4 = _DAT_10046a68;
  if (uVar7 == 0) {
    dVar1 = *param_2;
joined_r0x1001f35b:
    if (dVar1 <= 0.0) {
      dVar2 = -dVar4;
    }
    *param_2 = dVar2;
  }
  else {
    if (uVar7 == 0x400) {
      dVar1 = *param_2;
      dVar2 = _DAT_10046a78;
      goto joined_r0x1001f35b;
    }
    dVar4 = _DAT_10046a78;
    if (uVar7 == 0x800) {
      dVar1 = *param_2;
      goto joined_r0x1001f35b;
    }
    if (uVar7 == 0xc00) {
      dVar1 = *param_2;
      dVar2 = _DAT_10046a78;
      goto joined_r0x1001f35b;
    }
  }
  uVar7 = uVar5 & 0x1e;
LAB_1001f475:
  if (((uVar5 & 0x10) != 0) && ((param_3 & 0x20) != 0)) {
    __set_statfp(0x20);
    uVar7 = uVar7 & 0xffffffef;
  }
  return uVar7 == 0;
}



// Library Function - Single Match
//  __raise_exc
// 
// Library: Visual Studio 2019 Release

void __cdecl
__raise_exc(uint *param_1,uint *param_2,uint param_3,int param_4,undefined8 *param_5,
           undefined8 *param_6)

{
  FUN_1001f4b9(param_1,param_2,param_3,param_4,param_5,param_6,0);
  return;
}



void __cdecl
FUN_1001f4b9(uint *param_1,uint *param_2,uint param_3,int param_4,undefined8 *param_5,
            undefined8 *param_6,int param_7)

{
  uint *puVar1;
  undefined8 *puVar2;
  uint uVar3;
  DWORD dwExceptionCode;
  
  puVar1 = param_2;
  param_1[1] = 0;
  dwExceptionCode = 0xc000000d;
  param_1[2] = 0;
  param_1[3] = 0;
  if ((param_3 & 0x10) != 0) {
    dwExceptionCode = 0xc000008f;
    param_1[1] = param_1[1] | 1;
  }
  if ((param_3 & 2) != 0) {
    dwExceptionCode = 0xc0000093;
    param_1[1] = param_1[1] | 2;
  }
  if ((param_3 & 1) != 0) {
    dwExceptionCode = 0xc0000091;
    param_1[1] = param_1[1] | 4;
  }
  if ((param_3 & 4) != 0) {
    dwExceptionCode = 0xc000008e;
    param_1[1] = param_1[1] | 8;
  }
  if ((param_3 & 8) != 0) {
    dwExceptionCode = 0xc0000090;
    param_1[1] = param_1[1] | 0x10;
  }
  param_1[2] = param_1[2] ^ (~(*param_2 << 4) ^ param_1[2]) & 0x10;
  param_1[2] = param_1[2] ^ (~(*param_2 * 2) ^ param_1[2]) & 8;
  param_1[2] = param_1[2] ^ (~(*param_2 >> 1) ^ param_1[2]) & 4;
  param_1[2] = param_1[2] ^ (~(*param_2 >> 3) ^ param_1[2]) & 2;
  param_1[2] = param_1[2] ^ (~(*param_2 >> 5) ^ param_1[2]) & 1;
  uVar3 = FUN_100252b4();
  puVar2 = param_6;
  if ((uVar3 & 1) != 0) {
    param_1[3] = param_1[3] | 0x10;
  }
  if ((uVar3 & 4) != 0) {
    param_1[3] = param_1[3] | 8;
  }
  if ((uVar3 & 8) != 0) {
    param_1[3] = param_1[3] | 4;
  }
  if ((uVar3 & 0x10) != 0) {
    param_1[3] = param_1[3] | 2;
  }
  if ((uVar3 & 0x20) != 0) {
    param_1[3] = param_1[3] | 1;
  }
  uVar3 = *puVar1 & 0xc00;
  if (uVar3 == 0) {
    *param_1 = *param_1 & 0xfffffffc;
  }
  else {
    if (uVar3 == 0x400) {
      uVar3 = *param_1 & 0xfffffffd | 1;
    }
    else {
      if (uVar3 != 0x800) {
        if (uVar3 == 0xc00) {
          *param_1 = *param_1 | 3;
        }
        goto LAB_1001f619;
      }
      uVar3 = *param_1 & 0xfffffffe | 2;
    }
    *param_1 = uVar3;
  }
LAB_1001f619:
  uVar3 = *puVar1 & 0x300;
  if (uVar3 == 0) {
    uVar3 = *param_1 & 0xffffffeb | 8;
LAB_1001f64f:
    *param_1 = uVar3;
  }
  else {
    if (uVar3 == 0x200) {
      uVar3 = *param_1 & 0xffffffe7 | 4;
      goto LAB_1001f64f;
    }
    if (uVar3 == 0x300) {
      *param_1 = *param_1 & 0xffffffe3;
    }
  }
  *param_1 = *param_1 ^ (param_4 << 5 ^ *param_1) & 0x1ffe0;
  param_1[8] = param_1[8] | 1;
  if (param_7 == 0) {
    param_1[8] = param_1[8] & 0xffffffe3 | 2;
    *(undefined8 *)(param_1 + 4) = *param_5;
    param_1[0x18] = param_1[0x18] | 1;
    param_1[0x18] = param_1[0x18] & 0xffffffe3 | 2;
    *(undefined8 *)(param_1 + 0x14) = *param_6;
  }
  else {
    param_1[8] = param_1[8] & 0xffffffe1;
    param_1[4] = *(uint *)param_5;
    param_1[0x18] = param_1[0x18] | 1;
    param_1[0x18] = param_1[0x18] & 0xffffffe1;
    param_1[0x14] = *(uint *)param_6;
  }
  FUN_10025220();
  RaiseException(dwExceptionCode,0,1,(ULONG_PTR *)&param_1);
  if ((*(byte *)(param_1 + 2) & 0x10) != 0) {
    *puVar1 = *puVar1 & 0xfffffffe;
  }
  if ((*(byte *)(param_1 + 2) & 8) != 0) {
    *puVar1 = *puVar1 & 0xfffffffb;
  }
  if ((*(byte *)(param_1 + 2) & 4) != 0) {
    *puVar1 = *puVar1 & 0xfffffff7;
  }
  if ((*(byte *)(param_1 + 2) & 2) != 0) {
    *puVar1 = *puVar1 & 0xffffffef;
  }
  if ((*(byte *)(param_1 + 2) & 1) != 0) {
    *puVar1 = *puVar1 & 0xffffffdf;
  }
  uVar3 = *param_1 & 3;
  if (uVar3 == 0) {
    *puVar1 = *puVar1 & 0xfffff3ff;
  }
  else {
    if (uVar3 == 1) {
      uVar3 = *puVar1 & 0xfffff7ff | 0x400;
    }
    else {
      if (uVar3 != 2) {
        if (uVar3 == 3) {
          *puVar1 = *puVar1 | 0xc00;
        }
        goto LAB_1001f75a;
      }
      uVar3 = *puVar1 & 0xfffffbff | 0x800;
    }
    *puVar1 = uVar3;
  }
LAB_1001f75a:
  uVar3 = *param_1 >> 2 & 7;
  if (uVar3 == 0) {
    uVar3 = *puVar1 & 0xfffff3ff | 0x300;
  }
  else {
    if (uVar3 != 1) {
      if (uVar3 == 2) {
        *puVar1 = *puVar1 & 0xfffff3ff;
      }
      goto LAB_1001f787;
    }
    uVar3 = *puVar1 & 0xfffff3ff | 0x200;
  }
  *puVar1 = uVar3;
LAB_1001f787:
  if (param_7 == 0) {
    *puVar2 = *(undefined8 *)(param_1 + 0x14);
  }
  else {
    *(uint *)puVar2 = param_1[0x14];
  }
  return;
}



// Library Function - Single Match
//  __set_errno_from_matherr
// 
// Library: Visual Studio 2019 Release

void __cdecl __set_errno_from_matherr(int param_1)

{
  int *piVar1;
  
  if (param_1 == 1) {
    piVar1 = __errno();
    *piVar1 = 0x21;
  }
  else if (param_1 - 2U < 2) {
    piVar1 = __errno();
    *piVar1 = 0x22;
    return;
  }
  return;
}



// Library Function - Single Match
//  __umatherr
// 
// Library: Visual Studio 2019 Release

float10 __cdecl __umatherr(int param_1,int param_2)

{
  int iVar1;
  undefined *puVar2;
  CVProfNode *this;
  undefined4 in_stack_0000001c;
  undefined4 in_stack_00000020;
  undefined4 in_stack_00000024;
  
  puVar2 = (undefined *)0x0;
  iVar1 = 0;
  do {
    if ((&DAT_100466e0)[iVar1 * 2] == param_2) {
      puVar2 = (&PTR_DAT_100466e4)[iVar1 * 2];
      break;
    }
    iVar1 = iVar1 + 1;
  } while (iVar1 < 0x1d);
  if (puVar2 == (undefined *)0x0) {
    __ctrlfp(in_stack_00000024,0xffff);
    __set_errno_from_matherr(param_1);
  }
  else {
    __ctrlfp(in_stack_00000024,0xffff);
    iVar1 = CVProfNode::GetPrevLoadHitStoreLessChildren(this);
    if (iVar1 == 0) {
      __set_errno_from_matherr(param_1);
    }
  }
  return (float10)(double)CONCAT44(in_stack_00000020,in_stack_0000001c);
}



void FUN_1001f86b(void)

{
  code *pcVar1;
  
  pcVar1 = (code *)DecodePointer(DAT_10835b24);
  if (pcVar1 != (code *)0x0) {
    (*pcVar1)();
  }
  FUN_1002226a(0,1);
  _abort();
  return;
}



undefined4 * __thiscall FUN_1001f88d(void *this,exception *param_1)

{
  std::exception::exception((exception *)this,param_1);
  *(undefined ***)this = std::bad_alloc::vftable;
  return (undefined4 *)this;
}



void __cdecl FUN_1001f8b3(size_t param_1)

{
  code *pcVar1;
  int iVar2;
  void *pvVar3;
  undefined **local_14 [3];
  char *local_8;
  
  do {
    pvVar3 = _malloc(param_1);
    if (pvVar3 != (void *)0x0) {
      return;
    }
    iVar2 = __callnewh(param_1);
  } while (iVar2 != 0);
  local_8 = "bad allocation";
  FUN_1002538d(local_14,&local_8);
  local_14[0] = std::bad_alloc::vftable;
  FUN_1002364d((int *)local_14,&DAT_1003fa94);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



undefined4 * __thiscall FUN_1001f904(void *this,byte param_1)

{
  *(undefined ***)this = std::bad_alloc::vftable;
  FUN_100253cb((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    FID_conflict__free(this);
  }
  return (undefined4 *)this;
}



void __cdecl FID_conflict__free(void *_Memory)

{
  BOOL BVar1;
  int *piVar2;
  DWORD DVar3;
  int iVar4;
  
  if (_Memory != (void *)0x0) {
    BVar1 = HeapFree(DAT_10835d30,0,_Memory);
    if (BVar1 == 0) {
      piVar2 = __errno();
      DVar3 = GetLastError();
      iVar4 = __get_errno_from_oserr(DVar3);
      *piVar2 = iVar4;
    }
  }
  return;
}



pthreadlocinfo * __thiscall FUN_1001f92e(void *this,pthreadlocinfo *param_1)

{
  uint uVar1;
  _ptiddata p_Var2;
  pthreadlocinfo ptVar3;
  pthreadmbcinfo ptVar4;
  
  *(undefined *)((int)this + 0xc) = 0;
  if (param_1 == (pthreadlocinfo *)0x0) {
    p_Var2 = __getptd();
    *(_ptiddata *)((int)this + 8) = p_Var2;
    ptVar3 = p_Var2->ptlocinfo;
    *(pthreadlocinfo *)this = ptVar3;
    *(pthreadmbcinfo *)((int)this + 4) = p_Var2->ptmbcinfo;
    if ((ptVar3 != (pthreadlocinfo)PTR_DAT_100472c4) && ((p_Var2->_ownlocale & DAT_10047388) == 0))
    {
      ptVar3 = FUN_100258ef();
      *(pthreadlocinfo *)this = ptVar3;
    }
    if ((*(undefined **)((int)this + 4) != PTR_DAT_1004705c) &&
       ((*(uint *)(*(int *)((int)this + 8) + 0x70) & DAT_10047388) == 0)) {
      ptVar4 = FUN_10025c71();
      *(pthreadmbcinfo *)((int)this + 4) = ptVar4;
    }
    uVar1 = *(uint *)(*(int *)((int)this + 8) + 0x70);
    if ((uVar1 & 2) == 0) {
      *(uint *)(*(int *)((int)this + 8) + 0x70) = uVar1 | 2;
      *(undefined *)((int)this + 0xc) = 1;
    }
  }
  else {
    *(pthreadlocinfo *)this = *param_1;
    *(pthreadlocinfo *)((int)this + 4) = param_1[1];
  }
  return (pthreadlocinfo *)this;
}



void __cdecl FUN_1001f9b6(byte *param_1,byte *param_2)

{
  FUN_1001f9cb(param_1,param_2,(pthreadlocinfo *)0x0);
  return;
}



// WARNING: Could not reconcile some variable overlaps

int __cdecl FUN_1001f9cb(byte *param_1,byte *param_2,pthreadlocinfo *param_3)

{
  ushort uVar1;
  int *piVar2;
  uint uVar3;
  int iVar4;
  byte *pbVar5;
  ushort uVar6;
  uint uVar7;
  int iVar8;
  byte *pbVar9;
  pthreadlocinfo local_18;
  int local_14;
  int local_10;
  char local_c;
  uint local_8;
  
  FUN_1001f92e(&local_18,param_3);
  if ((param_1 == (byte *)0x0) || (param_2 == (byte *)0x0)) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    FUN_10025625();
LAB_1001fb55:
    iVar8 = 0x7fffffff;
  }
  else {
    iVar8 = 0;
    iVar4 = local_14;
    if (*(int *)(local_14 + 8) == 0) {
      iVar8 = FUN_100260e3((char *)param_1,param_2,&local_18);
    }
    else {
      do {
        uVar7 = (uint)*param_1;
        pbVar9 = param_1 + 1;
        if ((*(byte *)(uVar7 + 0x19 + iVar4) & 4) != 0) {
          if (*pbVar9 == 0) {
            uVar7 = 0;
            goto LAB_1001faa3;
          }
          iVar4 = FUN_1002637c(&local_18,*(wchar_t **)(iVar4 + 0x21c),0x200,(LPCSTR)param_1,2,
                               (LPWSTR)&local_8,2,*(UINT *)(iVar4 + 4),1);
          if (iVar4 == 1) {
            uVar7 = local_8 & 0xff;
LAB_1001fa89:
            pbVar9 = param_1 + 2;
            iVar4 = local_14;
            goto LAB_1001faa3;
          }
          if (iVar4 == 2) {
            uVar7 = (uint)(ushort)((short)local_8 * 0x100 + ((ushort)(local_8 >> 8) & 0xff));
            goto LAB_1001fa89;
          }
LAB_1001fb4a:
          piVar2 = __errno();
          *piVar2 = 0x16;
          goto LAB_1001fb55;
        }
        if ((*(byte *)(uVar7 + 0x19 + iVar4) & 0x10) != 0) {
          uVar7 = (uint)*(byte *)(uVar7 + 0x119 + iVar4);
        }
LAB_1001faa3:
        uVar3 = (uint)*param_2;
        pbVar5 = param_2 + 1;
        if ((*(byte *)(uVar3 + 0x19 + iVar4) & 4) == 0) {
          uVar1 = (ushort)*param_2;
          param_2 = pbVar5;
          if ((*(byte *)(uVar3 + 0x19 + iVar4) & 0x10) != 0) {
            uVar1 = (ushort)*(byte *)(uVar3 + 0x119 + iVar4);
          }
        }
        else if (*pbVar5 == 0) {
          uVar1 = 0;
          param_2 = pbVar5;
        }
        else {
          iVar4 = FUN_1002637c(&local_18,*(wchar_t **)(iVar4 + 0x21c),0x200,(LPCSTR)param_2,2,
                               (LPWSTR)&local_8,2,*(UINT *)(iVar4 + 4),1);
          if (iVar4 == 1) {
            uVar1 = (ushort)(byte)local_8;
          }
          else {
            if (iVar4 != 2) goto LAB_1001fb4a;
            uVar1 = (short)local_8 * 0x100 + ((ushort)(local_8 >> 8) & 0xff);
          }
          iVar4 = local_14;
          param_2 = param_2 + 2;
        }
        uVar6 = (ushort)uVar7;
        if (uVar1 != uVar6) {
          iVar8 = (-(uint)(uVar1 < uVar6) & 2) - 1;
          break;
        }
        param_1 = pbVar9;
      } while (uVar6 != 0);
    }
  }
  if (local_c != '\0') {
    *(uint *)(local_10 + 0x70) = *(uint *)(local_10 + 0x70) & 0xfffffffd;
  }
  return iVar8;
}



void __cdecl FUN_1001fb78(uint *param_1,byte *param_2,uint param_3)

{
  FUN_1001fb90(param_1,param_2,param_3,(pthreadlocinfo *)0x0);
  return;
}



uint * __cdecl FUN_1001fb90(uint *param_1,byte *param_2,uint param_3,pthreadlocinfo *param_4)

{
  byte bVar1;
  byte bVar2;
  int *piVar3;
  uint uVar4;
  uint *puVar5;
  uint *puVar6;
  undefined local_14 [4];
  int local_10;
  int local_c;
  char local_8;
  
  FUN_1001f92e(local_14,param_4);
  if (((param_1 == (uint *)0x0) && (param_3 != 0)) || ((param_2 == (byte *)0x0 && (param_3 != 0))))
  {
    piVar3 = __errno();
    *piVar3 = 0x16;
    FUN_10025625();
    param_1 = (uint *)0x0;
  }
  else if (*(int *)(local_10 + 8) == 0) {
    param_1 = (uint *)_strncpy((char *)param_1,(char *)param_2,param_3);
  }
  else {
    puVar5 = param_1;
    if (param_3 != 0) {
      do {
        bVar1 = *param_2;
        uVar4 = param_3 - 1;
        bVar2 = *(byte *)(bVar1 + 0x19 + local_10);
        *(byte *)puVar5 = bVar1;
        if ((bVar2 & 4) == 0) {
          puVar6 = (uint *)((int)puVar5 + 1);
          param_2 = param_2 + 1;
          if (bVar1 == 0) {
LAB_1001fc1f:
            if (uVar4 != 0) {
              FUN_10021290(puVar6,0,uVar4);
            }
            break;
          }
        }
        else {
          if (uVar4 == 0) {
            *(byte *)puVar5 = 0;
            break;
          }
          bVar1 = param_2[1];
          uVar4 = param_3 - 2;
          *(byte *)((int)puVar5 + 1) = bVar1;
          param_2 = param_2 + 2;
          puVar6 = (uint *)((int)puVar5 + 2);
          if (bVar1 == 0) {
            *(byte *)puVar5 = 0;
            goto LAB_1001fc1f;
          }
        }
        param_3 = uVar4;
        puVar5 = puVar6;
      } while (uVar4 != 0);
    }
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return param_1;
}



void __cdecl FUN_1001fc56(undefined (*param_1) [16],undefined (*param_2) [16])

{
  FUN_1001fc6b(param_1,param_2,(pthreadlocinfo *)0x0);
  return;
}



undefined (*) [16] __cdecl
FUN_1001fc6b(undefined (*param_1) [16],undefined (*param_2) [16],pthreadlocinfo *param_3)

{
  byte bVar1;
  undefined (*pauVar2) [16];
  int *piVar3;
  size_t sVar4;
  size_t sVar5;
  undefined4 extraout_ECX;
  int iVar6;
  int iVar7;
  undefined4 extraout_EDX;
  undefined (*pauVar8) [16];
  undefined (*pauVar9) [16];
  undefined (*pauVar10) [16];
  undefined local_1c [4];
  int local_18;
  int local_14;
  char local_10;
  
  FUN_1001f92e(local_1c,param_3);
  pauVar8 = (undefined (*) [16])0x0;
  if (*(int *)(local_18 + 8) == 0) {
    pauVar2 = FUN_10021ad0(extraout_ECX,extraout_EDX,param_1,param_2);
    goto LAB_1001fd37;
  }
  if (param_2 != (undefined (*) [16])0x0) {
    pauVar2 = param_1;
    if ((*param_2)[0] == '\0') goto LAB_1001fd37;
    if (param_1 != (undefined (*) [16])0x0) {
      sVar4 = _strlen((char *)param_2);
      sVar5 = _strlen((char *)param_1);
      pauVar2 = pauVar8;
      if ((*param_1)[0] != '\0') {
        iVar6 = (int)param_1 - (int)param_2;
        pauVar9 = param_1;
        while (pauVar2 = pauVar8, pauVar9 <= (undefined (*) [16])((int)param_1 + (sVar5 - sVar4))) {
          pauVar10 = param_2;
          bVar1 = (*pauVar9)[0];
          while (pauVar2 = pauVar9, bVar1 != 0) {
            if ((*pauVar10)[0] == '\0') goto LAB_1001fd37;
            if ((*pauVar10)[iVar6] != (*pauVar10)[0]) break;
            pauVar10 = (undefined (*) [16])(*pauVar10 + 1);
            bVar1 = (*pauVar10)[iVar6];
          }
          if ((*pauVar10)[0] == '\0') break;
          pauVar10 = (undefined (*) [16])(*pauVar9 + 1);
          iVar7 = iVar6 + 1;
          if ((*(byte *)((byte)(*pauVar9)[0] + 0x19 + local_18) & 4) != 0) {
            pauVar2 = pauVar8;
            if ((*pauVar10)[0] == '\0') break;
            pauVar10 = (undefined (*) [16])(*pauVar9 + 2);
            iVar7 = iVar6 + 2;
          }
          iVar6 = iVar7;
          pauVar2 = pauVar8;
          pauVar9 = pauVar10;
          if ((*pauVar10)[0] == '\0') break;
        }
      }
      goto LAB_1001fd37;
    }
  }
  piVar3 = __errno();
  *piVar3 = 0x16;
  FUN_10025625();
  pauVar2 = pauVar8;
LAB_1001fd37:
  if (local_10 != '\0') {
    *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
  }
  return pauVar2;
}



// WARNING: Control flow encountered bad instruction data
// Library Function - Multiple Matches With Different Base Names
//  _memcpy
//  _memmove
// 
// Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release

void * __cdecl FID_conflict__memcpy(void *_Dst,void *_Src,size_t _Size)

{
  undefined8 uVar1;
  undefined auVar2 [32];
  undefined auVar3 [32];
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  int iVar16;
  undefined8 *puVar17;
  void *pvVar18;
  uint uVar19;
  uint uVar20;
  int iVar21;
  undefined8 *puVar22;
  undefined *puVar23;
  undefined4 *puVar24;
  undefined4 *puVar25;
  undefined4 uVar26;
  undefined4 uVar27;
  undefined4 uVar28;
  
  if ((_Src < _Dst) && (_Dst < (void *)(_Size + (int)_Src))) {
    puVar25 = (undefined4 *)((_Size - 4) + (int)_Src);
    puVar24 = (undefined4 *)((_Size - 4) + (int)_Dst);
    if (((uint)puVar24 & 3) == 0) {
      uVar19 = _Size >> 2;
      if (uVar19 < 8) goto LAB_10020100;
      for (; uVar19 != 0; uVar19 = uVar19 - 1) {
        *puVar24 = *puVar25;
        puVar25 = puVar25 + -1;
        puVar24 = puVar24 + -1;
      }
      switch(_Size & 3) {
      case 1:
        goto switchD_10020124_caseD_1;
      case 2:
        goto switchD_10020124_caseD_2;
      case 3:
        goto switchD_10020124_caseD_3;
      }
    }
    else {
      switch(_Size) {
      case 0:
        break;
      case 1:
switchD_10020124_caseD_1:
        *(undefined *)((int)puVar24 + 3) = *(undefined *)((int)puVar25 + 3);
        return _Dst;
      case 2:
switchD_10020124_caseD_2:
        *(undefined *)((int)puVar24 + 3) = *(undefined *)((int)puVar25 + 3);
        *(undefined *)((int)puVar24 + 2) = *(undefined *)((int)puVar25 + 2);
        return _Dst;
      case 3:
switchD_10020124_caseD_3:
        *(undefined *)((int)puVar24 + 3) = *(undefined *)((int)puVar25 + 3);
        *(undefined *)((int)puVar24 + 2) = *(undefined *)((int)puVar25 + 2);
        *(undefined *)((int)puVar24 + 1) = *(undefined *)((int)puVar25 + 1);
        return _Dst;
      default:
        uVar20 = _Size - ((uint)puVar24 & 3);
        switch((uint)puVar24 & 3) {
        case 1:
          *(undefined *)((int)puVar24 + 3) = *(undefined *)((int)puVar25 + 3);
          puVar25 = (undefined4 *)((int)puVar25 + -1);
          uVar19 = uVar20 >> 2;
          puVar24 = (undefined4 *)((int)puVar24 - 1);
          if (uVar19 < 8) {
LAB_10020100:
                    // WARNING: Could not recover jumptable at 0x10020102. Too many branches
                    // WARNING: Treating indirect jump as call
            pvVar18 = (void *)(*(code *)(&PTR_LAB_100201d4)[-uVar19])();
            return pvVar18;
          }
          for (; uVar19 != 0; uVar19 = uVar19 - 1) {
            *puVar24 = *puVar25;
            puVar25 = puVar25 + -1;
            puVar24 = puVar24 + -1;
          }
          switch(uVar20 & 3) {
          case 1:
            goto switchD_10020124_caseD_1;
          case 2:
            goto switchD_10020124_caseD_2;
          case 3:
            goto switchD_10020124_caseD_3;
          }
          break;
        case 2:
          *(undefined *)((int)puVar24 + 3) = *(undefined *)((int)puVar25 + 3);
          uVar19 = uVar20 >> 2;
          *(undefined *)((int)puVar24 + 2) = *(undefined *)((int)puVar25 + 2);
          puVar25 = (undefined4 *)((int)puVar25 + -2);
          puVar24 = (undefined4 *)((int)puVar24 - 2);
          if (uVar19 < 8) goto LAB_10020100;
          for (; uVar19 != 0; uVar19 = uVar19 - 1) {
            *puVar24 = *puVar25;
            puVar25 = puVar25 + -1;
            puVar24 = puVar24 + -1;
          }
          switch(uVar20 & 3) {
          case 1:
            goto switchD_10020124_caseD_1;
          case 2:
            goto switchD_10020124_caseD_2;
          case 3:
            goto switchD_10020124_caseD_3;
          }
          break;
        case 3:
          *(undefined *)((int)puVar24 + 3) = *(undefined *)((int)puVar25 + 3);
          *(undefined *)((int)puVar24 + 2) = *(undefined *)((int)puVar25 + 2);
          uVar19 = uVar20 >> 2;
          *(undefined *)((int)puVar24 + 1) = *(undefined *)((int)puVar25 + 1);
          puVar25 = (undefined4 *)((int)puVar25 + -3);
          puVar24 = (undefined4 *)((int)puVar24 - 3);
          if (uVar19 < 8) goto LAB_10020100;
          for (; uVar19 != 0; uVar19 = uVar19 - 1) {
            *puVar24 = *puVar25;
            puVar25 = puVar25 + -1;
            puVar24 = puVar24 + -1;
          }
          switch(uVar20 & 3) {
          case 1:
            goto switchD_10020124_caseD_1;
          case 2:
            goto switchD_10020124_caseD_2;
          case 3:
            goto switchD_10020124_caseD_3;
          }
        }
      }
    }
    return _Dst;
  }
  puVar23 = (undefined *)_Dst;
  if ((DAT_10835b50 >> 1 & 1) != 0) {
                    // WARNING: Load size is inaccurate
    for (; _Size != 0; _Size = _Size - 1) {
      *puVar23 = *_Src;
      _Src = (undefined *)((int)_Src + 1);
      puVar23 = puVar23 + 1;
    }
    return _Dst;
  }
  puVar25 = (undefined4 *)_Dst;
  if (_Size < 0x80) {
LAB_1001ff5b:
    if (((uint)_Dst & 3) != 0) {
LAB_1001ff78:
      switch(_Size) {
      case 0:
        return _Dst;
      case 1:
        break;
      case 2:
        goto switchD_1001ff90_caseD_2;
      case 3:
        goto switchD_1001ff90_caseD_3;
      default:
        uVar20 = (_Size - 4) + ((uint)_Dst & 3);
        switch((uint)_Dst & 3) {
        case 0:
                    // WARNING: Bad instruction - Truncating control flow here
          halt_baddata();
        case 1:
                    // WARNING: Load size is inaccurate
          *(undefined *)_Dst = *_Src;
          *(undefined *)((int)_Dst + 1) = *(undefined *)((int)_Src + 1);
          uVar19 = uVar20 >> 2;
          *(undefined *)((int)_Dst + 2) = *(undefined *)((int)_Src + 2);
          _Src = (undefined4 *)((int)_Src + 3);
          puVar25 = (undefined4 *)((int)_Dst + 3);
          if (7 < uVar19) {
                    // WARNING: Load size is inaccurate
            for (; uVar19 != 0; uVar19 = uVar19 - 1) {
              *puVar25 = *_Src;
              _Src = (undefined4 *)((int)_Src + 4);
              puVar25 = puVar25 + 1;
            }
            switch(uVar20 & 3) {
            case 0:
              return _Dst;
            case 2:
              goto switchD_1001ff90_caseD_2;
            case 3:
              goto switchD_1001ff90_caseD_3;
            }
            break;
          }
          goto LAB_1001ff98;
        case 2:
                    // WARNING: Load size is inaccurate
          *(undefined *)_Dst = *_Src;
          uVar19 = uVar20 >> 2;
          *(undefined *)((int)_Dst + 1) = *(undefined *)((int)_Src + 1);
          _Src = (undefined4 *)((int)_Src + 2);
          puVar25 = (undefined4 *)((int)_Dst + 2);
          if (uVar19 < 8) goto LAB_1001ff98;
                    // WARNING: Load size is inaccurate
          for (; uVar19 != 0; uVar19 = uVar19 - 1) {
            *puVar25 = *_Src;
            _Src = (undefined4 *)((int)_Src + 4);
            puVar25 = puVar25 + 1;
          }
          switch(uVar20 & 3) {
          case 0:
            return _Dst;
          case 2:
            goto switchD_1001ff90_caseD_2;
          case 3:
            goto switchD_1001ff90_caseD_3;
          }
          break;
        case 3:
                    // WARNING: Load size is inaccurate
          *(undefined *)_Dst = *_Src;
          uVar19 = uVar20 >> 2;
          _Src = (undefined4 *)((int)_Src + 1);
          puVar25 = (undefined4 *)((int)_Dst + 1);
          if (uVar19 < 8) goto LAB_1001ff98;
                    // WARNING: Load size is inaccurate
          for (; uVar19 != 0; uVar19 = uVar19 - 1) {
            *puVar25 = *_Src;
            _Src = (undefined4 *)((int)_Src + 4);
            puVar25 = puVar25 + 1;
          }
          switch(uVar20 & 3) {
          case 0:
            return _Dst;
          case 2:
            goto switchD_1001ff90_caseD_2;
          case 3:
            goto switchD_1001ff90_caseD_3;
          }
        }
      }
      goto switchD_1001ff90_caseD_1;
    }
  }
  else {
    if (((((uint)_Dst ^ (uint)_Src) & 0xf) == 0) && ((DAT_10047390 >> 1 & 1) != 0)) {
      if (((uint)_Src & 0xf) != 0) {
        uVar19 = 0x10 - ((uint)_Src & 0xf);
        _Size = _Size - uVar19;
        for (uVar20 = uVar19 & 3; uVar20 != 0; uVar20 = uVar20 - 1) {
                    // WARNING: Load size is inaccurate
          *(undefined *)puVar25 = *_Src;
          _Src = (void *)((int)_Src + 1);
          puVar25 = (undefined4 *)((int)puVar25 + 1);
        }
        for (uVar19 = uVar19 >> 2; uVar19 != 0; uVar19 = uVar19 - 1) {
                    // WARNING: Load size is inaccurate
          *puVar25 = *_Src;
          _Src = (void *)((int)_Src + 4);
          puVar25 = puVar25 + 1;
        }
      }
      for (uVar20 = _Size >> 7; uVar20 != 0; uVar20 = uVar20 - 1) {
                    // WARNING: Load size is inaccurate
        uVar26 = *(undefined4 *)((int)_Src + 4);
        uVar27 = *(undefined4 *)((int)_Src + 8);
        uVar28 = *(undefined4 *)((int)_Src + 0xc);
        uVar4 = *(undefined4 *)((int)_Src + 0x10);
        uVar5 = *(undefined4 *)((int)_Src + 0x14);
        uVar6 = *(undefined4 *)((int)_Src + 0x18);
        uVar7 = *(undefined4 *)((int)_Src + 0x1c);
        uVar8 = *(undefined4 *)((int)_Src + 0x20);
        uVar9 = *(undefined4 *)((int)_Src + 0x24);
        uVar10 = *(undefined4 *)((int)_Src + 0x28);
        uVar11 = *(undefined4 *)((int)_Src + 0x2c);
        uVar12 = *(undefined4 *)((int)_Src + 0x30);
        uVar13 = *(undefined4 *)((int)_Src + 0x34);
        uVar14 = *(undefined4 *)((int)_Src + 0x38);
        uVar15 = *(undefined4 *)((int)_Src + 0x3c);
        *puVar25 = *_Src;
        puVar25[1] = uVar26;
        puVar25[2] = uVar27;
        puVar25[3] = uVar28;
        puVar25[4] = uVar4;
        puVar25[5] = uVar5;
        puVar25[6] = uVar6;
        puVar25[7] = uVar7;
        puVar25[8] = uVar8;
        puVar25[9] = uVar9;
        puVar25[10] = uVar10;
        puVar25[0xb] = uVar11;
        puVar25[0xc] = uVar12;
        puVar25[0xd] = uVar13;
        puVar25[0xe] = uVar14;
        puVar25[0xf] = uVar15;
        uVar26 = *(undefined4 *)((int)_Src + 0x44);
        uVar27 = *(undefined4 *)((int)_Src + 0x48);
        uVar28 = *(undefined4 *)((int)_Src + 0x4c);
        uVar4 = *(undefined4 *)((int)_Src + 0x50);
        uVar5 = *(undefined4 *)((int)_Src + 0x54);
        uVar6 = *(undefined4 *)((int)_Src + 0x58);
        uVar7 = *(undefined4 *)((int)_Src + 0x5c);
        uVar8 = *(undefined4 *)((int)_Src + 0x60);
        uVar9 = *(undefined4 *)((int)_Src + 100);
        uVar10 = *(undefined4 *)((int)_Src + 0x68);
        uVar11 = *(undefined4 *)((int)_Src + 0x6c);
        uVar12 = *(undefined4 *)((int)_Src + 0x70);
        uVar13 = *(undefined4 *)((int)_Src + 0x74);
        uVar14 = *(undefined4 *)((int)_Src + 0x78);
        uVar15 = *(undefined4 *)((int)_Src + 0x7c);
        puVar25[0x10] = *(undefined4 *)((int)_Src + 0x40);
        puVar25[0x11] = uVar26;
        puVar25[0x12] = uVar27;
        puVar25[0x13] = uVar28;
        puVar25[0x14] = uVar4;
        puVar25[0x15] = uVar5;
        puVar25[0x16] = uVar6;
        puVar25[0x17] = uVar7;
        puVar25[0x18] = uVar8;
        puVar25[0x19] = uVar9;
        puVar25[0x1a] = uVar10;
        puVar25[0x1b] = uVar11;
        puVar25[0x1c] = uVar12;
        puVar25[0x1d] = uVar13;
        puVar25[0x1e] = uVar14;
        puVar25[0x1f] = uVar15;
        _Src = (void *)((int)_Src + 0x80);
        puVar25 = puVar25 + 0x20;
      }
      if ((_Size & 0x7f) != 0) {
        for (uVar20 = (_Size & 0x7f) >> 4; uVar20 != 0; uVar20 = uVar20 - 1) {
                    // WARNING: Load size is inaccurate
          uVar26 = *(undefined4 *)((int)_Src + 4);
          uVar27 = *(undefined4 *)((int)_Src + 8);
          uVar28 = *(undefined4 *)((int)_Src + 0xc);
          *puVar25 = *_Src;
          puVar25[1] = uVar26;
          puVar25[2] = uVar27;
          puVar25[3] = uVar28;
          _Src = (void *)((int)_Src + 0x10);
          puVar25 = puVar25 + 4;
        }
        if ((_Size & 0xf) != 0) {
          for (uVar20 = (_Size & 0xf) >> 2; uVar20 != 0; uVar20 = uVar20 - 1) {
                    // WARNING: Load size is inaccurate
            *puVar25 = *_Src;
            _Src = (void *)((int)_Src + 4);
            puVar25 = puVar25 + 1;
          }
          for (uVar20 = _Size & 3; uVar20 != 0; uVar20 = uVar20 - 1) {
                    // WARNING: Load size is inaccurate
            *(undefined *)puVar25 = *_Src;
            _Src = (void *)((int)_Src + 1);
            puVar25 = (undefined4 *)((int)puVar25 + 1);
          }
        }
      }
      return _Dst;
    }
    if ((DAT_10835b50 & 1) == 0) goto LAB_1001ff5b;
    if (((uint)_Dst & 3) != 0) goto LAB_1001ff78;
    if (((uint)_Src & 3) == 0) {
      if (((uint)_Dst >> 2 & 1) != 0) {
                    // WARNING: Load size is inaccurate
        uVar26 = *_Src;
        _Size = _Size - 4;
        _Src = (void *)((int)_Src + 4);
        *(undefined4 *)_Dst = uVar26;
        _Dst = (void *)((int)_Dst + 4);
      }
      if (((uint)_Dst >> 3 & 1) != 0) {
                    // WARNING: Load size is inaccurate
        uVar1 = *_Src;
        _Size = _Size - 8;
        _Src = (void *)((int)_Src + 8);
        *(undefined8 *)_Dst = uVar1;
        _Dst = (void *)((int)_Dst + 8);
      }
      if (((uint)_Src & 7) == 0) {
                    // WARNING: Load size is inaccurate
        puVar17 = (undefined8 *)((int)_Src + -8);
        uVar26 = *_Src;
        uVar27 = *(undefined4 *)((int)_Src + 4);
        do {
          puVar22 = puVar17;
          uVar5 = *(undefined4 *)(puVar22 + 4);
          uVar6 = *(undefined4 *)((int)puVar22 + 0x24);
          _Size = _Size - 0x30;
          auVar2 = *(undefined (*) [32])(puVar22 + 2);
          uVar28 = *(undefined4 *)(puVar22 + 7);
          uVar4 = *(undefined4 *)((int)puVar22 + 0x3c);
          auVar3 = *(undefined (*) [32])(puVar22 + 4);
          *(undefined4 *)((int)_Dst + 8) = uVar26;
          *(undefined4 *)((int)_Dst + 0xc) = uVar27;
          *(undefined4 *)((int)_Dst + 0x10) = uVar5;
          *(undefined4 *)((int)_Dst + 0x14) = uVar6;
          *(undefined (*) [16])((int)_Dst + 0x10) = SUB3216(auVar2 >> 0x40,0);
          *(undefined (*) [16])((int)_Dst + 0x20) = SUB3216(auVar3 >> 0x40,0);
          _Dst = (void *)((int)_Dst + 0x30);
          puVar17 = puVar22 + 6;
          uVar26 = uVar28;
          uVar27 = uVar4;
        } while (0x2f < (int)_Size);
        puVar22 = puVar22 + 7;
      }
      else if (((uint)_Src >> 3 & 1) == 0) {
                    // WARNING: Load size is inaccurate
        iVar16 = (int)_Src + -4;
        uVar26 = *_Src;
        uVar27 = *(undefined4 *)((int)_Src + 4);
        uVar28 = *(undefined4 *)((int)_Src + 8);
        do {
          iVar21 = iVar16;
          uVar7 = *(undefined4 *)(iVar21 + 0x20);
          _Size = _Size - 0x30;
          auVar2 = *(undefined (*) [32])(iVar21 + 0x10);
          uVar4 = *(undefined4 *)(iVar21 + 0x34);
          uVar5 = *(undefined4 *)(iVar21 + 0x38);
          uVar6 = *(undefined4 *)(iVar21 + 0x3c);
          auVar3 = *(undefined (*) [32])(iVar21 + 0x20);
          *(undefined4 *)((int)_Dst + 4) = uVar26;
          *(undefined4 *)((int)_Dst + 8) = uVar27;
          *(undefined4 *)((int)_Dst + 0xc) = uVar28;
          *(undefined4 *)((int)_Dst + 0x10) = uVar7;
          *(undefined (*) [16])((int)_Dst + 0x10) = SUB3216(auVar2 >> 0x20,0);
          *(undefined (*) [16])((int)_Dst + 0x20) = SUB3216(auVar3 >> 0x20,0);
          _Dst = (void *)((int)_Dst + 0x30);
          iVar16 = iVar21 + 0x30;
          uVar26 = uVar4;
          uVar27 = uVar5;
          uVar28 = uVar6;
        } while (0x2f < (int)_Size);
        puVar22 = (undefined8 *)(iVar21 + 0x34);
      }
      else {
                    // WARNING: Load size is inaccurate
        iVar16 = (int)_Src + -0xc;
        uVar26 = *_Src;
        do {
          iVar21 = iVar16;
          uVar28 = *(undefined4 *)(iVar21 + 0x20);
          uVar4 = *(undefined4 *)(iVar21 + 0x24);
          uVar5 = *(undefined4 *)(iVar21 + 0x28);
          _Size = _Size - 0x30;
          auVar2 = *(undefined (*) [32])(iVar21 + 0x10);
          uVar27 = *(undefined4 *)(iVar21 + 0x3c);
          auVar3 = *(undefined (*) [32])(iVar21 + 0x20);
          *(undefined4 *)((int)_Dst + 0xc) = uVar26;
          *(undefined4 *)((int)_Dst + 0x10) = uVar28;
          *(undefined4 *)((int)_Dst + 0x14) = uVar4;
          *(undefined4 *)((int)_Dst + 0x18) = uVar5;
          *(undefined (*) [16])((int)_Dst + 0x10) = SUB3216(auVar2 >> 0x60,0);
          *(undefined (*) [16])((int)_Dst + 0x20) = SUB3216(auVar3 >> 0x60,0);
          _Dst = (void *)((int)_Dst + 0x30);
          iVar16 = iVar21 + 0x30;
          uVar26 = uVar27;
        } while (0x2f < (int)_Size);
        puVar22 = (undefined8 *)(iVar21 + 0x3c);
      }
      for (; 0xf < (int)_Size; _Size = _Size - 0x10) {
        uVar26 = *(undefined4 *)puVar22;
        uVar27 = *(undefined4 *)((int)puVar22 + 4);
        uVar28 = *(undefined4 *)(puVar22 + 1);
        uVar4 = *(undefined4 *)((int)puVar22 + 0xc);
        puVar22 = puVar22 + 2;
        *(undefined4 *)_Dst = uVar26;
        *(undefined4 *)((int)_Dst + 4) = uVar27;
        *(undefined4 *)((int)_Dst + 8) = uVar28;
        *(undefined4 *)((int)_Dst + 0xc) = uVar4;
        _Dst = (void *)((int)_Dst + 0x10);
      }
      if ((_Size >> 2 & 1) != 0) {
        uVar26 = *(undefined4 *)puVar22;
        _Size = _Size - 4;
        puVar22 = (undefined8 *)((int)puVar22 + 4);
        *(undefined4 *)_Dst = uVar26;
        _Dst = (void *)((int)_Dst + 4);
      }
      if ((_Size >> 3 & 1) != 0) {
        _Size = _Size - 8;
        *(undefined8 *)_Dst = *puVar22;
      }
                    // WARNING: Could not recover jumptable at 0x1001ff59. Too many branches
                    // WARNING: Treating indirect jump as call
      pvVar18 = (void *)(*(code *)(&switchD_1001ff90::switchdataD_10020088)[_Size])();
      return pvVar18;
    }
  }
  uVar19 = _Size >> 2;
  if (uVar19 < 8) {
LAB_1001ff98:
                    // WARNING: Could not recover jumptable at 0x1001ff98. Too many branches
                    // WARNING: Treating indirect jump as call
    pvVar18 = (void *)(*(code *)(&PTR_LAB_1002001c)[uVar19])();
    return pvVar18;
  }
                    // WARNING: Load size is inaccurate
  for (; uVar19 != 0; uVar19 = uVar19 - 1) {
    *puVar25 = *_Src;
    _Src = (undefined4 *)((int)_Src + 4);
    puVar25 = puVar25 + 1;
  }
  switch(_Size & 3) {
  case 0:
    return _Dst;
  case 2:
switchD_1001ff90_caseD_2:
                    // WARNING: Load size is inaccurate
    *(undefined *)puVar25 = *_Src;
    *(undefined *)((int)puVar25 + 1) = *(undefined *)((int)_Src + 1);
    return _Dst;
  case 3:
switchD_1001ff90_caseD_3:
                    // WARNING: Load size is inaccurate
    *(undefined *)puVar25 = *_Src;
    *(undefined *)((int)puVar25 + 1) = *(undefined *)((int)_Src + 1);
    *(undefined *)((int)puVar25 + 2) = *(undefined *)((int)_Src + 2);
    return _Dst;
  }
switchD_1001ff90_caseD_1:
                    // WARNING: Load size is inaccurate
  *(undefined *)puVar25 = *_Src;
  return _Dst;
}



void __fastcall FUN_1002003c(int param_1,int param_2)

{
  int unaff_ESI;
  int unaff_EDI;
  
  *(undefined4 *)(unaff_EDI + -0x1c + param_1 * 4) =
       *(undefined4 *)(unaff_ESI + -0x1c + param_1 * 4);
  *(undefined4 *)(unaff_EDI + -0x18 + param_1 * 4) =
       *(undefined4 *)(unaff_ESI + -0x18 + param_1 * 4);
  *(undefined4 *)(unaff_EDI + -0x14 + param_1 * 4) =
       *(undefined4 *)(unaff_ESI + -0x14 + param_1 * 4);
  *(undefined4 *)(unaff_EDI + -0x10 + param_1 * 4) =
       *(undefined4 *)(unaff_ESI + -0x10 + param_1 * 4);
  *(undefined4 *)(unaff_EDI + -0xc + param_1 * 4) = *(undefined4 *)(unaff_ESI + -0xc + param_1 * 4);
  *(undefined4 *)(unaff_EDI + -8 + param_1 * 4) = *(undefined4 *)(unaff_ESI + -8 + param_1 * 4);
  *(undefined4 *)(unaff_EDI + -4 + param_1 * 4) = *(undefined4 *)(unaff_ESI + -4 + param_1 * 4);
                    // WARNING: Could not recover jumptable at 0x1002007f. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)(&switchD_1001ff90::switchdataD_10020088)[param_2])();
  return;
}



void __fastcall FUN_100201d8(int param_1,int param_2)

{
  int unaff_ESI;
  int unaff_EDI;
  
  *(undefined4 *)(unaff_EDI + 0x1c + param_1 * 4) = *(undefined4 *)(unaff_ESI + 0x1c + param_1 * 4);
  *(undefined4 *)(unaff_EDI + 0x18 + param_1 * 4) = *(undefined4 *)(unaff_ESI + 0x18 + param_1 * 4);
  *(undefined4 *)(unaff_EDI + 0x14 + param_1 * 4) = *(undefined4 *)(unaff_ESI + 0x14 + param_1 * 4);
  *(undefined4 *)(unaff_EDI + 0x10 + param_1 * 4) = *(undefined4 *)(unaff_ESI + 0x10 + param_1 * 4);
  *(undefined4 *)(unaff_EDI + 0xc + param_1 * 4) = *(undefined4 *)(unaff_ESI + 0xc + param_1 * 4);
  *(undefined4 *)(unaff_EDI + 8 + param_1 * 4) = *(undefined4 *)(unaff_ESI + 8 + param_1 * 4);
  *(undefined4 *)(unaff_EDI + 4 + param_1 * 4) = *(undefined4 *)(unaff_ESI + 4 + param_1 * 4);
                    // WARNING: Could not recover jumptable at 0x1002021b. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)(&switchD_10020124::switchdataD_10020224)[param_2])();
  return;
}



// Library Function - Single Match
//  public: virtual __thiscall type_info::~type_info(void)
// 
// Library: Visual Studio 2012 Release

void __thiscall type_info::_type_info(type_info *this)

{
  *(undefined ***)this = vftable;
  _Type_info_dtor(this);
  return;
}



// Library Function - Single Match
//  public: bool __thiscall type_info::operator==(class type_info const &)const 
// 
// Library: Visual Studio 2012 Release

bool __thiscall type_info::operator__(type_info *this,type_info *param_1)

{
  int iVar1;
  
  iVar1 = _strcmp((char *)(param_1 + 9),(char *)(this + 9));
  return (bool)('\x01' - (iVar1 != 0));
}



// Library Function - Single Match
//  public: virtual void * __thiscall type_info::`scalar deleting destructor'(unsigned int)
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

void * __thiscall type_info::_scalar_deleting_destructor_(type_info *this,uint param_1)

{
  _type_info(this);
  if ((param_1 & 1) != 0) {
    FID_conflict__free(this);
  }
  return this;
}



undefined4 FUN_100203df(void)

{
  undefined4 *Ptr;
  
  Ptr = (undefined4 *)FUN_10026edb(0x20,4);
  DAT_10836b8c = EncodePointer(Ptr);
  if (Ptr == (undefined4 *)0x0) {
    DAT_10836b90 = DAT_10836b8c;
    return 0x18;
  }
  DAT_10836b90 = DAT_10836b8c;
  *Ptr = 0;
  return 0;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

PVOID __cdecl FUN_1002040e(PVOID param_1)

{
  PVOID pvVar1;
  
  FUN_10026d69();
  pvVar1 = FUN_10020452(param_1);
  FUN_1002044c();
  return pvVar1;
}



void FUN_1002044c(void)

{
  FUN_10026d72();
  return;
}



PVOID __cdecl FUN_10020452(PVOID param_1)

{
  PVOID *ppvVar1;
  PVOID *ppvVar2;
  SIZE_T SVar3;
  SIZE_T SVar4;
  PVOID pvVar5;
  int iVar6;
  
  ppvVar1 = (PVOID *)DecodePointer(DAT_10836b90);
  ppvVar2 = (PVOID *)DecodePointer(DAT_10836b8c);
  if ((ppvVar2 < ppvVar1) || (iVar6 = (int)ppvVar2 - (int)ppvVar1, iVar6 + 4U < 4)) {
    return (PVOID)0x0;
  }
  SVar3 = FUN_10026eaa(ppvVar1);
  if (SVar3 < iVar6 + 4U) {
    SVar4 = 0x800;
    if (SVar3 < 0x800) {
      SVar4 = SVar3;
    }
    if ((SVar4 + SVar3 < SVar3) ||
       (pvVar5 = FUN_10026f6a(ppvVar1,SVar4 + SVar3), pvVar5 == (void *)0x0)) {
      if (SVar3 + 0x10 < SVar3) {
        return (PVOID)0x0;
      }
      pvVar5 = FUN_10026f6a(ppvVar1,SVar3 + 0x10);
      if (pvVar5 == (void *)0x0) {
        return (PVOID)0x0;
      }
    }
    ppvVar2 = (PVOID *)((int)pvVar5 + (iVar6 >> 2) * 4);
    DAT_10836b90 = EncodePointer(pvVar5);
  }
  pvVar5 = EncodePointer(param_1);
  *ppvVar2 = pvVar5;
  DAT_10836b8c = EncodePointer(ppvVar2 + 1);
  return param_1;
}



int __cdecl FUN_1002050a(PVOID param_1)

{
  PVOID pvVar1;
  
  pvVar1 = FUN_1002040e(param_1);
  return (pvVar1 != (PVOID)0x0) - 1;
}



// WARNING: Control flow encountered bad instruction data
// Library Function - Multiple Matches With Different Base Names
//  _memcpy
//  _memmove
// 
// Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release

void * __cdecl FID_conflict__memcpy(void *_Dst,void *_Src,size_t _Size)

{
  undefined8 uVar1;
  undefined auVar2 [32];
  undefined auVar3 [32];
  undefined4 uVar4;
  undefined4 uVar5;
  undefined4 uVar6;
  undefined4 uVar7;
  undefined4 uVar8;
  undefined4 uVar9;
  undefined4 uVar10;
  undefined4 uVar11;
  undefined4 uVar12;
  undefined4 uVar13;
  undefined4 uVar14;
  undefined4 uVar15;
  int iVar16;
  undefined8 *puVar17;
  void *pvVar18;
  uint uVar19;
  uint uVar20;
  int iVar21;
  undefined8 *puVar22;
  undefined *puVar23;
  undefined4 *puVar24;
  undefined4 *puVar25;
  undefined4 uVar26;
  undefined4 uVar27;
  undefined4 uVar28;
  
  if ((_Src < _Dst) && (_Dst < (void *)(_Size + (int)_Src))) {
    puVar25 = (undefined4 *)((_Size - 4) + (int)_Src);
    puVar24 = (undefined4 *)((_Size - 4) + (int)_Dst);
    if (((uint)puVar24 & 3) == 0) {
      uVar19 = _Size >> 2;
      if (uVar19 < 8) goto LAB_100208d0;
      for (; uVar19 != 0; uVar19 = uVar19 - 1) {
        *puVar24 = *puVar25;
        puVar25 = puVar25 + -1;
        puVar24 = puVar24 + -1;
      }
      switch(_Size & 3) {
      case 1:
        goto switchD_100208f4_caseD_1;
      case 2:
        goto switchD_100208f4_caseD_2;
      case 3:
        goto switchD_100208f4_caseD_3;
      }
    }
    else {
      switch(_Size) {
      case 0:
        break;
      case 1:
switchD_100208f4_caseD_1:
        *(undefined *)((int)puVar24 + 3) = *(undefined *)((int)puVar25 + 3);
        return _Dst;
      case 2:
switchD_100208f4_caseD_2:
        *(undefined *)((int)puVar24 + 3) = *(undefined *)((int)puVar25 + 3);
        *(undefined *)((int)puVar24 + 2) = *(undefined *)((int)puVar25 + 2);
        return _Dst;
      case 3:
switchD_100208f4_caseD_3:
        *(undefined *)((int)puVar24 + 3) = *(undefined *)((int)puVar25 + 3);
        *(undefined *)((int)puVar24 + 2) = *(undefined *)((int)puVar25 + 2);
        *(undefined *)((int)puVar24 + 1) = *(undefined *)((int)puVar25 + 1);
        return _Dst;
      default:
        uVar20 = _Size - ((uint)puVar24 & 3);
        switch((uint)puVar24 & 3) {
        case 1:
          *(undefined *)((int)puVar24 + 3) = *(undefined *)((int)puVar25 + 3);
          puVar25 = (undefined4 *)((int)puVar25 + -1);
          uVar19 = uVar20 >> 2;
          puVar24 = (undefined4 *)((int)puVar24 - 1);
          if (uVar19 < 8) {
LAB_100208d0:
                    // WARNING: Could not recover jumptable at 0x100208d2. Too many branches
                    // WARNING: Treating indirect jump as call
            pvVar18 = (void *)(*(code *)(&PTR_LAB_100209a4)[-uVar19])();
            return pvVar18;
          }
          for (; uVar19 != 0; uVar19 = uVar19 - 1) {
            *puVar24 = *puVar25;
            puVar25 = puVar25 + -1;
            puVar24 = puVar24 + -1;
          }
          switch(uVar20 & 3) {
          case 1:
            goto switchD_100208f4_caseD_1;
          case 2:
            goto switchD_100208f4_caseD_2;
          case 3:
            goto switchD_100208f4_caseD_3;
          }
          break;
        case 2:
          *(undefined *)((int)puVar24 + 3) = *(undefined *)((int)puVar25 + 3);
          uVar19 = uVar20 >> 2;
          *(undefined *)((int)puVar24 + 2) = *(undefined *)((int)puVar25 + 2);
          puVar25 = (undefined4 *)((int)puVar25 + -2);
          puVar24 = (undefined4 *)((int)puVar24 - 2);
          if (uVar19 < 8) goto LAB_100208d0;
          for (; uVar19 != 0; uVar19 = uVar19 - 1) {
            *puVar24 = *puVar25;
            puVar25 = puVar25 + -1;
            puVar24 = puVar24 + -1;
          }
          switch(uVar20 & 3) {
          case 1:
            goto switchD_100208f4_caseD_1;
          case 2:
            goto switchD_100208f4_caseD_2;
          case 3:
            goto switchD_100208f4_caseD_3;
          }
          break;
        case 3:
          *(undefined *)((int)puVar24 + 3) = *(undefined *)((int)puVar25 + 3);
          *(undefined *)((int)puVar24 + 2) = *(undefined *)((int)puVar25 + 2);
          uVar19 = uVar20 >> 2;
          *(undefined *)((int)puVar24 + 1) = *(undefined *)((int)puVar25 + 1);
          puVar25 = (undefined4 *)((int)puVar25 + -3);
          puVar24 = (undefined4 *)((int)puVar24 - 3);
          if (uVar19 < 8) goto LAB_100208d0;
          for (; uVar19 != 0; uVar19 = uVar19 - 1) {
            *puVar24 = *puVar25;
            puVar25 = puVar25 + -1;
            puVar24 = puVar24 + -1;
          }
          switch(uVar20 & 3) {
          case 1:
            goto switchD_100208f4_caseD_1;
          case 2:
            goto switchD_100208f4_caseD_2;
          case 3:
            goto switchD_100208f4_caseD_3;
          }
        }
      }
    }
    return _Dst;
  }
  puVar23 = (undefined *)_Dst;
  if ((DAT_10835b50 >> 1 & 1) != 0) {
                    // WARNING: Load size is inaccurate
    for (; _Size != 0; _Size = _Size - 1) {
      *puVar23 = *_Src;
      _Src = (undefined *)((int)_Src + 1);
      puVar23 = puVar23 + 1;
    }
    return _Dst;
  }
  puVar25 = (undefined4 *)_Dst;
  if (_Size < 0x80) {
LAB_1002072b:
    if (((uint)_Dst & 3) != 0) {
LAB_10020748:
      switch(_Size) {
      case 0:
        return _Dst;
      case 1:
        break;
      case 2:
        goto switchD_10020760_caseD_2;
      case 3:
        goto switchD_10020760_caseD_3;
      default:
        uVar20 = (_Size - 4) + ((uint)_Dst & 3);
        switch((uint)_Dst & 3) {
        case 0:
                    // WARNING: Bad instruction - Truncating control flow here
          halt_baddata();
        case 1:
                    // WARNING: Load size is inaccurate
          *(undefined *)_Dst = *_Src;
          *(undefined *)((int)_Dst + 1) = *(undefined *)((int)_Src + 1);
          uVar19 = uVar20 >> 2;
          *(undefined *)((int)_Dst + 2) = *(undefined *)((int)_Src + 2);
          _Src = (undefined4 *)((int)_Src + 3);
          puVar25 = (undefined4 *)((int)_Dst + 3);
          if (7 < uVar19) {
                    // WARNING: Load size is inaccurate
            for (; uVar19 != 0; uVar19 = uVar19 - 1) {
              *puVar25 = *_Src;
              _Src = (undefined4 *)((int)_Src + 4);
              puVar25 = puVar25 + 1;
            }
            switch(uVar20 & 3) {
            case 0:
              return _Dst;
            case 2:
              goto switchD_10020760_caseD_2;
            case 3:
              goto switchD_10020760_caseD_3;
            }
            break;
          }
          goto LAB_10020768;
        case 2:
                    // WARNING: Load size is inaccurate
          *(undefined *)_Dst = *_Src;
          uVar19 = uVar20 >> 2;
          *(undefined *)((int)_Dst + 1) = *(undefined *)((int)_Src + 1);
          _Src = (undefined4 *)((int)_Src + 2);
          puVar25 = (undefined4 *)((int)_Dst + 2);
          if (uVar19 < 8) goto LAB_10020768;
                    // WARNING: Load size is inaccurate
          for (; uVar19 != 0; uVar19 = uVar19 - 1) {
            *puVar25 = *_Src;
            _Src = (undefined4 *)((int)_Src + 4);
            puVar25 = puVar25 + 1;
          }
          switch(uVar20 & 3) {
          case 0:
            return _Dst;
          case 2:
            goto switchD_10020760_caseD_2;
          case 3:
            goto switchD_10020760_caseD_3;
          }
          break;
        case 3:
                    // WARNING: Load size is inaccurate
          *(undefined *)_Dst = *_Src;
          uVar19 = uVar20 >> 2;
          _Src = (undefined4 *)((int)_Src + 1);
          puVar25 = (undefined4 *)((int)_Dst + 1);
          if (uVar19 < 8) goto LAB_10020768;
                    // WARNING: Load size is inaccurate
          for (; uVar19 != 0; uVar19 = uVar19 - 1) {
            *puVar25 = *_Src;
            _Src = (undefined4 *)((int)_Src + 4);
            puVar25 = puVar25 + 1;
          }
          switch(uVar20 & 3) {
          case 0:
            return _Dst;
          case 2:
            goto switchD_10020760_caseD_2;
          case 3:
            goto switchD_10020760_caseD_3;
          }
        }
      }
      goto switchD_10020760_caseD_1;
    }
  }
  else {
    if (((((uint)_Dst ^ (uint)_Src) & 0xf) == 0) && ((DAT_10047390 >> 1 & 1) != 0)) {
      if (((uint)_Src & 0xf) != 0) {
        uVar19 = 0x10 - ((uint)_Src & 0xf);
        _Size = _Size - uVar19;
        for (uVar20 = uVar19 & 3; uVar20 != 0; uVar20 = uVar20 - 1) {
                    // WARNING: Load size is inaccurate
          *(undefined *)puVar25 = *_Src;
          _Src = (void *)((int)_Src + 1);
          puVar25 = (undefined4 *)((int)puVar25 + 1);
        }
        for (uVar19 = uVar19 >> 2; uVar19 != 0; uVar19 = uVar19 - 1) {
                    // WARNING: Load size is inaccurate
          *puVar25 = *_Src;
          _Src = (void *)((int)_Src + 4);
          puVar25 = puVar25 + 1;
        }
      }
      for (uVar20 = _Size >> 7; uVar20 != 0; uVar20 = uVar20 - 1) {
                    // WARNING: Load size is inaccurate
        uVar26 = *(undefined4 *)((int)_Src + 4);
        uVar27 = *(undefined4 *)((int)_Src + 8);
        uVar28 = *(undefined4 *)((int)_Src + 0xc);
        uVar4 = *(undefined4 *)((int)_Src + 0x10);
        uVar5 = *(undefined4 *)((int)_Src + 0x14);
        uVar6 = *(undefined4 *)((int)_Src + 0x18);
        uVar7 = *(undefined4 *)((int)_Src + 0x1c);
        uVar8 = *(undefined4 *)((int)_Src + 0x20);
        uVar9 = *(undefined4 *)((int)_Src + 0x24);
        uVar10 = *(undefined4 *)((int)_Src + 0x28);
        uVar11 = *(undefined4 *)((int)_Src + 0x2c);
        uVar12 = *(undefined4 *)((int)_Src + 0x30);
        uVar13 = *(undefined4 *)((int)_Src + 0x34);
        uVar14 = *(undefined4 *)((int)_Src + 0x38);
        uVar15 = *(undefined4 *)((int)_Src + 0x3c);
        *puVar25 = *_Src;
        puVar25[1] = uVar26;
        puVar25[2] = uVar27;
        puVar25[3] = uVar28;
        puVar25[4] = uVar4;
        puVar25[5] = uVar5;
        puVar25[6] = uVar6;
        puVar25[7] = uVar7;
        puVar25[8] = uVar8;
        puVar25[9] = uVar9;
        puVar25[10] = uVar10;
        puVar25[0xb] = uVar11;
        puVar25[0xc] = uVar12;
        puVar25[0xd] = uVar13;
        puVar25[0xe] = uVar14;
        puVar25[0xf] = uVar15;
        uVar26 = *(undefined4 *)((int)_Src + 0x44);
        uVar27 = *(undefined4 *)((int)_Src + 0x48);
        uVar28 = *(undefined4 *)((int)_Src + 0x4c);
        uVar4 = *(undefined4 *)((int)_Src + 0x50);
        uVar5 = *(undefined4 *)((int)_Src + 0x54);
        uVar6 = *(undefined4 *)((int)_Src + 0x58);
        uVar7 = *(undefined4 *)((int)_Src + 0x5c);
        uVar8 = *(undefined4 *)((int)_Src + 0x60);
        uVar9 = *(undefined4 *)((int)_Src + 100);
        uVar10 = *(undefined4 *)((int)_Src + 0x68);
        uVar11 = *(undefined4 *)((int)_Src + 0x6c);
        uVar12 = *(undefined4 *)((int)_Src + 0x70);
        uVar13 = *(undefined4 *)((int)_Src + 0x74);
        uVar14 = *(undefined4 *)((int)_Src + 0x78);
        uVar15 = *(undefined4 *)((int)_Src + 0x7c);
        puVar25[0x10] = *(undefined4 *)((int)_Src + 0x40);
        puVar25[0x11] = uVar26;
        puVar25[0x12] = uVar27;
        puVar25[0x13] = uVar28;
        puVar25[0x14] = uVar4;
        puVar25[0x15] = uVar5;
        puVar25[0x16] = uVar6;
        puVar25[0x17] = uVar7;
        puVar25[0x18] = uVar8;
        puVar25[0x19] = uVar9;
        puVar25[0x1a] = uVar10;
        puVar25[0x1b] = uVar11;
        puVar25[0x1c] = uVar12;
        puVar25[0x1d] = uVar13;
        puVar25[0x1e] = uVar14;
        puVar25[0x1f] = uVar15;
        _Src = (void *)((int)_Src + 0x80);
        puVar25 = puVar25 + 0x20;
      }
      if ((_Size & 0x7f) != 0) {
        for (uVar20 = (_Size & 0x7f) >> 4; uVar20 != 0; uVar20 = uVar20 - 1) {
                    // WARNING: Load size is inaccurate
          uVar26 = *(undefined4 *)((int)_Src + 4);
          uVar27 = *(undefined4 *)((int)_Src + 8);
          uVar28 = *(undefined4 *)((int)_Src + 0xc);
          *puVar25 = *_Src;
          puVar25[1] = uVar26;
          puVar25[2] = uVar27;
          puVar25[3] = uVar28;
          _Src = (void *)((int)_Src + 0x10);
          puVar25 = puVar25 + 4;
        }
        if ((_Size & 0xf) != 0) {
          for (uVar20 = (_Size & 0xf) >> 2; uVar20 != 0; uVar20 = uVar20 - 1) {
                    // WARNING: Load size is inaccurate
            *puVar25 = *_Src;
            _Src = (void *)((int)_Src + 4);
            puVar25 = puVar25 + 1;
          }
          for (uVar20 = _Size & 3; uVar20 != 0; uVar20 = uVar20 - 1) {
                    // WARNING: Load size is inaccurate
            *(undefined *)puVar25 = *_Src;
            _Src = (void *)((int)_Src + 1);
            puVar25 = (undefined4 *)((int)puVar25 + 1);
          }
        }
      }
      return _Dst;
    }
    if ((DAT_10835b50 & 1) == 0) goto LAB_1002072b;
    if (((uint)_Dst & 3) != 0) goto LAB_10020748;
    if (((uint)_Src & 3) == 0) {
      if (((uint)_Dst >> 2 & 1) != 0) {
                    // WARNING: Load size is inaccurate
        uVar26 = *_Src;
        _Size = _Size - 4;
        _Src = (void *)((int)_Src + 4);
        *(undefined4 *)_Dst = uVar26;
        _Dst = (void *)((int)_Dst + 4);
      }
      if (((uint)_Dst >> 3 & 1) != 0) {
                    // WARNING: Load size is inaccurate
        uVar1 = *_Src;
        _Size = _Size - 8;
        _Src = (void *)((int)_Src + 8);
        *(undefined8 *)_Dst = uVar1;
        _Dst = (void *)((int)_Dst + 8);
      }
      if (((uint)_Src & 7) == 0) {
                    // WARNING: Load size is inaccurate
        puVar17 = (undefined8 *)((int)_Src + -8);
        uVar26 = *_Src;
        uVar27 = *(undefined4 *)((int)_Src + 4);
        do {
          puVar22 = puVar17;
          uVar5 = *(undefined4 *)(puVar22 + 4);
          uVar6 = *(undefined4 *)((int)puVar22 + 0x24);
          _Size = _Size - 0x30;
          auVar2 = *(undefined (*) [32])(puVar22 + 2);
          uVar28 = *(undefined4 *)(puVar22 + 7);
          uVar4 = *(undefined4 *)((int)puVar22 + 0x3c);
          auVar3 = *(undefined (*) [32])(puVar22 + 4);
          *(undefined4 *)((int)_Dst + 8) = uVar26;
          *(undefined4 *)((int)_Dst + 0xc) = uVar27;
          *(undefined4 *)((int)_Dst + 0x10) = uVar5;
          *(undefined4 *)((int)_Dst + 0x14) = uVar6;
          *(undefined (*) [16])((int)_Dst + 0x10) = SUB3216(auVar2 >> 0x40,0);
          *(undefined (*) [16])((int)_Dst + 0x20) = SUB3216(auVar3 >> 0x40,0);
          _Dst = (void *)((int)_Dst + 0x30);
          puVar17 = puVar22 + 6;
          uVar26 = uVar28;
          uVar27 = uVar4;
        } while (0x2f < (int)_Size);
        puVar22 = puVar22 + 7;
      }
      else if (((uint)_Src >> 3 & 1) == 0) {
                    // WARNING: Load size is inaccurate
        iVar16 = (int)_Src + -4;
        uVar26 = *_Src;
        uVar27 = *(undefined4 *)((int)_Src + 4);
        uVar28 = *(undefined4 *)((int)_Src + 8);
        do {
          iVar21 = iVar16;
          uVar7 = *(undefined4 *)(iVar21 + 0x20);
          _Size = _Size - 0x30;
          auVar2 = *(undefined (*) [32])(iVar21 + 0x10);
          uVar4 = *(undefined4 *)(iVar21 + 0x34);
          uVar5 = *(undefined4 *)(iVar21 + 0x38);
          uVar6 = *(undefined4 *)(iVar21 + 0x3c);
          auVar3 = *(undefined (*) [32])(iVar21 + 0x20);
          *(undefined4 *)((int)_Dst + 4) = uVar26;
          *(undefined4 *)((int)_Dst + 8) = uVar27;
          *(undefined4 *)((int)_Dst + 0xc) = uVar28;
          *(undefined4 *)((int)_Dst + 0x10) = uVar7;
          *(undefined (*) [16])((int)_Dst + 0x10) = SUB3216(auVar2 >> 0x20,0);
          *(undefined (*) [16])((int)_Dst + 0x20) = SUB3216(auVar3 >> 0x20,0);
          _Dst = (void *)((int)_Dst + 0x30);
          iVar16 = iVar21 + 0x30;
          uVar26 = uVar4;
          uVar27 = uVar5;
          uVar28 = uVar6;
        } while (0x2f < (int)_Size);
        puVar22 = (undefined8 *)(iVar21 + 0x34);
      }
      else {
                    // WARNING: Load size is inaccurate
        iVar16 = (int)_Src + -0xc;
        uVar26 = *_Src;
        do {
          iVar21 = iVar16;
          uVar28 = *(undefined4 *)(iVar21 + 0x20);
          uVar4 = *(undefined4 *)(iVar21 + 0x24);
          uVar5 = *(undefined4 *)(iVar21 + 0x28);
          _Size = _Size - 0x30;
          auVar2 = *(undefined (*) [32])(iVar21 + 0x10);
          uVar27 = *(undefined4 *)(iVar21 + 0x3c);
          auVar3 = *(undefined (*) [32])(iVar21 + 0x20);
          *(undefined4 *)((int)_Dst + 0xc) = uVar26;
          *(undefined4 *)((int)_Dst + 0x10) = uVar28;
          *(undefined4 *)((int)_Dst + 0x14) = uVar4;
          *(undefined4 *)((int)_Dst + 0x18) = uVar5;
          *(undefined (*) [16])((int)_Dst + 0x10) = SUB3216(auVar2 >> 0x60,0);
          *(undefined (*) [16])((int)_Dst + 0x20) = SUB3216(auVar3 >> 0x60,0);
          _Dst = (void *)((int)_Dst + 0x30);
          iVar16 = iVar21 + 0x30;
          uVar26 = uVar27;
        } while (0x2f < (int)_Size);
        puVar22 = (undefined8 *)(iVar21 + 0x3c);
      }
      for (; 0xf < (int)_Size; _Size = _Size - 0x10) {
        uVar26 = *(undefined4 *)puVar22;
        uVar27 = *(undefined4 *)((int)puVar22 + 4);
        uVar28 = *(undefined4 *)(puVar22 + 1);
        uVar4 = *(undefined4 *)((int)puVar22 + 0xc);
        puVar22 = puVar22 + 2;
        *(undefined4 *)_Dst = uVar26;
        *(undefined4 *)((int)_Dst + 4) = uVar27;
        *(undefined4 *)((int)_Dst + 8) = uVar28;
        *(undefined4 *)((int)_Dst + 0xc) = uVar4;
        _Dst = (void *)((int)_Dst + 0x10);
      }
      if ((_Size >> 2 & 1) != 0) {
        uVar26 = *(undefined4 *)puVar22;
        _Size = _Size - 4;
        puVar22 = (undefined8 *)((int)puVar22 + 4);
        *(undefined4 *)_Dst = uVar26;
        _Dst = (void *)((int)_Dst + 4);
      }
      if ((_Size >> 3 & 1) != 0) {
        _Size = _Size - 8;
        *(undefined8 *)_Dst = *puVar22;
      }
                    // WARNING: Could not recover jumptable at 0x10020729. Too many branches
                    // WARNING: Treating indirect jump as call
      pvVar18 = (void *)(*(code *)(&switchD_10020760::switchdataD_10020858)[_Size])();
      return pvVar18;
    }
  }
  uVar19 = _Size >> 2;
  if (uVar19 < 8) {
LAB_10020768:
                    // WARNING: Could not recover jumptable at 0x10020768. Too many branches
                    // WARNING: Treating indirect jump as call
    pvVar18 = (void *)(*(code *)(&PTR_LAB_100207ec)[uVar19])();
    return pvVar18;
  }
                    // WARNING: Load size is inaccurate
  for (; uVar19 != 0; uVar19 = uVar19 - 1) {
    *puVar25 = *_Src;
    _Src = (undefined4 *)((int)_Src + 4);
    puVar25 = puVar25 + 1;
  }
  switch(_Size & 3) {
  case 0:
    return _Dst;
  case 2:
switchD_10020760_caseD_2:
                    // WARNING: Load size is inaccurate
    *(undefined *)puVar25 = *_Src;
    *(undefined *)((int)puVar25 + 1) = *(undefined *)((int)_Src + 1);
    return _Dst;
  case 3:
switchD_10020760_caseD_3:
                    // WARNING: Load size is inaccurate
    *(undefined *)puVar25 = *_Src;
    *(undefined *)((int)puVar25 + 1) = *(undefined *)((int)_Src + 1);
    *(undefined *)((int)puVar25 + 2) = *(undefined *)((int)_Src + 2);
    return _Dst;
  }
switchD_10020760_caseD_1:
                    // WARNING: Load size is inaccurate
  *(undefined *)puVar25 = *_Src;
  return _Dst;
}



void __fastcall FUN_1002080c(int param_1,int param_2)

{
  int unaff_ESI;
  int unaff_EDI;
  
  *(undefined4 *)(unaff_EDI + -0x1c + param_1 * 4) =
       *(undefined4 *)(unaff_ESI + -0x1c + param_1 * 4);
  *(undefined4 *)(unaff_EDI + -0x18 + param_1 * 4) =
       *(undefined4 *)(unaff_ESI + -0x18 + param_1 * 4);
  *(undefined4 *)(unaff_EDI + -0x14 + param_1 * 4) =
       *(undefined4 *)(unaff_ESI + -0x14 + param_1 * 4);
  *(undefined4 *)(unaff_EDI + -0x10 + param_1 * 4) =
       *(undefined4 *)(unaff_ESI + -0x10 + param_1 * 4);
  *(undefined4 *)(unaff_EDI + -0xc + param_1 * 4) = *(undefined4 *)(unaff_ESI + -0xc + param_1 * 4);
  *(undefined4 *)(unaff_EDI + -8 + param_1 * 4) = *(undefined4 *)(unaff_ESI + -8 + param_1 * 4);
  *(undefined4 *)(unaff_EDI + -4 + param_1 * 4) = *(undefined4 *)(unaff_ESI + -4 + param_1 * 4);
                    // WARNING: Could not recover jumptable at 0x1002084f. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)(&switchD_10020760::switchdataD_10020858)[param_2])();
  return;
}



void __fastcall FUN_100209a8(int param_1,int param_2)

{
  int unaff_ESI;
  int unaff_EDI;
  
  *(undefined4 *)(unaff_EDI + 0x1c + param_1 * 4) = *(undefined4 *)(unaff_ESI + 0x1c + param_1 * 4);
  *(undefined4 *)(unaff_EDI + 0x18 + param_1 * 4) = *(undefined4 *)(unaff_ESI + 0x18 + param_1 * 4);
  *(undefined4 *)(unaff_EDI + 0x14 + param_1 * 4) = *(undefined4 *)(unaff_ESI + 0x14 + param_1 * 4);
  *(undefined4 *)(unaff_EDI + 0x10 + param_1 * 4) = *(undefined4 *)(unaff_ESI + 0x10 + param_1 * 4);
  *(undefined4 *)(unaff_EDI + 0xc + param_1 * 4) = *(undefined4 *)(unaff_ESI + 0xc + param_1 * 4);
  *(undefined4 *)(unaff_EDI + 8 + param_1 * 4) = *(undefined4 *)(unaff_ESI + 8 + param_1 * 4);
  *(undefined4 *)(unaff_EDI + 4 + param_1 * 4) = *(undefined4 *)(unaff_ESI + 4 + param_1 * 4);
                    // WARNING: Could not recover jumptable at 0x100209eb. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)(&switchD_100208f4::switchdataD_100209f4)[param_2])();
  return;
}



// Library Function - Single Match
//  _strncat
// 
// Library: Visual Studio

char * __cdecl _strncat(char *_Dest,char *_Source,size_t _Count)

{
  byte bVar1;
  uint uVar2;
  uint uVar3;
  uint uVar4;
  uint *puVar5;
  uint *puVar6;
  
  if (_Count != 0) {
    uVar4 = (uint)_Dest & 3;
    puVar5 = (uint *)_Dest;
    while (uVar4 != 0) {
      bVar1 = *(byte *)puVar5;
      puVar5 = (uint *)((int)puVar5 + 1);
      if (bVar1 == 0) goto LAB_10020bcd;
      uVar4 = (uint)puVar5 & 3;
    }
    do {
      do {
        puVar6 = puVar5;
        puVar5 = puVar6 + 1;
      } while (((*puVar6 ^ 0xffffffff ^ *puVar6 + 0x7efefeff) & 0x81010100) == 0);
      uVar4 = *puVar6;
      if ((char)uVar4 == '\0') goto LAB_10020bdf;
      if ((char)(uVar4 >> 8) == '\0') {
        puVar6 = (uint *)((int)puVar6 + 1);
        goto LAB_10020bdf;
      }
      if ((uVar4 & 0xff0000) == 0) {
        puVar6 = (uint *)((int)puVar6 + 2);
        goto LAB_10020bdf;
      }
    } while ((uVar4 & 0xff000000) != 0);
LAB_10020bcd:
    puVar6 = (uint *)((int)puVar5 + -1);
LAB_10020bdf:
    if (((uint)_Source & 3) == 0) {
      uVar3 = _Count >> 2;
    }
    else {
      do {
        bVar1 = *_Source;
        uVar4 = (uint)bVar1;
        _Source = (char *)((int)_Source + 1);
        if (bVar1 == 0) goto LAB_10020c3a;
        *(byte *)puVar6 = bVar1;
        puVar6 = (uint *)((int)puVar6 + 1);
        _Count = _Count - 1;
        if (_Count == 0) goto LAB_10020c30;
      } while (((uint)_Source & 3) != 0);
      uVar3 = _Count >> 2;
    }
    for (; uVar3 != 0; uVar3 = uVar3 - 1) {
      uVar2 = *(uint *)_Source;
      uVar4 = *(uint *)_Source;
      _Source = (char *)((int)_Source + 4);
      if (((uVar2 ^ 0xffffffff ^ uVar2 + 0x7efefeff) & 0x81010100) != 0) {
        if ((char)uVar4 == '\0') {
LAB_10020c3a:
          *(byte *)puVar6 = (byte)uVar4;
          return _Dest;
        }
        if ((char)(uVar4 >> 8) == '\0') {
          *(short *)puVar6 = (short)uVar4;
          return _Dest;
        }
        if ((uVar4 & 0xff0000) == 0) {
          *(short *)puVar6 = (short)uVar4;
          *(byte *)((int)puVar6 + 2) = 0;
          return _Dest;
        }
        if ((uVar4 & 0xff000000) == 0) {
          *puVar6 = uVar4;
          return _Dest;
        }
      }
      *puVar6 = uVar4;
      puVar6 = puVar6 + 1;
    }
    for (_Count = _Count & 3; _Count != 0; _Count = _Count - 1) {
      bVar1 = *_Source;
      _Source = (char *)((int)_Source + 1);
      *(byte *)puVar6 = bVar1;
      puVar6 = (uint *)((int)puVar6 + 1);
      if (bVar1 == 0) {
        return _Dest;
      }
    }
LAB_10020c30:
    *(byte *)puVar6 = (byte)_Count;
  }
  return _Dest;
}



void __cdecl FUN_10020ca5(byte *param_1,pthreadlocinfo *param_2)

{
  ushort uVar1;
  int *piVar2;
  undefined2 extraout_var;
  uint uVar3;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar4;
  undefined uVar5;
  pthreadlocinfo in_stack_ffffffd0;
  int local_28;
  char local_24;
  uint local_20 [6];
  uint local_8;
  pthreadlocinfo ptVar6;
  
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  FUN_1001f92e(&stack0xffffffd0,param_2);
  ptVar6 = in_stack_ffffffd0;
  if (param_1 == (byte *)0x0) {
    piVar2 = __errno();
    uVar5 = SUB41(in_stack_ffffffd0,0);
    *piVar2 = 0x16;
    FUN_10025625();
    uVar4 = extraout_DL;
  }
  else {
    while( true ) {
      if (in_stack_ffffffd0->mb_cur_max < 2) {
        uVar3 = in_stack_ffffffd0->pctype[*param_1] & 8;
      }
      else {
        in_stack_ffffffd0 = ptVar6;
        uVar1 = FUN_10027a53((uint)*param_1,8,(pthreadlocinfo *)&stack0xffffffd0);
        uVar3 = CONCAT22(extraout_var,uVar1);
        ptVar6 = in_stack_ffffffd0;
      }
      if (uVar3 == 0) break;
      param_1 = param_1 + 1;
    }
    FUN_10027204(local_20,(char *)param_1,(int *)&stack0xffffffd0);
    uVar5 = SUB41(ptVar6,0);
    uVar4 = extraout_DL_00;
  }
  if (local_24 != '\0') {
    *(uint *)(local_28 + 0x70) = *(uint *)(local_28 + 0x70) & 0xfffffffd;
  }
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,uVar4,uVar5);
  return;
}



void __cdecl FUN_10020d43(byte *param_1)

{
  FUN_10020ca5(param_1,(pthreadlocinfo *)0x0);
  return;
}



void FUN_10020d54(char *param_1)

{
  _atol(param_1);
  return;
}



// Library Function - Single Match
//  _atol
// 
// Library: Visual Studio 2012 Release

long __cdecl _atol(char *_Str)

{
  long lVar1;
  
  lVar1 = FUN_10027d2a((byte *)_Str,(byte **)0x0,10);
  return lVar1;
}



// Library Function - Single Match
//  __fclose_nolock
// 
// Library: Visual Studio 2012 Release

int __cdecl __fclose_nolock(FILE *_File)

{
  int *piVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  
  iVar4 = -1;
  if (_File == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    iVar4 = -1;
  }
  else {
    if ((*(byte *)&_File->_flag & 0x83) != 0) {
      iVar4 = FUN_10027f63(_File);
      __freebuf(_File);
      uVar2 = __fileno(_File);
      iVar3 = FUN_10027d78(uVar2);
      if (iVar3 < 0) {
        iVar4 = -1;
      }
      else if (_File->_tmpfname != (char *)0x0) {
        FID_conflict__free(_File->_tmpfname);
        _File->_tmpfname = (char *)0x0;
      }
    }
    _File->_flag = 0;
  }
  return iVar4;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _fclose
// 
// Library: Visual Studio 2012 Release

int __cdecl _fclose(FILE *_File)

{
  int *piVar1;
  int iVar2;
  
  iVar2 = -1;
  if (_File == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
  }
  else if ((*(byte *)&_File->_flag & 0x40) == 0) {
    __lock_file(_File);
    iVar2 = __fclose_nolock(_File);
    FUN_10020e4c();
  }
  else {
    _File->_flag = 0;
  }
  return iVar2;
}



void FUN_10020e4c(void)

{
  FILE *unaff_ESI;
  
  __unlock_file(unaff_ESI);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

uint __cdecl FUN_10020e54(FILE *param_1)

{
  int *piVar1;
  uint uVar2;
  undefined *puVar3;
  uint uVar4;
  
  uVar4 = 0;
  if (param_1 == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    return 0xffffffff;
  }
  __lock_file(param_1);
  if ((*(byte *)&param_1->_flag & 0x40) == 0) {
    uVar2 = __fileno(param_1);
    if ((uVar2 == 0xffffffff) || (uVar2 == 0xfffffffe)) {
      puVar3 = &DAT_100473a0;
    }
    else {
      puVar3 = (undefined *)((uVar2 & 0x1f) * 0x40 + (&DAT_10835b98)[(int)uVar2 >> 5]);
    }
    if ((puVar3[0x24] & 0x7f) == 0) {
      if ((uVar2 == 0xffffffff) || (uVar2 == 0xfffffffe)) {
        puVar3 = &DAT_100473a0;
      }
      else {
        puVar3 = (undefined *)((uVar2 & 0x1f) * 0x40 + (&DAT_10835b98)[(int)uVar2 >> 5]);
      }
      if ((puVar3[0x24] & 0x80) == 0) goto LAB_10020f0c;
    }
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    uVar4 = 0xffffffff;
  }
LAB_10020f0c:
  if (uVar4 == 0) {
    piVar1 = &param_1->_cnt;
    *piVar1 = *piVar1 + -1;
    if (*piVar1 < 0) {
      uVar4 = FUN_100280b4(param_1);
    }
    else {
      uVar4 = (uint)(byte)*param_1->_ptr;
      param_1->_ptr = param_1->_ptr + 1;
    }
  }
  FUN_10020f45();
  return uVar4;
}



void FUN_10020f45(void)

{
  FILE *unaff_ESI;
  
  __unlock_file(unaff_ESI);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __fsopen
// 
// Library: Visual Studio 2012 Release

FILE * __cdecl __fsopen(char *_Filename,char *_Mode,int _ShFlag)

{
  int *piVar1;
  undefined4 *puVar2;
  FILE *pFVar3;
  undefined local_14 [8];
  undefined4 uStack12;
  undefined *local_8;
  
  local_8 = &DAT_1003fb48;
  uStack12 = 0x10020f59;
  if (((_Filename == (char *)0x0) || (_Mode == (char *)0x0)) || (*_Mode == '\0')) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
  }
  else {
    puVar2 = FUN_100284db();
    if (puVar2 == (undefined4 *)0x0) {
      piVar1 = __errno();
      *piVar1 = 0x18;
    }
    else {
      local_8 = (undefined *)0x0;
      if (*_Filename != '\0') {
        pFVar3 = (FILE *)FUN_100285fa(_Filename,(WCHAR *)_Mode,_ShFlag,puVar2);
        local_8 = (undefined *)0xfffffffe;
        FUN_10021009();
        return pFVar3;
      }
      piVar1 = __errno();
      *piVar1 = 0x16;
      __local_unwind4(&DAT_10046c24,(int)local_14,0xfffffffe);
    }
  }
  return (FILE *)0x0;
}



void FUN_10021009(void)

{
  FILE *unaff_ESI;
  
  __unlock_file(unaff_ESI);
  return;
}



// Library Function - Single Match
//  _fopen
// 
// Library: Visual Studio 2012 Release

FILE * __cdecl _fopen(char *_Filename,char *_Mode)

{
  FILE *pFVar1;
  
  pFVar1 = __fsopen(_Filename,_Mode,0x40);
  return pFVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

bool FUN_10021026(void)

{
  return _DAT_10835aec == (DAT_10046c24 | 1);
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

undefined4 __cdecl FUN_1002103b(byte *param_1)

{
  int *piVar1;
  undefined4 uVar2;
  undefined **ppuVar3;
  int _Flag;
  pthreadlocinfo *pptVar4;
  int **ppiVar5;
  
  if (param_1 == (byte *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    uVar2 = 0xffffffff;
  }
  else {
    ppuVar3 = FUN_100245a8();
    __lock_file2(1,ppuVar3 + 8);
    ppuVar3 = FUN_100245a8();
    _Flag = FUN_10028a03((FILE *)(ppuVar3 + 8));
    ppiVar5 = (int **)&stack0x00000008;
    pptVar4 = (pthreadlocinfo *)0x0;
    ppuVar3 = FUN_100245a8();
    uVar2 = FUN_10028aa9((FILE *)(ppuVar3 + 8),param_1,pptVar4,ppiVar5);
    ppuVar3 = FUN_100245a8();
    __ftbuf(_Flag,(FILE *)(ppuVar3 + 8));
    FUN_100210d7();
  }
  return uVar2;
}



void FUN_100210d7(void)

{
  undefined **ppuVar1;
  
  ppuVar1 = FUN_100245a8();
  __unlock_file2(1,ppuVar1 + 8);
  return;
}



uint __cdecl FUN_100210ea(uint param_1,pthreadlocinfo *param_2)

{
  ushort uVar1;
  undefined2 extraout_var;
  uint uVar2;
  undefined2 extraout_var_00;
  int *piVar3;
  int iVar4;
  pthreadlocinfo local_1c [2];
  int local_14;
  char local_10;
  byte local_c;
  undefined local_b;
  CHAR local_8;
  CHAR local_7;
  undefined local_6;
  
  FUN_1001f92e(local_1c,param_2);
  if (param_1 < 0x100) {
    if (local_1c[0]->mb_cur_max < 2) {
      uVar2 = local_1c[0]->pctype[param_1] & 1;
    }
    else {
      uVar1 = FUN_10027a53(param_1,1,local_1c);
      uVar2 = CONCAT22(extraout_var,uVar1);
    }
    if (uVar2 == 0) {
      if (local_10 != '\0') {
        *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
      }
    }
    else {
      param_1 = (uint)local_1c[0]->pclmap[param_1];
      if (local_10 != '\0') {
        *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
      }
    }
  }
  else {
    if ((local_1c[0]->mb_cur_max < 2) ||
       (uVar1 = FUN_10029715((int)param_1 >> 8 & 0xff,local_1c),
       CONCAT22(extraout_var_00,uVar1) == 0)) {
      piVar3 = __errno();
      iVar4 = 1;
      *piVar3 = 0x2a;
      local_7 = '\0';
      local_8 = (CHAR)param_1;
    }
    else {
      local_6 = 0;
      iVar4 = 2;
      local_8 = (CHAR)(param_1 >> 8);
      local_7 = (CHAR)param_1;
    }
    iVar4 = FUN_1002637c(local_1c,local_1c[0]->locale_name[2],0x100,&local_8,iVar4,(LPWSTR)&local_c,
                         3,local_1c[0]->lc_codepage,1);
    if (iVar4 == 0) {
      if (local_10 != '\0') {
        *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
      }
    }
    else if (iVar4 == 1) {
      param_1 = (uint)local_c;
      if (local_10 != '\0') {
        *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
      }
    }
    else {
      param_1 = (uint)CONCAT11(local_c,local_b);
      if (local_10 != '\0') {
        *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
      }
    }
  }
  return param_1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _tolower
// 
// Library: Visual Studio 2012 Release

int __cdecl _tolower(int _C)

{
  uint uVar1;
  
  if (_DAT_10835ca0 == 0) {
    if (_C - 0x41U < 0x1a) {
      _C = _C + 0x20;
    }
    return _C;
  }
  uVar1 = FUN_100210ea(_C,(pthreadlocinfo *)0x0);
  return uVar1;
}



// WARNING: This is an inlined function
// Library Function - Single Match
//  __chkstk
// 
// Library: Visual Studio

void __alloca_probe(void)

{
  undefined *in_EAX;
  undefined4 *puVar1;
  undefined4 *puVar2;
  undefined4 unaff_retaddr;
  undefined auStack4 [4];
  
  puVar2 = (undefined4 *)((int)&stack0x00000000 - (int)in_EAX & ~-(uint)(&stack0x00000000 < in_EAX))
  ;
  for (puVar1 = (undefined4 *)((uint)auStack4 & 0xfffff000); puVar2 < puVar1;
      puVar1 = puVar1 + -0x400) {
  }
  *puVar2 = unaff_retaddr;
  return;
}



uint * __cdecl FUN_10021290(uint *param_1,byte param_2,uint param_3)

{
  uint uVar1;
  uint uVar2;
  uint uVar3;
  uint *puVar4;
  
  if (param_3 == 0) {
    return param_1;
  }
  uVar1 = (uint)param_2;
  puVar4 = param_1;
  if ((DAT_10835b50 >> 1 & 1) == 0) {
    if ((0x7f < (int)param_3) && ((DAT_10047390 >> 1 & 1) != 0)) {
      if (uVar1 == 0) {
        uVar1 = 0;
      }
      else {
        uVar1 = SUB164(CONCAT142(ZEXT214(0) & SUB1614((undefined  [16])0xffffffffff000000 >> 0x10,0)
                                 & SUB1614((undefined  [16])0xffffffffff00ffff >> 0x10,0),
                                 CONCAT11(param_2,param_2)),0);
        uVar1 = uVar1 | uVar1 << 0x10;
      }
      if (((uint)param_1 & 0xf) != 0) {
        uVar2 = 0x10 - ((uint)param_1 & 0xf);
        param_3 = param_3 - uVar2;
        for (uVar3 = uVar2 & 3; uVar3 != 0; uVar3 = uVar3 - 1) {
          *(byte *)puVar4 = param_2;
          puVar4 = (uint *)((int)puVar4 + 1);
        }
        for (uVar2 = uVar2 >> 2; uVar2 != 0; uVar2 = uVar2 - 1) {
          *puVar4 = uVar1;
          puVar4 = puVar4 + 1;
        }
      }
      for (uVar3 = param_3 >> 7; uVar3 != 0; uVar3 = uVar3 - 1) {
        *puVar4 = uVar1;
        puVar4[1] = uVar1;
        puVar4[2] = uVar1;
        puVar4[3] = uVar1;
        puVar4[4] = uVar1;
        puVar4[5] = uVar1;
        puVar4[6] = uVar1;
        puVar4[7] = uVar1;
        puVar4[8] = uVar1;
        puVar4[9] = uVar1;
        puVar4[10] = uVar1;
        puVar4[0xb] = uVar1;
        puVar4[0xc] = uVar1;
        puVar4[0xd] = uVar1;
        puVar4[0xe] = uVar1;
        puVar4[0xf] = uVar1;
        puVar4[0x10] = uVar1;
        puVar4[0x11] = uVar1;
        puVar4[0x12] = uVar1;
        puVar4[0x13] = uVar1;
        puVar4[0x14] = uVar1;
        puVar4[0x15] = uVar1;
        puVar4[0x16] = uVar1;
        puVar4[0x17] = uVar1;
        puVar4[0x18] = uVar1;
        puVar4[0x19] = uVar1;
        puVar4[0x1a] = uVar1;
        puVar4[0x1b] = uVar1;
        puVar4[0x1c] = uVar1;
        puVar4[0x1d] = uVar1;
        puVar4[0x1e] = uVar1;
        puVar4[0x1f] = uVar1;
        puVar4 = puVar4 + 0x20;
      }
      if ((param_3 & 0x7f) != 0) {
        for (uVar3 = (param_3 & 0x7f) >> 4; uVar3 != 0; uVar3 = uVar3 - 1) {
          *puVar4 = uVar1;
          puVar4[1] = uVar1;
          puVar4[2] = uVar1;
          puVar4[3] = uVar1;
          puVar4 = puVar4 + 4;
        }
        if ((param_3 & 0xf) != 0) {
          for (uVar3 = (param_3 & 0xf) >> 2; uVar3 != 0; uVar3 = uVar3 - 1) {
            *puVar4 = uVar1;
            puVar4 = puVar4 + 1;
          }
          for (uVar1 = param_3 & 3; uVar1 != 0; uVar1 = uVar1 - 1) {
            *(byte *)puVar4 = param_2;
            puVar4 = (uint *)((int)puVar4 + 1);
          }
        }
      }
      return param_1;
    }
    if (3 < param_3) {
      uVar2 = -(int)param_1 & 3;
      uVar3 = param_3;
      if (uVar2 != 0) {
        uVar3 = param_3 - uVar2;
        do {
          *(byte *)puVar4 = param_2;
          puVar4 = (uint *)((int)puVar4 + 1);
          uVar2 = uVar2 - 1;
        } while (uVar2 != 0);
      }
      uVar1 = uVar1 * 0x1010101;
      param_3 = uVar3 & 3;
      uVar3 = uVar3 >> 2;
      if (uVar3 != 0) {
        for (; uVar3 != 0; uVar3 = uVar3 - 1) {
          *puVar4 = uVar1;
          puVar4 = puVar4 + 1;
        }
        if (param_3 == 0) {
          return param_1;
        }
      }
    }
    do {
      *(char *)puVar4 = (char)uVar1;
      puVar4 = (uint *)((int)puVar4 + 1);
      param_3 = param_3 - 1;
    } while (param_3 != 0);
  }
  else {
    for (; param_3 != 0; param_3 = param_3 - 1) {
      *(byte *)puVar4 = param_2;
      puVar4 = (uint *)((int)puVar4 + 1);
    }
  }
  return param_1;
}



// Library Function - Single Match
//  __fpmath
// 
// Library: Visual Studio 2012 Release

void __cdecl __fpmath(int param_1)

{
  FUN_10021337();
  if (param_1 != 0) {
    __setdefaultprecision();
  }
  return;
}



void FUN_10021337(void)

{
  PTR_FUN_100473ec = __cfltcvt;
  PTR_FUN_100473f0 = FUN_1002a166;
  PTR_FUN_100473f4 = FUN_1002a1f7;
  PTR_FUN_100473f8 = FUN_1002a251;
  PTR_FUN_100473fc = __positive;
  PTR_FUN_10047400 = __cfltcvt;
  PTR_FUN_10047404 = __cfltcvt_l;
  PTR_FUN_10047408 = FUN_1002a20f;
  PTR_FUN_1004740c = FUN_1002a177;
  PTR_FUN_10047410 = FUN_1002a262;
  return;
}



undefined4 __cdecl FUN_100213a8(int param_1,uint *param_2,undefined4 param_3)

{
  code *pcVar1;
  int iVar2;
  int extraout_ECX;
  uint *puVar3;
  uint uVar4;
  uint uVar5;
  undefined *puVar6;
  int local_c;
  undefined4 local_8;
  
  puVar6 = &stack0xfffffffc;
  puVar3 = (uint *)&stack0xfffffffc;
  if ((*(uint *)(param_1 + 4) & 6) == 0) {
    local_c = param_1;
    local_8 = param_3;
    param_2[-1] = (uint)&local_c;
    uVar4 = param_2[3];
    uVar5 = param_2[2];
    iVar2 = __ValidateEH3RN(param_2);
    if (iVar2 < 1) {
      *(uint *)(param_1 + 4) = *(uint *)(param_1 + 4) | 8;
    }
    else {
      for (; uVar4 != 0xffffffff; uVar4 = *(uint *)(uVar5 + uVar4 * 0xc)) {
        pcVar1 = *(code **)(uVar5 + 4 + uVar4 * 0xc);
        if (pcVar1 != (code *)0x0) {
          iVar2 = (*pcVar1)(puVar3,uVar4,puVar6);
          param_2 = (uint *)puVar3[3];
          if (iVar2 != 0) {
            if (iVar2 < 0) {
              return 0;
            }
            _CallDestructExceptionObject((int *)puVar3[2]);
            uVar5 = param_2[2];
            __global_unwind2(param_2);
            puVar3 = param_2 + 4;
            __local_unwind2((int)param_2,uVar4);
            __NLG_Notify(1);
            param_2[3] = *(uint *)(uVar5 + extraout_ECX * 4);
            param_2 = (uint *)0x0;
            uVar4 = 0;
            (**(code **)(uVar5 + 8 + extraout_ECX * 4))();
          }
        }
        uVar5 = param_2[2];
      }
    }
  }
  else {
    __local_unwind2((int)param_2,0xffffffff);
  }
  return 1;
}



void FUN_100214a6(int param_1)

{
  __local_unwind2(*(int *)(param_1 + 0x18),*(uint *)(param_1 + 0x1c));
  return;
}



void FUN_100214a7(undefined4 param_1,int param_2)

{
  __local_unwind2(*(int *)(param_2 + 0x18),*(uint *)(param_2 + 0x1c));
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  __free_base
//  _free
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
// Visual Studio 2019 Release

void __cdecl FID_conflict__free(void *_Memory)

{
  BOOL BVar1;
  int *piVar2;
  DWORD DVar3;
  int iVar4;
  
  if (_Memory != (void *)0x0) {
    BVar1 = HeapFree(DAT_10835d30,0,_Memory);
    if (BVar1 == 0) {
      piVar2 = __errno();
      DVar3 = GetLastError();
      iVar4 = __get_errno_from_oserr(DVar3);
      *piVar2 = iVar4;
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _malloc
// 
// Library: Visual Studio 2012 Release

void * __cdecl _malloc(size_t _Size)

{
  void *pvVar1;
  int iVar2;
  int *piVar3;
  SIZE_T dwBytes;
  
  if (_Size < 0xffffffe1) {
    do {
      if (DAT_10835d30 == (HANDLE)0x0) {
        __FF_MSGBANNER();
        FUN_1002aa44(0x1e);
        ___crtExitProcess(0xff);
      }
      dwBytes = _Size;
      if (_Size == 0) {
        dwBytes = 1;
      }
      pvVar1 = HeapAlloc(DAT_10835d30,0,dwBytes);
      if (pvVar1 != (LPVOID)0x0) {
        return pvVar1;
      }
      if (_DAT_10836368 == 0) {
        piVar3 = __errno();
        *piVar3 = 0xc;
        break;
      }
      iVar2 = __callnewh(_Size);
    } while (iVar2 != 0);
    piVar3 = __errno();
    *piVar3 = 0xc;
  }
  else {
    __callnewh(_Size);
    piVar3 = __errno();
    *piVar3 = 0xc;
    pvVar1 = (void *)0x0;
  }
  return pvVar1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

int __cdecl FUN_1002158b(FILE *param_1,byte *param_2)

{
  int *piVar1;
  uint uVar2;
  undefined *puVar3;
  int _Flag;
  int iVar4;
  
  iVar4 = 0;
  if ((param_1 == (FILE *)0x0) || (param_2 == (byte *)0x0)) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    return -1;
  }
  __lock_file(param_1);
  if ((*(byte *)&param_1->_flag & 0x40) == 0) {
    uVar2 = __fileno(param_1);
    if ((uVar2 == 0xffffffff) || (uVar2 == 0xfffffffe)) {
      puVar3 = &DAT_100473a0;
    }
    else {
      puVar3 = (undefined *)((uVar2 & 0x1f) * 0x40 + (&DAT_10835b98)[(int)uVar2 >> 5]);
    }
    if ((puVar3[0x24] & 0x7f) == 0) {
      if ((uVar2 == 0xffffffff) || (uVar2 == 0xfffffffe)) {
        puVar3 = &DAT_100473a0;
      }
      else {
        puVar3 = (undefined *)((uVar2 & 0x1f) * 0x40 + (&DAT_10835b98)[(int)uVar2 >> 5]);
      }
      if ((puVar3[0x24] & 0x80) == 0) goto LAB_10021652;
    }
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    iVar4 = -1;
  }
LAB_10021652:
  if (iVar4 == 0) {
    _Flag = FUN_10028a03(param_1);
    iVar4 = FUN_10028aa9(param_1,param_2,(pthreadlocinfo *)0x0,(int **)&stack0x0000000c);
    __ftbuf(_Flag,param_1);
  }
  FUN_10021695();
  return iVar4;
}



void FUN_10021695(void)

{
  FILE *unaff_EDI;
  
  __unlock_file(unaff_EDI);
  return;
}



undefined4 __cdecl FUN_1002169d(char *param_1,uint param_2,byte *param_3)

{
  int *piVar1;
  undefined4 uVar2;
  int iVar3;
  char **ppcVar4;
  FILE local_24;
  
  local_24._ptr = (char *)0x0;
  ppcVar4 = (char **)&local_24._cnt;
  for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {
    *ppcVar4 = (char *)0x0;
    ppcVar4 = ppcVar4 + 1;
  }
  if (param_3 == (byte *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    uVar2 = 0xffffffff;
  }
  else if ((param_2 == 0) || (param_1 != (char *)0x0)) {
    local_24._cnt = 0x7fffffff;
    if (param_2 < 0x80000000) {
      local_24._cnt = param_2;
    }
    local_24._flag = 0x42;
    local_24._base = param_1;
    local_24._ptr = param_1;
    uVar2 = FUN_10028aa9(&local_24,param_3,(pthreadlocinfo *)0x0,(int **)&stack0x00000010);
    if (param_1 != (char *)0x0) {
      local_24._cnt = local_24._cnt - 1;
      if (local_24._cnt < 0) {
        FUN_1002ac01(0,&local_24);
      }
      else {
        *local_24._ptr = '\0';
      }
    }
  }
  else {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    uVar2 = 0xffffffff;
  }
  return uVar2;
}



void __cdecl FUN_10021749(char *param_1,uint param_2,byte *param_3,int **param_4)

{
  FUN_10021764(param_1,param_2,param_3,(pthreadlocinfo *)0x0,param_4);
  return;
}



undefined4 __cdecl
FUN_10021764(char *param_1,uint param_2,byte *param_3,pthreadlocinfo *param_4,int **param_5)

{
  int *piVar1;
  undefined4 uVar2;
  int iVar3;
  char **ppcVar4;
  FILE local_24;
  
  local_24._ptr = (char *)0x0;
  ppcVar4 = (char **)&local_24._cnt;
  for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {
    *ppcVar4 = (char *)0x0;
    ppcVar4 = ppcVar4 + 1;
  }
  if (param_3 == (byte *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    uVar2 = 0xffffffff;
  }
  else if ((param_2 == 0) || (param_1 != (char *)0x0)) {
    local_24._cnt = 0x7fffffff;
    if (param_2 < 0x80000000) {
      local_24._cnt = param_2;
    }
    local_24._flag = 0x42;
    local_24._base = param_1;
    local_24._ptr = param_1;
    uVar2 = FUN_10028aa9(&local_24,param_3,param_4,param_5);
    if (param_1 != (char *)0x0) {
      local_24._cnt = local_24._cnt - 1;
      if (local_24._cnt < 0) {
        FUN_1002ac01(0,&local_24);
      }
      else {
        *local_24._ptr = '\0';
      }
    }
  }
  else {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    uVar2 = 0xffffffff;
  }
  return uVar2;
}



// WARNING: This is an inlined function
// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// Library Function - Single Match
//  __alloca_probe_16
// 
// Library: Visual Studio

uint __alloca_probe_16(undefined1 param_1)

{
  uint in_EAX;
  uint uVar1;
  
  uVar1 = 4 - in_EAX & 0xf;
  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);
}



// WARNING: This is an inlined function
// WARNING: Function: __alloca_probe replaced with injection: alloca_probe
// Library Function - Single Match
//  __alloca_probe_8
// 
// Library: Visual Studio

uint __alloca_probe_8(undefined1 param_1)

{
  uint in_EAX;
  uint uVar1;
  
  uVar1 = 4 - in_EAX & 7;
  return in_EAX + uVar1 | -(uint)CARRY4(in_EAX,uVar1);
}



int __cdecl
FUN_1002183c(undefined *param_1,char *param_2,uint param_3,int param_4,undefined4 param_5,
            undefined4 param_6)

{
  int *piVar1;
  uint uVar2;
  int iVar3;
  char **ppcVar4;
  FILE local_24;
  
  local_24._ptr = (char *)0x0;
  ppcVar4 = (char **)&local_24._cnt;
  for (iVar3 = 7; iVar3 != 0; iVar3 = iVar3 + -1) {
    *ppcVar4 = (char *)0x0;
    ppcVar4 = ppcVar4 + 1;
  }
  if (param_4 == 0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    iVar3 = -1;
  }
  else if ((param_3 == 0) || (param_2 != (char *)0x0)) {
    local_24._cnt = 0x7fffffff;
    if (param_3 < 0x80000000) {
      local_24._cnt = param_3;
    }
    local_24._flag = 0x42;
    local_24._base = param_2;
    local_24._ptr = param_2;
    iVar3 = (*(code *)param_1)(&local_24,param_4,param_5,param_6);
    if (param_2 != (char *)0x0) {
      if (-1 < iVar3) {
        local_24._cnt = local_24._cnt - 1;
        if (-1 < local_24._cnt) {
          *local_24._ptr = '\0';
          return iVar3;
        }
        uVar2 = FUN_1002ac01(0,&local_24);
        if (uVar2 != 0xffffffff) {
          return iVar3;
        }
      }
      param_2[param_3 - 1] = '\0';
      iVar3 = (-1 < local_24._cnt) - 2;
    }
  }
  else {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    iVar3 = -1;
  }
  return iVar3;
}



// Library Function - Single Match
//  __vsprintf_s_l
// 
// Library: Visual Studio 2012 Release

int __cdecl
__vsprintf_s_l(char *_DstBuf,size_t _DstSize,char *_Format,_locale_t _Locale,va_list _ArgList)

{
  int *piVar1;
  int iVar2;
  
  if (_Format == (char *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    return -1;
  }
  if ((_DstBuf == (char *)0x0) || (_DstSize == 0)) {
    piVar1 = __errno();
    *piVar1 = 0x16;
  }
  else {
    iVar2 = FUN_1002183c(FUN_1002ad50,_DstBuf,_DstSize,(int)_Format,_Locale,_ArgList);
    if (iVar2 < 0) {
      *_DstBuf = '\0';
    }
    if (iVar2 != -2) {
      return iVar2;
    }
    piVar1 = __errno();
    *piVar1 = 0x22;
  }
  FUN_10025625();
  return -1;
}



// Library Function - Single Match
//  _vsprintf_s
// 
// Library: Visual Studio 2012 Release

int __cdecl _vsprintf_s(char *_DstBuf,size_t _SizeInBytes,char *_Format,va_list _ArgList)

{
  int iVar1;
  
  iVar1 = __vsprintf_s_l(_DstBuf,_SizeInBytes,_Format,(_locale_t)0x0,_ArgList);
  return iVar1;
}



// Library Function - Single Match
//  _strncpy
// 
// Library: Visual Studio

char * __cdecl _strncpy(char *_Dest,char *_Source,size_t _Count)

{
  uint uVar1;
  uint uVar2;
  char cVar3;
  uint uVar4;
  uint *puVar5;
  
  if (_Count == 0) {
    return _Dest;
  }
  puVar5 = (uint *)_Dest;
  if (((uint)_Source & 3) != 0) {
    while( true ) {
      cVar3 = *_Source;
      _Source = (char *)((int)_Source + 1);
      *(char *)puVar5 = cVar3;
      puVar5 = (uint *)((int)puVar5 + 1);
      _Count = _Count - 1;
      if (_Count == 0) {
        return _Dest;
      }
      if (cVar3 == '\0') break;
      if (((uint)_Source & 3) == 0) {
        uVar4 = _Count >> 2;
        goto joined_r0x100219ec;
      }
    }
    do {
      if (((uint)puVar5 & 3) == 0) {
        uVar4 = _Count >> 2;
        if (uVar4 == 0) goto LAB_10021a33;
        goto LAB_10021aa9;
      }
      *(undefined *)puVar5 = 0;
      puVar5 = (uint *)((int)puVar5 + 1);
      _Count = _Count - 1;
    } while (_Count != 0);
    return _Dest;
  }
  uVar4 = _Count >> 2;
  if (uVar4 != 0) {
    do {
      uVar1 = *(uint *)_Source;
      uVar2 = *(uint *)_Source;
      _Source = (char *)((int)_Source + 4);
      if (((uVar1 ^ 0xffffffff ^ uVar1 + 0x7efefeff) & 0x81010100) != 0) {
        if ((char)uVar2 == '\0') {
          *puVar5 = 0;
joined_r0x10021aa5:
          while( true ) {
            uVar4 = uVar4 - 1;
            puVar5 = puVar5 + 1;
            if (uVar4 == 0) break;
LAB_10021aa9:
            *puVar5 = 0;
          }
          cVar3 = '\0';
          _Count = _Count & 3;
          if (_Count != 0) goto LAB_10021a33;
          return _Dest;
        }
        if ((char)(uVar2 >> 8) == '\0') {
          *puVar5 = uVar2 & 0xff;
          goto joined_r0x10021aa5;
        }
        if ((uVar2 & 0xff0000) == 0) {
          *puVar5 = uVar2 & 0xffff;
          goto joined_r0x10021aa5;
        }
        if ((uVar2 & 0xff000000) == 0) {
          *puVar5 = uVar2;
          goto joined_r0x10021aa5;
        }
      }
      *puVar5 = uVar2;
      puVar5 = puVar5 + 1;
      uVar4 = uVar4 - 1;
joined_r0x100219ec:
    } while (uVar4 != 0);
    _Count = _Count & 3;
    if (_Count == 0) {
      return _Dest;
    }
  }
  do {
    cVar3 = *_Source;
    _Source = (char *)((int)_Source + 1);
    *(char *)puVar5 = cVar3;
    puVar5 = (uint *)((int)puVar5 + 1);
    if (cVar3 == '\0') {
      while (_Count = _Count - 1, _Count != 0) {
LAB_10021a33:
        *(char *)puVar5 = cVar3;
        puVar5 = (uint *)((int)puVar5 + 1);
      }
      return _Dest;
    }
    _Count = _Count - 1;
  } while (_Count != 0);
  return _Dest;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined (*) [16] __fastcall
FUN_10021ad0(undefined4 param_1,undefined4 param_2,undefined (*param_3) [16],
            undefined (*param_4) [16])

{
  undefined4 uVar1;
  ushort uVar2;
  undefined *puVar3;
  undefined *puVar4;
  char cVar5;
  undefined (*pauVar6) [16];
  undefined (*pauVar7) [16];
  uint uVar8;
  char *pcVar9;
  int iVar10;
  undefined (*pauVar11) [16];
  uint uVar12;
  uint uVar13;
  undefined (*pauVar14) [16];
  undefined in_XMM0 [16];
  undefined auVar15 [16];
  byte bVar16;
  char cVar17;
  char cVar19;
  char cVar20;
  char cVar21;
  char cVar22;
  char cVar23;
  char cVar24;
  undefined auVar18 [16];
  
  if (_DAT_10835b4c == 0) {
    cVar17 = (*param_4)[0];
    if (cVar17 == '\0') {
      return param_3;
    }
    if ((*param_4)[1] == '\0') {
      uVar13 = (uint)param_3 & 3;
      while (uVar13 != 0) {
        if ((*param_3)[0] == cVar17) {
          return param_3;
        }
        if ((*param_3)[0] == '\0') {
          return (undefined (*) [16])0x0;
        }
        uVar13 = (uint)(undefined (*) [16])(*param_3 + 1) & 3;
        param_3 = (undefined (*) [16])(*param_3 + 1);
      }
      while( true ) {
        while( true ) {
          uVar13 = *(uint *)*param_3;
          uVar12 = uVar13 ^ CONCAT22(CONCAT11(cVar17,cVar17),CONCAT11(cVar17,cVar17));
          uVar8 = uVar13 ^ 0xffffffff ^ uVar13 + 0x7efefeff;
          pauVar6 = (undefined (*) [16])(*param_3 + 4);
          if (((uVar12 ^ 0xffffffff ^ uVar12 + 0x7efefeff) & 0x81010100) != 0) break;
          param_3 = pauVar6;
          if ((uVar8 & 0x81010100) != 0) {
            if ((uVar8 & 0x1010100) != 0) {
              return (undefined (*) [16])0x0;
            }
            if ((uVar13 + 0x7efefeff & 0x80000000) == 0) {
              return (undefined (*) [16])0x0;
            }
          }
        }
        uVar1 = *(undefined4 *)*param_3;
        if ((char)uVar1 == cVar17) {
          return param_3;
        }
        if ((char)uVar1 == '\0') {
          return (undefined (*) [16])0x0;
        }
        cVar5 = (char)((uint)uVar1 >> 8);
        if (cVar5 == cVar17) {
          return (undefined (*) [16])(*param_3 + 1);
        }
        if (cVar5 == '\0') break;
        cVar5 = (char)((uint)uVar1 >> 0x10);
        if (cVar5 == cVar17) {
          return (undefined (*) [16])(*param_3 + 2);
        }
        if (cVar5 == '\0') {
          return (undefined (*) [16])0x0;
        }
        cVar5 = (char)((uint)uVar1 >> 0x18);
        if (cVar5 == cVar17) {
          return (undefined (*) [16])(*param_3 + 3);
        }
        param_3 = pauVar6;
        if (cVar5 == '\0') {
          return (undefined (*) [16])0x0;
        }
      }
      return (undefined (*) [16])0x0;
    }
    do {
      cVar5 = (*param_3)[0];
      pauVar6 = (undefined (*) [16])(*param_3 + 1);
      do {
        while (param_3 = pauVar6, cVar5 != cVar17) {
          if (cVar5 == '\0') {
            return (undefined (*) [16])0x0;
          }
          pauVar6 = (undefined (*) [16])(*param_3 + 1);
          cVar5 = (*param_3)[0];
        }
        cVar5 = (*param_3)[0];
        pauVar6 = (undefined (*) [16])(*param_3 + 1);
        pauVar11 = param_4;
      } while (cVar5 != (*param_4)[1]);
      do {
        if ((*pauVar11)[2] == '\0') {
LAB_10021d26:
          return (undefined (*) [16])(param_3[-1] + 0xf);
        }
        if ((*pauVar6)[0] != (*pauVar11)[2]) break;
        puVar3 = *pauVar11;
        if (puVar3[3] == '\0') goto LAB_10021d26;
        puVar4 = *pauVar6;
        pauVar11 = (undefined (*) [16])(*pauVar11 + 2);
        pauVar6 = (undefined (*) [16])(*pauVar6 + 2);
      } while (puVar3[3] == puVar4[1]);
    } while( true );
  }
  if (_DAT_10835b4c < 2) {
    uVar13 = (uint)CONCAT11((*param_4)[0],(*param_4)[0]);
    if (uVar13 != 0) {
      auVar18 = pshuflw(ZEXT416(uVar13),ZEXT416(uVar13),0);
      uVar13 = 0xffffffff;
      pauVar6 = param_4;
      do {
        pauVar11 = pauVar6;
        pauVar6 = (undefined (*) [16])(*pauVar11 + 1);
        if ((*pauVar11)[0] == '\0') goto LAB_10021b3e;
      } while (((uint)pauVar6 & 0xf) != 0);
      bVar16 = -(pauVar11[1][0] == '\0');
      auVar15 = CONCAT115(bVar16,CONCAT114(-((*pauVar11)[0xf] == '\0'),
                                           CONCAT113(-((*pauVar11)[0xe] == '\0'),
                                                     CONCAT112(-((*pauVar11)[0xd] == '\0'),
                                                               CONCAT111(-((*pauVar11)[0xc] == '\0')
                                                                         ,CONCAT110(-((*pauVar11)
                                                                                      [0xb] == '\0')
                                                                                    ,CONCAT19(-((*
                                                  pauVar11)[10] == '\0'),
                                                  CONCAT18(-((*pauVar11)[9] == '\0'),
                                                           CONCAT17(-((*pauVar11)[8] == '\0'),
                                                                    CONCAT16(-((*pauVar11)[7] ==
                                                                              '\0'),CONCAT15(-((*
                                                  pauVar11)[6] == '\0'),
                                                  CONCAT14(-((*pauVar11)[5] == '\0'),
                                                           CONCAT13(-((*pauVar11)[4] == '\0'),
                                                                    CONCAT12(-((*pauVar11)[3] ==
                                                                              '\0'),CONCAT11(-((*
                                                  pauVar11)[2] == '\0'),-((*pauVar6)[0] == '\0')))))
                                                  )))))))))));
      if ((ushort)((ushort)(SUB161(auVar15 >> 7,0) & 1) |
                   (ushort)(SUB161(auVar15 >> 0xf,0) & 1) << 1 |
                   (ushort)(SUB161(auVar15 >> 0x17,0) & 1) << 2 |
                   (ushort)(SUB161(auVar15 >> 0x1f,0) & 1) << 3 |
                   (ushort)(SUB161(auVar15 >> 0x27,0) & 1) << 4 |
                   (ushort)(SUB161(auVar15 >> 0x2f,0) & 1) << 5 |
                   (ushort)(SUB161(auVar15 >> 0x37,0) & 1) << 6 |
                   (ushort)(SUB161(auVar15 >> 0x3f,0) & 1) << 7 |
                   (ushort)(SUB161(auVar15 >> 0x47,0) & 1) << 8 |
                   (ushort)(SUB161(auVar15 >> 0x4f,0) & 1) << 9 |
                   (ushort)(SUB161(auVar15 >> 0x57,0) & 1) << 10 |
                   (ushort)(SUB161(auVar15 >> 0x5f,0) & 1) << 0xb |
                   (ushort)(SUB161(auVar15 >> 0x67,0) & 1) << 0xc |
                   (ushort)(SUB161(auVar15 >> 0x6f,0) & 1) << 0xd |
                   (ushort)(SUB161(auVar15 >> 0x77,0) & 1) << 0xe | (ushort)(bVar16 >> 7) << 0xf) ==
          0) {
        uVar13 = 0xf;
      }
LAB_10021b3e:
      pauVar6 = param_3;
      cVar17 = SUB161(auVar18,0);
      if (((uint)pauVar6 & 0xfff) < 0xff1) goto code_r0x10021b4d;
      goto LAB_10021b74;
    }
  }
  else if ((*param_4)[0] != '\0') {
    if (0xff0 < ((uint)param_4 & 0xfff)) {
      iVar10 = 0xf;
      pauVar6 = param_4;
      do {
        puVar3 = *pauVar6;
        pauVar6 = (undefined (*) [16])(*pauVar6 + 1);
        do {
          auVar18 = pinsrb(in_XMM0,(char)((uint)param_2 >> 8),0xf);
          in_XMM0 = auVar18 >> 8;
          iVar10 = iVar10 + -1;
          if (iVar10 == 0) goto LAB_10021c2d;
        } while (*puVar3 == '\0');
      } while( true );
    }
    in_XMM0 = *param_4;
LAB_10021c2d:
    do {
      pauVar11 = param_3;
      pauVar6 = param_4;
      if (((uint)pauVar11 & 0xfff) < 0xff1) goto LAB_10021c4c;
      if ((*pauVar11)[0] == '\0') {
        return (undefined (*) [16])0x0;
      }
      pauVar7 = pauVar11;
      if (SUB161(in_XMM0,0) == (*pauVar11)[0]) goto LAB_10021c63;
      param_3 = (undefined (*) [16])(*pauVar11 + 1);
    } while( true );
  }
  return param_3;
LAB_10021c4c:
  iVar10 = pcmpistri(in_XMM0,*pauVar11,0xc);
  param_3 = pauVar11[1];
  if (pauVar11 >= (undefined (*) [16])0xfffffff0 || pauVar11[1] == (undefined (*) [16])0x0) {
    if (pauVar11 < (undefined (*) [16])0xfffffff0) {
      return (undefined (*) [16])0x0;
    }
    pauVar11 = (undefined (*) [16])(*pauVar11 + iVar10);
    pauVar7 = pauVar11;
LAB_10021c63:
    while( true ) {
      for (; (0xff0 < ((uint)pauVar11 & 0xfff) || (0xff0 < ((uint)pauVar6 & 0xfff)));
          pauVar6 = (undefined (*) [16])(*pauVar6 + 1)) {
        if ((*pauVar6)[0] == '\0') {
          return pauVar7;
        }
        if ((*pauVar6)[0] != (*pauVar11)[0]) goto LAB_10021c26;
        pauVar11 = (undefined (*) [16])(*pauVar11 + 1);
      }
      pauVar14 = pauVar6[1];
      pcmpistri(*pauVar6,*pauVar11,0xc);
      if (!SCARRY4((int)pauVar6,0x10)) break;
      pauVar6 = pauVar14;
      pauVar11 = pauVar11[1];
      if ((int)pauVar14 < 0) {
        return pauVar7;
      }
    }
LAB_10021c26:
    param_3 = (undefined (*) [16])(*pauVar7 + 1);
  }
  goto LAB_10021c2d;
code_r0x10021b4d:
  cVar5 = SUB161(auVar18 >> 8,0);
  cVar19 = SUB161(auVar18 >> 0x10,0);
  cVar20 = SUB161(auVar18 >> 0x18,0);
  cVar21 = SUB161(auVar18 >> 0x20,0);
  cVar22 = SUB161(auVar18 >> 0x28,0);
  cVar23 = SUB161(auVar18 >> 0x30,0);
  cVar24 = SUB161(auVar18 >> 0x38,0);
  auVar15 = CONCAT115(-((*pauVar6)[0xf] == cVar24),
                      CONCAT114(-((*pauVar6)[0xe] == cVar23),
                                CONCAT113(-((*pauVar6)[0xd] == cVar22),
                                          CONCAT112(-((*pauVar6)[0xc] == cVar21),
                                                    CONCAT111(-((*pauVar6)[0xb] == cVar20),
                                                              CONCAT110(-((*pauVar6)[10] == cVar19),
                                                                        CONCAT19(-((*pauVar6)[9] ==
                                                                                  cVar5),CONCAT18(-(
                                                  (*pauVar6)[8] == cVar17),
                                                  CONCAT17(-((*pauVar6)[7] == cVar24),
                                                           CONCAT16(-((*pauVar6)[6] == cVar23),
                                                                    CONCAT15(-((*pauVar6)[5] ==
                                                                              cVar22),CONCAT14(-((*
                                                  pauVar6)[4] == cVar21),
                                                  CONCAT13(-((*pauVar6)[3] == cVar20),
                                                           CONCAT12(-((*pauVar6)[2] == cVar19),
                                                                    CONCAT11(-((*pauVar6)[1] ==
                                                                              cVar5),-((*pauVar6)[0]
                                                                                      == cVar17)))))
                                                  ))))))))))) |
            CONCAT115(-((*pauVar6)[0xf] == '\0'),
                      CONCAT114(-((*pauVar6)[0xe] == '\0'),
                                CONCAT113(-((*pauVar6)[0xd] == '\0'),
                                          CONCAT112(-((*pauVar6)[0xc] == '\0'),
                                                    CONCAT111(-((*pauVar6)[0xb] == '\0'),
                                                              CONCAT110(-((*pauVar6)[10] == '\0'),
                                                                        CONCAT19(-((*pauVar6)[9] ==
                                                                                  '\0'),CONCAT18(-((
                                                  *pauVar6)[8] == '\0'),
                                                  CONCAT17(-((*pauVar6)[7] == '\0'),
                                                           CONCAT16(-((*pauVar6)[6] == '\0'),
                                                                    CONCAT15(-((*pauVar6)[5] == '\0'
                                                                              ),CONCAT14(-((*pauVar6
                                                  )[4] == '\0'),
                                                  CONCAT13(-((*pauVar6)[3] == '\0'),
                                                           CONCAT12(-((*pauVar6)[2] == '\0'),
                                                                    CONCAT11(-((*pauVar6)[1] == '\0'
                                                                              ),-((*pauVar6)[0] ==
                                                                                 '\0')))))))))))))))
                     );
  uVar2 = (ushort)(SUB161(auVar15 >> 7,0) & 1) | (ushort)(SUB161(auVar15 >> 0xf,0) & 1) << 1 |
          (ushort)(SUB161(auVar15 >> 0x17,0) & 1) << 2 |
          (ushort)(SUB161(auVar15 >> 0x1f,0) & 1) << 3 |
          (ushort)(SUB161(auVar15 >> 0x27,0) & 1) << 4 |
          (ushort)(SUB161(auVar15 >> 0x2f,0) & 1) << 5 |
          (ushort)(SUB161(auVar15 >> 0x37,0) & 1) << 6 |
          (ushort)(SUB161(auVar15 >> 0x3f,0) & 1) << 7 |
          (ushort)(SUB161(auVar15 >> 0x47,0) & 1) << 8 |
          (ushort)(SUB161(auVar15 >> 0x4f,0) & 1) << 9 |
          (ushort)(SUB161(auVar15 >> 0x57,0) & 1) << 10 |
          (ushort)(SUB161(auVar15 >> 0x5f,0) & 1) << 0xb |
          (ushort)(SUB161(auVar15 >> 0x67,0) & 1) << 0xc |
          (ushort)(SUB161(auVar15 >> 0x6f,0) & 1) << 0xd |
          (ushort)(SUB161(auVar15 >> 0x77,0) & 1) << 0xe | (ushort)SUB161(auVar15 >> 0x7f,0) << 0xf;
  param_3 = pauVar6[1];
  if (uVar2 != 0) {
    iVar10 = 0;
    if (uVar2 != 0) {
      for (; (uVar2 >> iVar10 & 1) == 0; iVar10 = iVar10 + 1) {
      }
    }
    pauVar6 = (undefined (*) [16])(*pauVar6 + iVar10);
LAB_10021b74:
    if ((*pauVar6)[0] == '\0') {
      return (undefined (*) [16])0x0;
    }
    param_3 = (undefined (*) [16])(*pauVar6 + 1);
    if (cVar17 == (*pauVar6)[0]) {
      pcVar9 = *param_4 + 1;
      pauVar11 = param_3;
LAB_10021b87:
      for (; ((uVar13 & (uint)pcVar9) == 0 && (((uint)pauVar11 & 0xfff) < 0xff1));
          pauVar11 = pauVar11[1]) {
        auVar15 = CONCAT115(-(pcVar9[0xf] == '\0'),
                            CONCAT114(-(pcVar9[0xe] == '\0'),
                                      CONCAT113(-(pcVar9[0xd] == '\0'),
                                                CONCAT112(-(pcVar9[0xc] == '\0'),
                                                          CONCAT111(-(pcVar9[0xb] == '\0'),
                                                                    CONCAT110(-(pcVar9[10] == '\0'),
                                                                              CONCAT19(-(pcVar9[9]
                                                                                        == '\0'),
                                                                                       CONCAT18(-(
                                                  pcVar9[8] == '\0'),
                                                  CONCAT17(-(pcVar9[7] == '\0'),
                                                           CONCAT16(-(pcVar9[6] == '\0'),
                                                                    CONCAT15(-(pcVar9[5] == '\0'),
                                                                             CONCAT14(-(pcVar9[4] ==
                                                                                       '\0'),
                                                  CONCAT13(-(pcVar9[3] == '\0'),
                                                           CONCAT12(-(pcVar9[2] == '\0'),
                                                                    CONCAT11(-(pcVar9[1] == '\0'),
                                                                             -(*pcVar9 == '\0'))))))
                                                  )))))))))) |
                  CONCAT115(-((*pauVar11)[0xf] != pcVar9[0xf]),
                            CONCAT114(-((*pauVar11)[0xe] != pcVar9[0xe]),
                                      CONCAT113(-((*pauVar11)[0xd] != pcVar9[0xd]),
                                                CONCAT112(-((*pauVar11)[0xc] != pcVar9[0xc]),
                                                          CONCAT111(-((*pauVar11)[0xb] !=
                                                                     pcVar9[0xb]),
                                                                    CONCAT110(-((*pauVar11)[10] !=
                                                                               pcVar9[10]),
                                                                              CONCAT19(-((*pauVar11)
                                                                                         [9] != 
                                                  pcVar9[9]),
                                                  CONCAT18(-((*pauVar11)[8] != pcVar9[8]),
                                                           CONCAT17(-((*pauVar11)[7] != pcVar9[7]),
                                                                    CONCAT16(-((*pauVar11)[6] !=
                                                                              pcVar9[6]),
                                                                             CONCAT15(-((*pauVar11)
                                                                                        [5] != 
                                                  pcVar9[5]),
                                                  CONCAT14(-((*pauVar11)[4] != pcVar9[4]),
                                                           CONCAT13(-((*pauVar11)[3] != pcVar9[3]),
                                                                    CONCAT12(-((*pauVar11)[2] !=
                                                                              pcVar9[2]),
                                                                             CONCAT11(-((*pauVar11)
                                                                                        [1] != 
                                                  pcVar9[1]),-((*pauVar11)[0] != *pcVar9))))))))))))
                                                  ))));
        uVar2 = (ushort)(SUB161(auVar15 >> 7,0) & 1) | (ushort)(SUB161(auVar15 >> 0xf,0) & 1) << 1 |
                (ushort)(SUB161(auVar15 >> 0x17,0) & 1) << 2 |
                (ushort)(SUB161(auVar15 >> 0x1f,0) & 1) << 3 |
                (ushort)(SUB161(auVar15 >> 0x27,0) & 1) << 4 |
                (ushort)(SUB161(auVar15 >> 0x2f,0) & 1) << 5 |
                (ushort)(SUB161(auVar15 >> 0x37,0) & 1) << 6 |
                (ushort)(SUB161(auVar15 >> 0x3f,0) & 1) << 7 |
                (ushort)(SUB161(auVar15 >> 0x47,0) & 1) << 8 |
                (ushort)(SUB161(auVar15 >> 0x4f,0) & 1) << 9 |
                (ushort)(SUB161(auVar15 >> 0x57,0) & 1) << 10 |
                (ushort)(SUB161(auVar15 >> 0x5f,0) & 1) << 0xb |
                (ushort)(SUB161(auVar15 >> 0x67,0) & 1) << 0xc |
                (ushort)(SUB161(auVar15 >> 0x6f,0) & 1) << 0xd |
                (ushort)(SUB161(auVar15 >> 0x77,0) & 1) << 0xe |
                (ushort)SUB161(auVar15 >> 0x7f,0) << 0xf;
        if (uVar2 != 0) {
          iVar10 = 0;
          if (uVar2 != 0) {
            for (; (uVar2 >> iVar10 & 1) == 0; iVar10 = iVar10 + 1) {
            }
          }
          pauVar11 = (undefined (*) [16])(*pauVar11 + iVar10);
          pcVar9 = pcVar9 + iVar10;
          break;
        }
        pcVar9 = pcVar9 + 0x10;
      }
      if (*pcVar9 == '\0') {
        return pauVar6;
      }
      if (*pcVar9 == (*pauVar11)[0]) {
        pauVar11 = (undefined (*) [16])(*pauVar11 + 1);
        pcVar9 = pcVar9 + 1;
        goto LAB_10021b87;
      }
    }
  }
  goto LAB_10021b3e;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe

void __cdecl FUN_10021d33(char *param_1,uint param_2,pthreadlocinfo *param_3)

{
  uint _Size;
  char cVar1;
  wchar_t *pwVar2;
  uint uVar3;
  int *piVar4;
  size_t sVar5;
  uint uVar6;
  pthreadlocinfo *extraout_EDX;
  pthreadlocinfo *extraout_EDX_00;
  pthreadlocinfo *extraout_EDX_01;
  undefined4 *_Src;
  undefined4 *puVar7;
  int iVar8;
  undefined extraout_var;
  undefined extraout_var_00;
  undefined uVar9;
  
  uVar3 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  if (param_1 == (char *)0x0) {
LAB_10021d4b:
    piVar4 = __errno();
    iVar8 = 0x16;
    uVar9 = extraout_var;
  }
  else {
    sVar5 = _strnlen(param_1,param_2);
    if (param_2 <= sVar5) {
      *param_1 = '\0';
      goto LAB_10021d4b;
    }
    pwVar2 = (*param_3)->locale_name[2];
    if (pwVar2 == (wchar_t *)0x0) {
      for (; uVar9 = extraout_var_00, *param_1 != '\0'; param_1 = param_1 + 1) {
        cVar1 = *param_1;
        if (('`' < cVar1) && (cVar1 < '{')) {
          *param_1 = cVar1 + -0x20;
        }
      }
      goto LAB_10021e95;
    }
    _Src = (undefined4 *)0x0;
    uVar6 = FUN_1002637c(param_3,pwVar2,0x200,param_1,-1,(LPWSTR)0x0,0,(*param_3)->lc_codepage,1);
    if (uVar6 == 0) {
      piVar4 = __errno();
      uVar9 = (undefined)uVar6;
      *piVar4 = 0x2a;
LAB_10021db2:
      __errno();
      param_3 = extraout_EDX_00;
      goto LAB_10021e95;
    }
    if (uVar6 <= param_2) {
      if (((0 < (int)uVar6) && (0xffffffe0 / uVar6 != 0)) && (_Size = uVar6 + 8, uVar6 < _Size)) {
        if (_Size < 0x401) {
          puVar7 = (undefined4 *)&stack0xffffffec;
          _Src = (undefined4 *)&stack0xffffffec;
          if (&stack0x00000000 != (undefined *)0x14) {
LAB_10021e30:
            _Src = puVar7 + 2;
          }
        }
        else {
          _Src = (undefined4 *)_malloc(_Size);
          if (_Src != (undefined4 *)0x0) {
            *_Src = 0xdddd;
            puVar7 = _Src;
            goto LAB_10021e30;
          }
        }
      }
      if (_Src != (undefined4 *)0x0) {
        iVar8 = FUN_1002637c(param_3,(*param_3)->locale_name[2],0x200,param_1,-1,(LPWSTR)_Src,uVar6,
                             (*param_3)->lc_codepage,1);
        uVar9 = (undefined)uVar6;
        if (iVar8 == 0) {
          piVar4 = __errno();
          *piVar4 = 0x2a;
        }
        else {
          _strcpy_s(param_1,param_2,(char *)_Src);
        }
        FUN_10021ea8((int)_Src);
        param_3 = extraout_EDX_01;
        goto LAB_10021e95;
      }
      piVar4 = __errno();
      uVar9 = (undefined)uVar6;
      *piVar4 = 0xc;
      goto LAB_10021db2;
    }
    *param_1 = '\0';
    piVar4 = __errno();
    uVar9 = (undefined)uVar6;
    iVar8 = 0x22;
  }
  *piVar4 = iVar8;
  FUN_10025625();
  param_3 = extraout_EDX;
LAB_10021e95:
  FUN_1002534c(uVar3 ^ (uint)&stack0xfffffffc,(char)param_3,uVar9);
  return;
}



void __cdecl FUN_10021ea8(int param_1)

{
  if ((param_1 != 0) && (*(int *)(param_1 + -8) == 0xdddd)) {
    FID_conflict__free((int *)(param_1 + -8));
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __strupr
// 
// Library: Visual Studio 2012 Release

char * __cdecl __strupr(char *_String)

{
  char cVar1;
  char *pcVar2;
  int *piVar3;
  
  if (_DAT_10835ca0 == 0) {
    pcVar2 = _String;
    if (_String == (char *)0x0) {
      piVar3 = __errno();
      *piVar3 = 0x16;
      FUN_10025625();
      return (char *)0x0;
    }
    if (*_String != '\0') {
      do {
        cVar1 = *_String;
        if (('`' < cVar1) && (cVar1 < '{')) {
          *_String = cVar1 + -0x20;
        }
        _String = _String + 1;
      } while (*_String != '\0');
      return pcVar2;
    }
  }
  else {
    FUN_10021f21(_String,0xffffffff,(pthreadlocinfo *)0x0);
  }
  return _String;
}



void __cdecl FUN_10021f21(char *param_1,uint param_2,pthreadlocinfo *param_3)

{
  pthreadlocinfo local_14 [2];
  int local_c;
  char local_8;
  
  FUN_1001f92e(local_14,param_3);
  FUN_10021d33(param_1,param_2,local_14);
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

int __cdecl FUN_10021f55(LPCVOID *param_1)

{
  int *piVar1;
  BOOL BVar2;
  DWORD DVar3;
  int iVar4;
  DWORD *pDVar5;
  bool bVar6;
  _PROCESS_HEAP_ENTRY local_40;
  int local_24;
  undefined4 local_20;
  undefined4 uStack12;
  undefined *local_8;
  
  local_8 = &DAT_1003fba8;
  uStack12 = 0x10021f61;
  local_40.lpData = (PVOID)0x0;
  pDVar5 = &local_40.cbData;
  for (iVar4 = 6; iVar4 != 0; iVar4 = iVar4 + -1) {
    *pDVar5 = 0;
    pDVar5 = pDVar5 + 1;
  }
  local_24 = -2;
  if (param_1 == (LPCVOID *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    iVar4 = -6;
  }
  else {
    local_40.wFlags = 0;
    local_40.iRegionIndex = '\0';
    local_40.lpData = *param_1;
    if (local_40.lpData == (LPCVOID)0x0) {
      BVar2 = HeapWalk(DAT_10835d30,&local_40);
      if (BVar2 == 0) {
        return -3;
      }
      do {
        if ((local_40.wFlags & 4) != 0) {
          *param_1 = local_40.lpData;
          param_1[1] = (LPCVOID)local_40.cbData;
          param_1[2] = (LPCVOID)0x1;
          return local_24;
        }
LAB_10021feb:
        local_8 = (undefined *)0x0;
        local_20 = 0;
        BVar2 = HeapWalk(DAT_10835d30,&local_40);
        bVar6 = BVar2 == 0;
        if (bVar6) {
          local_20 = 1;
        }
        local_8 = (undefined *)0xfffffffe;
        if (bVar6) {
          DVar3 = GetLastError();
          return (DVar3 != 0x103) - 5;
        }
      } while (bVar6 != true);
    }
    else {
      if (param_1[2] != (LPCVOID)0x1) goto LAB_10021feb;
      BVar2 = HeapValidate(DAT_10835d30,0,local_40.lpData);
      if (BVar2 != 0) {
        local_40.wFlags = 4;
        goto LAB_10021feb;
      }
    }
    iVar4 = -4;
  }
  return iVar4;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _strrchr
// 
// Libraries: Visual Studio 2012, Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

char * __cdecl _strrchr(char *_Str,int _Ch)

{
  uint uVar1;
  undefined (*pauVar2) [16];
  uint uVar3;
  int iVar4;
  char *pcVar5;
  char *pcVar6;
  undefined (*pauVar7) [16];
  undefined auVar8 [16];
  undefined auVar10 [16];
  char cVar13;
  char cVar14;
  char cVar15;
  char cVar16;
  char cVar17;
  char cVar18;
  char cVar19;
  undefined auVar12 [16];
  byte bVar9;
  byte bVar11;
  
  if (_DAT_10835b4c != 0) {
    if (_DAT_10835b4c < 2) {
      auVar12 = pshuflw(ZEXT216(CONCAT11((char)_Ch,(char)_Ch)),
                        ZEXT216(CONCAT11((char)_Ch,(char)_Ch)),0);
      uVar1 = -1 << (sbyte)((uint)_Str & 0xf);
      pcVar6 = _Str + -((uint)_Str & 0xf);
      pcVar5 = (char *)0x0;
      while( true ) {
        bVar11 = -(pcVar6[0xf] == '\0');
        auVar10 = CONCAT115(bVar11,CONCAT114(-(pcVar6[0xe] == '\0'),
                                             CONCAT113(-(pcVar6[0xd] == '\0'),
                                                       CONCAT112(-(pcVar6[0xc] == '\0'),
                                                                 CONCAT111(-(pcVar6[0xb] == '\0'),
                                                                           CONCAT110(-(pcVar6[10] ==
                                                                                      '\0'),CONCAT19
                                                  (-(pcVar6[9] == '\0'),
                                                   CONCAT18(-(pcVar6[8] == '\0'),
                                                            CONCAT17(-(pcVar6[7] == '\0'),
                                                                     CONCAT16(-(pcVar6[6] == '\0'),
                                                                              CONCAT15(-(pcVar6[5]
                                                                                        == '\0'),
                                                                                       CONCAT14(-(
                                                  pcVar6[4] == '\0'),
                                                  CONCAT13(-(pcVar6[3] == '\0'),
                                                           CONCAT12(-(pcVar6[2] == '\0'),
                                                                    CONCAT11(-(pcVar6[1] == '\0'),
                                                                             -(*pcVar6 == '\0'))))))
                                                  ))))))))));
        cVar13 = SUB161(auVar12 >> 8,0);
        cVar14 = SUB161(auVar12 >> 0x10,0);
        cVar15 = SUB161(auVar12 >> 0x18,0);
        cVar16 = SUB161(auVar12 >> 0x20,0);
        cVar17 = SUB161(auVar12 >> 0x28,0);
        cVar18 = SUB161(auVar12 >> 0x30,0);
        cVar19 = SUB161(auVar12 >> 0x38,0);
        bVar9 = -(pcVar6[0xf] == cVar19);
        auVar8 = CONCAT115(bVar9,CONCAT114(-(pcVar6[0xe] == cVar18),
                                           CONCAT113(-(pcVar6[0xd] == cVar17),
                                                     CONCAT112(-(pcVar6[0xc] == cVar16),
                                                               CONCAT111(-(pcVar6[0xb] == cVar15),
                                                                         CONCAT110(-(pcVar6[10] ==
                                                                                    cVar14),CONCAT19
                                                  (-(pcVar6[9] == cVar13),
                                                   CONCAT18(-(pcVar6[8] == SUB161(auVar12,0)),
                                                            CONCAT17(-(pcVar6[7] == cVar19),
                                                                     CONCAT16(-(pcVar6[6] == cVar18)
                                                                              ,CONCAT15(-(pcVar6[5]
                                                                                         == cVar17),
                                                                                        CONCAT14(-(
                                                  pcVar6[4] == cVar16),
                                                  CONCAT13(-(pcVar6[3] == cVar15),
                                                           CONCAT12(-(pcVar6[2] == cVar14),
                                                                    CONCAT11(-(pcVar6[1] == cVar13),
                                                                             -(*pcVar6 ==
                                                                              SUB161(auVar12,0))))))
                                                  )))))))))));
        uVar3 = (ushort)((ushort)(SUB161(auVar10 >> 7,0) & 1) |
                         (ushort)(SUB161(auVar10 >> 0xf,0) & 1) << 1 |
                         (ushort)(SUB161(auVar10 >> 0x17,0) & 1) << 2 |
                         (ushort)(SUB161(auVar10 >> 0x1f,0) & 1) << 3 |
                         (ushort)(SUB161(auVar10 >> 0x27,0) & 1) << 4 |
                         (ushort)(SUB161(auVar10 >> 0x2f,0) & 1) << 5 |
                         (ushort)(SUB161(auVar10 >> 0x37,0) & 1) << 6 |
                         (ushort)(SUB161(auVar10 >> 0x3f,0) & 1) << 7 |
                         (ushort)(SUB161(auVar10 >> 0x47,0) & 1) << 8 |
                         (ushort)(SUB161(auVar10 >> 0x4f,0) & 1) << 9 |
                         (ushort)(SUB161(auVar10 >> 0x57,0) & 1) << 10 |
                         (ushort)(SUB161(auVar10 >> 0x5f,0) & 1) << 0xb |
                         (ushort)(SUB161(auVar10 >> 0x67,0) & 1) << 0xc |
                         (ushort)(SUB161(auVar10 >> 0x6f,0) & 1) << 0xd |
                         (ushort)(SUB161(auVar10 >> 0x77,0) & 1) << 0xe |
                        (ushort)(bVar11 >> 7) << 0xf) & uVar1;
        if (uVar3 != 0) break;
        uVar1 = (ushort)((ushort)(SUB161(auVar8 >> 7,0) & 1) |
                         (ushort)(SUB161(auVar8 >> 0xf,0) & 1) << 1 |
                         (ushort)(SUB161(auVar8 >> 0x17,0) & 1) << 2 |
                         (ushort)(SUB161(auVar8 >> 0x1f,0) & 1) << 3 |
                         (ushort)(SUB161(auVar8 >> 0x27,0) & 1) << 4 |
                         (ushort)(SUB161(auVar8 >> 0x2f,0) & 1) << 5 |
                         (ushort)(SUB161(auVar8 >> 0x37,0) & 1) << 6 |
                         (ushort)(SUB161(auVar8 >> 0x3f,0) & 1) << 7 |
                         (ushort)(SUB161(auVar8 >> 0x47,0) & 1) << 8 |
                         (ushort)(SUB161(auVar8 >> 0x4f,0) & 1) << 9 |
                         (ushort)(SUB161(auVar8 >> 0x57,0) & 1) << 10 |
                         (ushort)(SUB161(auVar8 >> 0x5f,0) & 1) << 0xb |
                         (ushort)(SUB161(auVar8 >> 0x67,0) & 1) << 0xc |
                         (ushort)(SUB161(auVar8 >> 0x6f,0) & 1) << 0xd |
                         (ushort)(SUB161(auVar8 >> 0x77,0) & 1) << 0xe | (ushort)(bVar9 >> 7) << 0xf
                        ) & uVar1;
        iVar4 = 0x1f;
        if (uVar1 != 0) {
          for (; uVar1 >> iVar4 == 0; iVar4 = iVar4 + -1) {
          }
        }
        if (uVar1 != 0) {
          pcVar5 = pcVar6 + iVar4;
        }
        uVar1 = 0xffffffff;
        pcVar6 = pcVar6 + 0x10;
      }
      uVar1 = (uVar3 * 2 & uVar3 * -2) - 1 &
              (ushort)((ushort)(SUB161(auVar8 >> 7,0) & 1) |
                       (ushort)(SUB161(auVar8 >> 0xf,0) & 1) << 1 |
                       (ushort)(SUB161(auVar8 >> 0x17,0) & 1) << 2 |
                       (ushort)(SUB161(auVar8 >> 0x1f,0) & 1) << 3 |
                       (ushort)(SUB161(auVar8 >> 0x27,0) & 1) << 4 |
                       (ushort)(SUB161(auVar8 >> 0x2f,0) & 1) << 5 |
                       (ushort)(SUB161(auVar8 >> 0x37,0) & 1) << 6 |
                       (ushort)(SUB161(auVar8 >> 0x3f,0) & 1) << 7 |
                       (ushort)(SUB161(auVar8 >> 0x47,0) & 1) << 8 |
                       (ushort)(SUB161(auVar8 >> 0x4f,0) & 1) << 9 |
                       (ushort)(SUB161(auVar8 >> 0x57,0) & 1) << 10 |
                       (ushort)(SUB161(auVar8 >> 0x5f,0) & 1) << 0xb |
                       (ushort)(SUB161(auVar8 >> 0x67,0) & 1) << 0xc |
                       (ushort)(SUB161(auVar8 >> 0x6f,0) & 1) << 0xd |
                       (ushort)(SUB161(auVar8 >> 0x77,0) & 1) << 0xe | (ushort)(bVar9 >> 7) << 0xf)
              & uVar1;
      iVar4 = 0x1f;
      if (uVar1 != 0) {
        for (; uVar1 >> iVar4 == 0; iVar4 = iVar4 + -1) {
        }
      }
      pcVar6 = pcVar6 + iVar4;
      if (uVar1 == 0) {
        pcVar6 = pcVar5;
      }
      return pcVar6;
    }
    uVar1 = _Ch & 0xff;
    if (uVar1 == 0) {
      pcVar5 = (char *)((uint)_Str & 0xfffffff0);
      auVar12 = CONCAT115(-(pcVar5[0xf] == '\0'),
                          CONCAT114(-(pcVar5[0xe] == '\0'),
                                    CONCAT113(-(pcVar5[0xd] == '\0'),
                                              CONCAT112(-(pcVar5[0xc] == '\0'),
                                                        CONCAT111(-(pcVar5[0xb] == '\0'),
                                                                  CONCAT110(-(pcVar5[10] == '\0'),
                                                                            CONCAT19(-(pcVar5[9] ==
                                                                                      '\0'),CONCAT18
                                                  (-(pcVar5[8] == '\0'),
                                                   CONCAT17(-(pcVar5[7] == '\0'),
                                                            CONCAT16(-(pcVar5[6] == '\0'),
                                                                     CONCAT15(-(pcVar5[5] == '\0'),
                                                                              CONCAT14(-(pcVar5[4]
                                                                                        == '\0'),
                                                                                       CONCAT13(-(
                                                  pcVar5[3] == '\0'),
                                                  CONCAT12(-(pcVar5[2] == '\0'),
                                                           CONCAT11(-(pcVar5[1] == '\0'),
                                                                    -(*pcVar5 == '\0')))))))))))))))
                         );
      uVar1 = (uint)(ushort)((ushort)(SUB161(auVar12 >> 7,0) & 1) |
                             (ushort)(SUB161(auVar12 >> 0xf,0) & 1) << 1 |
                             (ushort)(SUB161(auVar12 >> 0x17,0) & 1) << 2 |
                             (ushort)(SUB161(auVar12 >> 0x1f,0) & 1) << 3 |
                             (ushort)(SUB161(auVar12 >> 0x27,0) & 1) << 4 |
                             (ushort)(SUB161(auVar12 >> 0x2f,0) & 1) << 5 |
                             (ushort)(SUB161(auVar12 >> 0x37,0) & 1) << 6 |
                             (ushort)(SUB161(auVar12 >> 0x3f,0) & 1) << 7 |
                             (ushort)(SUB161(auVar12 >> 0x47,0) & 1) << 8 |
                             (ushort)(SUB161(auVar12 >> 0x4f,0) & 1) << 9 |
                             (ushort)(SUB161(auVar12 >> 0x57,0) & 1) << 10 |
                             (ushort)(SUB161(auVar12 >> 0x5f,0) & 1) << 0xb |
                             (ushort)(SUB161(auVar12 >> 0x67,0) & 1) << 0xc |
                             (ushort)(SUB161(auVar12 >> 0x6f,0) & 1) << 0xd |
                             (ushort)(SUB161(auVar12 >> 0x77,0) & 1) << 0xe |
                            (ushort)((byte)-(pcVar5[0xf] == '\0') >> 7) << 0xf) &
              -1 << ((byte)_Str & 0xf);
      while (uVar1 == 0) {
        pcVar6 = pcVar5 + 0x1f;
        auVar12 = CONCAT115(-(*pcVar6 == '\0'),
                            CONCAT114(-(pcVar5[0x1e] == '\0'),
                                      CONCAT113(-(pcVar5[0x1d] == '\0'),
                                                CONCAT112(-(pcVar5[0x1c] == '\0'),
                                                          CONCAT111(-(pcVar5[0x1b] == '\0'),
                                                                    CONCAT110(-(pcVar5[0x1a] == '\0'
                                                                               ),CONCAT19(-(pcVar5[
                                                  0x19] == '\0'),
                                                  CONCAT18(-(pcVar5[0x18] == '\0'),
                                                           CONCAT17(-(pcVar5[0x17] == '\0'),
                                                                    CONCAT16(-(pcVar5[0x16] == '\0')
                                                                             ,CONCAT15(-(pcVar5[0x15
                                                  ] == '\0'),
                                                  CONCAT14(-(pcVar5[0x14] == '\0'),
                                                           CONCAT13(-(pcVar5[0x13] == '\0'),
                                                                    CONCAT12(-(pcVar5[0x12] == '\0')
                                                                             ,CONCAT11(-(pcVar5[0x11
                                                  ] == '\0'),-(pcVar5[0x10] == '\0'))))))))))))))));
        pcVar5 = pcVar5 + 0x10;
        uVar1 = (uint)(ushort)((ushort)(SUB161(auVar12 >> 7,0) & 1) |
                               (ushort)(SUB161(auVar12 >> 0xf,0) & 1) << 1 |
                               (ushort)(SUB161(auVar12 >> 0x17,0) & 1) << 2 |
                               (ushort)(SUB161(auVar12 >> 0x1f,0) & 1) << 3 |
                               (ushort)(SUB161(auVar12 >> 0x27,0) & 1) << 4 |
                               (ushort)(SUB161(auVar12 >> 0x2f,0) & 1) << 5 |
                               (ushort)(SUB161(auVar12 >> 0x37,0) & 1) << 6 |
                               (ushort)(SUB161(auVar12 >> 0x3f,0) & 1) << 7 |
                               (ushort)(SUB161(auVar12 >> 0x47,0) & 1) << 8 |
                               (ushort)(SUB161(auVar12 >> 0x4f,0) & 1) << 9 |
                               (ushort)(SUB161(auVar12 >> 0x57,0) & 1) << 10 |
                               (ushort)(SUB161(auVar12 >> 0x5f,0) & 1) << 0xb |
                               (ushort)(SUB161(auVar12 >> 0x67,0) & 1) << 0xc |
                               (ushort)(SUB161(auVar12 >> 0x6f,0) & 1) << 0xd |
                               (ushort)(SUB161(auVar12 >> 0x77,0) & 1) << 0xe |
                              (ushort)((byte)-(*pcVar6 == '\0') >> 7) << 0xf);
      }
      iVar4 = 0;
      if (uVar1 != 0) {
        for (; (uVar1 >> iVar4 & 1) == 0; iVar4 = iVar4 + 1) {
        }
      }
      pauVar2 = (undefined (*) [16])(pcVar5 + iVar4);
    }
    else {
      pauVar2 = (undefined (*) [16])0x0;
      uVar3 = (uint)_Str & 0xf;
      while (uVar3 != 0) {
        if ((byte)*_Str == uVar1) {
          pauVar2 = (undefined (*) [16])_Str;
        }
        if ((byte)*_Str == 0) {
          return (char *)pauVar2;
        }
        _Str = _Str + 1;
        uVar3 = (uint)_Str & 0xf;
      }
      do {
        pauVar7 = (undefined (*) [16])((int)_Str + 0x10);
        iVar4 = pcmpistri(ZEXT416(uVar1),*(undefined (*) [16])_Str,0x40);
        if ((undefined (*) [16])0xffffffef < _Str) {
          pauVar2 = (undefined (*) [16])(_Str + iVar4);
        }
        _Str = (char *)pauVar7;
      } while (pauVar7 != (undefined (*) [16])0x0);
    }
    return (char *)pauVar2;
  }
  iVar4 = -1;
  do {
    pcVar5 = _Str;
    if (iVar4 == 0) break;
    iVar4 = iVar4 + -1;
    pcVar5 = _Str + 1;
    cVar13 = *_Str;
    _Str = pcVar5;
  } while (cVar13 != '\0');
  iVar4 = -(iVar4 + 1);
  pcVar5 = pcVar5 + -1;
  do {
    pcVar6 = pcVar5;
    if (iVar4 == 0) break;
    iVar4 = iVar4 + -1;
    pcVar6 = pcVar5 + -1;
    cVar13 = *pcVar5;
    pcVar5 = pcVar6;
  } while ((char)_Ch != cVar13);
  pcVar6 = pcVar6 + 1;
  if (*pcVar6 != (char)_Ch) {
    pcVar6 = (char *)0x0;
  }
  return pcVar6;
}



void __cdecl FID_conflict__free(void *_Memory)

{
  BOOL BVar1;
  int *piVar2;
  DWORD DVar3;
  int iVar4;
  
  if (_Memory != (void *)0x0) {
    BVar1 = HeapFree(DAT_10835d30,0,_Memory);
    if (BVar1 == 0) {
      piVar2 = __errno();
      DVar3 = GetLastError();
      iVar4 = __get_errno_from_oserr(DVar3);
      *piVar2 = iVar4;
    }
  }
  return;
}



// Library Function - Single Match
//  __alldiv
// 
// Library: Visual Studio

undefined8 __alldiv(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  bool bVar10;
  char cVar11;
  uint uVar9;
  
  cVar11 = (int)param_2 < 0;
  if ((bool)cVar11) {
    bVar10 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(uint)bVar10 - param_2;
  }
  if ((int)param_4 < 0) {
    cVar11 = cVar11 + '\x01';
    bVar10 = param_3 != 0;
    param_3 = -param_3;
    param_4 = -(uint)bVar10 - param_4;
  }
  uVar3 = param_1;
  uVar5 = param_3;
  uVar6 = param_2;
  uVar9 = param_4;
  if (param_4 == 0) {
    uVar3 = param_2 / param_3;
    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
                 (ulonglong)param_3);
  }
  else {
    do {
      uVar8 = uVar9 >> 1;
      uVar5 = uVar5 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;
      uVar7 = uVar6 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
      uVar6 = uVar7;
      uVar9 = uVar8;
    } while (uVar8 != 0);
    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar5;
    iVar4 = (int)uVar1;
    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
    uVar5 = uVar3 + iVar4 * param_4;
    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar5)) ||
       ((param_2 <= uVar5 && (param_1 < (uint)lVar2)))) {
      iVar4 = iVar4 + -1;
    }
    uVar3 = 0;
  }
  if (cVar11 == '\x01') {
    bVar10 = iVar4 != 0;
    iVar4 = -iVar4;
    uVar3 = -(uint)bVar10 - uVar3;
  }
  return CONCAT44(uVar3,iVar4);
}



void __cdecl FUN_1002226a(uint param_1,uint param_2)

{
  DAT_100467e0 = ~param_2 & DAT_100467e0 | param_1 & param_2;
  return;
}



// Library Function - Single Match
//  _abort
// 
// Library: Visual Studio 2012 Release

void __cdecl _abort(void)

{
  code *pcVar1;
  int iVar2;
  BOOL BVar3;
  
  iVar2 = FUN_1002ba8b();
  if (iVar2 != 0) {
    FUN_1002bab4(0x16);
  }
  if (((byte)DAT_100467e0 & 2) != 0) {
    BVar3 = IsProcessorFeaturePresent(0x17);
    if (BVar3 != 0) {
      pcVar1 = (code *)swi(0x29);
      (*pcVar1)();
    }
    FUN_100254c8(3,0x40000015,1);
  }
  __exit(3);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void __cdecl FUN_100222d0(undefined *param_1,uint param_2,uint param_3,undefined *param_4)

{
  int *piVar1;
  int iVar2;
  undefined extraout_DL;
  undefined *extraout_EDX;
  undefined *puVar3;
  uint uVar4;
  undefined *puVar5;
  undefined uVar6;
  undefined *in_stack_fffffee0;
  undefined *local_118;
  undefined *local_114;
  undefined *local_110;
  int local_10c;
  undefined *local_104;
  undefined4 auStack248 [30];
  undefined4 auStack128 [30];
  uint local_8;
  
  uVar6 = SUB41(in_stack_fffffee0,0);
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  local_104 = param_1;
  if ((((param_1 == (undefined *)0x0) && (param_2 != 0)) || (param_3 == 0)) ||
     (param_4 == (undefined *)0x0)) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,extraout_DL,uVar6);
    return;
  }
  if (param_2 < 2) {
LAB_1002260f:
    FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,(char)param_2,uVar6);
    return;
  }
  local_10c = 0;
  local_118 = param_1 + (param_2 - 1) * param_3;
LAB_10022353:
  while (param_2 = (uint)local_118, uVar4 = (param_2 - (int)local_104) / param_3 + 1, 8 < uVar4) {
    puVar5 = local_104 + (uVar4 >> 1) * param_3;
    iVar2 = (*(code *)param_4)(local_104,puVar5);
    if (0 < iVar2) {
      FUN_100226a0(local_104,puVar5,param_3);
    }
    iVar2 = (*(code *)param_4)(local_104,param_2);
    if (0 < iVar2) {
      FUN_100226a0(local_104,(undefined *)param_2,param_3);
    }
    iVar2 = (*(code *)param_4)(puVar5,param_2);
    local_110 = local_104;
    local_118 = (undefined *)param_2;
    local_114 = puVar5;
    if (0 < iVar2) {
      FUN_100226a0(puVar5,(undefined *)param_2,param_3);
    }
LAB_10022405:
    if (local_110 < puVar5) {
      do {
        local_110 = local_110 + param_3;
        if (puVar5 <= local_110) goto LAB_10022441;
        iVar2 = (*(code *)param_4)(local_110,puVar5);
      } while (iVar2 < 1);
      if (puVar5 <= local_110) goto LAB_10022441;
    }
    else {
LAB_10022441:
      do {
        local_110 = local_110 + param_3;
        if (param_2 < local_110) break;
        iVar2 = (*(code *)param_4)(local_110,puVar5);
      } while (iVar2 < 1);
    }
    do {
      local_118 = local_118 + -param_3;
      if (local_118 <= puVar5) break;
      iVar2 = (*(code *)param_4)(local_118,puVar5);
    } while (0 < iVar2);
    if (local_110 <= local_118) {
      puVar3 = local_118;
      uVar4 = param_3;
      if (local_110 != local_118) {
        do {
          puVar5 = puVar3 + 1;
          uVar6 = puVar5[(int)(local_110 + (-1 - (int)local_118))];
          puVar5[(int)(local_110 + (-1 - (int)local_118))] = *puVar3;
          *puVar3 = uVar6;
          uVar4 = uVar4 - 1;
          puVar3 = puVar5;
          puVar5 = local_114;
        } while (uVar4 != 0);
      }
      in_stack_fffffee0 = local_118;
      if (puVar5 == local_118) {
        local_114 = local_110;
        puVar5 = local_110;
      }
      goto LAB_10022405;
    }
    local_118 = local_118 + param_3;
    if (puVar5 < local_118) {
      do {
        local_118 = local_118 + -param_3;
        if (local_118 <= puVar5) goto LAB_10022530;
        iVar2 = (*(code *)param_4)(local_118,puVar5);
      } while (iVar2 == 0);
      if (local_118 <= puVar5) goto LAB_10022530;
    }
    else {
LAB_10022530:
      do {
        local_118 = local_118 + -param_3;
        if (local_118 <= local_104) break;
        iVar2 = (*(code *)param_4)(local_118,puVar5);
      } while (iVar2 == 0);
    }
    if ((int)local_118 - (int)local_104 < (int)(param_2 - (int)local_110)) goto LAB_100225a2;
    if (local_104 < local_118) {
      auStack248[local_10c] = local_104;
      auStack128[local_10c] = local_118;
      local_10c = local_10c + 1;
    }
    local_104 = local_110;
    local_118 = (undefined *)param_2;
    if (param_2 <= local_110) goto LAB_100225e9;
  }
  _shortsort(local_104,(undefined *)param_2,param_3,param_4);
  param_2 = (uint)extraout_EDX;
  goto LAB_100225e9;
LAB_100225a2:
  if (local_110 < param_2) {
    auStack248[local_10c] = local_110;
    auStack128[local_10c] = param_2;
    local_10c = local_10c + 1;
  }
  if (local_118 <= local_104) {
LAB_100225e9:
    uVar6 = SUB41(in_stack_fffffee0,0);
    local_10c = local_10c + -1;
    if (-1 < local_10c) {
      local_104 = (undefined *)auStack248[local_10c];
      local_118 = (undefined *)auStack128[local_10c];
      goto LAB_10022353;
    }
    goto LAB_1002260f;
  }
  goto LAB_10022353;
}



// Library Function - Single Match
//  _shortsort
// 
// Library: Visual Studio 2019 Release

void __cdecl _shortsort(undefined *param_1,undefined *param_2,int param_3,undefined *param_4)

{
  undefined *puVar1;
  undefined uVar2;
  int iVar3;
  undefined *puVar4;
  undefined *puVar5;
  
  if (param_1 < param_2) {
    do {
      puVar5 = param_1;
      for (puVar4 = param_1 + param_3; puVar4 <= param_2; puVar4 = puVar4 + param_3) {
        iVar3 = (*(code *)param_4)(puVar4,puVar5);
        if (0 < iVar3) {
          puVar5 = puVar4;
        }
      }
      if ((puVar5 != param_2) && (puVar4 = param_2, iVar3 = param_3, param_3 != 0)) {
        do {
          puVar1 = puVar4 + 1;
          uVar2 = puVar1[(int)(puVar5 + (-1 - (int)param_2))];
          puVar1[(int)(puVar5 + (-1 - (int)param_2))] = *puVar4;
          *puVar4 = uVar2;
          iVar3 = iVar3 + -1;
          puVar4 = puVar1;
        } while (iVar3 != 0);
      }
      param_2 = param_2 + -param_3;
    } while (param_1 < param_2);
  }
  return;
}



void __cdecl FUN_100226a0(undefined *param_1,undefined *param_2,int param_3)

{
  undefined *puVar1;
  undefined uVar2;
  undefined *puVar3;
  
  if ((param_1 != param_2) && (puVar3 = param_2, param_3 != 0)) {
    do {
      puVar1 = puVar3 + 1;
      uVar2 = puVar1[(int)(param_1 + (-1 - (int)param_2))];
      puVar1[(int)(param_1 + (-1 - (int)param_2))] = *puVar3;
      *puVar3 = uVar2;
      param_3 = param_3 + -1;
      puVar3 = puVar1;
    } while (param_3 != 0);
  }
  return;
}



void __cdecl FUN_100226d7(byte *param_1,uint param_2)

{
  FUN_100226ec(param_1,param_2,(pthreadlocinfo *)0x0);
  return;
}



byte * __cdecl FUN_100226ec(byte *param_1,uint param_2,pthreadlocinfo *param_3)

{
  byte bVar1;
  ushort uVar2;
  int *piVar3;
  byte *pbVar4;
  byte bVar5;
  byte *pbVar6;
  bool bVar7;
  undefined local_14 [4];
  int local_10;
  int local_c;
  char local_8;
  
  pbVar6 = (byte *)0x0;
  FUN_1001f92e(local_14,param_3);
  if (param_1 == (byte *)0x0) {
    piVar3 = __errno();
    *piVar3 = 0x16;
    FUN_10025625();
  }
  else if (*(int *)(local_10 + 8) == 0) {
    pbVar6 = (byte *)_strrchr((char *)param_1,param_2);
  }
  else {
    do {
      bVar5 = *param_1;
      if ((*(byte *)(bVar5 + 0x19 + local_10) & 4) == 0) {
        bVar7 = param_2 == bVar5;
LAB_1002275e:
        pbVar4 = param_1;
        if (bVar7) {
          pbVar6 = param_1;
        }
      }
      else {
        pbVar4 = param_1 + 1;
        bVar1 = *pbVar4;
        if (bVar1 == 0) {
          bVar7 = pbVar6 == (byte *)0x0;
          param_1 = pbVar4;
          bVar5 = bVar1;
          goto LAB_1002275e;
        }
        uVar2 = CONCAT11(bVar5,bVar1);
        bVar5 = bVar1;
        if (param_2 == uVar2) {
          pbVar6 = param_1;
        }
      }
      param_1 = pbVar4 + 1;
    } while (bVar5 != 0);
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return pbVar6;
}



int __cdecl FUN_1002277d(LPCSTR param_1,LPCSTR param_2)

{
  bool bVar1;
  undefined3 extraout_var;
  BOOL BVar2;
  int iVar3;
  int iVar4;
  wchar_t *lpWideCharStr;
  int iVar5;
  DWORD DVar6;
  UINT CodePage;
  
  CodePage = 0;
  bVar1 = FUN_1002bd88();
  if ((CONCAT31(extraout_var,bVar1) == 0) && (BVar2 = AreFileApisANSI(), BVar2 == 0)) {
    CodePage = 1;
  }
  iVar3 = MultiByteToWideChar(CodePage,0,param_1,-1,(LPWSTR)0x0,0);
  if ((iVar3 != 0) && (iVar4 = MultiByteToWideChar(CodePage,0,param_2,-1,(LPWSTR)0x0,0), iVar4 != 0)
     ) {
    lpWideCharStr = (wchar_t *)FUN_10026f23((iVar4 + iVar3) * 2);
    if (lpWideCharStr == (wchar_t *)0x0) {
      return -1;
    }
    iVar5 = MultiByteToWideChar(CodePage,0,param_1,-1,lpWideCharStr,iVar3);
    if ((iVar5 != 0) &&
       (iVar4 = MultiByteToWideChar(CodePage,0,param_2,-1,lpWideCharStr + iVar3,iVar4), iVar4 != 0))
    {
      iVar3 = __wrename(lpWideCharStr,lpWideCharStr + iVar3);
      FID_conflict__free(lpWideCharStr);
      return iVar3;
    }
    FID_conflict__free(lpWideCharStr);
  }
  DVar6 = GetLastError();
  FID_conflict___dosmaperr(DVar6);
  return -1;
}



tm * __cdecl FUN_10022840(longlong *param_1)

{
  tm *ptVar1;
  int iVar2;
  
  ptVar1 = (tm *)FUN_1002c8ae();
  if (ptVar1 != (tm *)0x0) {
    iVar2 = FUN_10022865(ptVar1,param_1);
    ptVar1 = (tm *)(~-(uint)(iVar2 != 0) & (uint)ptVar1);
  }
  return ptVar1;
}



int __cdecl FUN_10022865(tm *param_1,longlong *param_2)

{
  code *pcVar1;
  int *piVar2;
  int iVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  uint uVar7;
  bool bVar8;
  undefined8 uVar9;
  longlong lVar10;
  uint local_18;
  int local_14;
  uint local_10;
  int local_c;
  uint local_8;
  
  local_c = 0;
  local_10 = 0;
  local_8 = 0;
  if ((param_1 == (tm *)0x0) ||
     (FUN_10021290((uint *)param_1,0xff,0x24), param_2 == (longlong *)0x0)) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    FUN_10025625();
    return 0x16;
  }
  if (((*(int *)((int)param_2 + 4) < 1) && ((*(int *)((int)param_2 + 4) < 0 || (false)))) ||
     ((6 < *(int *)((int)param_2 + 4) &&
      ((7 < *(int *)((int)param_2 + 4) || (0x93406fff < *(uint *)param_2)))))) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    return 0x16;
  }
  ___tzset();
  iVar3 = FUN_1002c09c(&local_c);
  if (((iVar3 != 0) || (iVar3 = FUN_1002c0c6(&local_10), iVar3 != 0)) ||
     (iVar3 = FUN_1002c0f0(&local_8), iVar3 != 0)) {
    __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    pcVar1 = (code *)swi(3);
    iVar3 = (*pcVar1)();
    return iVar3;
  }
  iVar3 = *(int *)((int)param_2 + 4);
  uVar5 = *(uint *)param_2;
  if ((-1 < iVar3) && ((0 < iVar3 || (0x3f480 < uVar5)))) {
    local_18 = uVar5 - local_8;
    local_14 = (iVar3 - ((int)local_8 >> 0x1f)) - (uint)(uVar5 < local_8);
    iVar3 = FUN_10022fb6((uint *)param_1,(longlong *)&local_18);
    if (iVar3 != 0) {
      return iVar3;
    }
    if (local_c == 0) {
      return 0;
    }
    iVar3 = __isindst(param_1);
    if (iVar3 == 0) {
      return 0;
    }
    bVar8 = local_18 < local_10;
    local_18 = local_18 - local_10;
    local_14 = (local_14 - ((int)local_10 >> 0x1f)) - (uint)bVar8;
    iVar3 = FUN_10022fb6((uint *)param_1,(longlong *)&local_18);
    if (iVar3 == 0) {
      param_1->tm_isdst = 1;
      return 0;
    }
    return iVar3;
  }
  iVar3 = FUN_10022fb6((uint *)param_1,param_2);
  if (iVar3 != 0) {
    return iVar3;
  }
  if ((local_c == 0) || (iVar3 = __isindst(param_1), iVar3 == 0)) {
    uVar5 = param_1->tm_sec;
    uVar7 = uVar5 - local_8;
    uVar5 = (((int)uVar5 >> 0x1f) - ((int)local_8 >> 0x1f)) - (uint)(uVar5 < local_8);
  }
  else {
    uVar4 = local_10 + local_8;
    param_1->tm_isdst = 1;
    uVar5 = param_1->tm_sec;
    uVar7 = uVar5 - uVar4;
    uVar5 = (((int)uVar5 >> 0x1f) - ((int)uVar4 >> 0x1f)) - (uint)(uVar5 < uVar4);
  }
  uVar9 = __allrem(uVar7,uVar5,0x3c,0);
  iVar3 = (int)uVar9;
  param_1->tm_sec = iVar3;
  if (iVar3 < 0) {
    bVar8 = 0x3b < uVar7;
    uVar7 = uVar7 - 0x3c;
    param_1->tm_sec = iVar3 + 0x3c;
    uVar5 = (uVar5 - 1) + (uint)bVar8;
  }
  lVar10 = __alldiv(uVar7,uVar5,0x3c,0);
  lVar10 = lVar10 + param_1->tm_min;
  uVar9 = __allrem((uint)lVar10,(uint)((ulonglong)lVar10 >> 0x20),0x3c,0);
  iVar3 = (int)uVar9;
  param_1->tm_min = iVar3;
  if (iVar3 < 0) {
    param_1->tm_min = iVar3 + 0x3c;
    lVar10 = lVar10 + -0x3c;
  }
  lVar10 = __alldiv((uint)lVar10,(uint)((ulonglong)lVar10 >> 0x20),0x3c,0);
  lVar10 = lVar10 + param_1->tm_hour;
  uVar9 = __allrem((uint)lVar10,(uint)((ulonglong)lVar10 >> 0x20),0x18,0);
  iVar3 = (int)uVar9;
  param_1->tm_hour = iVar3;
  if (iVar3 < 0) {
    param_1->tm_hour = iVar3 + 0x18;
    lVar10 = lVar10 + -0x18;
  }
  lVar10 = __alldiv((uint)lVar10,(uint)((ulonglong)lVar10 >> 0x20),0x18,0);
  iVar6 = (int)((ulonglong)lVar10 >> 0x20);
  iVar3 = (int)lVar10;
  if (-1 < lVar10) {
    if ((iVar6 != 0 && -1 < lVar10) || (iVar3 != 0)) {
      param_1->tm_mday = param_1->tm_mday + iVar3;
      param_1->tm_wday = (param_1->tm_wday + iVar3) % 7;
      goto LAB_10022a8a;
    }
    if (iVar6 != 0 && -1 < lVar10) {
      return 0;
    }
    if ((-1 < lVar10) && (true)) {
      return 0;
    }
  }
  param_1->tm_mday = param_1->tm_mday + iVar3;
  param_1->tm_wday = (param_1->tm_wday + 7 + iVar3) % 7;
  if (param_1->tm_mday < 1) {
    param_1->tm_mon = 0xb;
    param_1->tm_mday = param_1->tm_mday + 0x1f;
    param_1->tm_yday = param_1->tm_yday + iVar3 + 0x16d;
    param_1->tm_year = param_1->tm_year + -1;
    return 0;
  }
LAB_10022a8a:
  param_1->tm_yday = param_1->tm_yday + iVar3;
  return 0;
}



void __cdecl FUN_10022adf(undefined4 *param_1)

{
  longlong lVar1;
  _FILETIME local_c;
  
  GetSystemTimeAsFileTime(&local_c);
  lVar1 = __aulldiv(local_c.dwLowDateTime + 0x2ac18000,
                    local_c.dwHighDateTime + 0xfe624e21 + (uint)(0xd53e7fff < local_c.dwLowDateTime)
                    ,10000000,0);
  if ((0x793406fff < lVar1) && ((true || (0x93406fff < (uint)lVar1)))) {
    lVar1 = -1;
  }
  if (param_1 != (undefined4 *)0x0) {
    *param_1 = (int)lVar1;
    param_1[1] = (int)((ulonglong)lVar1 >> 0x20);
  }
  return;
}



char * __cdecl FUN_10022b30(int *param_1)

{
  int iVar1;
  _ptiddata p_Var2;
  char *pcVar3;
  uint uVar4;
  int iVar5;
  int *piVar6;
  int iVar7;
  uint uVar8;
  char *pcVar9;
  char *pcVar10;
  bool bVar11;
  
  pcVar10 = &DAT_10835af8;
  p_Var2 = __getptd_noexit();
  if (p_Var2 != (_ptiddata)0x0) {
    if (p_Var2->_asctimebuf == (char *)0x0) {
      pcVar3 = (char *)FUN_10026edb(0x1a,1);
      p_Var2->_asctimebuf = pcVar3;
      if (pcVar3 == (char *)0x0) goto LAB_10022b63;
    }
    pcVar10 = p_Var2->_asctimebuf;
  }
LAB_10022b63:
  if ((((((pcVar10 != (char *)0x0) && (*pcVar10 = '\0', param_1 != (int *)0x0)) && (-1 < param_1[5])
        ) && ((iVar5 = param_1[4], -1 < iVar5 && (iVar5 < 0xc)))) &&
      ((-1 < param_1[2] && ((param_1[2] < 0x18 && (-1 < param_1[1])))))) &&
     ((param_1[1] < 0x3c && (((-1 < *param_1 && (*param_1 < 0x3c)) && (0 < param_1[3])))))) {
    if ((int)((&DAT_10047504)[iVar5] - (&DAT_10047500)[iVar5]) < param_1[3]) {
      uVar8 = param_1[5] + 0x76c;
      uVar4 = uVar8 & 0x80000003;
      bVar11 = uVar4 == 0;
      if ((int)uVar4 < 0) {
        bVar11 = (uVar4 - 1 | 0xfffffffc) == 0xffffffff;
      }
      if ((((!bVar11) || ((int)uVar8 % 100 == 0)) && ((int)uVar8 % 400 != 0)) ||
         ((iVar5 != 1 || (0x1d < param_1[3])))) goto LAB_10022d24;
    }
    iVar1 = param_1[6];
    if ((-1 < iVar1) && (iVar1 < 7)) {
      iVar7 = 0;
      pcVar3 = pcVar10;
      do {
        pcVar9 = pcVar3;
        *pcVar9 = "SunMonTueWedThuFriSat"[iVar7 + iVar1 * 3];
        pcVar10[iVar7 + 4] = "JanFebMarAprMayJunJulAugSepOctNovDec"[iVar7 + iVar5 * 3];
        iVar7 = iVar7 + 1;
        pcVar3 = pcVar9 + 1;
      } while (iVar7 < 3);
      pcVar9[1] = ' ';
      pcVar9[5] = ' ';
      iVar5 = param_1[3];
      pcVar9[6] = (char)(iVar5 / 10) + '0';
      pcVar9[7] = (char)(iVar5 % 10) + '0';
      pcVar9[8] = ' ';
      iVar5 = param_1[2];
      pcVar9[9] = (char)(iVar5 / 10) + '0';
      pcVar9[10] = (char)(iVar5 % 10) + '0';
      pcVar9[0xb] = ':';
      iVar5 = param_1[1];
      pcVar9[0xc] = (char)(iVar5 / 10) + '0';
      pcVar9[0xd] = (char)(iVar5 % 10) + '0';
      pcVar9[0xe] = ':';
      iVar5 = *param_1;
      pcVar9[0xf] = (char)(iVar5 / 10) + '0';
      pcVar9[0x10] = (char)(iVar5 % 10) + '0';
      pcVar9[0x11] = ' ';
      iVar5 = param_1[5] / 100 + 0x13;
      pcVar9[0x12] = (char)(iVar5 / 10) + '0';
      pcVar9[0x13] = (char)(iVar5 % 10) + '0';
      iVar5 = param_1[5];
      pcVar9[0x14] = (char)((iVar5 % 100) / 10) + '0';
      pcVar9[0x15] = (char)((iVar5 % 100) % 10) + '0';
      pcVar9[0x16] = '\n';
      pcVar9[0x17] = '\0';
      return pcVar10;
    }
  }
LAB_10022d24:
  piVar6 = __errno();
  *piVar6 = 0x16;
  FUN_10025625();
  return (char *)0x0;
}



undefined4 __cdecl FUN_10022d3d(undefined *param_1,uint param_2,int *param_3)

{
  int iVar1;
  char *pcVar2;
  uint uVar3;
  int iVar4;
  int *piVar5;
  char *pcVar6;
  int iVar7;
  uint uVar8;
  bool bVar9;
  
  if (((((((param_1 != (undefined *)0x0) && (param_2 != 0)) && (*param_1 = 0, 0x19 < param_2)) &&
        ((param_3 != (int *)0x0 && (-1 < param_3[5])))) &&
       ((iVar4 = param_3[4], -1 < iVar4 && ((iVar4 < 0xc && (-1 < param_3[2])))))) &&
      ((param_3[2] < 0x18 && (((-1 < param_3[1] && (param_3[1] < 0x3c)) && (-1 < *param_3)))))) &&
     ((*param_3 < 0x3c && (0 < param_3[3])))) {
    if ((int)((&DAT_10047504)[iVar4] - (&DAT_10047500)[iVar4]) < param_3[3]) {
      uVar8 = param_3[5] + 0x76c;
      uVar3 = uVar8 & 0x80000003;
      bVar9 = uVar3 == 0;
      if ((int)uVar3 < 0) {
        bVar9 = (uVar3 - 1 | 0xfffffffc) == 0xffffffff;
      }
      if ((((!bVar9) || ((int)uVar8 % 100 == 0)) && ((int)uVar8 % 400 != 0)) ||
         ((iVar4 != 1 || (0x1d < param_3[3])))) goto LAB_10022f0c;
    }
    iVar1 = param_3[6];
    if ((-1 < iVar1) && (iVar1 < 7)) {
      iVar7 = 0;
      pcVar2 = param_1;
      do {
        pcVar6 = pcVar2;
        *pcVar6 = "SunMonTueWedThuFriSat"[iVar7 + iVar1 * 3];
        param_1[iVar7 + 4] = "JanFebMarAprMayJunJulAugSepOctNovDec"[iVar7 + iVar4 * 3];
        iVar7 = iVar7 + 1;
        pcVar2 = pcVar6 + 1;
      } while (iVar7 < 3);
      pcVar6[1] = ' ';
      pcVar6[5] = ' ';
      iVar4 = param_3[3];
      pcVar6[6] = (char)(iVar4 / 10) + '0';
      pcVar6[7] = (char)(iVar4 % 10) + '0';
      pcVar6[8] = ' ';
      iVar4 = param_3[2];
      pcVar6[9] = (char)(iVar4 / 10) + '0';
      pcVar6[10] = (char)(iVar4 % 10) + '0';
      pcVar6[0xb] = ':';
      iVar4 = param_3[1];
      pcVar6[0xc] = (char)(iVar4 / 10) + '0';
      pcVar6[0xd] = (char)(iVar4 % 10) + '0';
      pcVar6[0xe] = ':';
      iVar4 = *param_3;
      pcVar6[0xf] = (char)(iVar4 / 10) + '0';
      pcVar6[0x10] = (char)(iVar4 % 10) + '0';
      pcVar6[0x11] = ' ';
      iVar4 = param_3[5] / 100 + 0x13;
      pcVar6[0x12] = (char)(iVar4 / 10) + '0';
      pcVar6[0x13] = (char)(iVar4 % 10) + '0';
      iVar4 = param_3[5];
      pcVar6[0x14] = (char)((iVar4 % 100) / 10) + '0';
      pcVar6[0x15] = (char)((iVar4 % 100) % 10) + '0';
      pcVar6[0x16] = '\n';
      pcVar6[0x17] = '\0';
      return 0;
    }
  }
LAB_10022f0c:
  piVar5 = __errno();
  *piVar5 = 0x16;
  FUN_10025625();
  return 0x16;
}



void __cdecl FUN_10022f24(undefined *param_1,uint param_2,longlong *param_3)

{
  uint uVar1;
  int *piVar2;
  int iVar3;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  undefined extraout_DL_02;
  undefined uVar4;
  undefined in_stack_ffffffd4;
  
  uVar1 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  if (((param_1 == (undefined *)0x0) || (param_2 == 0)) ||
     (*param_1 = 0, param_3 == (longlong *)0x0)) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    FUN_10025625();
    uVar4 = extraout_DL_02;
  }
  else if (((*(int *)((int)param_3 + 4) < 1) && ((*(int *)((int)param_3 + 4) < 0 || (false)))) ||
          ((6 < *(int *)((int)param_3 + 4) &&
           ((7 < *(int *)((int)param_3 + 4) || (0x93406fff < *(uint *)param_3)))))) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    uVar4 = extraout_DL;
  }
  else {
    iVar3 = FUN_10022865((tm *)&stack0xffffffd4,param_3);
    uVar4 = extraout_DL_00;
    if (iVar3 == 0) {
      FUN_10022d3d(param_1,param_2,(int *)&stack0xffffffd4);
      uVar4 = extraout_DL_01;
    }
  }
  FUN_1002534c(uVar1 ^ (uint)&stack0xfffffffc,uVar4,in_stack_ffffffd4);
  return;
}



undefined4 __cdecl FUN_10022fb6(uint *param_1,longlong *param_2)

{
  longlong lVar1;
  longlong lVar2;
  bool bVar3;
  int *piVar4;
  uint uVar5;
  uint uVar6;
  int iVar7;
  undefined4 *puVar8;
  uint uVar9;
  uint uVar10;
  int iVar11;
  bool bVar12;
  undefined8 uVar13;
  ulonglong uVar14;
  
  bVar3 = false;
  if ((param_1 == (uint *)0x0) || (FUN_10021290(param_1,0xff,0x24), param_2 == (longlong *)0x0)) {
    piVar4 = __errno();
    *piVar4 = 0x16;
    FUN_10025625();
    return 0x16;
  }
  uVar10 = *(uint *)param_2;
  uVar6 = *(uint *)((int)param_2 + 4);
  lVar1 = *param_2;
  if (((0x7fffffff < uVar6) && (((int)uVar6 < -1 || (uVar10 < 0xffff5740)))) ||
     ((6 < (int)uVar6 && ((7 < (int)uVar6 || (0x934126cf < uVar10)))))) {
    piVar4 = __errno();
    *piVar4 = 0x16;
    return 0x16;
  }
  uVar13 = __alldiv(uVar10,uVar6,0x1e13380,0);
  uVar5 = (uint)uVar13;
  uVar6 = uVar5 + 0x46;
  uVar10 = uVar5 + 0x45;
  uVar14 = __allmul(uVar5,(int)uVar5 >> 0x1f,0xfffffe93,0xffffffff);
  lVar2 = uVar14 - (longlong)
                   (((int)(uVar10 + ((int)uVar10 >> 0x1f & 3U)) >> 2) + -0x11 +
                   ((int)(uVar5 + 0x171) / 400 - (int)uVar10 / 100));
  uVar14 = __allmul((uint)lVar2,(uint)((ulonglong)lVar2 >> 0x20),0x15180,0);
  lVar1 = uVar14 + lVar1;
  uVar9 = (uint)lVar1;
  iVar11 = (int)((ulonglong)lVar1 >> 0x20);
  if ((iVar11 != 0 && -1 < lVar1) || ((-1 < lVar1 && (true)))) {
    uVar10 = uVar6 & 0x80000003;
    bVar12 = uVar10 == 0;
    if ((int)uVar10 < 0) {
      bVar12 = (uVar10 - 1 | 0xfffffffc) == 0xffffffff;
    }
    if (((!bVar12) || ((int)uVar6 % 100 == 0)) && ((int)(uVar5 + 0x7b2) % 400 != 0))
    goto LAB_10023126;
  }
  else {
    lVar1 = lVar1 + 0x1e13380;
    uVar6 = uVar10 & 0x80000003;
    bVar12 = uVar6 == 0;
    if ((int)uVar6 < 0) {
      bVar12 = (uVar6 - 1 | 0xfffffffc) == 0xffffffff;
    }
    uVar6 = uVar10;
    if (((!bVar12) || ((int)uVar10 % 100 == 0)) && ((int)(uVar5 + 0x7b1) % 400 != 0))
    goto LAB_10023126;
    lVar1 = CONCAT44(iVar11 + (uint)(0xfe1ecc7f < uVar9) + (uint)(0xfffeae7f < uVar9 + 0x1e13380),
                     uVar9 + 0x1e28500);
  }
  bVar3 = true;
LAB_10023126:
  param_1[5] = uVar6;
  uVar13 = __alldiv((uint)lVar1,(uint)((ulonglong)lVar1 >> 0x20),0x15180,0);
  uVar10 = (uint)uVar13;
  param_1[7] = uVar10;
  uVar14 = __allmul(uVar10,(int)uVar10 >> 0x1f,0xfffeae80,0xffffffff);
  lVar1 = lVar1 + uVar14;
  puVar8 = (undefined4 *)&DAT_10047534;
  if (!bVar3) {
    puVar8 = &DAT_10047500;
  }
  iVar7 = 1;
  iVar11 = puVar8[1];
  while (iVar11 < (int)param_1[7]) {
    iVar7 = iVar7 + 1;
    iVar11 = puVar8[iVar7];
  }
  param_1[4] = iVar7 - 1U;
  param_1[3] = param_1[7] - puVar8[iVar7 - 1U];
  uVar13 = __alldiv(*(uint *)param_2,*(uint *)((int)param_2 + 4),0x15180,0);
  param_1[6] = ((int)uVar13 + 4) % 7;
  uVar13 = __alldiv((uint)lVar1,(uint)((ulonglong)lVar1 >> 0x20),0xe10,0);
  uVar10 = (uint)uVar13;
  param_1[2] = uVar10;
  uVar14 = __allmul(uVar10,(int)uVar10 >> 0x1f,0xfffff1f0,0xffffffff);
  uVar10 = (uint)(lVar1 + uVar14);
  uVar13 = __alldiv(uVar10,(uint)(lVar1 + uVar14 >> 0x20),0x3c,0);
  param_1[8] = 0;
  param_1[1] = (uint)uVar13;
  *param_1 = uVar10 + (uint)uVar13 * -0x3c;
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

void __cdecl FUN_100231e1(int *param_1,int param_2)

{
  code *pcVar1;
  uint uVar2;
  int *piVar3;
  uint uVar4;
  undefined uVar5;
  int iVar6;
  uint uVar7;
  tm *ptVar8;
  bool bVar9;
  longlong lVar10;
  undefined8 uVar11;
  longlong lVar12;
  ulonglong uVar13;
  undefined uVar14;
  int iVar15;
  int local_48;
  uint local_44;
  int *local_40;
  int local_3c;
  uint local_38;
  undefined8 local_34;
  tm local_2c;
  uint local_8;
  
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  local_48 = 0;
  iVar15 = 0;
  local_40 = param_1;
  if (param_1 == (int *)0x0) {
    piVar3 = __errno();
    uVar14 = (undefined)iVar15;
    *piVar3 = 0x16;
    FUN_10025625();
    uVar5 = 0xff;
    goto LAB_10023475;
  }
  local_34._0_4_ = param_1[5];
  local_34._4_4_ = (int)(uint)local_34 >> 0x1f;
  local_34 = (longlong)(int)(uint)local_34;
  if (((local_34._4_4_ - 1) + (uint)(0x44 < (uint)local_34) != 0) ||
     ((true && (local_34 = (longlong)(int)(uint)local_34, 0x408 < (uint)local_34 - 0x45)))) {
LAB_10023463:
    uVar14 = (undefined)iVar15;
    piVar3 = __errno();
    *piVar3 = 0x16;
    uVar5 = 0xff;
  }
  else {
    iVar6 = param_1[4];
    if ((iVar6 < 0) || (0xb < iVar6)) {
      uVar4 = iVar6 / 0xc;
      iVar6 = iVar6 % 0xc;
      bVar9 = CARRY4((uint)local_34,uVar4);
      local_34._0_4_ = (uint)local_34 + uVar4;
      param_1[4] = iVar6;
      local_34._4_4_ = local_34._4_4_ + ((int)uVar4 >> 0x1f) + (uint)bVar9;
      if (iVar6 < 0) {
        bVar9 = (uint)local_34 != 0;
        local_34._0_4_ = (uint)local_34 - 1;
        param_1[4] = iVar6 + 0xc;
        local_34._4_4_ = (local_34._4_4_ - 1) + (uint)bVar9;
      }
      local_34 = CONCAT44(local_34._4_4_,(uint)local_34);
      if (((local_34._4_4_ - 1) + (uint)(0x44 < (uint)local_34) != 0) ||
         ((true && (local_34 = CONCAT44(local_34._4_4_,(uint)local_34),
                   0x408 < (uint)local_34 - 0x45)))) goto LAB_10023463;
    }
    uVar7 = local_34._4_4_;
    uVar2 = (uint)local_34;
    local_38 = param_1[4];
    uVar4 = (&DAT_10047500)[local_38];
    local_3c = (int)uVar4 >> 0x1f;
    local_44 = uVar4;
    lVar10 = __allrem((uint)local_34,local_34._4_4_,4,0);
    if ((((lVar10 == 0) &&
         (lVar10 = __allrem(uVar2,uVar7,100,(uint)lVar10 | (uint)((ulonglong)lVar10 >> 0x20)),
         lVar10 != 0)) ||
        (lVar10 = __allrem(uVar2 + 0x76c,uVar7 + (0xfffff893 < uVar2),400,0), lVar10 == 0)) &&
       (1 < (int)local_38)) {
      local_44 = uVar4 + 1;
      local_3c = local_3c + (uint)(0xfffffffe < uVar4);
    }
    uVar7 = uVar7 - (uVar2 == 0);
    lVar10 = __alldiv(uVar2 + 299,local_34._4_4_ + (0xfffffed4 < uVar2),400,0);
    iVar6 = local_40[3];
    local_38 = (uint)(lVar10 + iVar6);
    uVar11 = __alldiv(uVar2 - 1,uVar7,100,0);
    bVar9 = local_38 < (uint)uVar11;
    local_38 = local_38 - (uint)uVar11;
    lVar12 = __alldiv(uVar2 - 1,uVar7,4,0);
    lVar10 = CONCAT44(((int)((ulonglong)(lVar10 + iVar6) >> 0x20) - (int)((ulonglong)uVar11 >> 0x20)
                      ) - (uint)bVar9,local_38);
    uVar13 = __allmul((uint)local_34,local_34._4_4_,0x16d,0);
    lVar10 = lVar12 + lVar10 + uVar13 + CONCAT44(local_3c,local_44);
    uVar4 = (uint)lVar10;
    uVar13 = __allmul(uVar4 - 0x63df,(int)((ulonglong)lVar10 >> 0x20) - (uint)(uVar4 < 0x63df),0x18,
                      0);
    piVar3 = local_40;
    uVar13 = __allmul((uint)(uVar13 + (longlong)local_40[2]),
                      (uint)(uVar13 + (longlong)local_40[2] >> 0x20),0x3c,0);
    uVar13 = __allmul((uint)(uVar13 + (longlong)piVar3[1]),
                      (uint)(uVar13 + (longlong)piVar3[1] >> 0x20),0x3c,0);
    local_34 = uVar13 + (longlong)*piVar3;
    if (param_2 == 0) {
      iVar6 = FUN_10022fb6((uint *)&local_2c,&local_34);
LAB_1002344b:
      uVar14 = (undefined)iVar15;
      if (iVar6 != 0) goto LAB_10023463;
    }
    else {
      ___tzset();
      iVar6 = FUN_1002c0c6(&local_48);
      if (iVar6 != 0) {
LAB_10023484:
        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
        pcVar1 = (code *)swi(3);
        (*pcVar1)();
        return;
      }
      iVar6 = FUN_1002c0f0((undefined4 *)&stack0xffffffb4);
      if (iVar6 != 0) goto LAB_10023484;
      local_34 = local_34 + iVar15;
      iVar6 = FUN_10022865(&local_2c,&local_34);
      uVar14 = (undefined)iVar15;
      if (iVar6 != 0) goto LAB_10023463;
      if ((0 < piVar3[8]) || ((piVar3[8] < 0 && (0 < local_2c.tm_isdst)))) {
        local_34 = local_34 + local_48;
        iVar6 = FUN_10022865(&local_2c,&local_34);
        goto LAB_1002344b;
      }
    }
    uVar5 = (undefined)((ulonglong)local_34 >> 0x20);
    ptVar8 = &local_2c;
    for (iVar15 = 9; iVar15 != 0; iVar15 = iVar15 + -1) {
      *piVar3 = ptVar8->tm_sec;
      ptVar8 = (tm *)&ptVar8->tm_min;
      piVar3 = piVar3 + 1;
    }
  }
LAB_10023475:
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,uVar5,uVar14);
  return;
}



void __cdecl FUN_100234a0(LPSTR param_1,uint param_2)

{
  FUN_100234b5(0,param_1,param_2);
  return;
}



LPSTR __cdecl FUN_100234b5(uint param_1,LPSTR param_2,uint param_3)

{
  int iVar1;
  ulong *puVar2;
  int *piVar3;
  uint uVar4;
  DWORD DVar5;
  LPSTR pCVar6;
  uint nBufferLength;
  LPSTR local_c;
  uint local_8;
  
  uVar4 = param_1;
  if (param_1 == 0) {
    uVar4 = FUN_1002ca94();
  }
  else {
    iVar1 = is_valid_drive(param_1);
    if (iVar1 == 0) {
      puVar2 = ___doserrno();
      *puVar2 = 0xf;
      piVar3 = __errno();
      *piVar3 = 0xd;
      FUN_10025625();
      return (LPSTR)0x0;
    }
  }
  nBufferLength = param_3;
  pCVar6 = param_2;
  if (param_2 == (LPSTR)0x0) {
    local_8 = 0;
  }
  else {
    if ((int)param_3 < 1) {
      piVar3 = __errno();
      *piVar3 = 0x16;
      FUN_10025625();
      return (LPSTR)0x0;
    }
    local_8 = param_3;
    *param_2 = '\0';
  }
  if (uVar4 == 0) {
    param_1 = CONCAT22(param_1._2_2_,0x2e);
  }
  else {
    param_1 = CONCAT31(0x2e3a,(char)uVar4 + '@');
  }
  DVar5 = GetFullPathNameA((LPCSTR)&param_1,local_8,param_2,&local_c);
  if (DVar5 != 0) {
    if (pCVar6 != (LPSTR)0x0) {
      if ((int)local_8 <= (int)DVar5) {
        piVar3 = __errno();
        *piVar3 = 0x22;
        *pCVar6 = '\0';
        return (LPSTR)0x0;
      }
      return pCVar6;
    }
    if ((int)nBufferLength < (int)DVar5) {
      nBufferLength = DVar5;
    }
    pCVar6 = (LPSTR)FUN_1002ca54(nBufferLength,1);
    if (pCVar6 == (LPSTR)0x0) {
      piVar3 = __errno();
      *piVar3 = 0xc;
      puVar2 = ___doserrno();
      *puVar2 = 8;
      return (LPSTR)0x0;
    }
    DVar5 = GetFullPathNameA((LPCSTR)&param_1,nBufferLength,pCVar6,&local_c);
    if ((DVar5 != 0) && ((int)DVar5 < (int)nBufferLength)) {
      return pCVar6;
    }
  }
  DVar5 = GetLastError();
  FID_conflict___dosmaperr(DVar5);
  return (LPSTR)0x0;
}



// Library Function - Single Match
//  int __cdecl is_valid_drive(unsigned int)
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

int __cdecl is_valid_drive(uint param_1)

{
  uint uVar1;
  ulong *puVar2;
  int *piVar3;
  int iVar4;
  undefined in_DL;
  undefined extraout_DL;
  undefined extraout_DL_00;
  char in_stack_fffffff0;
  
  uVar1 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  if (param_1 < 0x1b) {
    if (param_1 != 0) {
      in_stack_fffffff0 = (char)param_1 + '@';
      GetDriveTypeW((LPCWSTR)&stack0xfffffff0);
      in_DL = extraout_DL_00;
    }
  }
  else {
    puVar2 = ___doserrno();
    *puVar2 = 0xf;
    piVar3 = __errno();
    *piVar3 = 0xd;
    FUN_10025625();
    in_DL = extraout_DL;
  }
  iVar4 = FUN_1002534c(uVar1 ^ (uint)&stack0xfffffffc,in_DL,in_stack_fffffff0);
  return iVar4;
}



void FUN_1002364d(int *param_1,byte *param_2)

{
  int iVar1;
  DWORD *pDVar2;
  DWORD *pDVar3;
  DWORD local_24 [4];
  DWORD local_14;
  ULONG_PTR local_10;
  int *local_c;
  byte *local_8;
  
  pDVar2 = &DAT_10039794;
  pDVar3 = local_24;
  for (iVar1 = 8; iVar1 != 0; iVar1 = iVar1 + -1) {
    *pDVar3 = *pDVar2;
    pDVar2 = pDVar2 + 1;
    pDVar3 = pDVar3 + 1;
  }
  if ((param_2 != (byte *)0x0) && ((*param_2 & 0x10) != 0)) {
    iVar1 = *(int *)(*param_1 + -4);
    param_2 = *(byte **)(iVar1 + 0x18);
    (**(code **)(iVar1 + 0x20))((int *)(*param_1 + -4));
  }
  local_c = param_1;
  if ((param_2 != (byte *)0x0) && ((*param_2 & 8) != 0)) {
    local_10 = 0x1994000;
  }
  local_8 = param_2;
  RaiseException(local_24[0],local_24[1],local_14,&local_10);
  return;
}



void __cdecl FUN_100236b0(_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3)

{
  undefined in_DL;
  undefined1 unaff_SI;
  
  FUN_1002534c(param_2[2] ^ (uint)param_2,in_DL,unaff_SI);
  FUN_1002d8cd(param_1,(undefined4 *)param_2[4],param_3,(void *)0x0,(uint *)param_2[3],param_2[5],
               param_2,'\0');
  return;
}



// Library Function - Single Match
//  __TranslatorGuardHandler
// 
// Library: Visual Studio 2015 Release

undefined4 __cdecl
__TranslatorGuardHandler(_CONTEXT *param_1,EHRegistrationNode *param_2,_CONTEXT *param_3)

{
  undefined4 uVar1;
  undefined in_DL;
  undefined1 unaff_BL;
  code *local_8;
  
  FUN_1002534c(*(uint *)(param_2 + 8) ^ (uint)param_2,in_DL,unaff_BL);
  if ((param_1->Dr0 & 0x66) != 0) {
    *(undefined4 *)(param_2 + 0x24) = 1;
    return 1;
  }
  FUN_1002d8cd(param_1,*(undefined4 **)(param_2 + 0x10),param_3,(void *)0x0,
               *(uint **)(param_2 + 0xc),*(int *)(param_2 + 0x14),*(undefined4 **)(param_2 + 0x18),
               '\x01');
  if (*(int *)(param_2 + 0x24) == 0) {
    _UnwindNestedFrames(param_2,(EHExceptionRecord *)param_1);
  }
  FUN_100237e7((undefined4 *)0x123,&local_8,0,0,0,0,0);
                    // WARNING: Could not recover jumptable at 0x10023776. Too many branches
                    // WARNING: Treating indirect jump as call
  uVar1 = (*local_8)();
  return uVar1;
}



// Library Function - Single Match
//  void * __cdecl _CallCatchBlock2(struct EHRegistrationNode *,struct _s_FuncInfo const *,void
// *,int,unsigned long)
// 
// Library: Visual Studio 2015 Release

void * __cdecl
_CallCatchBlock2(EHRegistrationNode *param_1,_s_FuncInfo *param_2,void *param_3,int param_4,
                ulong param_5)

{
  void *pvVar1;
  int **in_FS_OFFSET;
  int *local_1c;
  code *local_18;
  uint local_14;
  _s_FuncInfo *local_10;
  EHRegistrationNode *local_c;
  int local_8;
  
  local_14 = DAT_10046c24 ^ (uint)&local_1c;
  local_10 = param_2;
  local_8 = param_4 + 1;
  local_18 = FUN_100236b0;
  local_c = param_1;
  local_1c = *in_FS_OFFSET;
  *in_FS_OFFSET = (int *)&local_1c;
  pvVar1 = (void *)__CallSettingFrame_12(param_3,param_1,param_5);
  *in_FS_OFFSET = local_1c;
  return pvVar1;
}



// Library Function - Multiple Matches With Different Base Names
//  void __stdcall _CallMemberFunction1(void *,void *,void *)
//  void __stdcall _CallMemberFunction2(void *,void *,void *,int)
// 
// Library: Visual Studio 2012 Release

void FID_conflict__CallMemberFunction1(undefined4 param_1,undefined *UNRECOVERED_JUMPTABLE)

{
                    // WARNING: Could not recover jumptable at 0x100237e5. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)UNRECOVERED_JUMPTABLE)();
  return;
}



undefined4 __cdecl
FUN_100237e7(undefined4 *param_1,undefined4 *param_2,undefined4 param_3,undefined4 param_4,
            undefined4 param_5,undefined4 param_6,undefined4 param_7)

{
  _ptiddata p_Var1;
  int *in_FS_OFFSET;
  undefined4 *local_3c;
  code *local_38;
  uint local_34;
  undefined4 local_30;
  undefined4 *local_2c;
  undefined4 local_28;
  undefined4 local_24;
  undefined *local_20;
  undefined *local_1c;
  int local_18;
  undefined4 *local_14;
  undefined4 local_10;
  code *local_c;
  undefined4 local_8;
  
  local_1c = &stack0xfffffffc;
  local_20 = &stack0xffffffc0;
  if (param_1 == (undefined4 *)0x123) {
    *param_2 = 0x10023890;
    local_8 = 1;
  }
  else {
    local_38 = __TranslatorGuardHandler;
    local_34 = DAT_10046c24 ^ (uint)&local_3c;
    local_30 = param_5;
    local_2c = param_2;
    local_28 = param_6;
    local_24 = param_7;
    local_18 = 0;
    local_3c = (undefined4 *)*in_FS_OFFSET;
    *in_FS_OFFSET = (int)&local_3c;
    local_8 = 1;
    local_14 = param_1;
    local_10 = param_3;
    p_Var1 = __getptd();
    local_c = (code *)p_Var1->_translator;
    (*local_c)(*param_1,&local_14);
    local_8 = 0;
    if (local_18 == 0) {
      *in_FS_OFFSET = (int)local_3c;
    }
    else {
      *local_3c = *(undefined4 *)*in_FS_OFFSET;
      *in_FS_OFFSET = (int)local_3c;
    }
  }
  return local_8;
}



int __cdecl FUN_100238be(int param_1,int param_2,int param_3,uint *param_4,uint *param_5)

{
  int iVar1;
  uint uVar2;
  uint uVar3;
  uint local_8;
  
  uVar2 = *(uint *)(param_1 + 0xc);
  iVar1 = *(int *)(param_1 + 0x10);
  uVar3 = uVar2;
  local_8 = uVar2;
  if (-1 < param_2) {
    do {
      if (uVar2 == 0xffffffff) {
        _inconsistency();
      }
      uVar2 = uVar2 - 1;
      if (((*(int *)(uVar2 * 0x14 + 4 + iVar1) < param_3) &&
          (param_3 <= *(int *)(uVar2 * 0x14 + 8 + iVar1))) || (uVar2 == 0xffffffff)) {
        param_2 = param_2 + -1;
        uVar3 = local_8;
        local_8 = uVar2;
      }
    } while (-1 < param_2);
  }
  uVar2 = uVar2 + 1;
  *param_4 = uVar2;
  *param_5 = uVar3;
  if ((*(uint *)(param_1 + 0xc) <= uVar3 && uVar3 != *(uint *)(param_1 + 0xc)) || (uVar3 < uVar2)) {
    _inconsistency();
  }
  return uVar2 * 0x14 + iVar1;
}



// Library Function - Single Match
//  void __stdcall _JumpToContinuation(void *,struct EHRegistrationNode *)
// 
// Library: Visual Studio 2015 Release

void _JumpToContinuation(void *param_1,EHRegistrationNode *param_2)

{
  undefined4 *in_FS_OFFSET;
  
  *in_FS_OFFSET = *(undefined4 *)*in_FS_OFFSET;
                    // WARNING: Could not recover jumptable at 0x10023965. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)param_1)();
  return;
}



// Library Function - Single Match
//  void __stdcall _UnwindNestedFrames(struct EHRegistrationNode *,struct EHExceptionRecord *)
// 
// Library: Visual Studio 2015 Release

void _UnwindNestedFrames(EHRegistrationNode *param_1,EHExceptionRecord *param_2)

{
  undefined4 *puVar1;
  undefined4 *in_FS_OFFSET;
  
  puVar1 = (undefined4 *)*in_FS_OFFSET;
  RtlUnwind(param_1,(PVOID)0x10023998,(PEXCEPTION_RECORD)param_2,(PVOID)0x0);
  *(uint *)(param_2 + 4) = *(uint *)(param_2 + 4) & 0xfffffffd;
  *puVar1 = *in_FS_OFFSET;
  *in_FS_OFFSET = puVar1;
  return;
}



// Library Function - Single Match
//  __CreateFrameInfo
// 
// Library: Visual Studio 2012 Release

undefined4 * __cdecl __CreateFrameInfo(undefined4 *param_1,undefined4 param_2)

{
  _ptiddata p_Var1;
  
  *param_1 = param_2;
  p_Var1 = __getptd();
  param_1[1] = p_Var1->_pFrameInfoChain;
  p_Var1 = __getptd();
  p_Var1->_pFrameInfoChain = param_1;
  return param_1;
}



// Library Function - Single Match
//  __FindAndUnlinkFrame
// 
// Library: Visual Studio 2012 Release

void __cdecl __FindAndUnlinkFrame(void *param_1)

{
  void *pvVar1;
  _ptiddata p_Var2;
  void *pvVar3;
  
  p_Var2 = __getptd();
  if (param_1 == p_Var2->_pFrameInfoChain) {
    p_Var2 = __getptd();
    p_Var2->_pFrameInfoChain = *(void **)((int)param_1 + 4);
  }
  else {
    p_Var2 = __getptd();
    pvVar1 = p_Var2->_pFrameInfoChain;
    do {
      pvVar3 = pvVar1;
      if (*(int *)((int)pvVar3 + 4) == 0) {
        _inconsistency();
        return;
      }
      pvVar1 = *(void **)((int)pvVar3 + 4);
    } while (param_1 != *(void **)((int)pvVar3 + 4));
    *(undefined4 *)((int)pvVar3 + 4) = *(undefined4 *)((int)param_1 + 4);
  }
  return;
}



// Library Function - Single Match
//  __IsExceptionObjectToBeDestroyed
// 
// Library: Visual Studio 2012 Release

undefined4 __cdecl __IsExceptionObjectToBeDestroyed(int param_1)

{
  int *piVar1;
  _ptiddata p_Var2;
  
  p_Var2 = __getptd();
  piVar1 = (int *)p_Var2->_pFrameInfoChain;
  while( true ) {
    if (piVar1 == (int *)0x0) {
      return 1;
    }
    if (*piVar1 == param_1) break;
    piVar1 = (int *)piVar1[1];
  }
  return 0;
}



// Library Function - Multiple Matches With Different Base Names
//  ___CxxFrameHandler
//  ___CxxFrameHandler2
//  ___CxxFrameHandler3
// 
// Library: Visual Studio

undefined4 __cdecl
FID_conflict____CxxFrameHandler3
          (_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4)

{
  uint *in_EAX;
  undefined4 uVar1;
  
  uVar1 = FUN_1002d8cd(param_1,param_2,param_3,param_4,in_EAX,0,(undefined4 *)0x0,'\0');
  return uVar1;
}



void __cdecl FUN_10023a9c(byte *param_1,byte *param_2)

{
  FUN_10023ab1(param_1,param_2,(pthreadlocinfo *)0x0);
  return;
}



uint __cdecl FUN_10023ab1(byte *param_1,byte *param_2,pthreadlocinfo *param_3)

{
  byte bVar1;
  byte bVar2;
  int *piVar3;
  ushort uVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  byte *pbVar8;
  byte *pbVar9;
  undefined local_14 [4];
  int local_10;
  int local_c;
  char local_8;
  
  FUN_1001f92e(local_14,param_3);
  if ((param_1 == (byte *)0x0) || (param_2 == (byte *)0x0)) {
    piVar3 = __errno();
    *piVar3 = 0x16;
    FUN_10025625();
    uVar6 = 0x7fffffff;
  }
  else if (*(int *)(local_10 + 8) == 0) {
    uVar6 = _strcmp((char *)param_1,(char *)param_2);
  }
  else {
    do {
      bVar2 = *param_1;
      pbVar8 = param_1 + 1;
      uVar5 = (uint)bVar2;
      if (((*(byte *)(bVar2 + 0x19 + local_10) & 4) != 0) &&
         (bVar1 = *pbVar8, uVar5 = 0, bVar1 != 0)) {
        pbVar8 = param_1 + 2;
        uVar5 = (uint)CONCAT11(bVar2,bVar1);
      }
      bVar2 = *param_2;
      pbVar9 = param_2 + 1;
      uVar6 = 0;
      uVar7 = (uint)bVar2;
      if (((*(byte *)(bVar2 + 0x19 + local_10) & 4) != 0) &&
         (bVar1 = *pbVar9, uVar7 = uVar6, bVar1 != 0)) {
        pbVar9 = param_2 + 2;
        uVar7 = (uint)CONCAT11(bVar2,bVar1);
      }
      uVar4 = (ushort)uVar5;
      if ((ushort)uVar7 != uVar4) {
        uVar6 = (-(uint)((ushort)uVar7 < uVar4) & 2) - 1;
        break;
      }
      param_1 = pbVar8;
      param_2 = pbVar9;
    } while (uVar4 != 0);
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return uVar6;
}



void __cdecl FUN_10023b7a(size_t param_1)

{
  FUN_1001f8b3(param_1);
  return;
}



uint __cdecl FUN_10023b83(uint *param_1,uint param_2,uint param_3,uint param_4,FILE *param_5)

{
  int iVar1;
  uint uVar2;
  int *piVar3;
  uint uVar4;
  uint uVar5;
  uint uVar6;
  uint *puVar7;
  uint local_10;
  uint local_c;
  uint *local_8;
  
  if (param_3 == 0) {
    return 0;
  }
  if (param_4 == 0) {
    return 0;
  }
  if (param_1 == (uint *)0x0) {
LAB_10023ba9:
    piVar3 = __errno();
    *piVar3 = 0x16;
  }
  else {
    if ((param_5 == (FILE *)0x0) || ((uint)(0xffffffff / (ulonglong)param_3) < param_4)) {
      if (param_2 != 0xffffffff) {
        FUN_10021290(param_1,0,param_2);
      }
      if ((param_5 == (FILE *)0x0) || ((uint)(0xffffffff / (ulonglong)param_3) < param_4))
      goto LAB_10023ba9;
    }
    uVar6 = param_3 * param_4;
    uVar2 = uVar6;
    local_8 = param_1;
    local_c = param_2;
    if ((param_5->_flag & 0x10cU) == 0) {
      local_10 = 0x1000;
    }
    else {
      local_10 = param_5->_bufsiz;
    }
    while( true ) {
      if (uVar2 == 0) {
        return param_4;
      }
      if ((param_5->_flag & 0x10cU) == 0) break;
      uVar4 = param_5->_cnt;
      if (uVar4 == 0) break;
      if ((int)uVar4 < 0) {
LAB_10023d30:
        param_5->_flag = param_5->_flag | 0x20;
LAB_10023d34:
        return (uVar6 - uVar2) / param_3;
      }
      if (uVar2 < uVar4) {
        uVar4 = uVar2;
      }
      if (local_c < uVar4) goto LAB_10023d0a;
      _memcpy_s(local_8,local_c,param_5->_ptr,uVar4);
      param_5->_cnt = param_5->_cnt - uVar4;
      param_5->_ptr = param_5->_ptr + uVar4;
LAB_10023cc8:
      iVar1 = -uVar4;
      local_8 = (uint *)((int)local_8 + uVar4);
      local_c = local_c - uVar4;
LAB_10023cfa:
      uVar2 = uVar2 + iVar1;
    }
    if (uVar2 < local_10) {
      uVar4 = FUN_100280b4(param_5);
      if (uVar4 == 0xffffffff) goto LAB_10023d34;
      if (local_c != 0) {
        *(char *)local_8 = (char)uVar4;
        local_8 = (uint *)((int)local_8 + 1);
        iVar1 = -1;
        local_c = local_c - 1;
        local_10 = param_5->_bufsiz;
        goto LAB_10023cfa;
      }
    }
    else {
      if (local_10 == 0) {
        uVar4 = 0x7fffffff;
        if (uVar2 < 0x80000000) {
          uVar4 = uVar2;
        }
      }
      else {
        if (uVar2 < 0x80000000) {
          uVar5 = uVar2 % local_10;
          uVar4 = uVar2;
        }
        else {
          uVar5 = (uint)(0x7fffffff % (ulonglong)local_10);
          uVar4 = 0x7fffffff;
        }
        uVar4 = uVar4 - uVar5;
      }
      if (uVar4 <= local_c) {
        puVar7 = local_8;
        uVar5 = __fileno(param_5);
        uVar4 = FUN_1002dba8(uVar5,(LPWSTR)puVar7,uVar4);
        if (uVar4 == 0) {
          param_5->_flag = param_5->_flag | 0x10;
          goto LAB_10023d34;
        }
        if (uVar4 != 0xffffffff) goto LAB_10023cc8;
        goto LAB_10023d30;
      }
    }
LAB_10023d0a:
    if (param_2 != 0xffffffff) {
      FUN_10021290(param_1,0,param_2);
    }
    piVar3 = __errno();
    *piVar3 = 0x22;
  }
  FUN_10025625();
  return 0;
}



// Library Function - Single Match
//  _fread
// 
// Library: Visual Studio 2012 Release

size_t __cdecl _fread(void *_DstBuf,size_t _ElementSize,size_t _Count,FILE *_File)

{
  size_t sVar1;
  
  sVar1 = _fread_s(_DstBuf,0xffffffff,_ElementSize,_Count,_File);
  return sVar1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _fread_s
// 
// Library: Visual Studio 2012 Release

size_t __cdecl _fread_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File)

{
  int *piVar1;
  uint uVar2;
  
  if ((_ElementSize != 0) && (_Count != 0)) {
    if (_File != (FILE *)0x0) {
      __lock_file(_File);
      uVar2 = FUN_10023b83((uint *)_DstBuf,_DstSize,_ElementSize,_Count,_File);
      FUN_10023dec();
      return uVar2;
    }
    if (_DstSize != 0xffffffff) {
      FUN_10021290((uint *)_DstBuf,0,_DstSize);
    }
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
  }
  return 0;
}



void FUN_10023dec(void)

{
  FILE *unaff_ESI;
  
  __unlock_file(unaff_ESI);
  return;
}



int __cdecl FUN_10023df4(FILE *param_1,int param_2,DWORD param_3)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  
  if ((param_1->_flag & 0x83U) == 0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    iVar2 = -1;
  }
  else {
    param_1->_flag = param_1->_flag & 0xffffffef;
    if (param_3 == 1) {
      iVar2 = FUN_10023f06(param_1);
      param_2 = param_2 + iVar2;
      param_3 = 0;
    }
    FUN_10027f63(param_1);
    uVar3 = param_1->_flag;
    if ((char)uVar3 < '\0') {
      param_1->_flag = uVar3 & 0xfffffffc;
    }
    else if ((((uVar3 & 1) != 0) && ((uVar3 & 8) != 0)) && ((uVar3 & 0x400) == 0)) {
      param_1->_bufsiz = 0x200;
    }
    uVar3 = __fileno(param_1);
    iVar2 = FUN_1002e339(uVar3,param_2,param_3);
    iVar2 = (iVar2 != -1) - 1;
  }
  return iVar2;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

int __cdecl FUN_10023e83(FILE *param_1,int param_2,DWORD param_3)

{
  int *piVar1;
  int iVar2;
  
  if ((param_1 == (FILE *)0x0) || (((param_3 != 0 && (param_3 != 1)) && (param_3 != 2)))) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    iVar2 = -1;
  }
  else {
    __lock_file(param_1);
    iVar2 = FUN_10023df4(param_1,param_2,param_3);
    FUN_10023efe();
  }
  return iVar2;
}



void FUN_10023efe(void)

{
  FILE *unaff_ESI;
  
  __unlock_file(unaff_ESI);
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe

void __cdecl FUN_10023f06(FILE *param_1)

{
  int iVar1;
  int *piVar2;
  uint uVar3;
  BOOL BVar4;
  uint uVar5;
  int iVar6;
  byte *pbVar7;
  byte extraout_DL;
  byte bVar8;
  byte *extraout_EDX;
  byte *extraout_EDX_00;
  byte *extraout_EDX_01;
  byte *pbVar9;
  char *pcVar10;
  byte *extraout_EDX_02;
  byte *extraout_EDX_03;
  char *pcVar11;
  undefined8 uVar12;
  undefined uVar13;
  uint in_stack_ffffefd4;
  char *local_1020;
  uint local_101c;
  FILE *local_1018;
  int local_1014;
  int local_1010;
  byte local_1009 [4097];
  uint local_8;
  
  uVar13 = (undefined)in_stack_ffffefd4;
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  local_1018 = param_1;
  if (param_1 == (FILE *)0x0) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    FUN_10025625();
    bVar8 = extraout_DL;
    goto LAB_10024287;
  }
  uVar3 = __fileno(param_1);
  if (param_1->_cnt < 0) {
    param_1->_cnt = 0;
  }
  local_101c = uVar3;
  local_1010 = FUN_1002e339(uVar3,0,1);
  pbVar7 = extraout_EDX;
  if (local_1010 < 0) {
LAB_10024224:
    bVar8 = (byte)pbVar7;
  }
  else {
    local_1014 = (int)uVar3 >> 5;
    iVar6 = (uVar3 & 0x1f) * 0x40;
    uVar3 = param_1->_flag;
    local_1009[0] = (char)(*(char *)(iVar6 + 0x24 + (&DAT_10835b98)[local_1014]) * '\x02') >> 1;
    bVar8 = local_1009[0];
    if ((uVar3 & 0x108) != 0) {
      pcVar11 = param_1->_ptr;
      local_1020 = param_1->_base;
      in_stack_ffffefd4 = (int)pcVar11 - (int)local_1020;
      if ((uVar3 & 3) == 0) {
        if ((uVar3 & 0x80) == 0) {
          piVar2 = __errno();
          *piVar2 = 0x16;
          pbVar7 = extraout_EDX_02;
          goto LAB_10024224;
        }
      }
      else {
        if ((local_1009[0] == 1) && (*(int *)(iVar6 + 0x30 + (&DAT_10835b98)[local_1014]) != 0)) {
          pcVar11 = (char *)(in_stack_ffffefd4 >> 1);
          if (local_1018->_cnt != 0) {
            uVar12 = FUN_1002e4cf(local_101c,
                                  *(undefined4 *)(iVar6 + 0x28 + (&DAT_10835b98)[local_1014]),
                                  *(undefined4 *)(iVar6 + 0x2c + (&DAT_10835b98)[local_1014]),0);
            pbVar7 = (byte *)((ulonglong)uVar12 >> 0x20);
            iVar1 = (&DAT_10835b98)[local_1014];
            if (((((int)uVar12 != *(int *)(iVar6 + 0x28 + iVar1)) ||
                 (pbVar7 != *(byte **)(iVar6 + 0x2c + iVar1))) ||
                (BVar4 = ReadFile(*(HANDLE *)(iVar6 + iVar1),local_1009 + 1,0x1000,
                                  (LPDWORD)&local_1020,(LPOVERLAPPED)0x0), pbVar7 = extraout_EDX_00,
                BVar4 == 0)) ||
               ((iVar6 = FUN_1002e339(local_101c,local_1010,0), pbVar7 = extraout_EDX_01, iVar6 < 0
                || (local_1020 < pcVar11)))) goto LAB_10024224;
            pbVar7 = local_1009 + 1;
            pbVar9 = extraout_EDX_01;
            if (pcVar11 != (char *)0x0) {
              pbVar9 = pbVar7 + (int)local_1020;
              do {
                pcVar11 = pcVar11 + -1;
                if (pbVar9 <= pbVar7) break;
                if (*pbVar7 == 0xd) {
                  if ((pbVar7 < local_1009 + (int)local_1020) && (pbVar7[1] == 10)) {
                    pbVar7 = pbVar7 + 1;
                  }
                }
                else {
                  pbVar7 = pbVar7 + (char)(&DAT_10047570)[*pbVar7];
                }
                pbVar7 = pbVar7 + 1;
              } while (pcVar11 != (char *)0x0);
            }
            bVar8 = (byte)pbVar9;
          }
          goto LAB_10024285;
        }
        pcVar10 = local_1020;
        if ((*(byte *)(iVar6 + 4 + (&DAT_10835b98)[local_1014]) & 0x80) != 0) {
          for (; pcVar10 < pcVar11; pcVar10 = pcVar10 + 1) {
          }
        }
      }
      if (((local_1010 != 0) && ((uVar3 & 1) != 0)) && (local_1018->_cnt != 0)) {
        pcVar10 = local_1018->_base;
        iVar1 = local_1018->_cnt;
        uVar3 = 0;
        if ((*(byte *)(iVar6 + 4 + (&DAT_10835b98)[local_1014]) & 0x80) != 0) {
          iVar6 = FUN_1002e339(local_101c,0,2);
          if (iVar6 == local_1010) {
            uVar5 = ~-(uint)(local_1018->_base + (int)(pcVar11 + (iVar1 - (int)pcVar10)) <
                            local_1018->_base) &
                    (int)(local_1018->_base + (int)(pcVar11 + (iVar1 - (int)pcVar10))) -
                    (int)local_1018->_base;
            bVar8 = local_1009[0];
            if (uVar5 != 0) {
              do {
                uVar3 = uVar3 + 1;
              } while (uVar3 < uVar5);
            }
          }
          else {
            iVar6 = FUN_1002e339(local_101c,local_1010,0);
            pbVar7 = extraout_EDX_03;
            bVar8 = local_1009[0];
            if (iVar6 < 0) goto LAB_10024224;
          }
        }
      }
    }
  }
LAB_10024285:
  uVar13 = (undefined)in_stack_ffffefd4;
LAB_10024287:
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,bVar8,uVar13);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

undefined4 __cdecl FUN_10024296(FILE *param_1)

{
  int *piVar1;
  undefined4 uVar2;
  
  if (param_1 == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    uVar2 = 0xffffffff;
  }
  else {
    __lock_file(param_1);
    uVar2 = FUN_10023f06(param_1);
    FUN_100242fa();
  }
  return uVar2;
}



void FUN_100242fa(void)

{
  FILE *unaff_ESI;
  
  __unlock_file(unaff_ESI);
  return;
}



uint __cdecl FUN_10024302(WCHAR *param_1,uint param_2,uint param_3,FILE *param_4)

{
  int *piVar1;
  uint uVar2;
  int iVar3;
  WCHAR *pWVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  WCHAR *pWVar9;
  uint local_8;
  
  if ((param_2 != 0) && (param_3 != 0)) {
    if ((param_4 != (FILE *)0x0) &&
       ((param_1 != (WCHAR *)0x0 && (param_3 <= (uint)(0xffffffff / (ulonglong)param_2))))) {
      uVar8 = param_2 * param_3;
      uVar7 = uVar8;
      if ((param_4->_flag & 0x10cU) == 0) {
        local_8 = 0x1000;
      }
      else {
        local_8 = param_4->_bufsiz;
      }
      do {
        while( true ) {
          if (uVar7 == 0) {
            return param_3;
          }
          uVar6 = param_4->_flag & 0x108;
          if (uVar6 != 0) break;
LAB_100243af:
          if (local_8 <= uVar7) {
            if ((uVar6 != 0) && (iVar3 = FUN_10027f63(param_4), iVar3 != 0)) goto LAB_1002444d;
            uVar6 = uVar7;
            if (local_8 != 0) {
              uVar6 = uVar7 - uVar7 % local_8;
            }
            pWVar9 = param_1;
            uVar2 = uVar6;
            pWVar4 = (WCHAR *)__fileno(param_4);
            uVar5 = FUN_1002e63e(pWVar4,pWVar9,uVar2);
            if (uVar5 != 0xffffffff) {
              uVar2 = uVar6;
              if (uVar5 <= uVar6) {
                uVar2 = uVar5;
              }
              uVar7 = uVar7 - uVar2;
              if (uVar6 <= uVar5) goto LAB_1002440c;
            }
            goto LAB_10024449;
          }
          uVar6 = FUN_1002ac01((int)*(char *)param_1,param_4);
          if (uVar6 == 0xffffffff) goto LAB_1002444d;
          param_1 = (WCHAR *)((int)param_1 + 1);
          uVar7 = uVar7 - 1;
          local_8 = param_4->_bufsiz;
          if ((int)local_8 < 1) {
            local_8 = 1;
          }
        }
        uVar2 = param_4->_cnt;
        if (uVar2 == 0) goto LAB_100243af;
        if ((int)uVar2 < 0) {
LAB_10024449:
          param_4->_flag = param_4->_flag | 0x20;
LAB_1002444d:
          return (uVar8 - uVar7) / param_2;
        }
        if (uVar7 < uVar2) {
          uVar2 = uVar7;
        }
        FID_conflict__memcpy(param_4->_ptr,param_1,uVar2);
        param_4->_cnt = param_4->_cnt - uVar2;
        uVar7 = uVar7 - uVar2;
        param_4->_ptr = param_4->_ptr + uVar2;
LAB_1002440c:
        param_1 = (WCHAR *)((int)param_1 + uVar2);
      } while( true );
    }
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
  }
  return 0;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

uint __cdecl FUN_1002445b(WCHAR *param_1,uint param_2,uint param_3,FILE *param_4)

{
  int *piVar1;
  uint uVar2;
  
  if ((param_2 != 0) && (param_3 != 0)) {
    if (param_4 != (FILE *)0x0) {
      __lock_file(param_4);
      uVar2 = FUN_10024302(param_1,param_2,param_3,param_4);
      FUN_100244d5();
      return uVar2;
    }
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
  }
  return 0;
}



void FUN_100244d5(void)

{
  FILE *unaff_ESI;
  
  __unlock_file(unaff_ESI);
  return;
}



uint FUN_100244dd(void)

{
  _ptiddata p_Var1;
  uint uVar2;
  
  p_Var1 = __getptd();
  uVar2 = p_Var1->_holdrand * 0x343fd + 0x269ec3;
  p_Var1->_holdrand = uVar2;
  return uVar2 >> 0x10 & 0x7fff;
}



void __cdecl FUN_100244fe(ulong param_1)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd();
  p_Var1->_holdrand = param_1;
  return;
}



undefined4 FUN_1002450e(void)

{
  undefined **ppuVar1;
  int iVar2;
  uint uVar3;
  
  uVar3 = 0x14;
  if (DAT_10837ba4 == 0) {
    uVar3 = 0x200;
  }
  else if (0x13 < (int)DAT_10837ba4) goto LAB_1002452d;
  DAT_10837ba4 = uVar3;
LAB_1002452d:
  DAT_10837ba0 = FUN_10026edb(DAT_10837ba4,4);
  if (DAT_10837ba0 == (LPVOID)0x0) {
    DAT_10837ba4 = 0x14;
    DAT_10837ba0 = FUN_10026edb(0x14,4);
    if (DAT_10837ba0 == (LPVOID)0x0) {
      return 0x1a;
    }
  }
  iVar2 = 0;
  ppuVar1 = &PTR_DAT_100467e8;
  do {
    *(undefined ***)(iVar2 + (int)DAT_10837ba0) = ppuVar1;
    ppuVar1 = ppuVar1 + 8;
    iVar2 = iVar2 + 4;
  } while ((int)ppuVar1 < 0x10046a68);
  return 0;
}



void FUN_10024581(void)

{
  FUN_10027fc7();
  if (DAT_10835b80 != '\0') {
    FUN_1002ef92();
  }
  FID_conflict__free(DAT_10837ba0);
  DAT_10837ba0 = (void *)0x0;
  return;
}



undefined ** FUN_100245a8(void)

{
  return &PTR_DAT_100467e8;
}



// Library Function - Single Match
//  __lock_file
// 
// Library: Visual Studio 2012 Release

void __cdecl __lock_file(FILE *_File)

{
  if ((_File < &PTR_DAT_100467e8) || ((FILE *)&DAT_10046a48 < _File)) {
    EnterCriticalSection((LPCRITICAL_SECTION)(_File + 1));
  }
  else {
    __lock(((int)&_File[-0x802340]._bufsiz >> 5) + 0x10);
    _File->_flag = _File->_flag | 0x8000;
  }
  return;
}



// Library Function - Single Match
//  __lock_file2
// 
// Library: Visual Studio 2012 Release

void __cdecl __lock_file2(int _Index,void *_File)

{
  if (_Index < 0x14) {
    __lock(_Index + 0x10);
    *(uint *)((int)_File + 0xc) = *(uint *)((int)_File + 0xc) | 0x8000;
    return;
  }
  EnterCriticalSection((LPCRITICAL_SECTION)((int)_File + 0x20));
  return;
}



// Library Function - Single Match
//  __unlock_file
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

void __cdecl __unlock_file(FILE *_File)

{
  if (((FILE *)0x100467e7 < _File) && (_File < (FILE *)0x10046a49)) {
    _File->_flag = _File->_flag & 0xffff7fff;
    FUN_1002f199(((int)&_File[-0x802340]._bufsiz >> 5) + 0x10);
    return;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)(_File + 1));
  return;
}



// Library Function - Single Match
//  __unlock_file2
// 
// Library: Visual Studio 2012 Release

void __cdecl __unlock_file2(int _Index,void *_File)

{
  if (_Index < 0x14) {
    *(uint *)((int)_File + 0xc) = *(uint *)((int)_File + 0xc) & 0xffff7fff;
    FUN_1002f199(_Index + 0x10);
    return;
  }
  LeaveCriticalSection((LPCRITICAL_SECTION)((int)_File + 0x20));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 * __cdecl FUN_10024684(uint param_1,char *param_2)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  int *piVar5;
  undefined4 *puVar6;
  uint uVar7;
  
  if (param_2 != (char *)0x0) {
    if (param_1 == 0xfffffffe) {
      piVar5 = __errno();
      *piVar5 = 9;
      return (undefined4 *)0x0;
    }
    if ((((int)param_1 < 0) || (DAT_10836b84 <= param_1)) ||
       ((*(byte *)((&DAT_10835b98)[(int)param_1 >> 5] + 4 + (param_1 & 0x1f) * 0x40) & 1) == 0)) {
      piVar5 = __errno();
      *piVar5 = 9;
      goto LAB_100246f5;
    }
    for (; *param_2 == ' '; param_2 = param_2 + 1) {
    }
    cVar1 = *param_2;
    if (cVar1 != 'a') {
      if (cVar1 == 'r') {
        uVar7 = 1;
        goto LAB_10024719;
      }
      if (cVar1 != 'w') goto LAB_1002469e;
    }
    uVar7 = 2;
LAB_10024719:
    bVar2 = true;
    bVar4 = false;
    bVar3 = false;
    uVar7 = uVar7 | DAT_10836598;
LAB_1002478f:
    do {
      param_2 = param_2 + 1;
      cVar1 = *param_2;
      if ((cVar1 == '\0') || (!bVar2)) goto LAB_10024799;
    } while (cVar1 == ' ');
    if (cVar1 == '+') {
      if (-1 < (char)uVar7) {
        uVar7 = uVar7 & 0xfffffffc | 0x80;
        goto LAB_1002478f;
      }
    }
    else if (cVar1 == 'b') {
LAB_10024755:
      if (!bVar3) {
        bVar3 = true;
        goto LAB_1002478f;
      }
    }
    else if (cVar1 == 'c') {
      if (!bVar4) {
        bVar4 = true;
        uVar7 = uVar7 | 0x4000;
        goto LAB_1002478f;
      }
    }
    else {
      if (cVar1 != 'n') {
        if (cVar1 == 't') goto LAB_10024755;
        goto LAB_1002469e;
      }
      if (!bVar4) {
        bVar4 = true;
        uVar7 = uVar7 & 0xffffbfff;
        goto LAB_1002478f;
      }
    }
    bVar2 = false;
    goto LAB_1002478f;
  }
  goto LAB_1002469e;
LAB_10024799:
  for (; *param_2 == ' '; param_2 = param_2 + 1) {
  }
  if (*param_2 == '\0') {
    puVar6 = FUN_100284db();
    if (puVar6 == (undefined4 *)0x0) {
      piVar5 = __errno();
      *piVar5 = 0x18;
      return (undefined4 *)0x0;
    }
    _DAT_10835b14 = _DAT_10835b14 + 1;
    puVar6[3] = uVar7;
    puVar6[4] = param_1;
    FUN_100247f1();
    return puVar6;
  }
LAB_1002469e:
  piVar5 = __errno();
  *piVar5 = 0x16;
LAB_100246f5:
  FUN_10025625();
  return (undefined4 *)0x0;
}



void FUN_100247f1(void)

{
  FILE *unaff_ESI;
  
  __unlock_file(unaff_ESI);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _setvbuf
// 
// Library: Visual Studio 2012 Release

int __cdecl _setvbuf(FILE *_File,char *_Buf,int _Mode,size_t _Size)

{
  int *piVar1;
  uint uVar2;
  int iVar3;
  
  iVar3 = 0;
  if (_File == (FILE *)0x0) goto LAB_10024818;
  if (_Mode == 4) {
LAB_10024841:
    if ((_Mode == 0) || (_Mode == 0x40)) goto LAB_1002484f;
  }
  else {
    if (_Mode != 0) {
      if (_Mode != 0x40) goto LAB_10024818;
      goto LAB_10024841;
    }
LAB_1002484f:
    if (0x7ffffffd < _Size - 2) {
LAB_10024818:
      piVar1 = __errno();
      *piVar1 = 0x16;
      FUN_10025625();
      return -1;
    }
  }
  uVar2 = _Size & 0xfffffffe;
  __lock_file(_File);
  FUN_10027f63(_File);
  __freebuf(_File);
  _File->_flag = _File->_flag & 0xffffc2f3;
  if ((_Mode & 4U) == 0) {
    if (_Buf == (char *)0x0) {
      _Buf = (char *)FUN_10026f23(uVar2);
      if ((int *)_Buf == (int *)0x0) {
        _DAT_10835b14 = _DAT_10835b14 + 1;
        iVar3 = -1;
        goto LAB_100248dd;
      }
      _File->_flag = _File->_flag | 0x408;
    }
    else {
      _File->_flag = _File->_flag | 0x500;
    }
  }
  else {
    _File->_flag = _File->_flag | 4;
    _Buf = (char *)&_File->_charbuf;
    uVar2 = 2;
  }
  _File->_bufsiz = uVar2;
  _File->_base = _Buf;
  _File->_ptr = _Buf;
  _File->_cnt = 0;
LAB_100248dd:
  FUN_100248f7();
  return iVar3;
}



void FUN_100248f7(void)

{
  FILE *unaff_ESI;
  
  __unlock_file(unaff_ESI);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

undefined4 __cdecl FUN_100248ff(uint param_1)

{
  int iVar1;
  
  iVar1 = (param_1 & 0x1f) * 0x40 + (&DAT_10835b98)[(int)param_1 >> 5];
  if (*(int *)(iVar1 + 8) == 0) {
    __lock(10);
    if (*(int *)(iVar1 + 8) == 0) {
      FUN_1002bd5a((LPCRITICAL_SECTION)(iVar1 + 0xc),4000,0);
      *(int *)(iVar1 + 8) = *(int *)(iVar1 + 8) + 1;
    }
    FUN_10024984();
  }
  EnterCriticalSection
            ((LPCRITICAL_SECTION)
             ((&DAT_10835b98)[(int)param_1 >> 5] + 0xc + (param_1 & 0x1f) * 0x40));
  return 1;
}



void FUN_10024984(void)

{
  FUN_1002f199(10);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

uint FUN_1002498d(void)

{
  int iVar1;
  undefined4 *puVar2;
  uint uVar3;
  
  uVar3 = 0xffffffff;
  iVar1 = FUN_1002f0b7(0xb);
  if (iVar1 == 0) {
    uVar3 = 0xffffffff;
  }
  else {
    __lock(0xb);
    for (iVar1 = 0; iVar1 < 0x40; iVar1 = iVar1 + 1) {
      puVar2 = (undefined4 *)(&DAT_10835b98)[iVar1];
      if (puVar2 == (undefined4 *)0x0) {
        puVar2 = (undefined4 *)FUN_10026edb(0x20,0x40);
        if (puVar2 != (undefined4 *)0x0) {
          (&DAT_10835b98)[iVar1] = puVar2;
          DAT_10836b84 = DAT_10836b84 + 0x20;
          for (; puVar2 < (undefined4 *)((&DAT_10835b98)[iVar1] + 0x800); puVar2 = puVar2 + 0x10) {
            *(undefined2 *)(puVar2 + 1) = 0xa00;
            *puVar2 = 0xffffffff;
            puVar2[2] = 0;
          }
          uVar3 = iVar1 << 5;
          *(undefined *)((&DAT_10835b98)[(int)uVar3 >> 5] + 4) = 1;
          iVar1 = FUN_100248ff(uVar3);
          if (iVar1 == 0) {
            uVar3 = 0xffffffff;
          }
        }
        break;
      }
      for (; puVar2 < (undefined4 *)((&DAT_10835b98)[iVar1] + 0x800); puVar2 = puVar2 + 0x10) {
        if ((*(byte *)(puVar2 + 1) & 1) == 0) {
          if (puVar2[2] == 0) {
            __lock(10);
            if (puVar2[2] == 0) {
              FUN_1002bd5a((LPCRITICAL_SECTION)(puVar2 + 3),4000,0);
              puVar2[2] = puVar2[2] + 1;
            }
            FUN_10024a65();
          }
          if (true) {
            EnterCriticalSection((LPCRITICAL_SECTION)(puVar2 + 3));
            if ((*(byte *)(puVar2 + 1) & 1) == 0) {
              if (true) {
                *(undefined *)(puVar2 + 1) = 1;
                *puVar2 = 0xffffffff;
                uVar3 = ((int)puVar2 - (&DAT_10835b98)[iVar1] >> 6) + iVar1 * 0x20;
                break;
              }
            }
            else {
              LeaveCriticalSection((LPCRITICAL_SECTION)(puVar2 + 3));
            }
          }
        }
      }
      if (uVar3 != 0xffffffff) break;
    }
    FUN_10024b2d();
  }
  return uVar3;
}



void FUN_10024a65(void)

{
  FUN_1002f199(10);
  return;
}



void FUN_10024b2d(void)

{
  FUN_1002f199(0xb);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 __cdecl FUN_10024b36(uint param_1)

{
  int *piVar1;
  ulong *puVar2;
  int iVar3;
  DWORD nStdHandle;
  
  if ((-1 < (int)param_1) && (param_1 < DAT_10836b84)) {
    iVar3 = (param_1 & 0x1f) * 0x40;
    if (((*(byte *)(iVar3 + 4 + (&DAT_10835b98)[(int)param_1 >> 5]) & 1) != 0) &&
       (*(int *)(iVar3 + (&DAT_10835b98)[(int)param_1 >> 5]) != -1)) {
      if (_DAT_10835d38 == 1) {
        if (param_1 == 0) {
          nStdHandle = 0xfffffff6;
        }
        else if (param_1 == 1) {
          nStdHandle = 0xfffffff5;
        }
        else {
          if (param_1 != 2) goto LAB_10024b93;
          nStdHandle = 0xfffffff4;
        }
        SetStdHandle(nStdHandle,(HANDLE)0x0);
      }
LAB_10024b93:
      *(undefined4 *)(iVar3 + (&DAT_10835b98)[(int)param_1 >> 5]) = 0xffffffff;
      return 0;
    }
  }
  piVar1 = __errno();
  *piVar1 = 9;
  puVar2 = ___doserrno();
  *puVar2 = 0;
  return 0xffffffff;
}



undefined4 __cdecl FUN_10024bbc(uint param_1)

{
  ulong *puVar1;
  int *piVar2;
  int iVar3;
  
  if (param_1 == 0xfffffffe) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if ((-1 < (int)param_1) && (param_1 < DAT_10836b84)) {
      iVar3 = (param_1 & 0x1f) * 0x40;
      if ((*(byte *)((&DAT_10835b98)[(int)param_1 >> 5] + 4 + iVar3) & 1) != 0) {
        return *(undefined4 *)((&DAT_10835b98)[(int)param_1 >> 5] + iVar3);
      }
    }
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    FUN_10025625();
  }
  return 0xffffffff;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __open_osfhandle
// 
// Library: Visual Studio 2012 Release

int __cdecl __open_osfhandle(intptr_t _OSFileHandle,int _Flags)

{
  byte *pbVar1;
  DWORD DVar2;
  uint uVar3;
  int *piVar4;
  ulong *puVar5;
  int iVar6;
  int iVar7;
  byte bVar8;
  
  bVar8 = 0;
  if ((_Flags & 8U) != 0) {
    bVar8 = 0x20;
  }
  if ((_Flags & 0x4000U) != 0) {
    bVar8 = bVar8 | 0x80;
  }
  if ((_Flags & 0x80U) != 0) {
    bVar8 = bVar8 | 0x10;
  }
  DVar2 = GetFileType((HANDLE)_OSFileHandle);
  if (DVar2 == 0) {
    DVar2 = GetLastError();
    FID_conflict___dosmaperr(DVar2);
  }
  else {
    if (DVar2 == 2) {
      bVar8 = bVar8 | 0x40;
    }
    else if (DVar2 == 3) {
      bVar8 = bVar8 | 8;
    }
    uVar3 = FUN_1002498d();
    if (uVar3 != 0xffffffff) {
      FUN_10024d39(uVar3,(HANDLE)_OSFileHandle);
      iVar7 = (int)uVar3 >> 5;
      iVar6 = (uVar3 & 0x1f) * 0x40;
      *(byte *)(iVar6 + 4 + (&DAT_10835b98)[iVar7]) = bVar8 | 1;
      pbVar1 = (byte *)(iVar6 + 0x24 + (&DAT_10835b98)[iVar7]);
      *pbVar1 = *pbVar1 & 0x80;
      pbVar1 = (byte *)(iVar6 + 0x24 + (&DAT_10835b98)[iVar7]);
      *pbVar1 = *pbVar1 & 0x7f;
      FUN_10024d14();
      if (true) {
        return uVar3;
      }
      return -1;
    }
    piVar4 = __errno();
    *piVar4 = 0x18;
    puVar5 = ___doserrno();
    *puVar5 = 0;
  }
  return -1;
}



void FUN_10024d14(void)

{
  byte *pbVar1;
  uint unaff_ESI;
  int unaff_EDI;
  
  if (unaff_EDI == 0) {
    pbVar1 = (byte *)((&DAT_10835b98)[(int)unaff_ESI >> 5] + 4 + (unaff_ESI & 0x1f) * 0x40);
    *pbVar1 = *pbVar1 & 0xfe;
  }
  FUN_10024dbb(unaff_ESI);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 __cdecl FUN_10024d39(uint param_1,HANDLE param_2)

{
  int *piVar1;
  ulong *puVar2;
  int iVar3;
  DWORD nStdHandle;
  
  if ((-1 < (int)param_1) && (param_1 < DAT_10836b84)) {
    iVar3 = (param_1 & 0x1f) * 0x40;
    if (*(int *)(iVar3 + (&DAT_10835b98)[(int)param_1 >> 5]) == -1) {
      if (_DAT_10835d38 == 1) {
        if (param_1 == 0) {
          nStdHandle = 0xfffffff6;
        }
        else if (param_1 == 1) {
          nStdHandle = 0xfffffff5;
        }
        else {
          if (param_1 != 2) goto LAB_10024d92;
          nStdHandle = 0xfffffff4;
        }
        SetStdHandle(nStdHandle,param_2);
      }
LAB_10024d92:
      *(HANDLE *)(iVar3 + (&DAT_10835b98)[(int)param_1 >> 5]) = param_2;
      return 0;
    }
  }
  piVar1 = __errno();
  *piVar1 = 9;
  puVar2 = ___doserrno();
  *puVar2 = 0;
  return 0xffffffff;
}



void __cdecl FUN_10024dbb(uint param_1)

{
  LeaveCriticalSection
            ((LPCRITICAL_SECTION)
             ((&DAT_10835b98)[(int)param_1 >> 5] + (param_1 & 0x1f) * 0x40 + 0xc));
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_10024de1(undefined4 param_1,int param_2,int param_3)

{
  bool bVar1;
  undefined3 extraout_var;
  undefined4 uVar2;
  int iVar3;
  DWORD *_Memory;
  DWORD DVar4;
  
  if (param_2 == 1) {
    bVar1 = FUN_1002a9ca();
    if (CONCAT31(extraout_var,bVar1) != 0) {
      iVar3 = FUN_10026667();
      if (iVar3 != 0) {
        FUN_1002f760();
        DAT_10836b9c = GetCommandLineA();
        DAT_10835b1c = FUN_1002f6d3();
        iVar3 = FUN_100281d5();
        if (-1 < iVar3) {
          iVar3 = FUN_1002f327();
          if (-1 < iVar3) {
            iVar3 = FUN_1002f556();
            if (-1 < iVar3) {
              iVar3 = FUN_10026c41(0);
              if (iVar3 == 0) {
                DAT_10835b18 = DAT_10835b18 + 1;
                goto LAB_10024f48;
              }
            }
          }
          __ioterm();
        }
        FUN_100266dd();
      }
      FUN_1002a9df();
    }
LAB_10024dfe:
    uVar2 = 0;
  }
  else {
    if (param_2 == 0) {
      if (DAT_10835b18 < 1) goto LAB_10024dfe;
      DAT_10835b18 = DAT_10835b18 + -1;
      if (_DAT_10835b84 == 0) {
        __cexit();
      }
      FUN_10026b09();
      if (param_3 == 0) {
        __ioterm();
        FUN_100266dd();
        FUN_1002a9df();
      }
      FUN_10024ec3();
    }
    else if (param_2 == 2) {
      iVar3 = FUN_1002bd19(DAT_10047150);
      if (iVar3 == 0) {
        _Memory = (DWORD *)FUN_10026edb(1,0x3bc);
        if (_Memory != (DWORD *)0x0) {
          iVar3 = FUN_1002bd38(DAT_10047150,_Memory);
          if (iVar3 != 0) {
            FUN_100265b4((int)_Memory,0);
            DVar4 = GetCurrentThreadId();
            *_Memory = DVar4;
            _Memory[1] = 0xffffffff;
            goto LAB_10024f48;
          }
          FID_conflict__free(_Memory);
        }
        goto LAB_10024dfe;
      }
    }
    else if (param_2 == 3) {
      FUN_100264f7((void *)0x0);
    }
LAB_10024f48:
    uVar2 = 1;
  }
  return uVar2;
}



void FUN_10024ec3(void)

{
  int unaff_ESI;
  
  if ((unaff_ESI == 0) && (DAT_10047150 != -1)) {
    FUN_100266dd();
  }
  return;
}



void entry(undefined4 param_1,int param_2,int param_3)

{
  if (param_2 == 1) {
    ___security_init_cookie();
  }
  ___DllMainCRTStartup(param_1,param_2,param_3);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___DllMainCRTStartup
// 
// Library: Visual Studio 2012 Release

uint __cdecl ___DllMainCRTStartup(undefined4 param_1,int param_2,int param_3)

{
  int iVar1;
  uint uVar2;
  
  iVar1 = 1;
  if ((param_2 == 0) && (DAT_10835b18 == 0)) {
LAB_1002507c:
    uVar2 = 0;
  }
  else {
    if ((param_2 == 1) || (param_2 == 2)) {
      if (false) {
        iVar1 = (*(code *)0x0)(param_1,param_2,param_3);
      }
      if ((iVar1 == 0) || (iVar1 = FUN_10024de1(param_1,param_2,param_3), iVar1 == 0))
      goto LAB_1002507c;
    }
    uVar2 = FUN_10002490(param_1);
    if ((param_2 == 1) && (uVar2 == 0)) {
      FUN_10002490(param_1);
      FUN_10024de1(param_1,0,param_3);
      if (false) {
        (*(code *)0x0)(param_1,0,param_3);
      }
    }
    if ((param_2 == 0) || (param_2 == 3)) {
      iVar1 = FUN_10024de1(param_1,param_2,param_3);
      uVar2 = uVar2 & -(uint)(iVar1 != 0);
      if ((uVar2 != 0) && (false)) {
        uVar2 = (*(code *)0x0)(param_1,param_2,param_3);
      }
    }
  }
  return uVar2;
}



// Library Function - Single Match
//  ___DllXcptFilter
// 
// Library: Visual Studio 2012 Release

void __cdecl
___DllXcptFilter(undefined4 param_1,int param_2,int param_3,ulong param_4,
                _EXCEPTION_POINTERS *param_5)

{
  if (param_2 == 1) {
    FUN_10024de1(param_1,0,param_3);
  }
  ___CppXcptFilter(param_4,param_5);
  return;
}



// Library Function - Single Match
//  __decomp
// 
// Library: Visual Studio 2019 Release

void __cdecl __decomp(int param_1,uint param_2,int *param_3)

{
  uint uVar1;
  double dVar2;
  ushort uVar3;
  int iVar4;
  
  dVar2 = (double)CONCAT17(param_2._3_1_,CONCAT16(param_2._2_1_,CONCAT24((ushort)param_2,param_1)));
  if (dVar2 == 0.0) {
    iVar4 = 0;
  }
  else if (((param_2 & 0x7ff00000) == 0) && (((param_2 & 0xfffff) != 0 || (param_1 != 0)))) {
    iVar4 = -0x3fd;
    if ((param_2 & 0x100000) == 0) {
      do {
        uVar1 = param_2 * 2;
        param_2._0_2_ = (ushort)uVar1;
        param_2 = uVar1;
        if (param_1 < 0) {
          param_2 = uVar1 | 1;
        }
        param_1 = param_1 * 2;
        iVar4 = iVar4 + -1;
      } while ((uVar1 & 0x100000) == 0);
      param_2 = uVar1 & 0xffff0000 | (uint)(ushort)param_2;
    }
    uVar3 = (ushort)(param_2 >> 0x10) & 0xffef;
    param_2._2_1_ = (undefined)uVar3;
    param_2._3_1_ = (byte)(uVar3 >> 8);
    if ((ushort)((ushort)(0.0 < dVar2) << 8 | (ushort)(dVar2 == 0.0) << 0xe) == 0) {
      param_2._3_1_ = param_2._3_1_ | 0x80;
    }
    __set_exp(CONCAT17(param_2._3_1_,CONCAT16(param_2._2_1_,CONCAT24((ushort)param_2,param_1))),0);
  }
  else {
    __set_exp((ulonglong)dVar2,0);
    iVar4 = (param_2 >> 0x14 & 0x7ff) - 0x3fe;
  }
  *param_3 = iVar4;
  return;
}



// Library Function - Single Match
//  __set_exp
// 
// Library: Visual Studio 2019 Release

float10 __cdecl __set_exp(ulonglong param_1,short param_2)

{
  double local_c;
  
  local_c = (double)(param_1 & 0xffffffffffff |
                    (ulonglong)(ushort)((param_2 + 0x3fe) * 0x10 | param_1._6_2_ & 0x800f) << 0x30);
  return (float10)local_c;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___set_fpsr_sse2
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release

void ___set_fpsr_sse2(uint param_1)

{
  return;
}



int FUN_10025220(void)

{
  short in_FPUStatusWord;
  
  return (int)in_FPUStatusWord;
}



// Library Function - Single Match
//  __ctrlfp
// 
// Library: Visual Studio 2019 Release

int __ctrlfp(undefined4 param_1,undefined4 param_2)

{
  short in_FPUControlWord;
  
  return (int)in_FPUControlWord;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __set_statfp
// 
// Library: Visual Studio 2019 Release

void __set_statfp(uint param_1)

{
  return;
}



int FUN_100252b4(void)

{
  short in_FPUStatusWord;
  
  return (int)in_FPUStatusWord;
}



// Library Function - Single Match
//  ___doserrno
// 
// Library: Visual Studio 2012 Release

ulong * __cdecl ___doserrno(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd_noexit();
  if (p_Var1 == (_ptiddata)0x0) {
    return (ulong *)&DAT_10046c1c;
  }
  return &p_Var1->_tdoserrno;
}



// Library Function - Multiple Matches With Different Base Names
//  ___acrt_errno_map_os_error
//  __dosmaperr
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
// Visual Studio 2019 Release

void __cdecl FID_conflict___dosmaperr(ulong param_1)

{
  ulong *puVar1;
  int iVar2;
  int *piVar3;
  
  puVar1 = ___doserrno();
  *puVar1 = param_1;
  iVar2 = __get_errno_from_oserr(param_1);
  piVar3 = __errno();
  *piVar3 = iVar2;
  return;
}



// Library Function - Single Match
//  __errno
// 
// Library: Visual Studio 2012 Release

int * __cdecl __errno(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd_noexit();
  if (p_Var1 == (_ptiddata)0x0) {
    return (int *)&DAT_10046c18;
  }
  return &p_Var1->_terrno;
}



// Library Function - Single Match
//  __get_errno_from_oserr
// 
// Library: Visual Studio 2012 Release

int __cdecl __get_errno_from_oserr(ulong param_1)

{
  uint uVar1;
  
  uVar1 = 0;
  do {
    if (param_1 == (&DAT_10046ab0)[uVar1 * 2]) {
      return (&DAT_10046ab4)[uVar1 * 2];
    }
    uVar1 = uVar1 + 1;
  } while (uVar1 < 0x2d);
  if (param_1 - 0x13 < 0x12) {
    return 0xd;
  }
  return (-(uint)(0xe < param_1 - 0xbc) & 0xe) + 8;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __fastcall FUN_1002534c(int param_1,undefined param_2,undefined param_3)

{
  code *pcVar1;
  undefined4 uVar2;
  undefined4 uVar3;
  uint uVar4;
  undefined4 extraout_ECX;
  undefined4 extraout_ECX_00;
  undefined4 uVar5;
  undefined4 extraout_EDX;
  undefined4 unaff_EBX;
  undefined4 unaff_EBP;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  undefined2 in_ES;
  undefined2 in_CS;
  undefined2 in_SS;
  undefined2 in_DS;
  undefined2 in_FS;
  undefined2 in_GS;
  byte bVar6;
  byte bVar7;
  byte in_AF;
  byte bVar8;
  byte bVar9;
  byte in_TF;
  byte in_IF;
  byte bVar10;
  byte in_NT;
  byte in_AC;
  byte in_VIF;
  byte in_VIP;
  byte in_ID;
  undefined8 uVar11;
  undefined4 unaff_retaddr;
  
  if (param_1 == DAT_10046c24) {
    return;
  }
  uVar4 = IsProcessorFeaturePresent(0x17);
  uVar11 = CONCAT44(extraout_EDX,uVar4);
  bVar6 = 0;
  bVar10 = 0;
  bVar9 = (int)uVar4 < 0;
  bVar8 = uVar4 == 0;
  bVar7 = (POPCOUNT(uVar4 & 0xff) & 1U) == 0;
  uVar5 = extraout_ECX;
  uVar2 = unaff_retaddr;
  uVar3 = unaff_EBP;
  if (!(bool)bVar8) {
    pcVar1 = (code *)swi(0x29);
    uVar11 = (*pcVar1)();
    uVar5 = extraout_ECX_00;
    uVar2 = unaff_retaddr;
    uVar3 = unaff_EBP;
  }
  _DAT_108367ac = uVar3;
  _DAT_108366b4 = uVar2;
  _DAT_108367b8 =
       (uint)(in_NT & 1) * 0x4000 | (uint)(bVar10 & 1) * 0x800 | (uint)(in_IF & 1) * 0x200 |
       (uint)(in_TF & 1) * 0x100 | (uint)(bVar9 & 1) * 0x80 | (uint)(bVar8 & 1) * 0x40 |
       (uint)(in_AF & 1) * 0x10 | (uint)(bVar7 & 1) * 4 | (uint)(bVar6 & 1) |
       (uint)(in_ID & 1) * 0x200000 | (uint)(in_VIP & 1) * 0x100000 | (uint)(in_VIF & 1) * 0x80000 |
       (uint)(in_AC & 1) * 0x40000;
  _DAT_108367bc = &param_3;
  _DAT_108366f8 = 0x10001;
  _DAT_108366a8 = 0xc0000409;
  _DAT_108366ac = 1;
  _DAT_108366b8 = 1;
  DAT_108366bc = 2;
  _DAT_10836784 = in_GS;
  _DAT_10836788 = in_FS;
  _DAT_1083678c = in_ES;
  _DAT_10836790 = in_DS;
  _DAT_10836794 = unaff_EDI;
  _DAT_10836798 = unaff_ESI;
  _DAT_1083679c = unaff_EBX;
  _DAT_108367a4 = uVar5;
  DAT_108367b0 = _DAT_108366b4;
  _DAT_108367b4 = in_CS;
  _DAT_108367c0 = in_SS;
  ___raise_securityfailure((EXCEPTION_POINTERS *)&PTR_DAT_1003ab48);
  _DAT_108367a0 = (undefined4)((ulonglong)uVar11 >> 0x20);
  _DAT_108367a8 = (undefined4)uVar11;
  return;
}



void __cdecl FUN_1002535b(undefined4 param_1)

{
  DAT_10835b24 = param_1;
  return;
}



// Library Function - Single Match
//  public: __thiscall std::exception::exception(char const * const &)
// 
// Libraries: Visual Studio 2010 Release, Visual Studio 2012 Release

exception * __thiscall std::exception::exception(exception *this,char **param_1)

{
  *(undefined4 *)(this + 4) = 0;
  *(undefined ***)this = vftable;
  this[8] = (exception)0x0;
  FUN_1002542e(this,*param_1);
  return this;
}



undefined4 * __thiscall FUN_1002538d(void *this,undefined4 *param_1)

{
  *(undefined ***)this = std::exception::vftable;
  *(undefined4 *)((int)this + 4) = *param_1;
  *(undefined *)((int)this + 8) = 0;
  return (undefined4 *)this;
}



// Library Function - Single Match
//  public: __thiscall std::exception::exception(class std::exception const &)
// 
// Library: Visual Studio 2012 Release

exception * __thiscall std::exception::exception(exception *this,exception *param_1)

{
  *(undefined4 *)(this + 4) = 0;
  *(undefined ***)this = vftable;
  this[8] = (exception)0x0;
  operator_(this,param_1);
  return this;
}



void __fastcall FUN_100253cb(undefined4 *param_1)

{
  *param_1 = std::exception::vftable;
  std::exception::_Tidy((exception *)param_1);
  return;
}



// Library Function - Single Match
//  public: class std::exception & __thiscall std::exception::operator=(class std::exception const
// &)
// 
// Library: Visual Studio 2012 Release

exception * __thiscall std::exception::operator_(exception *this,exception *param_1)

{
  if (this != param_1) {
    _Tidy(this);
    if (param_1[8] == (exception)0x0) {
      *(undefined4 *)(this + 4) = *(undefined4 *)(param_1 + 4);
    }
    else {
      FUN_1002542e(this,*(char **)(param_1 + 4));
    }
  }
  return this;
}



undefined4 * __thiscall FUN_10025409(void *this,byte param_1)

{
  *(undefined ***)this = std::exception::vftable;
  std::exception::_Tidy((exception *)this);
  if ((param_1 & 1) != 0) {
    FID_conflict__free(this);
  }
  return (undefined4 *)this;
}



void __thiscall FUN_1002542e(void *this,char *param_1)

{
  size_t sVar1;
  char *_Dst;
  
  if (param_1 != (char *)0x0) {
    sVar1 = _strlen(param_1);
    _Dst = (char *)_malloc(sVar1 + 1);
    *(char **)((int)this + 4) = _Dst;
    if (_Dst != (char *)0x0) {
      _strcpy_s(_Dst,sVar1 + 1,param_1);
      *(undefined *)((int)this + 8) = 1;
    }
  }
  return;
}



// Library Function - Single Match
//  private: void __thiscall std::exception::_Tidy(void)
// 
// Library: Visual Studio 2012 Release

void __thiscall std::exception::_Tidy(exception *this)

{
  if (this[8] != (exception)0x0) {
    FID_conflict__free(*(void **)(this + 4));
  }
  *(undefined4 *)(this + 4) = 0;
  this[8] = (exception)0x0;
  return;
}



char * __fastcall FUN_10025488(int param_1)

{
  char *pcVar1;
  
  pcVar1 = *(char **)(param_1 + 4);
  if (pcVar1 == (char *)0x0) {
    pcVar1 = "Unknown exception";
  }
  return pcVar1;
}



// Library Function - Single Match
//  __callnewh
// 
// Library: Visual Studio 2012 Release

int __cdecl __callnewh(size_t _Size)

{
  code *pcVar1;
  int iVar2;
  
  pcVar1 = (code *)DecodePointer(DAT_10835b28);
  if (pcVar1 != (code *)0x0) {
    iVar2 = (*pcVar1)(_Size);
    if (iVar2 != 0) {
      return 1;
    }
  }
  return 0;
}



void __cdecl FUN_100254bb(undefined4 param_1)

{
  DAT_10835b28 = param_1;
  return;
}



void __cdecl FUN_100254c8(int param_1,DWORD param_2,DWORD param_3)

{
  uint uVar1;
  BOOL BVar2;
  LONG LVar3;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar4;
  undefined uVar5;
  DWORD local_324;
  DWORD local_320 [19];
  undefined4 local_2d4;
  
  uVar1 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  if (param_1 != -1) {
    FUN_1002fafa();
  }
  local_324 = 0;
  FUN_10021290(local_320,0,0x4c);
  uVar5 = SUB41(&local_324,0);
  local_2d4 = 0x10001;
  local_324 = param_2;
  local_320[0] = param_3;
  BVar2 = IsDebuggerPresent();
  LVar3 = ___crtUnhandledException((EXCEPTION_POINTERS *)&stack0xfffffcd4);
  uVar4 = extraout_DL;
  if (((LVar3 == 0) && (BVar2 == 0)) && (param_1 != -1)) {
    FUN_1002fafa();
    uVar4 = extraout_DL_00;
  }
  FUN_1002534c(uVar1 ^ (uint)&stack0xfffffffc,uVar4,uVar5);
  return;
}



void __cdecl FUN_100255ed(undefined4 param_1)

{
  DAT_10835b2c = param_1;
  return;
}



// Library Function - Single Match
//  __invalid_parameter
// 
// Libraries: Visual Studio 2010 Release, Visual Studio 2012 Release

void __invalid_parameter(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,
                        uintptr_t param_5)

{
  code *UNRECOVERED_JUMPTABLE;
  
  UNRECOVERED_JUMPTABLE = (code *)DecodePointer(DAT_10835b2c);
  if (UNRECOVERED_JUMPTABLE != (code *)0x0) {
                    // WARNING: Could not recover jumptable at 0x1002560e. Too many branches
                    // WARNING: Treating indirect jump as call
    (*UNRECOVERED_JUMPTABLE)();
    return;
  }
  __invoke_watson(param_1,param_2,param_3,param_4,param_5);
  UNRECOVERED_JUMPTABLE = (code *)swi(3);
  (*UNRECOVERED_JUMPTABLE)();
  return;
}



void FUN_10025625(void)

{
  __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  return;
}



// Library Function - Single Match
//  __invoke_watson
// 
// Library: Visual Studio 2012 Release

void __cdecl
__invoke_watson(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,uintptr_t param_5)

{
  code *pcVar1;
  BOOL BVar2;
  
  BVar2 = IsProcessorFeaturePresent(0x17);
  if (BVar2 != 0) {
    pcVar1 = (code *)swi(0x29);
    (*pcVar1)();
  }
  FUN_100254c8(2,0xc0000417,1);
  Plat_ExitProcess(0xc0000417);
  return;
}



void __cdecl FUN_10025660(int *param_1)

{
  int *piVar1;
  int iVar2;
  int **ppiVar3;
  
  LOCK();
  *param_1 = *param_1 + 1;
  piVar1 = (int *)param_1[0x1e];
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  piVar1 = (int *)param_1[0x20];
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  piVar1 = (int *)param_1[0x1f];
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  piVar1 = (int *)param_1[0x22];
  if (piVar1 != (int *)0x0) {
    LOCK();
    *piVar1 = *piVar1 + 1;
  }
  ppiVar3 = (int **)(param_1 + 7);
  iVar2 = 6;
  do {
    if ((ppiVar3[-2] != (int *)&DAT_10047158) && (piVar1 = *ppiVar3, piVar1 != (int *)0x0)) {
      LOCK();
      *piVar1 = *piVar1 + 1;
    }
    if ((ppiVar3[-3] != (int *)0x0) && (piVar1 = ppiVar3[-1], piVar1 != (int *)0x0)) {
      LOCK();
      *piVar1 = *piVar1 + 1;
    }
    ppiVar3 = ppiVar3 + 4;
    iVar2 = iVar2 + -1;
  } while (iVar2 != 0);
  LOCK();
  *(int *)(param_1[0x27] + 0xb0) = *(int *)(param_1[0x27] + 0xb0) + 1;
  return;
}



void __cdecl FUN_100256f5(void *param_1)

{
  int *piVar1;
  undefined **ppuVar2;
  void *_Memory;
  void **ppvVar3;
  int **ppiVar4;
  
  _Memory = param_1;
  if ((((*(undefined ***)((int)param_1 + 0x84) != (undefined **)0x0) &&
       (*(undefined ***)((int)param_1 + 0x84) != &PTR_DAT_10047798)) &&
      (*(int **)((int)param_1 + 0x78) != (int *)0x0)) && (**(int **)((int)param_1 + 0x78) == 0)) {
    piVar1 = *(int **)((int)param_1 + 0x80);
    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
      FID_conflict____acrt_locale_free_monetary(*(int *)((int)param_1 + 0x84));
    }
    piVar1 = *(int **)((int)param_1 + 0x7c);
    if ((piVar1 != (int *)0x0) && (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
      FID_conflict____free_lconv_num(*(void ***)((int)param_1 + 0x84));
    }
    FID_conflict__free(*(void **)((int)param_1 + 0x78));
    FID_conflict__free(*(void **)((int)param_1 + 0x84));
  }
  if ((*(int **)((int)param_1 + 0x88) != (int *)0x0) && (**(int **)((int)param_1 + 0x88) == 0)) {
    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x8c) + -0xfe));
    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x94) + -0x80));
    FID_conflict__free((void *)(*(int *)((int)param_1 + 0x98) + -0x80));
    FID_conflict__free(*(void **)((int)param_1 + 0x88));
  }
  ppuVar2 = *(undefined ***)((int)param_1 + 0x9c);
  if ((ppuVar2 != &PTR_DAT_10047160) && (ppuVar2[0x2c] == (undefined *)0x0)) {
    ___free_lc_time(ppuVar2);
    FID_conflict__free(*(void **)((int)param_1 + 0x9c));
  }
  ppvVar3 = (void **)((int)param_1 + 0xa0);
  param_1 = (void *)0x6;
  ppiVar4 = (int **)((int)_Memory + 0x1c);
  do {
    if (((ppiVar4[-2] != (int *)&DAT_10047158) && (piVar1 = *ppiVar4, piVar1 != (int *)0x0)) &&
       (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
      FID_conflict__free(*ppvVar3);
    }
    if (((ppiVar4[-3] != (int *)0x0) && (piVar1 = ppiVar4[-1], piVar1 != (int *)0x0)) &&
       (*piVar1 == 0)) {
      FID_conflict__free(piVar1);
    }
    ppvVar3 = ppvVar3 + 1;
    ppiVar4 = ppiVar4 + 4;
    param_1 = (void *)((int)param_1 + -1);
  } while (param_1 != (void *)0x0);
  FID_conflict__free(_Memory);
  return;
}



int * __cdecl FUN_1002584f(int *param_1)

{
  int *piVar1;
  int **ppiVar2;
  int iVar3;
  
  if (param_1 != (int *)0x0) {
    LOCK();
    *param_1 = *param_1 + -1;
    piVar1 = (int *)param_1[0x1e];
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    piVar1 = (int *)param_1[0x20];
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    piVar1 = (int *)param_1[0x1f];
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    piVar1 = (int *)param_1[0x22];
    if (piVar1 != (int *)0x0) {
      LOCK();
      *piVar1 = *piVar1 + -1;
    }
    ppiVar2 = (int **)(param_1 + 7);
    iVar3 = 6;
    do {
      if ((ppiVar2[-2] != (int *)&DAT_10047158) && (piVar1 = *ppiVar2, piVar1 != (int *)0x0)) {
        LOCK();
        *piVar1 = *piVar1 + -1;
      }
      if ((ppiVar2[-3] != (int *)0x0) && (piVar1 = ppiVar2[-1], piVar1 != (int *)0x0)) {
        LOCK();
        *piVar1 = *piVar1 + -1;
      }
      ppiVar2 = ppiVar2 + 4;
      iVar3 = iVar3 + -1;
    } while (iVar3 != 0);
    LOCK();
    *(int *)(param_1[0x27] + 0xb0) = *(int *)(param_1[0x27] + 0xb0) + -1;
  }
  return param_1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

pthreadlocinfo FUN_100258ef(void)

{
  _ptiddata p_Var1;
  pthreadlocinfo ptVar2;
  
  p_Var1 = __getptd();
  if (((p_Var1->_ownlocale & DAT_10047388) == 0) || (p_Var1->ptlocinfo == (pthreadlocinfo)0x0)) {
    __lock(0xc);
    ptVar2 = (pthreadlocinfo)
             __updatetlocinfoEx_nolock((int **)&p_Var1->ptlocinfo,(int *)PTR_DAT_100472c4);
    FUN_10025966();
  }
  else {
    p_Var1 = __getptd();
    ptVar2 = p_Var1->ptlocinfo;
  }
  if (ptVar2 == (pthreadlocinfo)0x0) {
    __amsg_exit(0x20);
  }
  return ptVar2;
}



void FUN_10025966(void)

{
  FUN_1002f199(0xc);
  return;
}



// Library Function - Single Match
//  __updatetlocinfoEx_nolock
// 
// Libraries: Visual Studio 2010 Release, Visual Studio 2012 Release, Visual Studio 2019 Release

int * __cdecl __updatetlocinfoEx_nolock(int **param_1,int *param_2)

{
  int *piVar1;
  
  if ((param_2 == (int *)0x0) || (param_1 == (int **)0x0)) {
    param_2 = (int *)0x0;
  }
  else {
    piVar1 = *param_1;
    if (piVar1 != param_2) {
      *param_1 = param_2;
      FUN_10025660(param_2);
      if (((piVar1 != (int *)0x0) && (FUN_1002584f(piVar1), *piVar1 == 0)) &&
         (piVar1 != (int *)&DAT_100472c8)) {
        FUN_100256f5(piVar1);
      }
    }
  }
  return param_2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_100259ba(void)

{
  if (_DAT_10836b94 == 0) {
    FUN_10025d17(0xfffffffd);
    _DAT_10836b94 = 1;
  }
  return 0;
}



// Library Function - Single Match
//  wchar_t const * __cdecl CPtoLocaleName(int)
// 
// Library: Visual Studio 2012 Release

wchar_t * __cdecl CPtoLocaleName(int param_1)

{
  if (param_1 == 0x3a4) {
    return (wchar_t *)L"ja-JP";
  }
  if (param_1 == 0x3a8) {
    return (wchar_t *)L"zh-CN";
  }
  if (param_1 == 0x3b5) {
    return (wchar_t *)L"ko-KR";
  }
  if (param_1 != 0x3b6) {
    return (wchar_t *)0x0;
  }
  return (wchar_t *)L"zh-TW";
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

UINT __cdecl FUN_10025a12(UINT param_1)

{
  int local_14 [2];
  int local_c;
  char local_8;
  
  FUN_1001f92e(local_14,(pthreadlocinfo *)0x0);
  _DAT_10835b48 = 0;
  if (param_1 == 0xfffffffe) {
    _DAT_10835b48 = 1;
    param_1 = GetOEMCP();
  }
  else if (param_1 == 0xfffffffd) {
    _DAT_10835b48 = 1;
    param_1 = GetACP();
  }
  else if (param_1 == 0xfffffffc) {
    _DAT_10835b48 = 1;
    param_1 = *(UINT *)(local_14[0] + 4);
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return param_1;
}



void __cdecl FUN_10025a80(int param_1)

{
  int iVar1;
  undefined *puVar2;
  uint *puVar3;
  
  puVar3 = (uint *)(param_1 + 0x18);
  FUN_10021290(puVar3,0,0x101);
  *(undefined4 *)(param_1 + 4) = 0;
  *(undefined4 *)(param_1 + 8) = 0;
  *(undefined4 *)(param_1 + 0x21c) = 0;
  iVar1 = 0x101;
  *(undefined4 *)(param_1 + 0xc) = 0;
  *(undefined4 *)(param_1 + 0x10) = 0;
  *(undefined4 *)(param_1 + 0x14) = 0;
  do {
    *(undefined *)puVar3 = *(undefined *)(((int)&DAT_10046e38 - param_1) + (int)puVar3);
    puVar3 = (uint *)((int)puVar3 + 1);
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  puVar2 = (undefined *)(param_1 + 0x119);
  iVar1 = 0x100;
  do {
    *puVar2 = puVar2[(int)&DAT_10046e38 - param_1];
    puVar2 = puVar2 + 1;
    iVar1 = iVar1 + -1;
  } while (iVar1 != 0);
  return;
}



// Library Function - Single Match
//  void __cdecl setSBUpLow(struct __crt_multibyte_data *)
// 
// Library: Visual Studio 2015 Release

void __cdecl setSBUpLow(__crt_multibyte_data *param_1)

{
  byte bVar1;
  __crt_multibyte_data _Var2;
  BOOL BVar3;
  uint uVar4;
  BYTE *pBVar5;
  char extraout_DL;
  char cVar6;
  __crt_multibyte_data *p_Var7;
  int in_stack_fffffadc;
  _cpinfo local_51c;
  WORD local_508 [256];
  WCHAR local_308 [128];
  WCHAR local_208 [128];
  CHAR local_108 [256];
  uint local_8;
  
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  BVar3 = GetCPInfo(*(UINT *)(param_1 + 4),&local_51c);
  if (BVar3 == 0) {
    uVar4 = 0;
    in_stack_fffffadc = -0x61 - (int)(param_1 + 0x119);
    do {
      p_Var7 = param_1 + uVar4 + 0x119;
      if (p_Var7 + in_stack_fffffadc + 0x20 < (__crt_multibyte_data *)0x1a) {
        param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x10);
        _Var2 = (__crt_multibyte_data)((char)uVar4 + ' ');
LAB_10025c49:
        *p_Var7 = _Var2;
      }
      else {
        if (p_Var7 + in_stack_fffffadc < (__crt_multibyte_data *)0x1a) {
          param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x20);
          _Var2 = (__crt_multibyte_data)((char)uVar4 + -0x20);
          goto LAB_10025c49;
        }
        *p_Var7 = (__crt_multibyte_data)0x0;
      }
      cVar6 = (char)param_1 + '\x19';
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
  }
  else {
    uVar4 = 0;
    do {
      local_108[uVar4] = (CHAR)uVar4;
      uVar4 = uVar4 + 1;
    } while (uVar4 < 0x100);
    pBVar5 = local_51c.LeadByte;
    local_108[0] = ' ';
    while (local_51c.LeadByte[0] != 0) {
      bVar1 = pBVar5[1];
      for (uVar4 = (uint)local_51c.LeadByte[0]; (uVar4 <= bVar1 && (uVar4 < 0x100));
          uVar4 = uVar4 + 1) {
        local_108[uVar4] = ' ';
      }
      pBVar5 = pBVar5 + 2;
      local_51c.LeadByte[0] = *pBVar5;
    }
    FUN_100300dd((pthreadlocinfo *)0x0,1,local_108,0x100,local_508,*(UINT *)(param_1 + 4),0);
    FUN_1002637c((pthreadlocinfo *)0x0,*(wchar_t **)(param_1 + 0x21c),0x100,local_108,0x100,
                 local_208,0x100,*(UINT *)(param_1 + 4),0);
    FUN_1002637c((pthreadlocinfo *)0x0,*(wchar_t **)(param_1 + 0x21c),0x200,local_108,0x100,
                 local_308,0x100,*(UINT *)(param_1 + 4),0);
    uVar4 = 0;
    do {
      if ((local_508[uVar4] & 1) == 0) {
        if ((local_508[uVar4] & 2) != 0) {
          param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x20);
          _Var2 = *(__crt_multibyte_data *)((int)local_308 + uVar4);
          goto LAB_10025bf0;
        }
        param_1[uVar4 + 0x119] = (__crt_multibyte_data)0x0;
      }
      else {
        param_1[uVar4 + 0x19] = (__crt_multibyte_data)((byte)param_1[uVar4 + 0x19] | 0x10);
        _Var2 = *(__crt_multibyte_data *)((int)local_208 + uVar4);
LAB_10025bf0:
        param_1[uVar4 + 0x119] = _Var2;
      }
      uVar4 = uVar4 + 1;
      cVar6 = extraout_DL;
    } while (uVar4 < 0x100);
  }
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,cVar6,(char)in_stack_fffffadc);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

pthreadmbcinfo FUN_10025c71(void)

{
  int iVar1;
  _ptiddata p_Var2;
  pthreadmbcinfo _Memory;
  
  p_Var2 = __getptd();
  if (((p_Var2->_ownlocale & DAT_10047388) == 0) || (p_Var2->ptlocinfo == (pthreadlocinfo)0x0)) {
    __lock(0xd);
    _Memory = p_Var2->ptmbcinfo;
    if (_Memory != (pthreadmbcinfo)PTR_DAT_1004705c) {
      if (_Memory != (pthreadmbcinfo)0x0) {
        LOCK();
        iVar1 = _Memory->refcount + -1;
        _Memory->refcount = iVar1;
        if ((iVar1 == 0) && (_Memory != (pthreadmbcinfo)&DAT_10046e38)) {
          FID_conflict__free(_Memory);
        }
      }
      p_Var2->ptmbcinfo = (pthreadmbcinfo)PTR_DAT_1004705c;
      _Memory = (pthreadmbcinfo)PTR_DAT_1004705c;
      LOCK();
      *(int *)PTR_DAT_1004705c = *(int *)PTR_DAT_1004705c + 1;
    }
    FUN_10025d0e();
  }
  else {
    _Memory = p_Var2->ptmbcinfo;
  }
  if (_Memory == (pthreadmbcinfo)0x0) {
    __amsg_exit(0x20);
  }
  return _Memory;
}



void FUN_10025d0e(void)

{
  FUN_1002f199(0xd);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

int __cdecl FUN_10025d17(UINT param_1)

{
  _ptiddata p_Var1;
  UINT UVar2;
  pthreadmbcinfo ptVar3;
  int *piVar4;
  int iVar5;
  pthreadmbcinfo ptVar6;
  int iVar7;
  int iVar8;
  pthreadmbcinfo ptVar9;
  
  iVar8 = -1;
  p_Var1 = __getptd();
  FUN_10025c71();
  ptVar3 = p_Var1->ptmbcinfo;
  UVar2 = FUN_10025a12(param_1);
  if (UVar2 == ptVar3->mbcodepage) {
    iVar8 = 0;
  }
  else {
    ptVar3 = (pthreadmbcinfo)FUN_10026f23(0x220);
    if (ptVar3 != (pthreadmbcinfo)0x0) {
      ptVar6 = p_Var1->ptmbcinfo;
      ptVar9 = ptVar3;
      for (iVar8 = 0x88; iVar8 != 0; iVar8 = iVar8 + -1) {
        ptVar9->refcount = ptVar6->refcount;
        ptVar6 = (pthreadmbcinfo)&ptVar6->mbcodepage;
        ptVar9 = (pthreadmbcinfo)&ptVar9->mbcodepage;
      }
      iVar7 = 0;
      ptVar3->refcount = 0;
      iVar8 = FUN_10025ebf(UVar2,(__crt_multibyte_data *)ptVar3);
      if (iVar8 == 0) {
        LOCK();
        iVar5 = p_Var1->ptmbcinfo->refcount + -1;
        p_Var1->ptmbcinfo->refcount = iVar5;
        if ((iVar5 == 0) && (p_Var1->ptmbcinfo != (pthreadmbcinfo)&DAT_10046e38)) {
          FID_conflict__free(p_Var1->ptmbcinfo);
        }
        p_Var1->ptmbcinfo = ptVar3;
        LOCK();
        ptVar3->refcount = ptVar3->refcount + 1;
        if (((*(byte *)&p_Var1->_ownlocale & 2) == 0) && (((byte)DAT_10047388 & 1) == 0)) {
          __lock(0xd);
          _DAT_10835b30 = ptVar3->mbcodepage;
          _DAT_10835b34 = ptVar3->ismbcodepage;
          _DAT_10835b44 = ptVar3->mblocalename;
          for (iVar5 = 0; iVar5 < 5; iVar5 = iVar5 + 1) {
            (&DAT_10835b38)[iVar5] = ptVar3->mbulinfo[iVar5];
          }
          for (iVar5 = 0; iVar5 < 0x101; iVar5 = iVar5 + 1) {
            (&DAT_10046c30)[iVar5] = ptVar3->mbctype[iVar5];
          }
          for (; iVar7 < 0x100; iVar7 = iVar7 + 1) {
            (&DAT_10046d38)[iVar7] = ptVar3->mbcasemap[iVar7];
          }
          LOCK();
          iVar7 = *(int *)PTR_DAT_1004705c;
          *(int *)PTR_DAT_1004705c = iVar7 + -1;
          if ((iVar7 + -1 == 0) && ((undefined4 *)PTR_DAT_1004705c != &DAT_10046e38)) {
            FID_conflict__free(PTR_DAT_1004705c);
          }
          LOCK();
          PTR_DAT_1004705c = (undefined *)ptVar3;
          ptVar3->refcount = ptVar3->refcount + 1;
          FUN_10025e89();
        }
      }
      else if (iVar8 == -1) {
        if (ptVar3 != (pthreadmbcinfo)&DAT_10046e38) {
          FID_conflict__free(ptVar3);
        }
        piVar4 = __errno();
        *piVar4 = 0x16;
      }
    }
  }
  return iVar8;
}



void FUN_10025e89(void)

{
  FUN_1002f199(0xd);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_10025ebf(UINT param_1,__crt_multibyte_data *param_2)

{
  byte bVar1;
  undefined2 uVar2;
  UINT CodePage;
  uint uVar3;
  BOOL BVar4;
  BYTE *pBVar5;
  __crt_multibyte_data *p_Var6;
  wchar_t *pwVar7;
  byte *pbVar8;
  int iVar9;
  byte *pbVar10;
  undefined2 *puVar11;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  undefined extraout_DL_02;
  undefined extraout_DL_03;
  undefined extraout_DL_04;
  undefined uVar12;
  undefined2 *puVar13;
  uint uVar14;
  undefined uVar15;
  int in_stack_ffffffdc;
  int local_20;
  _cpinfo local_1c;
  uint local_8;
  
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  CodePage = FUN_10025a12(param_1);
  uVar15 = (undefined)in_stack_ffffffdc;
  if (CodePage != 0) {
    uVar14 = 0;
    uVar3 = 0;
    local_20 = 0;
LAB_10025efb:
    if (*(UINT *)((int)&DAT_10047060 + uVar3) != CodePage) goto code_r0x10025f07;
    FUN_10021290((uint *)(param_2 + 0x18),0,0x101);
    in_stack_ffffffdc = local_20 * 0x30;
    pbVar8 = &DAT_10047070 + in_stack_ffffffdc;
    do {
      bVar1 = *pbVar8;
      pbVar10 = pbVar8;
      while ((bVar1 != 0 && (bVar1 = pbVar10[1], bVar1 != 0))) {
        for (uVar3 = (uint)*pbVar10; (uVar3 <= bVar1 && (uVar3 < 0x100)); uVar3 = uVar3 + 1) {
          param_2[uVar3 + 0x19] =
               (__crt_multibyte_data)((byte)param_2[uVar3 + 0x19] | (&DAT_10047058)[uVar14]);
          bVar1 = pbVar10[1];
        }
        pbVar10 = pbVar10 + 2;
        bVar1 = *pbVar10;
      }
      uVar14 = uVar14 + 1;
      pbVar8 = pbVar8 + 8;
    } while (uVar14 < 4);
    *(UINT *)(param_2 + 4) = CodePage;
    *(undefined4 *)(param_2 + 8) = 1;
    pwVar7 = CPtoLocaleName(CodePage);
    *(wchar_t **)(param_2 + 0x21c) = pwVar7;
    puVar11 = (undefined2 *)(param_2 + 0xc);
    puVar13 = (undefined2 *)(&DAT_10047064 + in_stack_ffffffdc);
    iVar9 = 6;
    do {
      uVar2 = *puVar13;
      puVar13 = puVar13 + 1;
      *puVar11 = uVar2;
      puVar11 = puVar11 + 1;
      iVar9 = iVar9 + -1;
    } while (iVar9 != 0);
    goto LAB_10026090;
  }
  FUN_10025a80((int)param_2);
  uVar12 = extraout_DL_00;
LAB_1002609a:
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,uVar12,uVar15);
  return;
code_r0x10025f07:
  local_20 = local_20 + 1;
  uVar3 = uVar3 + 0x30;
  if (0xef < uVar3) goto code_r0x10025f15;
  goto LAB_10025efb;
code_r0x10025f15:
  uVar12 = extraout_DL;
  if ((CodePage != 65000) && (CodePage != 0xfde9)) {
    BVar4 = IsValidCodePage(CodePage & 0xffff);
    uVar15 = (undefined)in_stack_ffffffdc;
    uVar12 = extraout_DL_01;
    if (BVar4 != 0) {
      BVar4 = GetCPInfo(CodePage,&local_1c);
      uVar15 = (undefined)in_stack_ffffffdc;
      if (BVar4 == 0) {
        uVar12 = extraout_DL_02;
        if (_DAT_10835b48 != 0) {
          FUN_10025a80((int)param_2);
          uVar12 = extraout_DL_03;
        }
      }
      else {
        FUN_10021290((uint *)(param_2 + 0x18),0,0x101);
        *(UINT *)(param_2 + 4) = CodePage;
        *(undefined4 *)(param_2 + 0x21c) = 0;
        if (local_1c.MaxCharSize < 2) {
          *(undefined4 *)(param_2 + 8) = 0;
        }
        else {
          pBVar5 = local_1c.LeadByte;
          while ((local_1c.LeadByte[0] != 0 && (bVar1 = pBVar5[1], bVar1 != 0))) {
            for (uVar3 = (uint)*pBVar5; uVar3 <= bVar1; uVar3 = uVar3 + 1) {
              param_2[uVar3 + 0x19] = (__crt_multibyte_data)((byte)param_2[uVar3 + 0x19] | 4);
            }
            pBVar5 = pBVar5 + 2;
            local_1c.LeadByte[0] = *pBVar5;
          }
          p_Var6 = param_2 + 0x1a;
          iVar9 = 0xfe;
          do {
            *p_Var6 = (__crt_multibyte_data)((byte)*p_Var6 | 8);
            p_Var6 = p_Var6 + 1;
            iVar9 = iVar9 + -1;
          } while (iVar9 != 0);
          pwVar7 = CPtoLocaleName(*(int *)(param_2 + 4));
          *(wchar_t **)(param_2 + 0x21c) = pwVar7;
          *(undefined4 *)(param_2 + 8) = 1;
        }
        *(undefined4 *)(param_2 + 0xc) = 0;
        *(undefined4 *)(param_2 + 0x10) = 0;
        *(undefined4 *)(param_2 + 0x14) = 0;
LAB_10026090:
        uVar15 = (undefined)in_stack_ffffffdc;
        setSBUpLow(param_2);
        uVar12 = extraout_DL_04;
      }
    }
  }
  goto LAB_1002609a;
}



// Library Function - Single Match
//  ___ascii_stricmp
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release

int __cdecl ___ascii_stricmp(char *_Str1,char *_Str2)

{
  uint uVar1;
  uint uVar2;
  
  do {
    uVar1 = (uint)(byte)*_Str1;
    _Str1 = (char *)((byte *)_Str1 + 1);
    if (uVar1 - 0x41 < 0x1a) {
      uVar1 = uVar1 + 0x20;
    }
    uVar2 = (uint)(byte)*_Str2;
    _Str2 = (char *)((byte *)_Str2 + 1);
    if (uVar2 - 0x41 < 0x1a) {
      uVar2 = uVar2 + 0x20;
    }
  } while ((uVar1 != 0) && (uVar1 == uVar2));
  return uVar1 - uVar2;
}



int __cdecl FUN_100260e3(char *param_1,byte *param_2,pthreadlocinfo *param_3)

{
  int *piVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  pthreadlocinfo local_14 [2];
  int local_c;
  char local_8;
  
  FUN_1001f92e(local_14,param_3);
  if ((param_1 == (char *)0x0) || (param_2 == (byte *)0x0)) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    iVar4 = 0x7fffffff;
  }
  else if (local_14[0]->locale_name[2] == (wchar_t *)0x0) {
    iVar4 = ___ascii_stricmp(param_1,(char *)param_2);
  }
  else {
    iVar4 = (int)param_1 - (int)param_2;
    do {
      uVar2 = FUN_100210ea((uint)param_2[iVar4],local_14);
      uVar3 = FUN_100210ea((uint)*param_2,local_14);
      param_2 = param_2 + 1;
      if (uVar2 == 0) break;
    } while (uVar2 == uVar3);
    iVar4 = uVar2 - uVar3;
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return iVar4;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe

void __cdecl
FUN_10026178(int *param_1,wchar_t *param_2,uint param_3,LPCSTR param_4,int param_5,LPWSTR param_6,
            int param_7,UINT param_8,int param_9)

{
  uint uVar1;
  char *pcVar2;
  int iVar3;
  uint uVar4;
  undefined4 *lpWideCharStr;
  uint cchWideChar;
  undefined4 *puVar5;
  int iVar6;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  undefined uVar7;
  undefined uVar8;
  uint uVar9;
  
  uVar1 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  pcVar2 = param_4;
  iVar6 = param_5;
  if (0 < param_5) {
    do {
      iVar6 = iVar6 + -1;
      if (*pcVar2 == '\0') goto LAB_100261a4;
      pcVar2 = pcVar2 + 1;
    } while (iVar6 != 0);
    iVar6 = -1;
LAB_100261a4:
    iVar3 = (param_5 - iVar6) + -1;
    iVar6 = param_5 - iVar6;
    if (param_5 <= iVar3) {
      iVar6 = iVar3;
    }
  }
  if (param_8 == 0) {
    param_8 = *(UINT *)(*param_1 + 4);
  }
  uVar4 = MultiByteToWideChar(param_8,(uint)(param_9 != 0) * 8 + 1,param_4,iVar6,(LPWSTR)0x0,0);
  uVar7 = extraout_DL;
  if (uVar4 != 0) {
    if ((((int)uVar4 < 1) || (uVar7 = (undefined)(0xffffffe0 % uVar4), 0xffffffe0 / uVar4 < 2)) ||
       (uVar4 * 2 + 8 <= uVar4 * 2)) {
      lpWideCharStr = (undefined4 *)0x0;
    }
    else {
      uVar9 = uVar4 * 2 + 8;
      if (uVar9 < 0x401) {
        puVar5 = (undefined4 *)&stack0xffffffe8;
        lpWideCharStr = (undefined4 *)&stack0xffffffe8;
        if (&stack0x00000000 != (undefined *)0x18) {
LAB_10026245:
          lpWideCharStr = puVar5 + 2;
        }
      }
      else {
        lpWideCharStr = (undefined4 *)_malloc(uVar9);
        uVar7 = extraout_DL_00;
        if (lpWideCharStr != (undefined4 *)0x0) {
          *lpWideCharStr = 0xdddd;
          puVar5 = lpWideCharStr;
          goto LAB_10026245;
        }
      }
    }
    if (lpWideCharStr != (undefined4 *)0x0) {
      iVar6 = MultiByteToWideChar(param_8,1,param_4,iVar6,(LPWSTR)lpWideCharStr,uVar4);
      uVar9 = uVar4;
      if ((iVar6 != 0) &&
         (cchWideChar = FUN_1002fa40(param_2,param_3,(LPCWSTR)lpWideCharStr,uVar4,(LPWSTR)0x0,0),
         cchWideChar != 0)) {
        if ((param_3 & 0x400) == 0) {
          if ((((int)cchWideChar < 1) || (0xffffffe0 / cchWideChar < 2)) ||
             (cchWideChar * 2 + 8 <= cchWideChar * 2)) {
            puVar5 = (undefined4 *)0x0;
LAB_1002631a:
            if (puVar5 != (undefined4 *)0x0) {
              iVar6 = FUN_1002fa40(param_2,param_3,(LPCWSTR)lpWideCharStr,uVar9,(LPWSTR)puVar5,
                                   cchWideChar);
              if (iVar6 != 0) {
                if (param_7 == 0) {
                  param_7 = 0;
                  param_6 = (LPWSTR)0x0;
                }
                WideCharToMultiByte(param_8,0,(LPCWSTR)puVar5,cchWideChar,(LPSTR)param_6,param_7,
                                    (LPCSTR)0x0,(LPBOOL)0x0);
              }
              FUN_10021ea8((int)puVar5);
            }
          }
          else {
            uVar4 = cchWideChar * 2 + 8;
            if (uVar4 < 0x401) {
              puVar5 = (undefined4 *)&stack0xffffffe8;
              if (&stack0x00000000 != (undefined *)0x18) {
LAB_10026313:
                puVar5 = puVar5 + 2;
                goto LAB_1002631a;
              }
            }
            else {
              puVar5 = (undefined4 *)_malloc(uVar4);
              if (puVar5 != (undefined4 *)0x0) {
                *puVar5 = 0xdddd;
                goto LAB_10026313;
              }
            }
          }
        }
        else if ((param_7 != 0) && ((int)cchWideChar <= param_7)) {
          FUN_1002fa40(param_2,param_3,(LPCWSTR)lpWideCharStr,uVar4,param_6,param_7);
        }
      }
      uVar8 = (undefined)uVar9;
      FUN_10021ea8((int)lpWideCharStr);
      uVar7 = extraout_DL_01;
      goto LAB_10026368;
    }
  }
  uVar8 = (undefined)uVar4;
LAB_10026368:
  FUN_1002534c(uVar1 ^ (uint)&stack0xfffffffc,uVar7,uVar8);
  return;
}



void __cdecl
FUN_1002637c(pthreadlocinfo *param_1,wchar_t *param_2,uint param_3,LPCSTR param_4,int param_5,
            LPWSTR param_6,int param_7,UINT param_8,int param_9)

{
  int local_14 [2];
  int local_c;
  char local_8;
  
  FUN_1001f92e(local_14,param_1);
  FUN_10026178(local_14,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

void FUN_100263c2(void *param_1)

{
  int *piVar1;
  int iVar2;
  
  if (param_1 != (void *)0x0) {
    if (*(int *)((int)param_1 + 0x24) != 0) {
      FID_conflict__free(*(void **)((int)param_1 + 0x24));
    }
    if (*(int *)((int)param_1 + 0x2c) != 0) {
      FID_conflict__free(*(void **)((int)param_1 + 0x2c));
    }
    if (*(int *)((int)param_1 + 0x34) != 0) {
      FID_conflict__free(*(void **)((int)param_1 + 0x34));
    }
    if (*(int *)((int)param_1 + 0x3c) != 0) {
      FID_conflict__free(*(void **)((int)param_1 + 0x3c));
    }
    if (*(int *)((int)param_1 + 0x40) != 0) {
      FID_conflict__free(*(void **)((int)param_1 + 0x40));
    }
    if (*(int *)((int)param_1 + 0x44) != 0) {
      FID_conflict__free(*(void **)((int)param_1 + 0x44));
    }
    if (*(int *)((int)param_1 + 0x48) != 0) {
      FID_conflict__free(*(void **)((int)param_1 + 0x48));
    }
    if (*(undefined **)((int)param_1 + 0x5c) != &DAT_1003aaa8) {
      FID_conflict__free(*(void **)((int)param_1 + 0x5c));
    }
    __lock(0xd);
    piVar1 = *(int **)((int)param_1 + 0x68);
    if (piVar1 != (int *)0x0) {
      LOCK();
      iVar2 = *piVar1;
      *piVar1 = iVar2 + -1;
      if ((iVar2 + -1 == 0) && (piVar1 != &DAT_10046e38)) {
        FID_conflict__free(piVar1);
      }
    }
    FUN_100264e2();
    __lock(0xc);
    piVar1 = *(int **)((int)param_1 + 0x6c);
    if (piVar1 != (int *)0x0) {
      FUN_1002584f(piVar1);
      if (((piVar1 != (int *)PTR_DAT_100472c4) && (piVar1 != (int *)&DAT_100472c8)) &&
         (*piVar1 == 0)) {
        FUN_100256f5(piVar1);
      }
    }
    FUN_100264ee();
    FID_conflict__free(param_1);
  }
  return;
}



void FUN_100264e2(void)

{
  FUN_1002f199(0xd);
  return;
}



void FUN_100264ee(void)

{
  FUN_1002f199(0xc);
  return;
}



void __cdecl FUN_100264f7(void *param_1)

{
  if (DAT_10047150 != 0xffffffff) {
    if (param_1 == (void *)0x0) {
      param_1 = (void *)FUN_1002bd19(DAT_10047150);
    }
    FUN_1002bd38(DAT_10047150,(LPVOID)0x0);
    FUN_100263c2(param_1);
  }
  return;
}



// Library Function - Single Match
//  __getptd
// 
// Library: Visual Studio 2012 Release

_ptiddata __cdecl __getptd(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd_noexit();
  if (p_Var1 == (_ptiddata)0x0) {
    __amsg_exit(0x10);
  }
  return p_Var1;
}



// Library Function - Single Match
//  __getptd_noexit
// 
// Library: Visual Studio 2012 Release

_ptiddata __cdecl __getptd_noexit(void)

{
  DWORD dwErrCode;
  _ptiddata _Memory;
  int iVar1;
  DWORD DVar2;
  
  dwErrCode = GetLastError();
  _Memory = (_ptiddata)FUN_1002bd19(DAT_10047150);
  if (_Memory == (_ptiddata)0x0) {
    _Memory = (_ptiddata)FUN_10026edb(1,0x3bc);
    if (_Memory != (_ptiddata)0x0) {
      iVar1 = FUN_1002bd38(DAT_10047150,_Memory);
      if (iVar1 == 0) {
        FID_conflict__free(_Memory);
        _Memory = (_ptiddata)0x0;
      }
      else {
        FUN_100265b4((int)_Memory,0);
        DVar2 = GetCurrentThreadId();
        _Memory->_thandle = 0xffffffff;
        _Memory->_tid = DVar2;
      }
    }
  }
  SetLastError(dwErrCode);
  return _Memory;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

void __cdecl FUN_100265b4(int param_1,int param_2)

{
  *(undefined **)(param_1 + 0x5c) = &DAT_1003aaa8;
  *(undefined4 *)(param_1 + 8) = 0;
  *(undefined4 *)(param_1 + 0x14) = 1;
  *(undefined4 *)(param_1 + 0x70) = 1;
  *(undefined2 *)(param_1 + 0xb8) = 0x43;
  *(undefined2 *)(param_1 + 0x1be) = 0x43;
  *(undefined4 **)(param_1 + 0x68) = &DAT_10046e38;
  *(undefined4 *)(param_1 + 0x3b8) = 0;
  __lock(0xd);
  LOCK();
  **(int **)(param_1 + 0x68) = **(int **)(param_1 + 0x68) + 1;
  FUN_10026655();
  __lock(0xc);
  *(int *)(param_1 + 0x6c) = param_2;
  if (param_2 == 0) {
    *(undefined **)(param_1 + 0x6c) = PTR_DAT_100472c4;
  }
  FUN_10025660(*(int **)(param_1 + 0x6c));
  FUN_1002665e();
  return;
}



void FUN_10026655(void)

{
  FUN_1002f199(0xd);
  return;
}



void FUN_1002665e(void)

{
  FUN_1002f199(0xc);
  return;
}



undefined4 FUN_10026667(void)

{
  int iVar1;
  DWORD *pDVar2;
  DWORD DVar3;
  
  FUN_10026cd9();
  iVar1 = FUN_1002f160();
  if (iVar1 != 0) {
    DAT_10047150 = FUN_1002bcdc(FUN_100263c2);
    if (DAT_10047150 != 0xffffffff) {
      pDVar2 = (DWORD *)FUN_10026edb(1,0x3bc);
      if (pDVar2 != (DWORD *)0x0) {
        iVar1 = FUN_1002bd38(DAT_10047150,pDVar2);
        if (iVar1 != 0) {
          FUN_100265b4((int)pDVar2,0);
          DVar3 = GetCurrentThreadId();
          pDVar2[1] = 0xffffffff;
          *pDVar2 = DVar3;
          return 1;
        }
      }
      FUN_100266dd();
      return 0;
    }
  }
  FUN_100266dd();
  return 0;
}



void FUN_100266dd(void)

{
  LPCRITICAL_SECTION lpCriticalSection;
  LPCRITICAL_SECTION *pp_Var1;
  LPCRITICAL_SECTION *pp_Var2;
  
  if (DAT_10047150 != 0xffffffff) {
    FUN_1002bcfa(DAT_10047150);
    DAT_10047150 = 0xffffffff;
  }
  pp_Var1 = (LPCRITICAL_SECTION *)&DAT_10047670;
  pp_Var2 = (LPCRITICAL_SECTION *)&DAT_10047670;
  do {
    lpCriticalSection = *pp_Var2;
    if ((lpCriticalSection != (LPCRITICAL_SECTION)0x0) && (pp_Var2[1] != (LPCRITICAL_SECTION)0x1)) {
      DeleteCriticalSection(lpCriticalSection);
      FID_conflict__free(lpCriticalSection);
      *pp_Var2 = (LPCRITICAL_SECTION)0x0;
    }
    pp_Var2 = pp_Var2 + 2;
  } while ((int)pp_Var2 < 0x10047790);
  do {
    if ((*pp_Var1 != (LPCRITICAL_SECTION)0x0) && (pp_Var1[1] == (LPCRITICAL_SECTION)0x1)) {
      DeleteCriticalSection(*pp_Var1);
    }
    pp_Var1 = pp_Var1 + 2;
  } while ((int)pp_Var1 < 0x10047790);
  return;
}



// Library Function - Single Match
//  _strlen
// 
// Library: Visual Studio

size_t __cdecl _strlen(char *_Str)

{
  char cVar1;
  uint uVar2;
  uint *puVar3;
  uint *puVar4;
  
  uVar2 = (uint)_Str & 3;
  puVar3 = (uint *)_Str;
  while (uVar2 != 0) {
    cVar1 = *(char *)puVar3;
    puVar3 = (uint *)((int)puVar3 + 1);
    if (cVar1 == '\0') goto LAB_10026763;
    uVar2 = (uint)puVar3 & 3;
  }
  do {
    do {
      puVar4 = puVar3;
      puVar3 = puVar4 + 1;
    } while (((*puVar4 ^ 0xffffffff ^ *puVar4 + 0x7efefeff) & 0x81010100) == 0);
    uVar2 = *puVar4;
    if ((char)uVar2 == '\0') {
      return (int)puVar4 - (int)_Str;
    }
    if ((char)(uVar2 >> 8) == '\0') {
      return (size_t)((int)puVar4 + (1 - (int)_Str));
    }
    if ((uVar2 & 0xff0000) == 0) {
      return (size_t)((int)puVar4 + (2 - (int)_Str));
    }
  } while ((uVar2 & 0xff000000) != 0);
LAB_10026763:
  return (size_t)((int)puVar3 + (-1 - (int)_Str));
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_1002678b(void)

{
  int *piVar1;
  uint *puVar2;
  int iVar3;
  BOOL BVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  
  _DAT_10835b4c = 0;
  DAT_10047390 = DAT_10047390 | 1;
  BVar4 = IsProcessorFeaturePresent(10);
  uVar5 = DAT_10047390;
  if (BVar4 != 0) {
    _DAT_10835b4c = 1;
    if (true) {
      piVar1 = (int *)cpuid_basic_info(0);
    }
    else if (false) {
      piVar1 = (int *)cpuid_Version_info(0);
    }
    else if (false) {
      piVar1 = (int *)cpuid_cache_tlb_info(0);
    }
    else if (false) {
      piVar1 = (int *)cpuid_serial_info(0);
    }
    else if (false) {
      piVar1 = (int *)cpuid_Deterministic_Cache_Parameters_info(0);
    }
    else if (false) {
      piVar1 = (int *)cpuid_MONITOR_MWAIT_Features_info(0);
    }
    else if (false) {
      piVar1 = (int *)cpuid_Thermal_Power_Management_info(0);
    }
    else if (false) {
      piVar1 = (int *)cpuid_Extended_Feature_Enumeration_info(0);
    }
    else if (false) {
      piVar1 = (int *)cpuid_Direct_Cache_Access_info(0);
    }
    else if (false) {
      piVar1 = (int *)cpuid_Architectural_Performance_Monitoring_info(0);
    }
    else if (false) {
      piVar1 = (int *)cpuid_Extended_Topology_info(0);
    }
    else if (false) {
      piVar1 = (int *)cpuid_Processor_Extended_States_info(0);
    }
    else if (false) {
      piVar1 = (int *)cpuid_Quality_of_Service_info(0);
    }
    else if (false) {
      piVar1 = (int *)cpuid_brand_part1_info(0);
    }
    else if (false) {
      piVar1 = (int *)cpuid_brand_part2_info(0);
    }
    else if (false) {
      piVar1 = (int *)cpuid_brand_part3_info(0);
    }
    else {
      piVar1 = (int *)cpuid(0);
    }
    if (false) {
      puVar2 = (uint *)cpuid_basic_info(0);
    }
    else if (true) {
      puVar2 = (uint *)cpuid_Version_info(1);
    }
    else if (false) {
      puVar2 = (uint *)cpuid_cache_tlb_info(2);
    }
    else if (false) {
      puVar2 = (uint *)cpuid_serial_info(3);
    }
    else if (false) {
      puVar2 = (uint *)cpuid_Deterministic_Cache_Parameters_info(4);
    }
    else if (false) {
      puVar2 = (uint *)cpuid_MONITOR_MWAIT_Features_info(5);
    }
    else if (false) {
      puVar2 = (uint *)cpuid_Thermal_Power_Management_info(6);
    }
    else if (false) {
      puVar2 = (uint *)cpuid_Extended_Feature_Enumeration_info(7);
    }
    else if (false) {
      puVar2 = (uint *)cpuid_Direct_Cache_Access_info(9);
    }
    else if (false) {
      puVar2 = (uint *)cpuid_Architectural_Performance_Monitoring_info(10);
    }
    else if (false) {
      puVar2 = (uint *)cpuid_Extended_Topology_info(0xb);
    }
    else if (false) {
      puVar2 = (uint *)cpuid_Processor_Extended_States_info(0xd);
    }
    else if (false) {
      puVar2 = (uint *)cpuid_Quality_of_Service_info(0xf);
    }
    else if (false) {
      puVar2 = (uint *)cpuid_brand_part1_info(0x80000002);
    }
    else if (false) {
      puVar2 = (uint *)cpuid_brand_part2_info(0x80000003);
    }
    else if (false) {
      puVar2 = (uint *)cpuid_brand_part3_info(0x80000004);
    }
    else {
      puVar2 = (uint *)cpuid(1);
    }
    uVar6 = puVar2[3];
    if (((piVar1[2] ^ 0x49656e69U | piVar1[3] ^ 0x6c65746eU | piVar1[1] ^ 0x756e6547U) == 0) &&
       (((((uVar5 = *puVar2 & 0xfff3ff0, uVar5 == 0x106c0 || (uVar5 == 0x20660)) ||
          (uVar5 == 0x20670)) || ((uVar5 == 0x30650 || (uVar5 == 0x30660)))) || (uVar5 == 0x30670)))
       ) {
      DAT_10835b50 = DAT_10835b50 | 1;
    }
    if (*piVar1 < 7) {
      uVar7 = 0;
    }
    else {
      if (false) {
        iVar3 = cpuid_basic_info(0);
      }
      else if (false) {
        iVar3 = cpuid_Version_info(1);
      }
      else if (false) {
        iVar3 = cpuid_cache_tlb_info(2);
      }
      else if (false) {
        iVar3 = cpuid_serial_info(3);
      }
      else if (false) {
        iVar3 = cpuid_Deterministic_Cache_Parameters_info(4);
      }
      else if (false) {
        iVar3 = cpuid_MONITOR_MWAIT_Features_info(5);
      }
      else if (false) {
        iVar3 = cpuid_Thermal_Power_Management_info(6);
      }
      else if (true) {
        iVar3 = cpuid_Extended_Feature_Enumeration_info(7);
      }
      else if (false) {
        iVar3 = cpuid_Direct_Cache_Access_info(9);
      }
      else if (false) {
        iVar3 = cpuid_Architectural_Performance_Monitoring_info(10);
      }
      else if (false) {
        iVar3 = cpuid_Extended_Topology_info(0xb);
      }
      else if (false) {
        iVar3 = cpuid_Processor_Extended_States_info(0xd);
      }
      else if (false) {
        iVar3 = cpuid_Quality_of_Service_info(0xf);
      }
      else if (false) {
        iVar3 = cpuid_brand_part1_info(0x80000002);
      }
      else if (false) {
        iVar3 = cpuid_brand_part2_info(0x80000003);
      }
      else if (false) {
        iVar3 = cpuid_brand_part3_info(0x80000004);
      }
      else {
        iVar3 = cpuid(7);
      }
      uVar7 = *(uint *)(iVar3 + 4);
      if ((uVar7 & 0x200) != 0) {
        DAT_10835b50 = DAT_10835b50 | 2;
      }
    }
    uVar5 = DAT_10047390 | 2;
    if ((uVar6 & 0x100000) != 0) {
      _DAT_10835b4c = 2;
      uVar5 = DAT_10047390 | 6;
      if (((uVar6 & 0x8000000) != 0) && ((uVar6 & 0x10000000) != 0)) {
        _DAT_10835b4c = 3;
        uVar5 = DAT_10047390 | 0xe;
        if ((uVar7 & 0x20) != 0) {
          _DAT_10835b4c = 5;
          uVar5 = DAT_10047390 | 0x2e;
        }
      }
    }
  }
  DAT_10047390 = uVar5;
  return 0;
}



// Library Function - Single Match
//  _strcmp
// 
// Library: Visual Studio 2012 Release

int __cdecl _strcmp(char *_Str1,char *_Str2)

{
  ushort uVar1;
  undefined4 uVar2;
  byte bVar3;
  bool bVar4;
  
  if (((uint)_Str1 & 3) != 0) {
    if (((uint)_Str1 & 1) != 0) {
      bVar3 = *_Str1;
      _Str1 = _Str1 + 1;
      bVar4 = bVar3 < (byte)*_Str2;
      if (bVar3 != *_Str2) goto LAB_10026958;
      _Str2 = _Str2 + 1;
      if (bVar3 == 0) {
        return 0;
      }
      if (((uint)_Str1 & 2) == 0) goto LAB_10026920;
    }
    uVar1 = *(ushort *)_Str1;
    _Str1 = (char *)((int)_Str1 + 2);
    bVar3 = (byte)uVar1;
    bVar4 = bVar3 < (byte)*_Str2;
    if (bVar3 != *_Str2) goto LAB_10026958;
    if (bVar3 == 0) {
      return 0;
    }
    bVar3 = (byte)((uint)uVar1 >> 8);
    bVar4 = bVar3 < ((byte *)_Str2)[1];
    if (bVar3 != ((byte *)_Str2)[1]) goto LAB_10026958;
    if (bVar3 == 0) {
      return 0;
    }
    _Str2 = (char *)((byte *)_Str2 + 2);
  }
LAB_10026920:
  while( true ) {
    uVar2 = *(undefined4 *)_Str1;
    bVar3 = (byte)uVar2;
    bVar4 = bVar3 < (byte)*_Str2;
    if (bVar3 != *_Str2) break;
    if (bVar3 == 0) {
      return 0;
    }
    bVar3 = (byte)((uint)uVar2 >> 8);
    bVar4 = bVar3 < ((byte *)_Str2)[1];
    if (bVar3 != ((byte *)_Str2)[1]) break;
    if (bVar3 == 0) {
      return 0;
    }
    bVar3 = (byte)((uint)uVar2 >> 0x10);
    bVar4 = bVar3 < ((byte *)_Str2)[2];
    if (bVar3 != ((byte *)_Str2)[2]) break;
    if (bVar3 == 0) {
      return 0;
    }
    bVar3 = (byte)((uint)uVar2 >> 0x18);
    bVar4 = bVar3 < ((byte *)_Str2)[3];
    if (bVar3 != ((byte *)_Str2)[3]) break;
    _Str2 = (char *)((byte *)_Str2 + 4);
    _Str1 = (char *)((int)_Str1 + 4);
    if (bVar3 == 0) {
      return 0;
    }
  }
LAB_10026958:
  return -(uint)bVar4 | 1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  private: static void __cdecl type_info::_Type_info_dtor(class type_info *)
// 
// Library: Visual Studio 2012 Release

void __cdecl type_info::_Type_info_dtor(type_info *param_1)

{
  int *_Memory;
  int *piVar1;
  int *piVar2;
  
  __lock(0xe);
  _Memory = DAT_10835b58;
  if (*(int *)(param_1 + 4) != 0) {
    piVar1 = (int *)&DAT_10835b54;
    do {
      piVar2 = piVar1;
      if (DAT_10835b58 == (int *)0x0) goto LAB_100269e1;
      piVar1 = DAT_10835b58;
    } while (*DAT_10835b58 != *(int *)(param_1 + 4));
    piVar2[1] = DAT_10835b58[1];
    FID_conflict__free(_Memory);
LAB_100269e1:
    FID_conflict__free(*(void **)(param_1 + 4));
    *(undefined4 *)(param_1 + 4) = 0;
  }
  FUN_10026a04();
  return;
}



void FUN_10026a04(void)

{
  FUN_1002f199(0xe);
  return;
}



undefined4 __cdecl FUN_10026a0d(LPCSTR param_1,LPWSTR *param_2)

{
  bool bVar1;
  int *piVar2;
  undefined3 extraout_var;
  BOOL BVar3;
  int iVar4;
  DWORD DVar5;
  LPWSTR lpWideCharStr;
  UINT CodePage;
  undefined4 uVar6;
  
  CodePage = 0;
  if ((param_1 == (LPCSTR)0x0) || (param_2 == (LPWSTR *)0x0)) {
    piVar2 = __errno();
    uVar6 = 0x16;
    *piVar2 = 0x16;
    FUN_10025625();
  }
  else {
    bVar1 = FUN_1002bd88();
    if ((CONCAT31(extraout_var,bVar1) == 0) && (BVar3 = AreFileApisANSI(), BVar3 == 0)) {
      CodePage = 1;
    }
    *param_2 = (LPWSTR)0x0;
    iVar4 = MultiByteToWideChar(CodePage,0,param_1,-1,(LPWSTR)0x0,0);
    if (iVar4 == 0) {
      DVar5 = GetLastError();
      FID_conflict___dosmaperr(DVar5);
    }
    else {
      lpWideCharStr = (LPWSTR)FUN_10026f23(iVar4 * 2);
      *param_2 = lpWideCharStr;
      if (lpWideCharStr != (LPWSTR)0x0) {
        iVar4 = MultiByteToWideChar(CodePage,0,param_1,-1,lpWideCharStr,iVar4);
        if (iVar4 != 0) {
          return 1;
        }
        DVar5 = GetLastError();
        FID_conflict___dosmaperr(DVar5);
        FID_conflict__free(*param_2);
        *param_2 = (LPWSTR)0x0;
      }
    }
    uVar6 = 0;
  }
  return uVar6;
}



void __cdecl FUN_10026abf(undefined4 param_1)

{
  BOOL BVar1;
  FARPROC pFVar2;
  HMODULE local_8;
  
  BVar1 = GetModuleHandleExW(0,L"mscoree.dll",&local_8);
  if (BVar1 != 0) {
    pFVar2 = GetProcAddress(local_8,"CorExitProcess");
    if (pFVar2 != (FARPROC)0x0) {
      (*pFVar2)(param_1);
    }
  }
  return;
}



// Library Function - Single Match
//  ___crtExitProcess
// 
// Library: Visual Studio 2012 Release

void __cdecl ___crtExitProcess(int param_1)

{
  FUN_10026abf(param_1);
                    // WARNING: Subroutine does not return
  ExitProcess(param_1);
}



void FUN_10026b09(void)

{
  int iVar1;
  PVOID _Memory;
  void **ppvVar2;
  
  _Memory = DecodePointer(DAT_10836b90);
  for (ppvVar2 = DAT_10835b70; (ppvVar2 != (void **)0x0 && (*ppvVar2 != (void *)0x0));
      ppvVar2 = ppvVar2 + 1) {
    FID_conflict__free(*ppvVar2);
  }
  FID_conflict__free(DAT_10835b70);
  DAT_10835b70 = (void **)0x0;
  for (ppvVar2 = DAT_10835b6c; (ppvVar2 != (void **)0x0 && (*ppvVar2 != (void *)0x0));
      ppvVar2 = ppvVar2 + 1) {
    FID_conflict__free(*ppvVar2);
  }
  FID_conflict__free(DAT_10835b6c);
  DAT_10835b6c = (void **)0x0;
  FID_conflict__free(DAT_10835b68);
  FID_conflict__free(DAT_10835b64);
  DAT_10835b68 = (void *)0x0;
  DAT_10835b64 = (void *)0x0;
  if ((_Memory != (PVOID)0xffffffff) && (DAT_10836b90 != (PVOID)0x0)) {
    FID_conflict__free(_Memory);
  }
  DAT_10836b90 = EncodePointer((PVOID)0xffffffff);
  if (DAT_10835c98 != (void *)0x0) {
    FID_conflict__free(DAT_10835c98);
    DAT_10835c98 = (void *)0x0;
  }
  if (DAT_10835c9c != (void *)0x0) {
    FID_conflict__free(DAT_10835c9c);
    DAT_10835c9c = (void *)0x0;
  }
  LOCK();
  iVar1 = *(int *)PTR_DAT_1004705c;
  *(int *)PTR_DAT_1004705c = *(int *)PTR_DAT_1004705c + -1;
  if ((iVar1 == 1) && ((undefined4 *)PTR_DAT_1004705c != &DAT_10046e38)) {
    FID_conflict__free(PTR_DAT_1004705c);
    PTR_DAT_1004705c = (undefined *)&DAT_10046e38;
  }
  return;
}



// Library Function - Single Match
//  __amsg_exit
// 
// Library: Visual Studio 2012 Release

void __cdecl __amsg_exit(int param_1)

{
  code *pcVar1;
  
  __FF_MSGBANNER();
  FUN_1002aa44(param_1);
  __exit(0xff);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  __cexit
// 
// Library: Visual Studio 2012 Release

void __cdecl __cexit(void)

{
  _doexit(0,0,1);
  return;
}



int __cdecl FUN_10026c41(int param_1)

{
  BOOL BVar1;
  int iVar2;
  
  if (true) {
    BVar1 = __IsNonwritableInCurrentImage((PBYTE)&PTR___fpmath_10039790);
    if (BVar1 != 0) {
      __fpmath(param_1);
    }
  }
  FUN_1002a33f();
  iVar2 = __initterm_e((undefined **)&DAT_1003631c,(undefined **)&DAT_10036330);
  if (iVar2 == 0) {
    FUN_1002050a(FUN_1002f780);
    FUN_10026d11((undefined **)&DAT_10036270,(undefined **)&DAT_10036318);
    if (DAT_10836b88 != (code *)0x0) {
      BVar1 = __IsNonwritableInCurrentImage((PBYTE)&DAT_10836b88);
      if (BVar1 != 0) {
        (*DAT_10836b88)(0,2,0);
      }
    }
    iVar2 = 0;
  }
  return iVar2;
}



// Library Function - Single Match
//  __exit
// 
// Library: Visual Studio 2012 Release

void __cdecl __exit(int _Code)

{
  _doexit(_Code,1,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_10026cd9(void)

{
  PVOID pvVar1;
  HMODULE hModule;
  FARPROC pFVar2;
  
  pvVar1 = EncodePointer((PVOID)0x0);
  FUN_100254bb(pvVar1);
  FUN_100255ed(pvVar1);
  FUN_1002535b(pvVar1);
  FUN_1002ba98(pvVar1);
  FUN_1002cc3b();
  FUN_10030261(pvVar1);
  hModule = GetModuleHandleW(L"kernel32.dll");
  pFVar2 = GetProcAddress(hModule,"FlsAlloc");
  DAT_10836b00 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"FlsFree");
  DAT_10836b04 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"FlsGetValue");
  DAT_10836b08 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"FlsSetValue");
  DAT_10836b0c = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"InitializeCriticalSectionEx");
  DAT_10836b10 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"CreateEventExW");
  _DAT_10836b14 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"CreateSemaphoreExW");
  _DAT_10836b18 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"SetThreadStackGuarantee");
  _DAT_10836b1c = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"CreateThreadpoolTimer");
  _DAT_10836b20 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"SetThreadpoolTimer");
  _DAT_10836b24 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"WaitForThreadpoolTimerCallbacks");
  _DAT_10836b28 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"CloseThreadpoolTimer");
  _DAT_10836b2c = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"CreateThreadpoolWait");
  _DAT_10836b30 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"SetThreadpoolWait");
  _DAT_10836b34 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"CloseThreadpoolWait");
  _DAT_10836b38 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"FlushProcessWriteBuffers");
  _DAT_10836b3c = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"FreeLibraryWhenCallbackReturns");
  _DAT_10836b40 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"GetCurrentProcessorNumber");
  _DAT_10836b44 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"GetLogicalProcessorInformation");
  _DAT_10836b48 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"CreateSymbolicLinkW");
  _DAT_10836b4c = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"SetDefaultDllDirectories");
  _DAT_10836b50 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"EnumSystemLocalesEx");
  _DAT_10836b58 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"CompareStringEx");
  DAT_10836b54 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"GetDateFormatEx");
  _DAT_10836b5c = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"GetLocaleInfoEx");
  _DAT_10836b60 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"GetTimeFormatEx");
  _DAT_10836b64 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"GetUserDefaultLocaleName");
  _DAT_10836b68 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"IsValidLocaleName");
  _DAT_10836b6c = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"LCMapStringEx");
  DAT_10836b70 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"GetCurrentPackageId");
  DAT_10836b74 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"GetTickCount64");
  _DAT_10836b78 = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"GetFileInformationByHandleExW");
  _DAT_10836b7c = (uint)pFVar2 ^ DAT_10046c24;
  pFVar2 = GetProcAddress(hModule,"SetFileInformationByHandleW");
  _DAT_10836b80 = (uint)pFVar2 ^ DAT_10046c24;
  return;
}



void __cdecl FUN_10026d11(undefined **param_1,undefined **param_2)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = 0;
  uVar2 = ~-(uint)(param_2 < param_1) & (uint)((int)param_2 + (3 - (int)param_1)) >> 2;
  if (uVar2 != 0) {
    do {
      if ((code *)*param_1 != (code *)0x0) {
        (*(code *)*param_1)();
      }
      param_1 = (code **)param_1 + 1;
      uVar1 = uVar1 + 1;
    } while (uVar1 < uVar2);
  }
  return;
}



// Library Function - Single Match
//  __initterm_e
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

void __cdecl __initterm_e(undefined **param_1,undefined **param_2)

{
  int iVar1;
  
  iVar1 = 0;
  while ((param_1 < param_2 && (iVar1 == 0))) {
    if ((code *)*param_1 != (code *)0x0) {
      iVar1 = (*(code *)*param_1)();
    }
    param_1 = (code **)param_1 + 1;
  }
  return;
}



void FUN_10026d69(void)

{
  __lock(8);
  return;
}



void FUN_10026d72(void)

{
  FUN_1002f199(8);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _doexit
// 
// Library: Visual Studio 2012 Release

void __cdecl _doexit(int param_1,int param_2,int param_3)

{
  PVOID *ppvVar1;
  PVOID pvVar2;
  code *pcVar3;
  PVOID *ppvVar4;
  PVOID *ppvVar5;
  PVOID *ppvVar6;
  PVOID *local_20;
  
  __lock(8);
  pcVar3 = DecodePointer_exref;
  if (_DAT_10835b5c != 1) {
    _DAT_10835b84 = 1;
    DAT_10835b80 = (undefined)param_3;
    if (param_2 == 0) {
      local_20 = (PVOID *)DecodePointer(DAT_10836b90);
      if (local_20 != (PVOID *)0x0) {
        ppvVar1 = (PVOID *)DecodePointer(DAT_10836b8c);
        ppvVar6 = ppvVar1;
        while (ppvVar1 = ppvVar1 + -1, local_20 <= ppvVar1) {
          pvVar2 = EncodePointer((PVOID)0x0);
          if (*ppvVar1 != pvVar2) {
            if (ppvVar1 < local_20) break;
            pcVar3 = (code *)(*pcVar3)(*ppvVar1);
            pvVar2 = EncodePointer((PVOID)0x0);
            *ppvVar1 = pvVar2;
            (*pcVar3)();
            pcVar3 = DecodePointer_exref;
            ppvVar4 = (PVOID *)DecodePointer(DAT_10836b90);
            ppvVar5 = (PVOID *)DecodePointer(DAT_10836b8c);
            if ((local_20 != ppvVar4) || (ppvVar6 != ppvVar5)) {
              ppvVar1 = ppvVar5;
              local_20 = ppvVar4;
              ppvVar6 = ppvVar5;
            }
          }
        }
      }
      FUN_10026d11((undefined **)&DAT_1003633c,(undefined **)&DAT_1003634c);
    }
    FUN_10026d11((undefined **)&DAT_10036350,(undefined **)&DAT_10036354);
  }
  FUN_10026e95();
  if (param_3 != 0) {
    return;
  }
  _DAT_10835b5c = 1;
  FUN_1002f199(8);
  ___crtExitProcess(param_1);
  if (false) {
    FUN_1002f199(8);
  }
  return;
}



void FUN_10026e95(void)

{
  int unaff_EBP;
  
  if (*(int *)(unaff_EBP + 0x10) != 0) {
    FUN_1002f199(8);
  }
  return;
}



SIZE_T __cdecl FUN_10026eaa(LPCVOID param_1)

{
  int *piVar1;
  SIZE_T SVar2;
  
  if (param_1 == (LPCVOID)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    return 0xffffffff;
  }
  SVar2 = HeapSize(DAT_10835d30,0,param_1);
  return SVar2;
}



LPVOID __cdecl FUN_10026edb(uint param_1,uint param_2)

{
  LPVOID pvVar1;
  uint uVar2;
  
  uVar2 = 0;
  while( true ) {
    pvVar1 = __calloc_impl(param_1,param_2,(int *)0x0);
    if (pvVar1 != (LPVOID)0x0) {
      return pvVar1;
    }
    if (DAT_10835b90 == 0) break;
    CThread::Sleep(uVar2);
    uVar2 = uVar2 + 1000;
    if (DAT_10835b90 < uVar2) {
      uVar2 = 0xffffffff;
    }
    if (uVar2 == 0xffffffff) {
      return (LPVOID)0x0;
    }
  }
  return (LPVOID)0x0;
}



void * __cdecl FUN_10026f23(size_t param_1)

{
  uint uVar1;
  void *pvVar2;
  uint uVar3;
  
  uVar3 = 0;
  while( true ) {
    uVar1 = DAT_10835b90;
    pvVar2 = _malloc(param_1);
    if (pvVar2 != (void *)0x0) {
      return pvVar2;
    }
    if (uVar1 == 0) break;
    CThread::Sleep(uVar3);
    uVar3 = uVar3 + 1000;
    if (DAT_10835b90 < uVar3) {
      uVar3 = 0xffffffff;
    }
    if (uVar3 == 0xffffffff) {
      return (void *)0x0;
    }
  }
  return (void *)0x0;
}



void * __cdecl FUN_10026f6a(void *param_1,size_t param_2)

{
  void *pvVar1;
  uint uVar2;
  
  uVar2 = 0;
  do {
    pvVar1 = _realloc(param_1,param_2);
    if (pvVar1 != (void *)0x0) {
      return pvVar1;
    }
    if (param_2 == 0) {
      return (void *)0x0;
    }
    if (DAT_10835b90 == 0) {
      return (void *)0x0;
    }
    CThread::Sleep(uVar2);
    uVar2 = uVar2 + 1000;
    if (DAT_10835b90 < uVar2) {
      uVar2 = 0xffffffff;
    }
  } while (uVar2 != 0xffffffff);
  return (void *)0x0;
}



void * __cdecl FUN_10026fb4(LPCVOID param_1,uint param_2,uint param_3)

{
  void *pvVar1;
  uint uVar2;
  
  uVar2 = 0;
  do {
    pvVar1 = FUN_10030319(param_1,param_2,param_3);
    if (pvVar1 != (void *)0x0) {
      return pvVar1;
    }
    if (param_3 == 0) {
      return (void *)0x0;
    }
    if (DAT_10835b90 == 0) {
      return (void *)0x0;
    }
    CThread::Sleep(uVar2);
    uVar2 = uVar2 + 1000;
    if (DAT_10835b90 < uVar2) {
      uVar2 = 0xffffffff;
    }
  } while (uVar2 != 0xffffffff);
  return (void *)0x0;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// WARNING: Variable defined which should be unmapped: param_2
// Library Function - Single Match
//  __SEH_prolog4
// 
// Library: Visual Studio

void __cdecl __SEH_prolog4(undefined4 param_1,int param_2)

{
  int iVar1;
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  int *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  uint auStack28 [5];
  undefined local_8 [8];
  
  iVar1 = -param_2;
  *(undefined4 *)((int)auStack28 + iVar1 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack28 + iVar1 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack28 + iVar1 + 8) = unaff_EDI;
  *(uint *)((int)auStack28 + iVar1 + 4) = DAT_10046c24 ^ (uint)&param_2;
  *(undefined4 *)((int)auStack28 + iVar1) = unaff_retaddr;
  *in_FS_OFFSET = (int)local_8;
  return;
}



// WARNING: This is an inlined function
// Library Function - Single Match
//  __SEH_epilog4
// 
// Library: Visual Studio

void __SEH_epilog4(void)

{
  undefined4 *unaff_EBP;
  undefined4 *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  
  *in_FS_OFFSET = unaff_EBP[-4];
  *unaff_EBP = unaff_retaddr;
  return;
}



undefined4 __cdecl FUN_10027070(PEXCEPTION_RECORD param_1,PVOID param_2,undefined4 param_3)

{
  int iVar1;
  uint uVar2;
  code *pcVar3;
  BOOL BVar4;
  undefined4 uVar5;
  undefined in_DL;
  undefined extraout_DL;
  undefined uVar6;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  undefined4 extraout_EDX;
  uint extraout_EDX_00;
  uint uVar7;
  undefined4 unaff_EDI;
  int *piVar8;
  undefined8 uVar9;
  undefined uVar10;
  PEXCEPTION_RECORD local_1c;
  undefined4 local_18;
  uint *local_14;
  undefined4 local_10;
  uint local_c;
  char local_5;
  
  local_5 = '\0';
  iVar1 = (int)param_2 + 0x10;
  piVar8 = (int *)(*(uint *)((int)param_2 + 8) ^ DAT_10046c24);
  local_10 = 1;
  if (*piVar8 != -2) {
    FUN_1002534c(piVar8[1] + iVar1 ^ *(uint *)(*piVar8 + iVar1),in_DL,(char)unaff_EDI);
    in_DL = extraout_DL;
  }
  FUN_1002534c(piVar8[3] + iVar1 ^ *(uint *)(piVar8[2] + iVar1),in_DL,(char)unaff_EDI);
  uVar10 = (undefined)unaff_EDI;
  if ((*(byte *)&param_1->ExceptionFlags & 0x66) == 0) {
    local_1c = param_1;
    local_18 = param_3;
    *(PEXCEPTION_RECORD **)((int)param_2 + -4) = &local_1c;
    local_c = *(uint *)((int)param_2 + 0xc);
    uVar5 = extraout_EDX;
    if (*(uint *)((int)param_2 + 0xc) == 0xfffffffe) {
      return local_10;
    }
    do {
      local_14 = (uint *)(piVar8 + local_c * 3 + 4);
      uVar2 = *local_14;
      if ((undefined *)piVar8[local_c * 3 + 5] != (undefined *)0x0) {
        uVar9 = __EH4_CallFilterFunc_8((undefined *)piVar8[local_c * 3 + 5]);
        uVar5 = (undefined4)((ulonglong)uVar9 >> 0x20);
        uVar10 = (undefined)unaff_EDI;
        uVar6 = (undefined)((ulonglong)uVar9 >> 0x20);
        local_5 = '\x01';
        if ((int)uVar9 < 0) {
          local_10 = 0;
          goto LAB_100271ab;
        }
        if (0 < (int)uVar9) {
          if (((param_1->ExceptionCode == 0xe06d7363) && (true)) &&
             (BVar4 = __IsNonwritableInCurrentImage((PBYTE)&PTR____DestructExceptionObject_1003aa88)
             , BVar4 != 0)) {
            ___DestructExceptionObject((int *)param_1);
          }
          __EH4_GlobalUnwind2_8(param_2,param_1);
          uVar7 = local_c;
          if (*(uint *)((int)param_2 + 0xc) != local_c) {
            __EH4_LocalUnwind_16((int)param_2,local_c,iVar1,&DAT_10046c24);
            uVar7 = extraout_EDX_00;
          }
          uVar6 = (undefined)uVar7;
          *(uint *)((int)param_2 + 0xc) = uVar2;
          if (*piVar8 != -2) {
            FUN_1002534c(piVar8[1] + iVar1 ^ *(uint *)(*piVar8 + iVar1),uVar6,uVar10);
            uVar6 = extraout_DL_01;
          }
          FUN_1002534c(piVar8[3] + iVar1 ^ *(uint *)(piVar8[2] + iVar1),uVar6,uVar10);
          __EH4_TransferToHandler_8((undefined *)local_14[2]);
          pcVar3 = (code *)swi(3);
          uVar5 = (*pcVar3)();
          return uVar5;
        }
      }
      uVar10 = (undefined)unaff_EDI;
      uVar6 = (undefined)uVar5;
      local_c = uVar2;
    } while (uVar2 != 0xfffffffe);
    if (local_5 == '\0') {
      return local_10;
    }
  }
  else {
    if (*(int *)((int)param_2 + 0xc) == -2) {
      return local_10;
    }
    __EH4_LocalUnwind_16((int)param_2,0xfffffffe,iVar1,&DAT_10046c24);
    uVar6 = extraout_DL_00;
  }
LAB_100271ab:
  if (*piVar8 != -2) {
    FUN_1002534c(piVar8[1] + iVar1 ^ *(uint *)(*piVar8 + iVar1),uVar6,uVar10);
  }
  FUN_1002534c(piVar8[3] + iVar1 ^ *(uint *)(piVar8[2] + iVar1),(char)piVar8[2],uVar10);
  return local_10;
}



void __cdecl FUN_10027204(uint *param_1,char *param_2,int *param_3)

{
  uint uVar1;
  int iVar2;
  uint uVar3;
  char *local_24;
  char *local_20;
  uint local_1c;
  uint local_18;
  ushort local_14 [6];
  uint local_8;
  
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  uVar3 = 0;
  local_20 = param_2;
  uVar1 = FUN_100272ab(local_14,&local_24,param_2,0,0,0,0,param_3);
  if ((uVar1 & 4) == 0) {
    iVar2 = FUN_100303fc(local_14,&local_1c);
    if (((uVar1 & 2) != 0) || (iVar2 == 1)) {
      uVar3 = 0x80;
    }
    if (((uVar1 & 1) != 0) || (iVar2 == 2)) {
      uVar3 = uVar3 | 0x100;
    }
  }
  else {
    uVar3 = 0x200;
    local_18 = 0;
    local_1c = 0;
  }
  *param_1 = uVar3;
  param_1[1] = (int)local_24 - (int)local_20;
  param_1[4] = local_1c;
  param_1[5] = local_18;
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,(char)param_1,(char)param_1);
  return;
}



void __cdecl
FUN_100272ab(ushort *param_1,char **param_2,char *param_3,int param_4,int param_5,int param_6,
            int param_7,int *param_8)

{
  char cVar1;
  uint uVar2;
  bool bVar3;
  bool bVar4;
  bool bVar5;
  ushort uVar6;
  ushort uVar7;
  ushort uVar8;
  ushort uVar9;
  int iVar10;
  int *piVar11;
  uint uVar12;
  int iVar13;
  ushort uVar14;
  undefined **ppuVar15;
  undefined **ppuVar16;
  undefined4 extraout_EDX;
  char *pcVar17;
  undefined **ppuVar18;
  ushort *puVar19;
  undefined4 uVar20;
  ushort uVar21;
  int iVar22;
  uint uVar23;
  uint uVar24;
  ushort *puVar25;
  undefined4 uVar26;
  ushort uVar27;
  char *pcVar28;
  int iVar29;
  uint uVar30;
  int local_70;
  uint local_6c;
  undefined **local_68;
  char local_59;
  int local_58;
  char *local_54;
  uint local_50;
  undefined2 local_4c;
  undefined2 uStack74;
  undefined2 uStack72;
  undefined2 uStack70;
  undefined *local_44;
  undefined4 local_40;
  ushort uStack60;
  undefined2 uStack58;
  ushort uStack56;
  ushort uStack54;
  byte local_30;
  undefined uStack47;
  ushort uStack46;
  ushort local_2c [4];
  char local_24 [23];
  char local_d;
  uint local_8;
  
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  local_70 = 1;
  iVar10 = 0;
  uVar6 = 0;
  pcVar28 = local_24;
  local_50 = 0;
  bVar3 = false;
  bVar5 = false;
  bVar4 = false;
  local_58 = 0;
  if (param_8 != (int *)0x0) {
    local_54 = param_3;
    for (; (((cVar1 = *param_3, cVar1 == ' ' || (cVar1 == '\t')) || (cVar1 == '\n')) ||
           (cVar1 == '\r')); param_3 = param_3 + 1) {
    }
LAB_1002732b:
    pcVar17 = param_3;
    iVar22 = 0;
    local_59 = *pcVar17;
    param_3 = pcVar17 + 1;
    if (false) goto switchD_1002733a_caseD_a;
    switch(iVar10) {
    case 0:
      if (8 < (byte)(local_59 - 0x31U)) {
        if (local_59 == ***(char ***)(*param_8 + 0x84)) {
LAB_1002735f:
          iVar10 = 5;
        }
        else if (local_59 == '+') {
          iVar10 = 2;
          uVar6 = 0;
        }
        else if (local_59 == '-') {
          iVar10 = 2;
          uVar6 = 0x8000;
        }
        else {
          if (local_59 != '0') goto LAB_10027607;
LAB_10027379:
          iVar10 = 1;
        }
        goto LAB_1002732b;
      }
      break;
    case 1:
      bVar3 = true;
      if (8 < (byte)(local_59 - 0x31U)) {
        if (local_59 == ***(char ***)(*param_8 + 0x84)) goto LAB_100273b1;
        if ((local_59 != '+') && (local_59 != '-')) {
          if (local_59 != '0') goto LAB_100273c4;
          goto LAB_10027379;
        }
        goto LAB_100273e5;
      }
      break;
    case 2:
      if (8 < (byte)(local_59 - 0x31U)) {
        if (local_59 == ***(char ***)(*param_8 + 0x84)) goto LAB_1002735f;
        pcVar17 = local_54;
        if (local_59 == '0') goto LAB_10027379;
        goto LAB_1002760b;
      }
      break;
    case 3:
      while (('/' < local_59 && (local_59 < ':'))) {
        if (local_50 < 0x19) {
          local_50 = local_50 + 1;
          *pcVar28 = local_59 + -0x30;
          pcVar28 = pcVar28 + 1;
        }
        else {
          local_58 = local_58 + 1;
        }
        local_59 = *param_3;
        param_3 = param_3 + 1;
      }
      if (local_59 != ***(char ***)(*param_8 + 0x84)) {
        if ((local_59 == '+') || (local_59 == '-')) goto LAB_100273e5;
LAB_100273c4:
        bVar3 = true;
        iVar22 = 0;
        if (('C' < local_59) && ((local_59 < 'F' || ((byte)(local_59 + 0x9cU) < 2))))
        goto LAB_100273de;
        goto LAB_10027607;
      }
LAB_100273b1:
      bVar3 = true;
      iVar10 = 4;
      goto LAB_1002732b;
    case 4:
      bVar3 = true;
      bVar5 = true;
      if (local_50 == 0) {
        while (local_59 == '0') {
          local_58 = local_58 + -1;
          local_59 = *param_3;
          param_3 = param_3 + 1;
        }
      }
      while (('/' < local_59 && (local_59 < ':'))) {
        if (local_50 < 0x19) {
          local_50 = local_50 + 1;
          *pcVar28 = local_59 + -0x30;
          pcVar28 = pcVar28 + 1;
          local_58 = local_58 + -1;
        }
        local_59 = *param_3;
        param_3 = param_3 + 1;
      }
      iVar22 = 0;
      if ((local_59 == '+') || (local_59 == '-')) {
LAB_100273e5:
        bVar3 = true;
        iVar10 = 0xb;
        param_3 = param_3 + -1;
      }
      else {
        if ((local_59 < 'D') || (('E' < local_59 && (1 < (byte)(local_59 + 0x9cU))))) {
          pcVar17 = param_3 + -1;
          goto LAB_1002760b;
        }
LAB_100273de:
        bVar3 = true;
        iVar10 = 6;
      }
      goto LAB_1002732b;
    case 5:
      bVar5 = true;
      pcVar17 = local_54;
      if ((byte)(local_59 - 0x30U) < 10) {
        iVar10 = 4;
        goto LAB_1002734a;
      }
      goto LAB_1002760b;
    case 6:
      local_54 = pcVar17 + -1;
      if ((byte)(local_59 - 0x31U) < 9) goto LAB_10027528;
      if (local_59 == '+') goto LAB_10027559;
      if (local_59 == '-') {
        iVar10 = 7;
        local_70 = -1;
      }
      else {
LAB_1002753e:
        pcVar17 = local_54;
        if (local_59 != '0') goto LAB_1002760b;
        iVar10 = 8;
      }
      goto LAB_1002732b;
    case 7:
      if (8 < (byte)(local_59 - 0x31U)) goto LAB_1002753e;
      goto LAB_10027528;
    case 8:
      bVar4 = true;
      while (local_59 == '0') {
        local_59 = *param_3;
        param_3 = param_3 + 1;
      }
      if ((byte)(local_59 - 0x31U) < 9) {
LAB_10027528:
        iVar10 = 9;
        goto LAB_1002734a;
      }
      goto LAB_10027607;
    case 9:
      iVar22 = 0;
      bVar4 = true;
      goto LAB_100275e9;
    default:
      goto switchD_1002733a_caseD_a;
    case 0xb:
      if (param_7 != 0) {
        local_54 = pcVar17;
        if (local_59 == '+') {
LAB_10027559:
          iVar10 = 7;
        }
        else {
          if (local_59 != '-') goto LAB_1002760b;
          local_70 = -1;
          iVar10 = 7;
        }
        goto LAB_1002732b;
      }
      iVar10 = 10;
      param_3 = pcVar17;
switchD_1002733a_caseD_a:
      pcVar17 = param_3;
      if (iVar10 != 10) goto LAB_1002732b;
      goto LAB_1002760b;
    }
    iVar10 = 3;
LAB_1002734a:
    param_3 = param_3 + -1;
    goto LAB_1002732b;
  }
  piVar11 = __errno();
  *piVar11 = 0x16;
  FUN_10025625();
  uVar20 = extraout_EDX;
  goto LAB_10027a12;
LAB_100275e9:
  if ((local_59 < '0') || ('9' < local_59)) goto LAB_10027602;
  iVar22 = local_59 + -0x30 + iVar22 * 10;
  if (iVar22 < 0x1451) {
    local_59 = *param_3;
    param_3 = param_3 + 1;
    goto LAB_100275e9;
  }
  iVar22 = 0x1451;
LAB_10027602:
  while (('/' < local_59 && (local_59 < ':'))) {
    local_59 = *param_3;
    param_3 = param_3 + 1;
  }
LAB_10027607:
  pcVar17 = param_3 + -1;
LAB_1002760b:
  *param_2 = pcVar17;
  if (bVar3) {
    if (0x18 < local_50) {
      if ('\x04' < local_d) {
        local_d = local_d + '\x01';
      }
      pcVar28 = pcVar28 + -1;
      local_58 = local_58 + 1;
      local_50 = 0x18;
    }
    if (local_50 == 0) {
      uVar14 = 0;
      uVar21 = 0;
      uVar26 = 0;
      uVar20 = 0;
    }
    else {
      pcVar28 = pcVar28 + -1;
      cVar1 = *pcVar28;
      while (cVar1 == '\0') {
        local_50 = local_50 - 1;
        local_58 = local_58 + 1;
        pcVar28 = pcVar28 + -1;
        cVar1 = *pcVar28;
      }
      FUN_10030ee0(local_24,local_50,&local_40);
      if (local_70 < 0) {
        iVar22 = -iVar22;
      }
      uVar23 = iVar22 + local_58;
      if (!bVar4) {
        uVar23 = uVar23 + param_5;
      }
      if (!bVar5) {
        uVar23 = uVar23 - param_6;
      }
      if (0x1450 < (int)uVar23) {
        uVar21 = 0x7fff;
        uVar26 = 0x80000000;
        goto LAB_100279f8;
      }
      if ((int)uVar23 < -0x1450) {
        uVar14 = 0;
        uVar21 = 0;
        uVar26 = 0;
        uVar20 = 0;
      }
      else {
        ppuVar18 = &PTR_DAT_100477c8;
        if (uVar23 != 0) {
          if ((int)uVar23 < 0) {
            uVar23 = -uVar23;
            ppuVar18 = (undefined **)0x10047928;
          }
          if (param_4 == 0) {
            local_40._0_2_ = 0;
          }
LAB_100279b1:
          do {
            iVar10 = 0;
            if (uVar23 == 0) break;
            ppuVar18 = ppuVar18 + 0x15;
            uVar24 = (int)uVar23 >> 3;
            uVar12 = uVar23 & 7;
            uVar23 = uVar24;
            if (uVar12 != 0) {
              ppuVar15 = ppuVar18 + uVar12 * 3;
              ppuVar16 = ppuVar15;
              if (0x7fff < *(ushort *)ppuVar15) {
                ppuVar16 = (undefined **)&local_4c;
                local_4c = SUB42(*ppuVar15,0);
                uStack74 = (undefined2)((uint)*ppuVar15 >> 0x10);
                uStack72 = SUB42(ppuVar15[1],0);
                uStack70 = (undefined2)((uint)ppuVar15[1] >> 0x10);
                local_44 = ppuVar15[2];
                iVar22 = CONCAT22(uStack72,uStack74) + -1;
                uStack74 = (undefined2)iVar22;
                uStack72 = (undefined2)((uint)iVar22 >> 0x10);
              }
              uVar14 = (*(ushort *)((int)ppuVar16 + 10) ^ uStack54) & 0x8000;
              local_30 = 0;
              uStack47 = 0;
              uStack46 = 0;
              uVar9 = uStack54 & 0x7fff;
              local_2c[0] = 0;
              uVar27 = *(ushort *)((int)ppuVar16 + 10) & 0x7fff;
              uVar21 = uVar27 + uVar9;
              local_2c[1] = uStack46;
              local_2c[2] = local_2c[0];
              local_2c[3] = uStack46;
              if (((uVar9 < 0x7fff) && (uVar27 < 0x7fff)) && (uVar21 < 0xbffe)) {
                uVar7 = local_2c[0];
                uVar8 = uStack46;
                if (0x3fbf < uVar21) {
                  if (((uVar9 == 0) &&
                      (uVar21 = uVar21 + 1, (CONCAT22(uStack54,uStack56) & 0x7fffffff) == 0)) &&
                     ((CONCAT22(uStack58,uStack60) == 0 &&
                      (CONCAT22(local_40._2_2_,(ushort)local_40) == 0)))) {
                    uStack54 = 0;
                    goto LAB_100279b1;
                  }
                  if (((uVar27 != 0) || (uVar21 = uVar21 + 1, ((uint)ppuVar16[2] & 0x7fffffff) != 0)
                      ) || ((ppuVar16[1] != (undefined *)0x0 ||
                            (uVar7 = local_2c[0], uVar8 = uStack46, *ppuVar16 != (undefined *)0x0)))
                     ) {
                    puVar19 = local_2c;
                    local_6c = 5;
                    iVar22 = iVar10;
                    do {
                      if (0 < (int)local_6c) {
                        puVar25 = (ushort *)((int)&local_40 + iVar22 * 2);
                        local_68 = ppuVar16 + 2;
                        iVar29 = local_6c;
                        do {
                          uVar12 = (uint)*puVar25 * (uint)*(ushort *)local_68 +
                                   *(int *)(puVar19 + -2);
                          if ((uVar12 < *(uint *)(puVar19 + -2)) ||
                             (iVar13 = iVar10, uVar12 < (uint)*puVar25 * (uint)*(ushort *)local_68))
                          {
                            iVar13 = 1;
                          }
                          *(uint *)(puVar19 + -2) = uVar12;
                          if (iVar13 != 0) {
                            *puVar19 = *puVar19 + 1;
                          }
                          local_68 = (undefined **)((int)local_68 + -2);
                          puVar25 = puVar25 + 1;
                          iVar29 = iVar29 + -1;
                        } while (0 < iVar29);
                      }
                      puVar19 = puVar19 + 1;
                      iVar22 = iVar22 + 1;
                      local_6c = local_6c + -1;
                    } while (0 < (int)local_6c);
                    local_54 = (char *)CONCAT22(local_2c[3],local_2c[2]);
                    uVar21 = uVar21 + 0xc002;
                    uVar12 = CONCAT22(uStack46,CONCAT11(uStack47,local_30));
                    if ((short)uVar21 < 1) {
LAB_10027880:
                      uVar21 = uVar21 - 1;
                      if (-1 < (short)uVar21) goto LAB_100278e9;
                      local_6c = (uint)(ushort)-uVar21;
                      uVar21 = 0;
                      uVar24 = (uint)local_54;
                      do {
                        if ((local_30 & 1) != 0) {
                          iVar10 = iVar10 + 1;
                        }
                        uVar2 = CONCAT22(local_2c[1],local_2c[0]);
                        local_2c[1] = local_2c[1] >> 1 | (ushort)((uVar24 << 0x1f) >> 0x10);
                        uVar30 = uVar12 >> 1;
                        local_54 = (char *)(uVar24 >> 1);
                        uVar12 = uVar30 | uVar2 << 0x1f;
                        local_6c = local_6c - 1;
                        local_2c[2] = (ushort)local_54;
                        local_2c[3] = (ushort)(uVar24 >> 0x11);
                        local_2c[0] = (ushort)(uVar2 >> 1);
                        local_30 = (byte)uVar30;
                        uStack47 = (undefined)(uVar30 >> 8);
                        uStack46 = (ushort)(uVar12 >> 0x10);
                        uVar24 = (uint)local_54;
                      } while (local_6c != 0);
                      if (iVar10 == 0) goto LAB_100278e9;
                      uVar9 = (ushort)uVar30 | 1;
                      local_30 = (byte)uVar9;
                      uVar12 = uVar30 | 1;
                    }
                    else {
                      do {
                        if ((int)local_54 < 0) break;
                        iVar22 = CONCAT22(local_2c[1],local_2c[0]) * 2;
                        uVar9 = local_2c[1] >> 0xf;
                        local_2c[0] = (ushort)iVar22 | (ushort)(uVar12 >> 0x1f);
                        uVar12 = uVar12 * 2;
                        local_2c[1] = (ushort)((uint)iVar22 >> 0x10);
                        uVar24 = (int)local_54 * 2;
                        local_30 = (byte)uVar12;
                        uStack47 = (undefined)(uVar12 >> 8);
                        uStack46 = (ushort)(uVar12 >> 0x10);
                        local_54 = (char *)(uVar24 | uVar9);
                        uVar21 = uVar21 - 1;
                        local_2c[2] = (ushort)local_54;
                        local_2c[3] = (ushort)(uVar24 >> 0x10);
                      } while (0 < (short)uVar21);
                      if ((short)uVar21 < 1) goto LAB_10027880;
LAB_100278e9:
                      uVar9 = CONCAT11(uStack47,local_30);
                    }
                    if ((0x8000 < uVar9) || ((uVar12 & 0x1ffff) == 0x18000)) {
                      if (CONCAT22(local_2c[0],uStack46) == -1) {
                        uStack46 = 0;
                        local_2c[0] = 0;
                        if (CONCAT22(local_2c[2],local_2c[1]) == -1) {
                          local_2c[1] = 0;
                          local_2c[2] = 0;
                          if (local_2c[3] == 0xffff) {
                            local_2c[3] = 0x8000;
                            uVar21 = uVar21 + 1;
                          }
                          else {
                            local_2c[3] = local_2c[3] + 1;
                          }
                        }
                        else {
                          iVar10 = CONCAT22(local_2c[2],local_2c[1]) + 1;
                          local_2c[1] = (ushort)iVar10;
                          local_2c[2] = (ushort)((uint)iVar10 >> 0x10);
                        }
                        local_54 = (char *)CONCAT22(local_2c[3],local_2c[2]);
                      }
                      else {
                        iVar10 = CONCAT22(local_2c[0],uStack46) + 1;
                        uStack46 = (ushort)iVar10;
                        local_2c[0] = (ushort)((uint)iVar10 >> 0x10);
                      }
                    }
                    if (uVar21 < 0x7fff) {
                      local_40._0_2_ = uStack46;
                      local_40._2_2_ = local_2c[0];
                      uStack60 = local_2c[1];
                      uStack58 = SUB42(local_54,0);
                      uStack56 = (ushort)((uint)local_54 >> 0x10);
                      uStack54 = uVar21 | uVar14;
                    }
                    else {
                      uStack60 = 0;
                      uStack58 = 0;
                      local_40._0_2_ = 0;
                      local_40._2_2_ = 0;
                      iVar10 = ((uVar14 == 0) - 1 & 0x80000000) + 0x7fff8000;
                      uStack56 = (ushort)iVar10;
                      uStack54 = (ushort)((uint)iVar10 >> 0x10);
                    }
                    goto LAB_100279b1;
                  }
                }
              }
              else {
                iVar10 = ((uVar14 == 0) - 1 & 0x80000000) + 0x7fff8000;
                uStack56 = (ushort)iVar10;
                uStack54 = (ushort)((uint)iVar10 >> 0x10);
                uVar7 = uStack56;
                uVar8 = uStack54;
              }
              uStack54 = uVar8;
              uStack56 = uVar7;
              uStack60 = 0;
              uStack58 = 0;
              local_40._0_2_ = 0;
              local_40._2_2_ = 0;
            }
          } while( true );
        }
        uVar20 = CONCAT22(uStack60,local_40._2_2_);
        uVar26 = CONCAT22(uStack56,uStack58);
        uVar21 = uStack54;
        uVar14 = (ushort)local_40;
      }
    }
  }
  else {
    uVar21 = 0;
    uVar26 = 0;
LAB_100279f8:
    uVar14 = 0;
    uVar20 = 0;
  }
  param_1[5] = uVar21 | uVar6;
  *param_1 = uVar14;
  *(undefined4 *)(param_1 + 1) = uVar20;
  *(undefined4 *)(param_1 + 3) = uVar26;
LAB_10027a12:
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,(char)uVar20,(char)param_1);
  return;
}



ushort __cdecl FUN_10027a53(int param_1,ushort param_2,pthreadlocinfo *param_3)

{
  ushort uVar1;
  undefined2 extraout_var;
  int iVar2;
  pthreadlocinfo local_1c [2];
  int local_14;
  char local_10;
  CHAR local_c;
  CHAR local_b;
  undefined local_a;
  ushort local_8 [2];
  
  FUN_1001f92e(local_1c,param_3);
  if (param_1 + 1U < 0x101) {
    local_8[0] = local_1c[0]->pctype[param_1];
  }
  else {
    uVar1 = FUN_10029715(param_1 >> 8 & 0xff,local_1c);
    if (CONCAT22(extraout_var,uVar1) == 0) {
      local_b = '\0';
      iVar2 = 1;
      local_c = (CHAR)param_1;
    }
    else {
      local_a = 0;
      iVar2 = 2;
      local_c = (CHAR)((uint)param_1 >> 8);
      local_b = (CHAR)param_1;
    }
    iVar2 = FUN_100300dd(local_1c,1,&local_c,iVar2,local_8,local_1c[0]->lc_codepage,1);
    if (iVar2 == 0) {
      if (local_10 != '\0') {
        *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
      }
      return 0;
    }
  }
  if (local_10 != '\0') {
    *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
  }
  return local_8[0] & param_2;
}



uint __cdecl
FUN_10027b04(pthreadlocinfo *param_1,byte *param_2,byte **param_3,uint param_4,uint param_5)

{
  byte *pbVar1;
  ushort uVar2;
  int *piVar3;
  undefined2 extraout_var;
  uint uVar4;
  uint uVar5;
  int iVar6;
  byte *pbVar7;
  pthreadlocinfo ptVar8;
  pthreadlocinfo local_28 [2];
  int local_20;
  char local_1c;
  ushort *local_18;
  uint local_14;
  uint local_10;
  uint local_c;
  byte local_5;
  
  FUN_1001f92e(local_28,param_1);
  if (param_3 != (byte **)0x0) {
    *param_3 = param_2;
  }
  if ((param_2 == (byte *)0x0) || ((param_4 != 0 && (((int)param_4 < 2 || (0x24 < (int)param_4))))))
  {
    piVar3 = __errno();
    *piVar3 = 0x16;
    FUN_10025625();
  }
  else {
    local_10 = 0;
    local_5 = *param_2;
    ptVar8 = local_28[0];
    pbVar1 = param_2;
    while( true ) {
      pbVar7 = pbVar1 + 1;
      if (ptVar8->mb_cur_max < 2) {
        uVar4 = ptVar8->pctype[local_5] & 8;
      }
      else {
        uVar2 = FUN_10027a53((uint)local_5,8,local_28);
        uVar4 = CONCAT22(extraout_var,uVar2);
        ptVar8 = local_28[0];
      }
      if (uVar4 == 0) break;
      local_5 = *pbVar7;
      pbVar1 = pbVar7;
    }
    if (local_5 == 0x2d) {
      param_5 = param_5 | 2;
LAB_10027ba2:
      local_5 = *pbVar7;
      pbVar7 = pbVar1 + 2;
    }
    else if (local_5 == 0x2b) goto LAB_10027ba2;
    if (((-1 < (int)param_4) && (param_4 != 1)) && ((int)param_4 < 0x25)) {
      if (param_4 == 0) {
        if (local_5 != 0x30) {
          param_4 = 10;
          goto LAB_10027c13;
        }
        if ((*pbVar7 != 0x78) && (*pbVar7 != 0x58)) {
          param_4 = 8;
          goto LAB_10027c13;
        }
        param_4 = 0x10;
      }
      else if ((param_4 != 0x10) || (local_5 != 0x30)) goto LAB_10027c13;
      if ((*pbVar7 == 0x78) || (*pbVar7 == 0x58)) {
        local_5 = pbVar7[1];
        pbVar7 = pbVar7 + 2;
      }
LAB_10027c13:
      uVar4 = (uint)(0xffffffff / (ulonglong)param_4);
      local_14 = (uint)(0xffffffff % (ulonglong)param_4);
      local_18 = local_28[0]->pctype;
      do {
        if ((local_18[local_5] & 4) == 0) {
          if ((local_18[local_5] & 0x103) == 0) goto LAB_10027c94;
          iVar6 = (int)(char)local_5;
          if ((byte)(local_5 + 0x9f) < 0x1a) {
            iVar6 = iVar6 + -0x20;
          }
          uVar5 = iVar6 - 0x37;
        }
        else {
          uVar5 = (int)(char)local_5 - 0x30;
        }
        if (param_4 <= uVar5) goto LAB_10027c94;
        if ((local_10 < uVar4) || ((local_10 == uVar4 && (uVar5 <= local_14)))) {
          local_10 = local_10 * param_4 + uVar5;
          param_5 = param_5 | 8;
        }
        else {
          param_5 = param_5 | 0xc;
          if (param_3 == (byte **)0x0) goto LAB_10027c94;
        }
        local_5 = *pbVar7;
        pbVar7 = pbVar7 + 1;
      } while( true );
    }
    if (param_3 != (byte **)0x0) {
      *param_3 = param_2;
    }
  }
  local_10 = 0;
LAB_10027d14:
  if (local_1c != '\0') {
    *(uint *)(local_20 + 0x70) = *(uint *)(local_20 + 0x70) & 0xfffffffd;
  }
  return local_10;
LAB_10027c94:
  pbVar7 = pbVar7 + -1;
  if ((param_5 & 8) == 0) {
    if (param_3 != (byte **)0x0) {
      pbVar7 = param_2;
    }
    local_10 = 0;
  }
  else if (((param_5 & 4) != 0) ||
          (((param_5 & 1) == 0 &&
           ((((param_5 & 2) != 0 && (0x80000000 < local_10)) ||
            (((param_5 & 2) == 0 && (0x7fffffff < local_10)))))))) {
    local_10 = uVar4;
    local_c = param_5;
    piVar3 = __errno();
    *piVar3 = 0x22;
    param_5 = local_c;
    if ((local_c & 1) == 0) {
      local_10 = ((local_c & 2) != 0) + 0x7fffffff;
    }
    else {
      local_10 = 0xffffffff;
    }
  }
  if (param_3 != (byte **)0x0) {
    *param_3 = pbVar7;
  }
  if ((param_5 & 2) != 0) {
    local_10 = -local_10;
  }
  goto LAB_10027d14;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_10027d2a(byte *param_1,byte **param_2,uint param_3)

{
  undefined **ppuVar1;
  
  if (_DAT_10835ca0 == 0) {
    ppuVar1 = &PTR_DAT_10047380;
  }
  else {
    ppuVar1 = (undefined **)0x0;
  }
  FUN_10027b04((pthreadlocinfo *)ppuVar1,param_1,param_2,param_3,0);
  return;
}



// Library Function - Single Match
//  __fileno
// 
// Library: Visual Studio 2012 Release

int __cdecl __fileno(FILE *_File)

{
  int *piVar1;
  
  if (_File == (FILE *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    return -1;
  }
  return _File->_file;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

undefined4 __cdecl FUN_10027d78(uint param_1)

{
  ulong *puVar1;
  int *piVar2;
  undefined4 uVar3;
  int iVar4;
  
  if (param_1 == 0xfffffffe) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if (((int)param_1 < 0) || (DAT_10836b84 <= param_1)) {
      puVar1 = ___doserrno();
      *puVar1 = 0;
    }
    else {
      iVar4 = (param_1 & 0x1f) * 0x40;
      if ((*(byte *)((&DAT_10835b98)[(int)param_1 >> 5] + 4 + iVar4) & 1) != 0) {
        FUN_100248ff(param_1);
        if ((*(byte *)((&DAT_10835b98)[(int)param_1 >> 5] + 4 + iVar4) & 1) == 0) {
          piVar2 = __errno();
          *piVar2 = 9;
          uVar3 = 0xffffffff;
        }
        else {
          uVar3 = FUN_10027e53(param_1);
        }
        FUN_10027e2b();
        return uVar3;
      }
      puVar1 = ___doserrno();
      *puVar1 = 0;
    }
    piVar2 = __errno();
    *piVar2 = 9;
    FUN_10025625();
  }
  return 0xffffffff;
}



void FUN_10027e2b(void)

{
  uint unaff_ESI;
  
  FUN_10024dbb(unaff_ESI);
  return;
}



undefined4 __cdecl FUN_10027e53(uint param_1)

{
  int iVar1;
  int iVar2;
  HANDLE hObject;
  BOOL BVar3;
  DWORD DVar4;
  undefined4 uVar5;
  
  iVar1 = FUN_10024bbc(param_1);
  if (iVar1 != -1) {
    if (((param_1 == 1) && ((*(byte *)(DAT_10835b98 + 0x84) & 1) != 0)) ||
       ((param_1 == 2 && ((*(byte *)(DAT_10835b98 + 0x44) & 1) != 0)))) {
      iVar1 = FUN_10024bbc(2);
      iVar2 = FUN_10024bbc(1);
      if (iVar2 == iVar1) goto LAB_10027eb7;
    }
    hObject = (HANDLE)FUN_10024bbc(param_1);
    BVar3 = CloseHandle(hObject);
    if (BVar3 == 0) {
      DVar4 = GetLastError();
      goto LAB_10027eb9;
    }
  }
LAB_10027eb7:
  DVar4 = 0;
LAB_10027eb9:
  FUN_10024b36(param_1);
  *(undefined *)((&DAT_10835b98)[(int)param_1 >> 5] + 4 + (param_1 & 0x1f) * 0x40) = 0;
  if (DVar4 == 0) {
    uVar5 = 0;
  }
  else {
    FID_conflict___dosmaperr(DVar4);
    uVar5 = 0xffffffff;
  }
  return uVar5;
}



// Library Function - Single Match
//  __freebuf
// 
// Library: Visual Studio 2012 Release

void __cdecl __freebuf(FILE *_File)

{
  if (((*(byte *)&_File->_flag & 0x83) != 0) && ((*(byte *)&_File->_flag & 8) != 0)) {
    FID_conflict__free(_File->_base);
    _File->_flag = _File->_flag & 0xfffffbf7;
    _File->_ptr = (char *)0x0;
    _File->_base = (char *)0x0;
    _File->_cnt = 0;
  }
  return;
}



int __cdecl FUN_10027f1d(FILE *param_1)

{
  int iVar1;
  uint uVar2;
  DWORD DVar3;
  
  if (param_1 == (FILE *)0x0) {
    iVar1 = _flsall(0);
  }
  else {
    iVar1 = FUN_10027f63(param_1);
    if (iVar1 == 0) {
      if ((param_1->_flag & 0x4000U) == 0) {
        iVar1 = 0;
      }
      else {
        uVar2 = __fileno(param_1);
        DVar3 = FUN_100312a5(uVar2);
        iVar1 = -(uint)(DVar3 != 0);
      }
    }
    else {
      iVar1 = -1;
    }
  }
  return iVar1;
}



undefined4 __cdecl FUN_10027f63(FILE *param_1)

{
  WCHAR *pWVar1;
  uint uVar2;
  undefined4 uVar3;
  uint uVar4;
  WCHAR *pWVar5;
  
  uVar3 = 0;
  if (((((byte)param_1->_flag & 3) == 2) && ((param_1->_flag & 0x108U) != 0)) &&
     (uVar4 = (int)param_1->_ptr - (int)param_1->_base, 0 < (int)uVar4)) {
    pWVar5 = (WCHAR *)param_1->_base;
    uVar2 = uVar4;
    pWVar1 = (WCHAR *)__fileno(param_1);
    uVar2 = FUN_1002e63e(pWVar1,pWVar5,uVar2);
    if (uVar2 == uVar4) {
      if ((char)param_1->_flag < '\0') {
        param_1->_flag = param_1->_flag & 0xfffffffd;
      }
    }
    else {
      param_1->_flag = param_1->_flag | 0x20;
      uVar3 = 0xffffffff;
    }
  }
  param_1->_cnt = 0;
  param_1->_ptr = param_1->_base;
  return uVar3;
}



void FUN_10027fc7(void)

{
  _flsall(1);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  _flsall
// 
// Library: Visual Studio 2012 Release

int __cdecl _flsall(int param_1)

{
  void *_File;
  FILE *pFVar1;
  int iVar2;
  int _Index;
  int iVar3;
  int local_28;
  
  iVar3 = 0;
  local_28 = 0;
  __lock(1);
  for (_Index = 0; _Index < DAT_10837ba4; _Index = _Index + 1) {
    _File = *(void **)(DAT_10837ba0 + _Index * 4);
    if ((_File != (void *)0x0) && ((*(byte *)((int)_File + 0xc) & 0x83) != 0)) {
      __lock_file2(_Index,_File);
      pFVar1 = *(FILE **)(DAT_10837ba0 + _Index * 4);
      if ((*(byte *)&pFVar1->_flag & 0x83) != 0) {
        if (param_1 == 1) {
          iVar2 = FUN_10027f1d(pFVar1);
          if (iVar2 != -1) {
            iVar3 = iVar3 + 1;
          }
        }
        else if ((param_1 == 0) && ((*(byte *)&pFVar1->_flag & 2) != 0)) {
          iVar2 = FUN_10027f1d(pFVar1);
          if (iVar2 == -1) {
            local_28 = -1;
          }
        }
      }
      FUN_10028078();
    }
  }
  FUN_100280ab();
  if (param_1 != 1) {
    iVar3 = local_28;
  }
  return iVar3;
}



void FUN_10028078(void)

{
  int unaff_ESI;
  
  __unlock_file2(unaff_ESI,*(void **)(DAT_10837ba0 + unaff_ESI * 4));
  return;
}



void FUN_100280ab(void)

{
  FUN_1002f199(1);
  return;
}



uint __cdecl FUN_100280b4(FILE *param_1)

{
  byte bVar1;
  int *piVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  undefined *puVar6;
  LPWSTR pWVar7;
  
  if (param_1 == (FILE *)0x0) {
    piVar2 = __errno();
    *piVar2 = 0x16;
    FUN_10025625();
  }
  else {
    uVar4 = param_1->_flag;
    if (((uVar4 & 0x83) != 0) && ((uVar4 & 0x40) == 0)) {
      if ((uVar4 & 2) == 0) {
        param_1->_flag = uVar4 | 1;
        if ((uVar4 & 0x10c) == 0) {
          __getbuf(param_1);
        }
        else {
          param_1->_ptr = param_1->_base;
        }
        uVar4 = param_1->_bufsiz;
        pWVar7 = (LPWSTR)param_1->_base;
        uVar3 = __fileno(param_1);
        uVar4 = FUN_1002da94(uVar3,pWVar7,uVar4);
        param_1->_cnt = uVar4;
        if ((uVar4 != 0) && (uVar4 != 0xffffffff)) {
          if ((*(byte *)&param_1->_flag & 0x82) == 0) {
            iVar5 = __fileno(param_1);
            if ((iVar5 == -1) || (iVar5 = __fileno(param_1), iVar5 == -2)) {
              puVar6 = &DAT_100473a0;
            }
            else {
              iVar5 = __fileno(param_1);
              uVar4 = __fileno(param_1);
              puVar6 = (undefined *)((uVar4 & 0x1f) * 0x40 + (&DAT_10835b98)[iVar5 >> 5]);
            }
            if ((puVar6[4] & 0x82) == 0x82) {
              param_1->_flag = param_1->_flag | 0x2000;
            }
          }
          if (((param_1->_bufsiz == 0x200) && ((*(byte *)&param_1->_flag & 8) != 0)) &&
             ((param_1->_flag & 0x400U) == 0)) {
            param_1->_bufsiz = 0x1000;
          }
          param_1->_cnt = param_1->_cnt + -1;
          bVar1 = *param_1->_ptr;
          param_1->_ptr = param_1->_ptr + 1;
          return (uint)bVar1;
        }
        param_1->_flag = param_1->_flag | (-(uint)(uVar4 != 0) & 0x10) + 0x10;
        param_1->_cnt = 0;
      }
      else {
        param_1->_flag = uVar4 | 0x20;
      }
    }
  }
  return 0xffffffff;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

undefined4 FUN_100281d5(void)

{
  HANDLE hFile;
  uint uVar1;
  byte bVar2;
  undefined4 uVar3;
  DWORD DVar4;
  HANDLE pvVar5;
  HANDLE *ppvVar6;
  int iVar7;
  _STARTUPINFOW local_78;
  int local_34;
  uint local_30;
  HANDLE *local_2c;
  HANDLE *local_28;
  HANDLE *local_24;
  HANDLE local_20;
  undefined local_14 [8];
  undefined4 uStack12;
  undefined *local_8;
  
  local_8 = &DAT_1003fe88;
  uStack12 = 0x100281e1;
  __lock(0xb);
  local_8 = (undefined *)0x0;
  local_28 = (HANDLE *)FUN_10026edb(0x20,0x40);
  if (local_28 == (HANDLE *)0x0) {
    __local_unwind4(&DAT_10046c24,(int)local_14,0xfffffffe);
    uVar3 = 0xffffffff;
  }
  else {
    DAT_10836b84 = (HANDLE)0x20;
    DAT_10835b98 = local_28;
    for (; local_28 < DAT_10835b98 + 0x200; local_28 = local_28 + 0x10) {
      *(undefined2 *)(local_28 + 1) = 0xa00;
      *local_28 = (HANDLE)0xffffffff;
      local_28[2] = (HANDLE)0x0;
      *(byte *)(local_28 + 9) = *(byte *)(local_28 + 9) & 0x80;
      *(byte *)(local_28 + 9) = *(byte *)(local_28 + 9) & 0x7f;
      *(undefined2 *)((int)local_28 + 0x25) = 0xa0a;
      local_28[0xe] = (HANDLE)0x0;
      *(undefined *)(local_28 + 0xd) = 0;
    }
    GetStartupInfoW(&local_78);
    if ((local_78.cbReserved2 != 0) && ((HANDLE *)local_78.lpReserved2 != (HANDLE *)0x0)) {
      local_20 = *(HANDLE *)local_78.lpReserved2;
      local_2c = (HANDLE *)((int)local_78.lpReserved2 + 4);
      local_24 = (HANDLE *)((int)local_2c + (int)local_20);
      if (0x7ff < (int)local_20) {
        local_20 = (HANDLE)0x800;
      }
      local_34 = 1;
      while (iVar7 = local_34, (int)DAT_10836b84 < (int)local_20) {
        local_28 = (HANDLE *)FUN_10026edb(0x20,0x40);
        if (local_28 == (HANDLE *)0x0) {
          local_20 = DAT_10836b84;
          break;
        }
        (&DAT_10835b98)[iVar7] = local_28;
        DAT_10836b84 = (HANDLE)((int)DAT_10836b84 + 0x20);
        for (; local_28 < (HANDLE *)((int)(&DAT_10835b98)[iVar7] + 0x800);
            local_28 = local_28 + 0x10) {
          *(undefined2 *)(local_28 + 1) = 0xa00;
          *local_28 = (HANDLE)0xffffffff;
          local_28[2] = (HANDLE)0x0;
          *(byte *)(local_28 + 9) = *(byte *)(local_28 + 9) & 0x80;
          *(undefined2 *)((int)local_28 + 0x25) = 0xa0a;
          local_28[0xe] = (HANDLE)0x0;
          *(undefined *)(local_28 + 0xd) = 0;
        }
        local_34 = iVar7 + 1;
      }
      local_30 = 0;
      pvVar5 = local_20;
      while (uVar1 = local_30, (int)local_30 < (int)pvVar5) {
        hFile = *local_24;
        if ((((hFile != (HANDLE)0xffffffff) && (hFile != (HANDLE)0xfffffffe)) &&
            ((*(byte *)local_2c & 1) != 0)) &&
           (((*(byte *)local_2c & 8) != 0 ||
            (DVar4 = GetFileType(hFile), pvVar5 = local_20, DVar4 != 0)))) {
          ppvVar6 = (HANDLE *)((uVar1 & 0x1f) * 0x40 + (int)(&DAT_10835b98)[(int)uVar1 >> 5]);
          *ppvVar6 = *local_24;
          *(byte *)(ppvVar6 + 1) = *(byte *)local_2c;
          local_28 = ppvVar6;
          FUN_1002bd5a((LPCRITICAL_SECTION)(ppvVar6 + 3),4000,0);
          ppvVar6[2] = (HANDLE)((int)ppvVar6[2] + 1);
          pvVar5 = local_20;
        }
        local_2c = (HANDLE *)((int)local_2c + 1);
        local_24 = local_24 + 1;
        local_30 = uVar1 + 1;
      }
    }
    for (iVar7 = 0; local_30 = iVar7, iVar7 < 3; iVar7 = iVar7 + 1) {
      ppvVar6 = DAT_10835b98 + iVar7 * 0x10;
      local_28 = ppvVar6;
      if ((*ppvVar6 == (HANDLE)0xffffffff) || (*ppvVar6 == (HANDLE)0xfffffffe)) {
        *(undefined *)(ppvVar6 + 1) = 0x81;
        if (iVar7 == 0) {
          DVar4 = 0xfffffff6;
        }
        else {
          DVar4 = 0xfffffff5 - (iVar7 != 1);
        }
        local_20 = GetStdHandle(DVar4);
        if (((local_20 == (HANDLE)0xffffffff) || (local_20 == (HANDLE)0x0)) ||
           (DVar4 = GetFileType(local_20), DVar4 == 0)) {
          *(byte *)(ppvVar6 + 1) = *(byte *)(ppvVar6 + 1) | 0x40;
          *ppvVar6 = (HANDLE)0xfffffffe;
          if (DAT_10837ba0 != 0) {
            *(undefined4 *)(*(int *)(DAT_10837ba0 + iVar7 * 4) + 0x10) = 0xfffffffe;
          }
        }
        else {
          *ppvVar6 = local_20;
          if ((DVar4 & 0xff) == 2) {
            bVar2 = *(byte *)(ppvVar6 + 1) | 0x40;
LAB_10028435:
            *(byte *)(ppvVar6 + 1) = bVar2;
          }
          else if ((DVar4 & 0xff) == 3) {
            bVar2 = *(byte *)(ppvVar6 + 1) | 8;
            goto LAB_10028435;
          }
          FUN_1002bd5a((LPCRITICAL_SECTION)(ppvVar6 + 3),4000,0);
          ppvVar6[2] = (HANDLE)((int)ppvVar6[2] + 1);
        }
      }
      else {
        *(byte *)(ppvVar6 + 1) = *(byte *)(ppvVar6 + 1) | 0x80;
      }
    }
    local_8 = (undefined *)0xfffffffe;
    FUN_10028480();
    uVar3 = 0;
  }
  return uVar3;
}



void FUN_10028480(void)

{
  FUN_1002f199(0xb);
  return;
}



// Library Function - Single Match
//  __ioterm
// 
// Library: Visual Studio 2012 Release

void __cdecl __ioterm(void)

{
  void *pvVar1;
  LPCRITICAL_SECTION p_Var2;
  void **ppvVar3;
  LPCRITICAL_SECTION lpCriticalSection;
  
  ppvVar3 = (void **)&DAT_10835b98;
  do {
    pvVar1 = *ppvVar3;
    if (pvVar1 != (void *)0x0) {
      if (pvVar1 < (void *)((int)pvVar1 + 0x800U)) {
        lpCriticalSection = (LPCRITICAL_SECTION)((int)pvVar1 + 0xc);
        do {
          if (lpCriticalSection[-1].SpinCount != 0) {
            DeleteCriticalSection(lpCriticalSection);
          }
          p_Var2 = lpCriticalSection + 2;
          lpCriticalSection = (LPCRITICAL_SECTION)&lpCriticalSection[2].LockSemaphore;
        } while (&p_Var2->LockCount < (undefined *)((int)*ppvVar3 + 0x800U));
      }
      FID_conflict__free(*ppvVar3);
      *ppvVar3 = (void *)0x0;
    }
    ppvVar3 = ppvVar3 + 1;
  } while ((int)ppvVar3 < 0x10835c98);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

undefined4 * FUN_100284db(void)

{
  int iVar1;
  void *pvVar2;
  undefined4 *puVar3;
  undefined4 *_File;
  int _Index;
  
  puVar3 = (undefined4 *)0x0;
  __lock(1);
  _Index = 0;
  do {
    _File = puVar3;
    if (DAT_10837ba4 <= _Index) {
LAB_100285c0:
      if (_File != (undefined4 *)0x0) {
        _File[3] = _File[3] & 0x8000;
        _File[1] = 0;
        _File[2] = 0;
        *_File = 0;
        _File[7] = 0;
        _File[4] = 0xffffffff;
      }
      FUN_100285f1();
      return _File;
    }
    iVar1 = *(int *)(DAT_10837ba0 + _Index * 4);
    if (iVar1 == 0) {
      pvVar2 = FUN_10026f23(0x38);
      *(void **)(DAT_10837ba0 + _Index * 4) = pvVar2;
      if (pvVar2 != (void *)0x0) {
        FUN_1002bd5a((LPCRITICAL_SECTION)(*(int *)(DAT_10837ba0 + _Index * 4) + 0x20),4000,0);
        EnterCriticalSection((LPCRITICAL_SECTION)(*(int *)(DAT_10837ba0 + _Index * 4) + 0x20));
        _File = *(undefined4 **)(DAT_10837ba0 + _Index * 4);
        _File[3] = 0;
      }
      goto LAB_100285c0;
    }
    if (((*(byte *)(iVar1 + 0xc) & 0x83) == 0) && ((*(uint *)(iVar1 + 0xc) & 0x8000) == 0)) {
      if ((_Index - 3U < 0x11) && (iVar1 = FUN_1002f0b7(_Index + 0x10), iVar1 == 0))
      goto LAB_100285c0;
      __lock_file2(_Index,*(void **)(DAT_10837ba0 + _Index * 4));
      _File = *(undefined4 **)(DAT_10837ba0 + _Index * 4);
      if ((*(byte *)(_File + 3) & 0x83) == 0) goto LAB_100285c0;
      __unlock_file2(_Index,_File);
    }
    _Index = _Index + 1;
  } while( true );
}



void FUN_100285f1(void)

{
  FUN_1002f199(1);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 * __cdecl FUN_100285fa(LPCSTR param_1,WCHAR *param_2,int param_3,undefined4 *param_4)

{
  char cVar1;
  bool bVar2;
  bool bVar3;
  bool bVar4;
  byte bVar5;
  int *piVar6;
  int iVar7;
  uint uVar8;
  WCHAR *pWVar9;
  byte *pbVar10;
  byte *pbVar11;
  uint uVar12;
  int local_8;
  
  bVar4 = false;
  local_8 = 0;
  bVar3 = false;
  for (pWVar9 = param_2; *(char *)pWVar9 == ' '; pWVar9 = (WCHAR *)((int)pWVar9 + 1)) {
  }
  cVar1 = *(char *)pWVar9;
  if (cVar1 == 'a') {
    uVar8 = 0x109;
LAB_10028655:
    uVar12 = DAT_10836598 | 2;
  }
  else {
    if (cVar1 != 'r') {
      if (cVar1 != 'w') goto LAB_1002862b;
      uVar8 = 0x301;
      goto LAB_10028655;
    }
    uVar8 = 0;
    uVar12 = DAT_10836598 | 1;
  }
  bVar2 = true;
  pbVar10 = (byte *)((int)pWVar9 + 1);
  bVar5 = *pbVar10;
  if (bVar5 != 0) {
    param_2 = (WCHAR *)0x1000;
    do {
      if (!bVar2) break;
      iVar7 = (int)(char)bVar5;
      if (iVar7 < 0x54) {
        if (iVar7 == 0x53) {
          if (local_8 != 0) goto LAB_10028767;
          local_8 = 1;
          uVar8 = uVar8 | 0x20;
        }
        else if (iVar7 != 0x20) {
          if (iVar7 == 0x2b) {
            if ((uVar8 & 2) != 0) goto LAB_10028767;
            uVar8 = uVar8 & 0xfffffffe | 2;
            uVar12 = uVar12 & 0xfffffffc | 0x80;
          }
          else if (iVar7 == 0x2c) {
            bVar3 = true;
LAB_10028767:
            bVar2 = false;
          }
          else if (iVar7 == 0x44) {
            if ((uVar8 & 0x40) != 0) goto LAB_10028767;
            uVar8 = uVar8 | 0x40;
          }
          else if (iVar7 == 0x4e) {
            uVar8 = uVar8 | 0x80;
          }
          else {
            if (iVar7 != 0x52) goto LAB_1002862b;
            if (local_8 != iVar7 + -0x52) goto LAB_10028767;
            local_8 = 1;
            uVar8 = uVar8 | 0x10;
          }
        }
      }
      else if (iVar7 == 0x54) {
        if ((uVar8 & 0x1000) != 0) goto LAB_10028767;
        uVar8 = uVar8 | 0x1000;
      }
      else if (iVar7 == 0x62) {
        if ((uVar8 & 0xc000) != 0) goto LAB_10028767;
        uVar8 = uVar8 | 0x8000;
      }
      else if (iVar7 == 99) {
        if (bVar4) goto LAB_10028767;
        bVar4 = true;
        uVar12 = uVar12 | 0x4000;
      }
      else if (iVar7 == 0x6e) {
        if (bVar4) goto LAB_10028767;
        bVar4 = true;
        uVar12 = uVar12 & 0xffffbfff;
      }
      else {
        if (iVar7 != 0x74) goto LAB_1002862b;
        if ((uVar8 & 0xc000) != 0) goto LAB_10028767;
        uVar8 = uVar8 | 0x4000;
      }
      pbVar10 = pbVar10 + 1;
      bVar5 = *pbVar10;
    } while (bVar5 != 0);
    if (bVar3) {
      for (; *pbVar10 == 0x20; pbVar10 = pbVar10 + 1) {
      }
      iVar7 = FUN_10031509(&DAT_10039b9c,pbVar10,3);
      if (iVar7 != 0) goto LAB_1002862b;
      for (pbVar10 = pbVar10 + 3; *pbVar10 == 0x20; pbVar10 = pbVar10 + 1) {
      }
      if (*pbVar10 != 0x3d) goto LAB_1002862b;
      do {
        pbVar11 = pbVar10;
        pbVar10 = pbVar11 + 1;
      } while (*pbVar10 == 0x20);
      iVar7 = FUN_10031638(pbVar10,(byte *)"UTF-8",5);
      if (iVar7 == 0) {
        pbVar10 = pbVar11 + 6;
        uVar8 = uVar8 | 0x40000;
      }
      else {
        iVar7 = FUN_10031638(pbVar10,(byte *)"UTF-16LE",8);
        if (iVar7 == 0) {
          pbVar10 = pbVar11 + 9;
          uVar8 = uVar8 | 0x20000;
        }
        else {
          iVar7 = FUN_10031638(pbVar10,(byte *)"UNICODE",7);
          if (iVar7 != 0) goto LAB_1002862b;
          pbVar10 = pbVar11 + 8;
          uVar8 = uVar8 | 0x10000;
        }
      }
    }
  }
  for (; *pbVar10 == 0x20; pbVar10 = pbVar10 + 1) {
  }
  if (*pbVar10 == 0) {
    iVar7 = FUN_100314eb(&param_2,param_1,uVar8,param_3,0x180);
    if (iVar7 != 0) {
      return (undefined4 *)0x0;
    }
    _DAT_10835b14 = _DAT_10835b14 + 1;
    param_4[1] = 0;
    *param_4 = 0;
    param_4[2] = 0;
    param_4[7] = 0;
    param_4[3] = uVar12;
    param_4[4] = param_2;
    return param_4;
  }
LAB_1002862b:
  piVar6 = __errno();
  *piVar6 = 0x16;
  FUN_10025625();
  return (undefined4 *)0x0;
}



// Library Function - Single Match
//  __local_unwind4
// 
// Library: Visual Studio 2012 Release

void __cdecl __local_unwind4(uint *param_1,int param_2,uint param_3)

{
  undefined4 *puVar1;
  uint uVar2;
  undefined4 *in_FS_OFFSET;
  undefined4 uStack40;
  code *pcStack36;
  uint local_20;
  uint uStack28;
  int iStack24;
  uint *puStack20;
  
  puStack20 = param_1;
  iStack24 = param_2;
  uStack28 = param_3;
  pcStack36 = FUN_10028910;
  uStack40 = *in_FS_OFFSET;
  local_20 = DAT_10046c24 ^ (uint)&uStack40;
  *in_FS_OFFSET = &uStack40;
  while( true ) {
    uVar2 = *(uint *)(param_2 + 0xc);
    if ((uVar2 == 0xfffffffe) || ((param_3 != 0xfffffffe && (uVar2 <= param_3)))) break;
    puVar1 = (undefined4 *)((*(uint *)(param_2 + 8) ^ *param_1) + 0x10 + uVar2 * 0xc);
    *(undefined4 *)(param_2 + 0xc) = *puVar1;
    if (puVar1[1] == 0) {
      __NLG_Notify(0x101);
      FUN_1002a4d4();
    }
  }
  *in_FS_OFFSET = uStack40;
  return;
}



undefined4 __fastcall
FUN_10028910(undefined4 param_1,undefined param_2,int param_3,uint param_4,undefined4 param_5,
            uint *param_6)

{
  undefined4 uVar1;
  int iVar2;
  undefined1 unaff_retaddr;
  
  uVar1 = 1;
  if ((*(uint *)(param_3 + 4) & 6) != 0) {
    iVar2 = FUN_1002534c(*(uint *)(param_4 + 8) ^ param_4,param_2,unaff_retaddr);
    __local_unwind4(*(uint **)(iVar2 + 0x14),*(int *)(iVar2 + 0x10),*(uint *)(iVar2 + 0xc));
    *param_6 = param_4;
    uVar1 = 3;
  }
  return uVar1;
}



void FUN_10028956(int param_1)

{
  __local_unwind4(*(uint **)(param_1 + 0x28),*(int *)(param_1 + 0x18),*(uint *)(param_1 + 0x1c));
  return;
}



void FUN_10028957(undefined4 param_1,int param_2)

{
  __local_unwind4(*(uint **)(param_2 + 0x28),*(int *)(param_2 + 0x18),*(uint *)(param_2 + 0x1c));
  return;
}



// Library Function - Single Match
//  @_EH4_CallFilterFunc@8
// 
// Library: Visual Studio

void __fastcall __EH4_CallFilterFunc_8(undefined *param_1)

{
  (*(code *)param_1)();
  return;
}



// Library Function - Single Match
//  @_EH4_TransferToHandler@8
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

void __fastcall __EH4_TransferToHandler_8(undefined *UNRECOVERED_JUMPTABLE)

{
  __NLG_Notify(1);
                    // WARNING: Could not recover jumptable at 0x100289a0. Too many branches
                    // WARNING: Treating indirect jump as call
  (*(code *)UNRECOVERED_JUMPTABLE)();
  return;
}



// Library Function - Single Match
//  @_EH4_GlobalUnwind2@8
// 
// Libraries: Visual Studio 2010, Visual Studio 2012, Visual Studio 2015

void __fastcall __EH4_GlobalUnwind2_8(PVOID param_1,PEXCEPTION_RECORD param_2)

{
  RtlUnwind(param_1,(PVOID)0x100289b6,param_2,(PVOID)0x0);
  return;
}



// Library Function - Single Match
//  @_EH4_LocalUnwind@16
// 
// Library: Visual Studio

void __fastcall __EH4_LocalUnwind_16(int param_1,uint param_2,undefined4 param_3,uint *param_4)

{
  __local_unwind4(param_4,param_1,param_2);
  return;
}



// Library Function - Single Match
//  __ftbuf
// 
// Library: Visual Studio 2012 Release

void __cdecl __ftbuf(int _Flag,FILE *_File)

{
  if ((_Flag != 0) && ((_File->_flag & 0x1000U) != 0)) {
    FUN_10027f63(_File);
    _File->_flag = _File->_flag & 0xffffeeff;
    _File->_bufsiz = 0;
    _File->_ptr = (char *)0x0;
    _File->_base = (char *)0x0;
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 __cdecl FUN_10028a03(FILE *param_1)

{
  char *pcVar1;
  byte bVar2;
  uint uVar3;
  undefined3 extraout_var;
  undefined **ppuVar4;
  void *pvVar5;
  int iVar6;
  
  uVar3 = __fileno(param_1);
  bVar2 = FUN_1003180b(uVar3);
  if (CONCAT31(extraout_var,bVar2) == 0) {
    return 0;
  }
  ppuVar4 = FUN_100245a8();
  if (param_1 == (FILE *)(ppuVar4 + 8)) {
    iVar6 = 0;
  }
  else {
    ppuVar4 = FUN_100245a8();
    if (param_1 != (FILE *)(ppuVar4 + 0x10)) {
      return 0;
    }
    iVar6 = 1;
  }
  _DAT_10835b14 = _DAT_10835b14 + 1;
  if ((param_1->_flag & 0x10cU) != 0) {
    return 0;
  }
  if ((&DAT_10835c98)[iVar6] == 0) {
    pvVar5 = FUN_10026f23(0x1000);
    (&DAT_10835c98)[iVar6] = pvVar5;
    if (pvVar5 == (void *)0x0) {
      param_1->_base = (char *)&param_1->_charbuf;
      param_1->_ptr = (char *)&param_1->_charbuf;
      param_1->_bufsiz = 2;
      param_1->_cnt = 2;
      goto LAB_10028a96;
    }
  }
  pcVar1 = (char *)(&DAT_10835c98)[iVar6];
  param_1->_base = pcVar1;
  param_1->_ptr = pcVar1;
  param_1->_bufsiz = 0x1000;
  param_1->_cnt = 0x1000;
LAB_10028a96:
  param_1->_flag = param_1->_flag | 0x1102;
  return 1;
}



void __cdecl FUN_10028aa9(FILE *param_1,byte *param_2,pthreadlocinfo *param_3,int **param_4)

{
  byte bVar1;
  WCHAR WVar2;
  byte *pbVar3;
  ushort uVar4;
  uint uVar5;
  undefined2 extraout_var_00;
  int *piVar6;
  undefined3 extraout_var;
  code *pcVar7;
  char *pcVar8;
  byte *pbVar9;
  int iVar10;
  int *piVar11;
  int extraout_ECX;
  byte bVar12;
  byte extraout_DL;
  undefined *puVar13;
  uint uVar14;
  int *piVar15;
  char *pcVar16;
  bool bVar17;
  longlong lVar18;
  int **ppiVar19;
  undefined4 uVar20;
  pthreadlocinfo *pptVar21;
  undefined in_stack_fffffd7c;
  int *local_27c;
  int *local_278;
  pthreadlocinfo local_274 [2];
  int local_26c;
  char local_268;
  int local_264;
  undefined4 local_260;
  int *local_25c;
  int local_258;
  int *local_254;
  int local_250;
  uint local_24c;
  int local_248;
  int *local_244;
  char *local_240;
  int local_23c;
  int local_238;
  FILE *local_234;
  byte local_230;
  char local_22f;
  int *local_22c;
  char *local_228;
  int local_224;
  int **local_220;
  uint local_21c;
  byte local_215;
  byte *local_214;
  undefined local_210;
  undefined local_11 [9];
  uint local_8;
  
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  local_234 = param_1;
  local_214 = param_2;
  uVar14 = 0;
  local_220 = param_4;
  local_258 = 0;
  piVar15 = (int *)0x0;
  local_21c = 0;
  local_244 = (int *)0x0;
  local_22c = (int *)0x0;
  local_238 = 0;
  local_260 = 0;
  local_250 = 0;
  local_23c = 0;
  FUN_1001f92e(local_274,param_3);
  local_25c = __errno();
  if (local_234 != (FILE *)0x0) {
    if ((*(byte *)&local_234->_flag & 0x40) == 0) {
      uVar5 = __fileno(local_234);
      if ((uVar5 == 0xffffffff) || (uVar5 == 0xfffffffe)) {
        puVar13 = &DAT_100473a0;
      }
      else {
        puVar13 = (undefined *)((uVar5 & 0x1f) * 0x40 + (&DAT_10835b98)[(int)uVar5 >> 5]);
      }
      if ((puVar13[0x24] & 0x7f) == 0) {
        if ((uVar5 == 0xffffffff) || (uVar5 == 0xfffffffe)) {
          puVar13 = &DAT_100473a0;
        }
        else {
          puVar13 = (undefined *)((uVar5 & 0x1f) * 0x40 + (&DAT_10835b98)[(int)uVar5 >> 5]);
        }
        if ((puVar13[0x24] & 0x80) == 0) goto LAB_10028ba0;
      }
    }
    else {
LAB_10028ba0:
      if (local_214 != (byte *)0x0) {
        bVar12 = *local_214;
        local_228 = (char *)0x0;
        iVar10 = 0;
        local_224 = 0;
        local_248 = 0;
        local_254 = (int *)0x0;
        local_24c = local_24c & 0xffffff00 | (uint)bVar12;
        pbVar3 = local_214;
        while ((local_215 = bVar12, bVar12 != 0 && (local_214 = pbVar3 + 1, -1 < iVar10))) {
          if ((byte)(bVar12 - 0x20) < 0x59) {
            uVar5 = (int)"UNICODE"[(char)bVar12 + 4] & 0xf;
          }
          else {
            uVar5 = 0;
          }
          local_248 = (int)(char)(&DAT_10039bd8)[uVar5 * 8 + local_248] >> 4;
          pbVar9 = local_214;
          switch(local_248) {
          case 0:
LAB_10028e3c:
            local_23c = 0;
            uVar4 = FUN_10029715((uint)bVar12,local_274);
            if (CONCAT22(extraout_var_00,uVar4) != 0) {
              _write_char((byte)local_24c,local_234,&local_224);
              bVar12 = *local_214;
              local_214 = local_214 + 1;
              local_24c = local_24c & 0xffffff00 | (uint)bVar12;
              if (bVar12 == 0) goto LAB_100295f4;
            }
            _write_char((byte)local_24c,local_234,&local_224);
            pbVar9 = local_214;
            iVar10 = local_224;
            break;
          case 1:
            local_22c = (int *)0xffffffff;
            uVar14 = 0;
            local_260 = 0;
            local_250 = 0;
            local_244 = (int *)0x0;
            local_238 = 0;
            local_21c = 0;
            local_23c = 0;
            break;
          case 2:
            if (bVar12 == 0x20) {
              uVar14 = uVar14 | 2;
              local_21c = uVar14;
            }
            else if (bVar12 == 0x23) {
              uVar14 = uVar14 | 0x80;
              local_21c = uVar14;
            }
            else if (bVar12 == 0x2b) {
              uVar14 = uVar14 | 1;
              local_21c = uVar14;
            }
            else if (bVar12 == 0x2d) {
              uVar14 = uVar14 | 4;
              local_21c = uVar14;
            }
            else if (bVar12 == 0x30) {
              uVar14 = uVar14 | 8;
              local_21c = uVar14;
            }
            break;
          case 3:
            if (bVar12 == 0x2a) {
              local_244 = *local_220;
              local_220 = local_220 + 1;
              if ((int)local_244 < 0) {
                uVar14 = uVar14 | 4;
                local_244 = (int *)-(int)local_244;
                local_21c = uVar14;
              }
            }
            else {
              local_244 = (int *)((int)(char)bVar12 + (int)local_244 * 10 + -0x30);
              iVar10 = local_224;
            }
            break;
          case 4:
            local_22c = (int *)0x0;
            break;
          case 5:
            if (bVar12 == 0x2a) {
              local_22c = *local_220;
              local_220 = local_220 + 1;
              if ((int)local_22c < 0) {
                local_22c = (int *)0xffffffff;
              }
            }
            else {
              local_22c = (int *)((int)(char)bVar12 + (int)local_22c * 10 + -0x30);
              iVar10 = local_224;
            }
            break;
          case 6:
            if (bVar12 == 0x49) {
              bVar1 = *local_214;
              if ((bVar1 == 0x36) && (pbVar3[2] == 0x34)) {
                uVar14 = uVar14 | 0x8000;
                pbVar9 = pbVar3 + 3;
                local_21c = uVar14;
              }
              else if ((bVar1 == 0x33) && (pbVar3[2] == 0x32)) {
                uVar14 = uVar14 & 0xffff7fff;
                pbVar9 = pbVar3 + 3;
                local_21c = uVar14;
              }
              else if ((((bVar1 != 100) && (bVar1 != 0x69)) && (bVar1 != 0x6f)) &&
                      (((bVar1 != 0x75 && (bVar1 != 0x78)) && (bVar1 != 0x58)))) {
                local_248 = 0;
                goto LAB_10028e3c;
              }
            }
            else if (bVar12 == 0x68) {
              uVar14 = uVar14 | 0x20;
              local_21c = uVar14;
            }
            else if (bVar12 == 0x6c) {
              if (*local_214 == 0x6c) {
                uVar14 = uVar14 | 0x1000;
                pbVar9 = pbVar3 + 2;
                local_21c = uVar14;
              }
              else {
                uVar14 = uVar14 | 0x10;
                local_21c = uVar14;
              }
            }
            else if (bVar12 == 0x77) {
              uVar14 = uVar14 | 0x800;
              local_21c = uVar14;
            }
            break;
          case 7:
            if ((char)bVar12 < 'e') {
              if (bVar12 == 100) {
LAB_10029113:
                uVar14 = uVar14 | 0x40;
                local_21c = uVar14;
LAB_1002911c:
                local_228 = (char *)0xa;
LAB_10029126:
                if (((uVar14 & 0x8000) == 0) && ((uVar14 & 0x1000) == 0)) {
                  if ((uVar14 & 0x20) == 0) {
                    if ((uVar14 & 0x40) == 0) {
                      piVar15 = *local_220;
                      piVar11 = (int *)0x0;
                      local_220 = local_220 + 1;
                      goto LAB_100292fd;
                    }
                    piVar15 = *local_220;
                  }
                  else if ((uVar14 & 0x40) == 0) {
                    piVar15 = (int *)(uint)*(ushort *)local_220;
                  }
                  else {
                    piVar15 = (int *)(int)*(short *)local_220;
                  }
                  piVar11 = (int *)((int)piVar15 >> 0x1f);
                  local_220 = local_220 + 1;
                }
                else {
                  piVar15 = *local_220;
                  piVar11 = local_220[1];
                  local_220 = local_220 + 2;
                }
LAB_100292fd:
                if ((((uVar14 & 0x40) != 0) && ((int)piVar11 < 1)) &&
                   (((int)piVar11 < 0 || (false)))) {
                  bVar17 = piVar15 != (int *)0x0;
                  piVar15 = (int *)-(int)piVar15;
                  piVar11 = (int *)-(int)((int)piVar11 + (uint)bVar17);
                  uVar14 = uVar14 | 0x100;
                  local_21c = uVar14;
                }
                if ((uVar14 & 0x9000) == 0) {
                  piVar11 = (int *)0x0;
                }
                lVar18 = CONCAT44(piVar11,piVar15);
                if ((int)local_22c < 0) {
                  local_22c = (int *)0x1;
                }
                else {
                  local_21c = uVar14 & 0xfffffff7;
                  if (0x200 < (int)local_22c) {
                    local_22c = (int *)0x200;
                  }
                }
                if (((uint)piVar15 | (uint)piVar11) == 0) {
                  local_238 = 0;
                }
                piVar11 = (int *)local_11;
                while( true ) {
                  piVar6 = (int *)((int)local_22c + -1);
                  if (((int)local_22c < 1) && (lVar18 == 0)) break;
                  local_22c = piVar6;
                  lVar18 = __aulldvrm((uint)lVar18,(uint)((ulonglong)lVar18 >> 0x20),(uint)local_228
                                      ,(int)local_228 >> 0x1f);
                  local_240 = (char *)lVar18;
                  iVar10 = extraout_ECX + 0x30;
                  if (0x39 < iVar10) {
                    iVar10 = iVar10 + local_258;
                  }
                  *(char *)piVar11 = (char)iVar10;
                  piVar11 = (int *)((int)piVar11 + -1);
                }
                local_228 = local_11 + -(int)piVar11;
                piVar15 = (int *)((int)piVar11 + 1);
                uVar14 = local_21c;
                local_22c = piVar6;
                if (((local_21c & 0x200) != 0) &&
                   ((local_228 == (char *)0x0 || (*(char *)piVar15 != '0')))) {
                  local_228 = local_11 + -(int)piVar11 + 1;
                  *(undefined *)piVar11 = 0x30;
                  piVar15 = piVar11;
                }
              }
              else if ((char)bVar12 < 'T') {
                if (bVar12 == 0x53) {
                  if ((uVar14 & 0x830) == 0) {
                    uVar14 = uVar14 | 0x800;
                    local_21c = uVar14;
                  }
                  goto LAB_10028f5d;
                }
                if (bVar12 == 0x41) {
LAB_10028ee2:
                  local_260 = 1;
                  local_215 = bVar12 + 0x20;
LAB_10028ef5:
                  uVar5 = uVar14 | 0x40;
                  local_240 = (char *)0x200;
                  piVar6 = (int *)&local_210;
                  pcVar16 = local_240;
                  local_21c = uVar5;
                  if ((int)local_22c < 0) {
                    local_22c = (int *)0x6;
                  }
                  else if (local_22c == (int *)0x0) {
                    if (local_215 == 0x67) {
                      local_22c = (int *)0x1;
                    }
                  }
                  else {
                    if (0x200 < (int)local_22c) {
                      local_22c = (int *)0x200;
                    }
                    if (0xa3 < (int)local_22c) {
                      pcVar16 = (char *)((int)local_22c + 0x15d);
                      local_254 = (int *)FUN_10026f23((size_t)pcVar16);
                      piVar6 = local_254;
                      if (local_254 == (int *)0x0) {
                        local_22c = (int *)0xa3;
                        piVar6 = (int *)&local_210;
                        pcVar16 = local_240;
                      }
                    }
                  }
                  local_240 = pcVar16;
                  local_27c = *local_220;
                  local_278 = local_220[1];
                  pptVar21 = local_274;
                  iVar10 = (int)(char)local_215;
                  ppiVar19 = &local_27c;
                  piVar15 = piVar6;
                  pcVar16 = local_240;
                  piVar11 = local_22c;
                  uVar20 = local_260;
                  local_220 = local_220 + 2;
                  pcVar7 = (code *)DecodePointer(PTR_FUN_10047404);
                  (*pcVar7)(ppiVar19,piVar15,pcVar16,iVar10,piVar11,uVar20,pptVar21);
                  if (((uVar14 & 0x80) != 0) && (local_22c == (int *)0x0)) {
                    pptVar21 = local_274;
                    piVar15 = piVar6;
                    pcVar7 = (code *)DecodePointer(PTR_FUN_10047410);
                    (*pcVar7)(piVar15,pptVar21);
                  }
                  if ((local_215 == 0x67) && ((uVar14 & 0x80) == 0)) {
                    pptVar21 = local_274;
                    piVar15 = piVar6;
                    pcVar7 = (code *)DecodePointer(PTR_FUN_1004740c);
                    (*pcVar7)(piVar15,pptVar21);
                  }
                  if (*(char *)piVar6 == '-') {
                    local_21c = uVar14 | 0x140;
                    uVar5 = local_21c;
                    piVar6 = (int *)((int)piVar6 + 1);
                  }
LAB_1002907d:
                  piVar15 = piVar6;
                  uVar14 = uVar5;
                  local_228 = (char *)_strlen((char *)piVar15);
                }
                else if (bVar12 == 0x43) {
                  if ((uVar14 & 0x830) == 0) {
                    uVar14 = uVar14 | 0x800;
                    local_21c = uVar14;
                  }
LAB_10028fd6:
                  if ((uVar14 & 0x810) == 0) {
                    local_210 = *(undefined *)local_220;
                    local_228 = (char *)0x1;
                    local_220 = local_220 + 1;
                  }
                  else {
                    WVar2 = *(WCHAR *)local_220;
                    local_220 = local_220 + 1;
                    iVar10 = FUN_10031983((int *)&local_228,(uint *)&local_210,0x200,WVar2);
                    if (iVar10 != 0) {
                      local_250 = 1;
                    }
                  }
                  piVar15 = (int *)&local_210;
                }
                else if ((bVar12 == 0x45) || (bVar12 == 0x47)) goto LAB_10028ee2;
              }
              else {
                if (bVar12 == 0x58) goto LAB_10029271;
                if (bVar12 == 0x5a) {
                  piVar11 = *local_220;
                  local_220 = local_220 + 1;
                  uVar5 = uVar14;
                  piVar6 = (int *)PTR_s__null__100473e0;
                  if ((piVar11 == (int *)0x0) ||
                     (piVar15 = (int *)piVar11[1], piVar15 == (int *)0x0)) goto LAB_1002907d;
                  local_228 = (char *)(int)*(WCHAR *)piVar11;
                  if ((uVar14 & 0x800) == 0) {
                    local_23c = 0;
                  }
                  else {
                    local_23c = 1;
                    local_228 = (char *)((int)local_228 / 2);
                  }
                }
                else {
                  if (bVar12 == 0x61) goto LAB_10028ef5;
                  if (bVar12 == 99) goto LAB_10028fd6;
                }
              }
LAB_100293fa:
              if (local_250 == 0) {
                if ((uVar14 & 0x40) != 0) {
                  if ((uVar14 & 0x100) == 0) {
                    if ((uVar14 & 1) == 0) {
                      if ((uVar14 & 2) == 0) goto LAB_10029441;
                      local_230 = 0x20;
                    }
                    else {
                      local_230 = 0x2b;
                    }
                  }
                  else {
                    local_230 = 0x2d;
                  }
                  local_238 = 1;
                }
LAB_10029441:
                pcVar16 = (char *)((int)local_244 + (-local_238 - (int)local_228));
                if ((uVar14 & 0xc) == 0) {
                  _write_multi_char(0x20,(int)pcVar16,local_234,&local_224);
                }
                FUN_1002969d(&local_230,local_238,local_234,&local_224,local_25c);
                if (((uVar14 & 8) != 0) && ((uVar14 & 4) == 0)) {
                  _write_multi_char(0x30,(int)pcVar16,local_234,&local_224);
                }
                if ((local_23c == 0) || (pcVar8 = local_228, piVar11 = piVar15, (int)local_228 < 1))
                {
                  FUN_1002969d((byte *)piVar15,(int)local_228,local_234,&local_224,local_25c);
                }
                else {
                  do {
                    local_240 = pcVar8 + -1;
                    iVar10 = FUN_10031983(&local_264,(uint *)(local_11 + 1),6,*(WCHAR *)piVar11);
                    if ((iVar10 != 0) || (local_264 == 0)) {
                      local_224 = -1;
                      break;
                    }
                    FUN_1002969d(local_11 + 1,local_264,local_234,&local_224,local_25c);
                    pcVar8 = local_240;
                    piVar11 = (int *)((int)piVar11 + 2);
                  } while (local_240 != (char *)0x0);
                }
                if ((-1 < local_224) && ((uVar14 & 4) != 0)) {
                  _write_multi_char(0x20,(int)pcVar16,local_234,&local_224);
                }
              }
            }
            else {
              if ('p' < (char)bVar12) {
                if (bVar12 == 0x73) {
LAB_10028f5d:
                  piVar11 = (int *)0x7fffffff;
                  if (local_22c != (int *)0xffffffff) {
                    piVar11 = local_22c;
                  }
                  piVar6 = *local_220;
                  local_220 = local_220 + 1;
                  piVar15 = piVar6;
                  if ((uVar14 & 0x810) == 0) {
                    if (piVar6 == (int *)0x0) {
                      piVar6 = (int *)PTR_s__null__100473e0;
                      piVar15 = (int *)PTR_s__null__100473e0;
                    }
                    for (; (piVar11 != (int *)0x0 &&
                           (piVar11 = (int *)((int)piVar11 + -1), *(char *)piVar6 != '\0'));
                        piVar6 = (int *)((int)piVar6 + 1)) {
                    }
                    local_228 = (char *)((int)piVar6 - (int)piVar15);
                  }
                  else {
                    if (piVar6 == (int *)0x0) {
                      piVar15 = (int *)PTR_DAT_100473e4;
                    }
                    local_23c = 1;
                    for (piVar6 = piVar15;
                        (piVar11 != (int *)0x0 &&
                        (piVar11 = (int *)((int)piVar11 + -1), *(WCHAR *)piVar6 != L'\0'));
                        piVar6 = (int *)((int)piVar6 + 2)) {
                    }
                    local_228 = (char *)((int)piVar6 - (int)piVar15 >> 1);
                  }
                  goto LAB_100293fa;
                }
                if (bVar12 == 0x75) goto LAB_1002911c;
                if (bVar12 != 0x78) goto LAB_100293fa;
                local_258 = 0x27;
LAB_10029291:
                local_228 = (char *)0x10;
                if ((char)uVar14 < '\0') {
                  local_22f = (char)local_258 + 'Q';
                  local_230 = 0x30;
                  local_238 = 2;
                }
                goto LAB_10029126;
              }
              if (bVar12 == 0x70) {
                local_22c = (int *)&DAT_00000008;
LAB_10029271:
                local_258 = 7;
                goto LAB_10029291;
              }
              if ((char)bVar12 < 'e') goto LAB_100293fa;
              if ((char)bVar12 < 'h') goto LAB_10028ef5;
              if (bVar12 == 0x69) goto LAB_10029113;
              if (bVar12 != 0x6e) {
                if (bVar12 != 0x6f) goto LAB_100293fa;
                local_228 = (char *)0x8;
                if ((char)uVar14 < '\0') {
                  uVar14 = uVar14 | 0x200;
                  local_21c = uVar14;
                }
                goto LAB_10029126;
              }
              piVar11 = *local_220;
              local_220 = local_220 + 1;
              bVar17 = FUN_10021026();
              if (CONCAT31(extraout_var,bVar17) == 0) goto LAB_100295f4;
              if ((uVar14 & 0x20) == 0) {
                *piVar11 = local_224;
              }
              else {
                *(WCHAR *)piVar11 = (WCHAR)local_224;
              }
              local_250 = 1;
            }
            pbVar9 = local_214;
            iVar10 = local_224;
            if (local_254 != (int *)0x0) {
              FID_conflict__free(local_254);
              local_254 = (int *)0x0;
              pbVar9 = local_214;
              iVar10 = local_224;
            }
          }
          bVar12 = *pbVar9;
          local_24c = local_24c & 0xffffff00 | (uint)bVar12;
          pbVar3 = pbVar9;
        }
        goto LAB_100295d0;
      }
    }
  }
LAB_100295f4:
  piVar15 = __errno();
  *piVar15 = 0x16;
  FUN_10025625();
  bVar12 = extraout_DL;
LAB_100295d0:
  if (local_268 != '\0') {
    *(uint *)(local_26c + 0x70) = *(uint *)(local_26c + 0x70) & 0xfffffffd;
  }
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,bVar12,in_stack_fffffd7c);
  return;
}



// Library Function - Single Match
//  _write_char
// 
// Library: Visual Studio 2019 Release

void __cdecl _write_char(byte param_1,FILE *param_2,int *param_3)

{
  int *piVar1;
  uint uVar2;
  
  if (((*(byte *)&param_2->_flag & 0x40) == 0) || (param_2->_base != (char *)0x0)) {
    piVar1 = &param_2->_cnt;
    *piVar1 = *piVar1 + -1;
    if (*piVar1 < 0) {
      uVar2 = FUN_1002ac01((int)(char)param_1,param_2);
    }
    else {
      *param_2->_ptr = param_1;
      param_2->_ptr = param_2->_ptr + 1;
      uVar2 = (uint)param_1;
    }
    if (uVar2 == 0xffffffff) {
      *param_3 = -1;
      return;
    }
  }
  *param_3 = *param_3 + 1;
  return;
}



// Library Function - Single Match
//  _write_multi_char
// 
// Library: Visual Studio 2019 Release

void __cdecl _write_multi_char(byte param_1,int param_2,FILE *param_3,int *param_4)

{
  if (0 < param_2) {
    do {
      param_2 = param_2 + -1;
      _write_char(param_1,param_3,param_4);
      if (*param_4 == -1) {
        return;
      }
    } while (0 < param_2);
  }
  return;
}



void __cdecl FUN_1002969d(byte *param_1,int param_2,FILE *param_3,int *param_4,int *param_5)

{
  int iVar1;
  
  iVar1 = *param_5;
  if (((*(byte *)&param_3->_flag & 0x40) == 0) || (param_3->_base != (char *)0x0)) {
    *param_5 = 0;
    if (0 < param_2) {
      do {
        param_2 = param_2 + -1;
        _write_char(*param_1,param_3,param_4);
        param_1 = param_1 + 1;
        if (*param_4 == -1) {
          if (*param_5 != 0x2a) break;
          _write_char(0x3f,param_3,param_4);
        }
      } while (0 < param_2);
      if (*param_5 != 0) {
        return;
      }
    }
    *param_5 = iVar1;
  }
  else {
    *param_4 = *param_4 + param_2;
  }
  return;
}



ushort __cdecl FUN_10029715(uint param_1,pthreadlocinfo *param_2)

{
  ushort uVar1;
  int local_14 [2];
  int local_c;
  char local_8;
  
  FUN_1001f92e(local_14,param_2);
  uVar1 = *(ushort *)(*(int *)(local_14[0] + 0x90) + (param_1 & 0xff) * 2);
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return uVar1 & 0x8000;
}



void __cdecl FUN_1002974f(uint param_1)

{
  FUN_10029715(param_1,(pthreadlocinfo *)0x0);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

void FUN_10029760(void)

{
  if (PTR_DAT_100472c4 != &DAT_100472c8) {
    __lock(0xc);
    PTR_DAT_100472c4 =
         (undefined *)__updatetlocinfoEx_nolock((int **)&PTR_DAT_100472c4,(int *)&DAT_100472c8);
    FUN_100297a9();
  }
  return;
}



void FUN_100297a9(void)

{
  FUN_1002f199(0xc);
  return;
}



// Library Function - Single Match
//  __cfltcvt
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release,
// Visual Studio 2012 Release

errno_t __cdecl
__cfltcvt(double *arg,char *buffer,size_t sizeInBytes,int format,int precision,int caps)

{
  errno_t eVar1;
  
  eVar1 = __cfltcvt_l(arg,buffer,sizeInBytes,format,precision,caps,(_locale_t)0x0);
  return eVar1;
}



// Library Function - Single Match
//  __cfltcvt_l
// 
// Libraries: Visual Studio 2005 Release, Visual Studio 2008 Release, Visual Studio 2010 Release,
// Visual Studio 2012 Release

errno_t __cdecl
__cfltcvt_l(double *arg,char *buffer,size_t sizeInBytes,int format,int precision,int caps,
           _locale_t plocinfo)

{
  errno_t eVar1;
  
  if ((format == 0x65) || (format == 0x45)) {
    eVar1 = FUN_10029dec((undefined4 *)arg,buffer,sizeInBytes,precision,caps,&plocinfo->locinfo);
  }
  else {
    if (format == 0x66) {
      eVar1 = FUN_10029fa6((undefined4 *)arg,buffer,sizeInBytes,precision,&plocinfo->locinfo);
      return eVar1;
    }
    if ((format == 0x61) || (format == 0x41)) {
      eVar1 = FUN_10029921((uint *)arg,buffer,sizeInBytes,precision,caps,&plocinfo->locinfo);
    }
    else {
      eVar1 = FUN_1002a067((undefined4 *)arg,buffer,sizeInBytes,precision,caps,&plocinfo->locinfo);
    }
  }
  return eVar1;
}



int __cdecl
FUN_10029921(uint *param_1,undefined *param_2,uint param_3,uint param_4,int param_5,
            pthreadlocinfo *param_6)

{
  uint *puVar1;
  int *piVar2;
  uint uVar3;
  char *pcVar4;
  uint *puVar5;
  uint uVar6;
  uint extraout_ECX;
  uint extraout_ECX_00;
  uint extraout_ECX_01;
  uint uVar7;
  uint *puVar8;
  char *pcVar9;
  bool bVar10;
  ulonglong uVar11;
  undefined8 uVar12;
  int iVar13;
  int local_30 [2];
  int local_28;
  char local_24;
  uint local_1c;
  uint local_18;
  int local_14;
  uint *local_10;
  uint local_c;
  int local_8;
  
  local_c = 0x3ff;
  local_8 = 0x30;
  FUN_1001f92e(local_30,param_6);
  if ((int)param_4 < 0) {
    param_4 = 0;
  }
  if ((param_2 == (undefined *)0x0) || (param_3 == 0)) {
    piVar2 = __errno();
    iVar13 = 0x16;
  }
  else {
    *param_2 = 0;
    if (param_4 + 0xb < param_3) {
      local_18 = *param_1;
      if (((param_1[1] >> 0x14 & 0x7ff) == 0x7ff) && (true)) {
        uVar3 = 0xffffffff;
        if (param_3 != 0xffffffff) {
          uVar3 = param_3 - 2;
        }
        iVar13 = FUN_10029c7d(param_1,param_2 + 2,uVar3,param_4,0);
        if (iVar13 == 0) {
          if (param_2[2] == '-') {
            *param_2 = 0x2d;
            param_2 = param_2 + 1;
          }
          *param_2 = 0x30;
          param_2[1] = ((param_5 == 0) - 1U & 0xe0) + 0x78;
          pcVar4 = _strrchr(param_2 + 2,0x65);
          if (pcVar4 != (char *)0x0) {
            *pcVar4 = ((param_5 == 0) - 1U & 0xe0) + 0x70;
            pcVar4[3] = '\0';
          }
          iVar13 = 0;
        }
        else {
          *param_2 = 0;
        }
        goto LAB_10029c67;
      }
      if ((param_1[1] & 0x80000000) != 0) {
        *param_2 = 0x2d;
        param_2 = param_2 + 1;
      }
      *param_2 = 0x30;
      param_2[1] = ((param_5 == 0) - 1U & 0xe0) + 0x78;
      iVar13 = (-(uint)(param_5 != 0) & 0xffffffe0) + 0x27;
      if ((param_1[1] & 0x7ff00000) == 0) {
        param_2[2] = 0x30;
        if ((*param_1 | param_1[1] & 0xfffff) == 0) {
          local_c = 0;
        }
        else {
          local_c = 0x3fe;
        }
      }
      else {
        param_2[2] = 0x31;
      }
      local_10 = (uint *)(param_2 + 3);
      puVar8 = (uint *)(param_2 + 4);
      if (param_4 == 0) {
        *(char *)local_10 = '\0';
      }
      else {
        *(char *)local_10 = ***(char ***)(local_30[0] + 0x84);
      }
      local_1c = param_1[1] & 0xfffff;
      local_14 = iVar13;
      if ((local_1c != 0) || (*param_1 != 0)) {
        param_2 = (undefined *)0xf0000;
        do {
          if ((int)param_4 < 1) break;
          uVar11 = __aullshr((byte)local_8,param_1[1] & (uint)param_2);
          uVar3 = (uint)(ushort)((short)uVar11 + 0x30);
          if (0x39 < uVar3) {
            uVar3 = uVar3 + iVar13;
          }
          *(char *)puVar8 = (char)uVar3;
          puVar8 = (uint *)((int)puVar8 + 1);
          param_2 = (undefined *)((uint)param_2 >> 4);
          local_8 = local_8 + -4;
          param_4 = param_4 - 1;
        } while (-1 < (short)local_8);
        if ((-1 < (short)local_8) &&
           (uVar11 = __aullshr((byte)local_8,param_1[1] & (uint)param_2), puVar1 = puVar8,
           8 < (ushort)uVar11)) {
          while( true ) {
            puVar5 = (uint *)((int)puVar1 + -1);
            if ((*(char *)puVar5 != 'f') && (*(char *)puVar5 != 'F')) break;
            *(char *)puVar5 = '0';
            puVar1 = puVar5;
          }
          if (puVar5 == local_10) {
            *(char *)((int)puVar1 + -2) = *(char *)((int)puVar1 + -2) + '\x01';
          }
          else if (*(char *)puVar5 == '9') {
            *(char *)puVar5 = (char)local_14 + ':';
          }
          else {
            *(char *)puVar5 = *(char *)puVar5 + '\x01';
          }
        }
      }
      if (0 < (int)param_4) {
        FUN_10021290(puVar8,0x30,param_4);
        puVar8 = (uint *)((int)puVar8 + param_4);
      }
      if (*(char *)local_10 == '\0') {
        puVar8 = local_10;
      }
      *(byte *)puVar8 = ((param_5 == 0) - 1U & 0xe0) + 0x70;
      uVar11 = __aullshr(0x34,param_1[1]);
      uVar3 = (uint)(uVar11 & 0x7ff);
      uVar6 = uVar3 - local_c;
      uVar3 = (uint)(uVar3 < local_c);
      uVar7 = -uVar3;
      if ((uVar3 != 0) || ((uVar7 == 0 || uVar3 != 0 && (false)))) {
        *(char *)((int)puVar8 + 1) = '-';
        bVar10 = uVar6 != 0;
        uVar6 = -uVar6;
        uVar7 = -(uVar7 + bVar10);
      }
      else {
        *(char *)((int)puVar8 + 1) = '+';
      }
      pcVar9 = (char *)((int)puVar8 + 2);
      *pcVar9 = '0';
      pcVar4 = pcVar9;
      if (-1 < (int)uVar7) {
        if (((int)uVar7 < 1) && (uVar6 < 1000)) {
LAB_10029c18:
          if (((int)uVar7 < 0) || (((int)uVar7 < 1 && (uVar6 < 100)))) goto LAB_10029c37;
        }
        else {
          uVar12 = __alldvrm(uVar6,uVar7,1000,0);
          local_1c = (uint)((ulonglong)uVar12 >> 0x20);
          *pcVar9 = (char)uVar12 + '0';
          pcVar4 = (char *)((int)puVar8 + 3);
          uVar6 = extraout_ECX;
          if (pcVar4 == pcVar9) goto LAB_10029c18;
        }
        uVar12 = __alldvrm(uVar6,uVar7,100,0);
        local_1c = (uint)((ulonglong)uVar12 >> 0x20);
        *pcVar4 = (char)uVar12 + '0';
        pcVar4 = pcVar4 + 1;
        uVar6 = extraout_ECX_00;
      }
LAB_10029c37:
      if ((pcVar4 != pcVar9) || ((-1 < (int)uVar7 && ((0 < (int)uVar7 || (9 < uVar6)))))) {
        uVar12 = __alldvrm(uVar6,uVar7,10,0);
        *pcVar4 = (char)uVar12 + '0';
        pcVar4 = pcVar4 + 1;
        uVar6 = extraout_ECX_01;
      }
      iVar13 = 0;
      *pcVar4 = (char)uVar6 + '0';
      pcVar4[1] = '\0';
      goto LAB_10029c67;
    }
    piVar2 = __errno();
    iVar13 = 0x22;
  }
  *piVar2 = iVar13;
  FUN_10025625();
LAB_10029c67:
  if (local_24 != '\0') {
    *(uint *)(local_28 + 0x70) = *(uint *)(local_28 + 0x70) & 0xfffffffd;
  }
  return iVar13;
}



void __cdecl
FUN_10029c7d(undefined4 *param_1,undefined *param_2,uint param_3,int param_4,int param_5)

{
  FUN_10029dec(param_1,param_2,param_3,param_4,param_5,(pthreadlocinfo *)0x0);
  return;
}



int __cdecl
FUN_10029c9b(undefined *param_1,uint param_2,int param_3,int param_4,int *param_5,char param_6,
            pthreadlocinfo *param_7)

{
  code *pcVar1;
  int *piVar2;
  int iVar3;
  errno_t eVar4;
  int iVar5;
  undefined *puVar6;
  char *_Dst;
  int iVar7;
  int local_14 [2];
  int local_c;
  char local_8;
  
  FUN_1001f92e(local_14,param_7);
  if ((param_1 == (undefined *)0x0) || (param_2 == 0)) {
    piVar2 = __errno();
    iVar7 = 0x16;
  }
  else {
    iVar7 = 0;
    iVar3 = param_3;
    if (param_3 < 1) {
      iVar3 = 0;
    }
    if (iVar3 + 9U < param_2) {
      if (param_6 != '\0') {
        __shift(param_1 + (*param_5 == 0x2d),(uint)(0 < param_3));
      }
      puVar6 = param_1;
      if (*param_5 == 0x2d) {
        *param_1 = 0x2d;
        puVar6 = param_1 + 1;
      }
      if (0 < param_3) {
        *puVar6 = puVar6[1];
        puVar6 = puVar6 + 1;
        *puVar6 = *(undefined *)**(undefined4 **)(local_14[0] + 0x84);
      }
      _Dst = puVar6 + (uint)(param_6 == '\0') + param_3;
      puVar6 = (undefined *)0xffffffff;
      if (param_2 != 0xffffffff) {
        puVar6 = param_1 + (param_2 - (int)_Dst);
      }
      eVar4 = _strcpy_s(_Dst,(rsize_t)puVar6,"e+000");
      if (eVar4 != 0) {
        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
        pcVar1 = (code *)swi(3);
        iVar3 = (*pcVar1)();
        return iVar3;
      }
      if (param_4 != 0) {
        *_Dst = 'E';
      }
      if (*(char *)param_5[3] != '0') {
        iVar3 = param_5[1] + -1;
        if (iVar3 < 0) {
          iVar3 = -iVar3;
          _Dst[1] = '-';
        }
        if (99 < iVar3) {
          iVar5 = iVar3 / 100;
          iVar3 = iVar3 % 100;
          _Dst[2] = _Dst[2] + (char)iVar5;
        }
        if (9 < iVar3) {
          iVar5 = iVar3 / 10;
          iVar3 = iVar3 % 10;
          _Dst[3] = _Dst[3] + (char)iVar5;
        }
        _Dst[4] = _Dst[4] + (char)iVar3;
      }
      if (((DAT_10836a14 & 1) != 0) && (_Dst[2] == '0')) {
        FID_conflict__memcpy(_Dst + 2,_Dst + 3,3);
      }
      goto LAB_10029dcc;
    }
    piVar2 = __errno();
    iVar7 = 0x22;
  }
  *piVar2 = iVar7;
  FUN_10025625();
LAB_10029dcc:
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return iVar7;
}



void __cdecl
FUN_10029dec(undefined4 *param_1,undefined *param_2,uint param_3,int param_4,int param_5,
            pthreadlocinfo *param_6)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  undefined uVar4;
  undefined uVar5;
  int in_stack_ffffffd0;
  char local_20 [24];
  uint local_8;
  
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  FUN_10031d58(*param_1,param_1[1],(int *)&stack0xffffffd0,local_20,0x16);
  if (param_2 == (undefined *)0x0) {
    piVar1 = __errno();
    uVar5 = (undefined)in_stack_ffffffd0;
  }
  else {
    if (param_3 != 0) {
      uVar3 = 0xffffffff;
      if (param_3 != 0xffffffff) {
        uVar3 = (param_3 - (in_stack_ffffffd0 == 0x2d)) - (uint)(0 < param_4);
      }
      iVar2 = FUN_10031be0(param_2 + (uint)(0 < param_4) + (uint)(in_stack_ffffffd0 == 0x2d),uVar3,
                           param_4 + 1,(int)&stack0xffffffd0);
      uVar5 = (undefined)in_stack_ffffffd0;
      if (iVar2 == 0) {
        FUN_10029c9b(param_2,param_3,param_4,param_5,(int *)&stack0xffffffd0,'\0',param_6);
        uVar4 = extraout_DL_01;
      }
      else {
        *param_2 = 0;
        uVar4 = extraout_DL_00;
      }
      goto LAB_10029ea9;
    }
    piVar1 = __errno();
    uVar5 = (undefined)in_stack_ffffffd0;
  }
  *piVar1 = 0x16;
  FUN_10025625();
  uVar4 = extraout_DL;
LAB_10029ea9:
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,uVar4,uVar5);
  return;
}



undefined4 __cdecl
FUN_10029eba(char *param_1,int param_2,uint param_3,int *param_4,char param_5,
            pthreadlocinfo *param_6)

{
  int iVar1;
  int *piVar2;
  undefined4 uVar3;
  char *pcVar4;
  int local_18 [2];
  int local_10;
  char local_c;
  uint local_8;
  
  local_8 = param_4[1] - 1;
  FUN_1001f92e(local_18,param_6);
  if ((param_1 == (char *)0x0) || (param_2 == 0)) {
    piVar2 = __errno();
    uVar3 = 0x16;
    *piVar2 = 0x16;
    FUN_10025625();
  }
  else {
    uVar3 = 0;
    if ((param_5 != '\0') && (local_8 == param_3)) {
      *(undefined2 *)(param_1 + (*param_4 == 0x2d) + local_8) = 0x30;
    }
    if (*param_4 == 0x2d) {
      *param_1 = '-';
      param_1 = param_1 + 1;
    }
    if (param_4[1] < 1) {
      __shift(param_1,1);
      *param_1 = '0';
      pcVar4 = param_1 + 1;
    }
    else {
      pcVar4 = param_1 + param_4[1];
    }
    if (0 < (int)param_3) {
      __shift(pcVar4,1);
      *pcVar4 = ***(char ***)(local_18[0] + 0x84);
      iVar1 = param_4[1];
      if (iVar1 < 0) {
        if (param_5 == '\0') {
          if (SBORROW4(param_3,-iVar1) == (int)(param_3 + iVar1) < 0) {
            param_3 = -iVar1;
          }
        }
        else {
          param_3 = -iVar1;
        }
        __shift(pcVar4 + 1,param_3);
        FUN_10021290((uint *)(pcVar4 + 1),0x30,param_3);
      }
    }
  }
  if (local_c != '\0') {
    *(uint *)(local_10 + 0x70) = *(uint *)(local_10 + 0x70) & 0xfffffffd;
  }
  return uVar3;
}



void __cdecl
FUN_10029fa6(undefined4 *param_1,char *param_2,int param_3,uint param_4,pthreadlocinfo *param_5)

{
  int *piVar1;
  int iVar2;
  uint uVar3;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  undefined extraout_DL_02;
  undefined uVar4;
  undefined uVar5;
  int in_stack_ffffffd0;
  int local_2c;
  char local_20 [24];
  uint local_8;
  
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  FUN_10031d58(*param_1,param_1[1],(int *)&stack0xffffffd0,local_20,0x16);
  if (param_2 == (char *)0x0) {
    piVar1 = __errno();
    uVar5 = (undefined)in_stack_ffffffd0;
    *piVar1 = 0x16;
    FUN_10025625();
    uVar4 = extraout_DL;
  }
  else if (param_3 == 0) {
    piVar1 = __errno();
    uVar5 = (undefined)in_stack_ffffffd0;
    *piVar1 = 0x16;
    FUN_10025625();
    uVar4 = extraout_DL_00;
  }
  else {
    uVar3 = 0xffffffff;
    if (param_3 != -1) {
      uVar3 = param_3 - (uint)(in_stack_ffffffd0 == 0x2d);
    }
    iVar2 = FUN_10031be0(param_2 + (in_stack_ffffffd0 == 0x2d),uVar3,local_2c + param_4,
                         (int)&stack0xffffffd0);
    uVar5 = (undefined)in_stack_ffffffd0;
    if (iVar2 == 0) {
      FUN_10029eba(param_2,param_3,param_4,(int *)&stack0xffffffd0,'\0',param_5);
      uVar4 = extraout_DL_02;
    }
    else {
      *param_2 = '\0';
      uVar4 = extraout_DL_01;
    }
  }
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,uVar4,uVar5);
  return;
}



void __cdecl
FUN_1002a067(undefined4 *param_1,char *param_2,uint param_3,uint param_4,int param_5,
            pthreadlocinfo *param_6)

{
  char *pcVar1;
  int *piVar2;
  uint uVar3;
  int iVar4;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  undefined extraout_DL_02;
  undefined extraout_DL_03;
  undefined uVar5;
  char *pcVar6;
  bool bVar7;
  undefined uVar8;
  int in_stack_ffffffcc;
  int local_30;
  char local_20 [24];
  uint local_8;
  
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  FUN_10031d58(*param_1,param_1[1],(int *)&stack0xffffffcc,local_20,0x16);
  if (param_2 == (char *)0x0) {
    piVar2 = __errno();
    uVar8 = (undefined)in_stack_ffffffcc;
    *piVar2 = 0x16;
    FUN_10025625();
    uVar5 = extraout_DL;
  }
  else if (param_3 == 0) {
    piVar2 = __errno();
    uVar8 = (undefined)in_stack_ffffffcc;
    *piVar2 = 0x16;
    FUN_10025625();
    uVar5 = extraout_DL_00;
  }
  else {
    bVar7 = in_stack_ffffffcc == 0x2d;
    uVar3 = 0xffffffff;
    if (param_3 != 0xffffffff) {
      uVar3 = param_3 - bVar7;
    }
    iVar4 = FUN_10031be0(param_2 + bVar7,uVar3,param_4,(int)&stack0xffffffcc);
    uVar8 = (undefined)in_stack_ffffffcc;
    if (iVar4 == 0) {
      if ((local_30 + -1 < -4) || ((int)param_4 <= local_30 + -1)) {
        FUN_10029c9b(param_2,param_3,param_4,param_5,(int *)&stack0xffffffcc,'\x01',param_6);
        uVar5 = extraout_DL_03;
      }
      else {
        pcVar1 = param_2 + bVar7;
        if (false) {
          do {
            pcVar6 = pcVar1;
            pcVar1 = pcVar6 + 1;
          } while (*pcVar6 != '\0');
          pcVar6[-1] = '\0';
        }
        FUN_10029eba(param_2,param_3,param_4,(int *)&stack0xffffffcc,'\x01',param_6);
        uVar5 = extraout_DL_02;
      }
    }
    else {
      *param_2 = '\0';
      uVar5 = extraout_DL_01;
    }
  }
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,uVar5,uVar8);
  return;
}



void __cdecl FUN_1002a166(char *param_1)

{
  FUN_1002a177(param_1,(pthreadlocinfo *)0x0);
  return;
}



void __cdecl FUN_1002a177(char *param_1,pthreadlocinfo *param_2)

{
  char cVar1;
  char *pcVar2;
  int local_14 [2];
  int local_c;
  char local_8;
  char *pcVar3;
  
  FUN_1001f92e(local_14,param_2);
  cVar1 = *param_1;
  if (cVar1 != '\0') {
    do {
      if (cVar1 == ***(char ***)(local_14[0] + 0x84)) break;
      param_1 = param_1 + 1;
      cVar1 = *param_1;
    } while (cVar1 != '\0');
  }
  if (*param_1 != '\0') {
    do {
      param_1 = param_1 + 1;
      cVar1 = *param_1;
      pcVar2 = param_1;
      if ((cVar1 == '\0') || (cVar1 == 'e')) break;
    } while (cVar1 != 'E');
    do {
      pcVar3 = pcVar2;
      pcVar2 = pcVar3 + -1;
    } while (*pcVar2 == '0');
    if (*pcVar2 == ***(char ***)(local_14[0] + 0x84)) {
      pcVar2 = pcVar3 + -2;
    }
    do {
      cVar1 = *param_1;
      pcVar2 = pcVar2 + 1;
      param_1 = param_1 + 1;
      *pcVar2 = cVar1;
    } while (cVar1 != '\0');
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return;
}



void __cdecl FUN_1002a1f7(uint param_1,uint *param_2,char *param_3)

{
  FUN_1002a20f(param_1,param_2,param_3,(pthreadlocinfo *)0x0);
  return;
}



void __cdecl FUN_1002a20f(uint param_1,uint *param_2,char *param_3,pthreadlocinfo *param_4)

{
  uint local_c;
  uint local_8;
  
  if (param_1 == 0) {
    FUN_100311f2(&param_1,param_3,param_4);
    *param_2 = param_1;
  }
  else {
    FUN_10031164(&local_c,param_3,param_4);
    *param_2 = local_c;
    param_2[1] = local_8;
  }
  return;
}



void __cdecl FUN_1002a251(byte *param_1)

{
  FUN_1002a262(param_1,(pthreadlocinfo *)0x0);
  return;
}



void __cdecl FUN_1002a262(byte *param_1,pthreadlocinfo *param_2)

{
  byte bVar1;
  int iVar2;
  byte bVar3;
  bool bVar4;
  int local_14 [2];
  int local_c;
  char local_8;
  
  FUN_1001f92e(local_14,param_2);
  iVar2 = _tolower((int)(char)*param_1);
  bVar4 = iVar2 == 0x65;
  while (!bVar4) {
    param_1 = param_1 + 1;
    iVar2 = _isdigit((uint)*param_1);
    bVar4 = iVar2 == 0;
  }
  iVar2 = _tolower((int)(char)*param_1);
  if (iVar2 == 0x78) {
    param_1 = param_1 + 2;
  }
  bVar3 = *param_1;
  *param_1 = ***(byte ***)(local_14[0] + 0x84);
  do {
    param_1 = param_1 + 1;
    bVar1 = *param_1;
    *param_1 = bVar3;
    bVar3 = bVar1;
  } while (*param_1 != 0);
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return;
}



// Library Function - Single Match
//  __positive
// 
// Library: Visual Studio 2012 Release

int __cdecl __positive(double *arg)

{
  if (0.0 < *arg != (*arg == 0.0)) {
    return 1;
  }
  return 0;
}



// Library Function - Single Match
//  __shift
// 
// Library: Visual Studio 2012 Release

void __cdecl __shift(char *param_1,int param_2)

{
  size_t sVar1;
  
  if (param_2 != 0) {
    sVar1 = _strlen(param_1);
    FID_conflict__memcpy(param_1 + param_2,param_1,sVar1 + 1);
  }
  return;
}



// Library Function - Single Match
//  __setdefaultprecision
// 
// Library: Visual Studio 2012 Release

void __setdefaultprecision(void)

{
  code *pcVar1;
  errno_t eVar2;
  
  eVar2 = __controlfp_s((uint *)0x0,0x10000,0x30000);
  if (eVar2 == 0) {
    return;
  }
  __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void FUN_1002a33f(void)

{
  PVOID pvVar1;
  uint uVar2;
  
  uVar2 = 0;
  do {
    pvVar1 = EncodePointer(*(PVOID *)((int)&PTR_FUN_100473ec + uVar2));
    *(PVOID *)((int)&PTR_FUN_100473ec + uVar2) = pvVar1;
    uVar2 = uVar2 + 4;
  } while (uVar2 < 0x28);
  return;
}



// Library Function - Single Match
//  _CallDestructExceptionObject
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release

void __cdecl _CallDestructExceptionObject(int *param_1)

{
  BOOL BVar1;
  
  if ((*param_1 == -0x1f928c9d) && (true)) {
    BVar1 = __IsNonwritableInCurrentImage((PBYTE)&PTR____DestructExceptionObject_1003aa88);
    if (BVar1 != 0) {
      ___DestructExceptionObject(param_1);
    }
  }
  return;
}



// Library Function - Single Match
//  __global_unwind2
// 
// Library: Visual Studio

void __cdecl __global_unwind2(PVOID param_1)

{
  RtlUnwind(param_1,(PVOID)0x1002a3b8,(PEXCEPTION_RECORD)0x0,(PVOID)0x0);
  return;
}



undefined4 __fastcall
FUN_1002a3c0(undefined4 param_1,undefined param_2,int param_3,undefined4 param_4,undefined4 param_5,
            undefined4 *param_6,uint param_7)

{
  undefined4 uVar1;
  int iVar2;
  undefined1 unaff_retaddr;
  
  uVar1 = 1;
  if ((*(uint *)(param_3 + 4) & 6) != 0) {
    iVar2 = FUN_1002534c(*(uint *)(param_7 - 4) ^ param_7,param_2,unaff_retaddr);
    __local_unwind2(*(int *)(iVar2 + 0x24),*(uint *)(iVar2 + 0x28));
    *param_6 = param_4;
    uVar1 = 3;
  }
  return uVar1;
}



// Library Function - Single Match
//  __local_unwind2
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

void __cdecl __local_unwind2(int param_1,uint param_2)

{
  uint uVar1;
  undefined4 *in_FS_OFFSET;
  undefined4 local_20;
  code *pcStack28;
  undefined4 local_18;
  int iStack20;
  
  iStack20 = param_1;
  pcStack28 = FUN_1002a3c0;
  local_20 = *in_FS_OFFSET;
  *in_FS_OFFSET = &local_20;
  while( true ) {
    uVar1 = *(uint *)(param_1 + 0xc);
    if ((uVar1 == 0xffffffff) || ((param_2 != 0xffffffff && (uVar1 <= param_2)))) break;
    local_18 = *(undefined4 *)(*(int *)(param_1 + 8) + uVar1 * 0xc);
    *(undefined4 *)(param_1 + 0xc) = local_18;
    if (*(int *)(*(int *)(param_1 + 8) + 4 + uVar1 * 0xc) == 0) {
      __NLG_Notify(0x101);
      FUN_1002a4d4();
    }
  }
  *in_FS_OFFSET = local_20;
  return;
}



// Library Function - Single Match
//  __NLG_Notify1
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

undefined4 __fastcall __NLG_Notify1(undefined4 param_1)

{
  undefined4 in_EAX;
  undefined4 unaff_EBP;
  
  DAT_10047424 = in_EAX;
  DAT_10047428 = param_1;
  DAT_1004742c = unaff_EBP;
  return in_EAX;
}



// Library Function - Single Match
//  __NLG_Notify
// 
// Libraries: Visual Studio 2017 Debug, Visual Studio 2017 Release, Visual Studio 2019 Debug, Visual
// Studio 2019 Release

void __NLG_Notify(ulong param_1)

{
  undefined4 in_EAX;
  undefined4 unaff_EBP;
  
  DAT_10047424 = in_EAX;
  DAT_10047428 = param_1;
  DAT_1004742c = unaff_EBP;
  return;
}



void FUN_1002a4d4(void)

{
  code *in_EAX;
  
  (*in_EAX)();
  return;
}



// Library Function - Single Match
//  _ValidateScopeTableHandlers
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined4 __cdecl _ValidateScopeTableHandlers(PBYTE param_1,int param_2,int param_3)

{
  int *piVar1;
  int iVar2;
  PIMAGE_SECTION_HEADER p_Var3;
  uint uVar4;
  uint uVar5;
  
  p_Var3 = (PIMAGE_SECTION_HEADER)0x0;
  uVar4 = 0xffffffff;
  if (param_3 != -1) {
    do {
      piVar1 = (int *)(param_2 + param_3 * 0xc);
      uVar5 = *(int *)(param_2 + 8 + param_3 * 0xc) - (int)param_1 & 0xfffff000;
      if (((uVar5 != uVar4) &&
          ((((uVar4 = uVar5, p_Var3 == (PIMAGE_SECTION_HEADER)0x0 ||
             (uVar5 < p_Var3->VirtualAddress)) || (p_Var3->Misc + p_Var3->VirtualAddress <= uVar5))
           && ((p_Var3 = __FindPESection(param_1,uVar5), p_Var3 == (PIMAGE_SECTION_HEADER)0x0 ||
               ((p_Var3->Characteristics & 0x20000000) == 0)))))) ||
         (((iVar2 = piVar1[1], iVar2 != 0 &&
           ((uVar5 = iVar2 - (int)param_1 & 0xfffff000, uVar5 != uVar4 &&
            ((uVar4 = uVar5, uVar5 < p_Var3->VirtualAddress ||
             (p_Var3->Misc + p_Var3->VirtualAddress <= uVar5)))))) &&
          ((p_Var3 = __FindPESection(param_1,uVar5), p_Var3 == (PIMAGE_SECTION_HEADER)0x0 ||
           ((p_Var3->Characteristics & 0x20000000) == 0)))))) {
        return 0;
      }
      param_3 = *piVar1;
    } while (param_3 != -1);
  }
  return 1;
}



// Library Function - Single Match
//  __ValidateEH3RN
// 
// Library: Visual Studio 2012 Release

undefined4 __cdecl __ValidateEH3RN(uint *param_1)

{
  PBYTE pBVar1;
  uint uVar2;
  uint *puVar3;
  BOOL BVar4;
  int iVar5;
  PIMAGE_SECTION_HEADER p_Var6;
  SIZE_T SVar7;
  uint uVar8;
  uint *puVar9;
  PBYTE pBVar10;
  int iVar11;
  int **in_FS_OFFSET;
  bool bVar12;
  uint local_5c;
  undefined local_4c [24];
  DWORD local_34;
  uint *local_30;
  uint local_2c;
  uint *local_28;
  uint local_24;
  uint local_20;
  uint *local_1c;
  int *local_14;
  code *pcStack16;
  uint local_c;
  undefined4 local_8;
  
  pcStack16 = FUN_10027070;
  local_14 = *in_FS_OFFSET;
  local_c = DAT_10046c24 ^ 0x1003fee8;
  local_5c = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  local_1c = &local_5c;
  *in_FS_OFFSET = (int *)&local_14;
  local_30 = (uint *)param_1[2];
  if (((uint)local_30 & 3) == 0) {
    puVar9 = (uint *)in_FS_OFFSET[6][2];
    if ((local_30 < puVar9) || ((uint *)in_FS_OFFSET[6][1] <= local_30)) {
      local_20 = param_1[3];
      if (local_20 != 0xffffffff) {
        local_24 = 0;
        uVar8 = 0;
        puVar3 = local_30;
        do {
          if ((*puVar3 != 0xffffffff) && (uVar8 <= *puVar3)) goto LAB_1002a5e4;
          if (puVar3[1] != 0) {
            local_24 = 1;
          }
          uVar8 = uVar8 + 1;
          puVar3 = puVar3 + 3;
        } while (uVar8 <= local_20);
        if ((local_24 != 0) && (((uint *)param_1[-2] < puVar9 || (param_1 <= (uint *)param_1[-2]))))
        goto LAB_1002a5e4;
        uVar8 = (uint)local_30 & 0xfffff000;
        for (iVar11 = 0; local_2c = uVar8, local_28 = local_30, puVar9 = &local_5c,
            iVar11 < DAT_10835d28; iVar11 = iVar11 + 1) {
          local_24 = (&DAT_10835ca8)[iVar11 * 2];
          pBVar10 = (PBYTE)(&DAT_10835cac)[iVar11 * 2];
          if (local_24 == uVar8) {
            local_8 = 0;
            BVar4 = __ValidateImageBase(pBVar10);
            puVar9 = local_1c;
            if (((BVar4 != 0) &&
                (iVar5 = _ValidateScopeTableHandlers(pBVar10,(int)local_28,local_20),
                puVar9 = local_1c, iVar5 != 0)) &&
               (p_Var6 = __FindPESection(pBVar10,param_1[1] - (int)pBVar10), iVar5 = DAT_10835d2c,
               puVar9 = local_1c, p_Var6 != (PIMAGE_SECTION_HEADER)0x0)) {
              if ((iVar11 < 1) || (DAT_10835d2c = 1, iVar5 != 0)) goto LAB_1002a8eb;
              iVar5 = DAT_10835d28;
              if ((&DAT_10835ca8)[iVar11 * 2] != uVar8) goto joined_r0x1002a710;
              goto LAB_1002a748;
            }
            break;
          }
        }
        local_1c = puVar9;
        uVar2 = local_20;
        puVar9 = local_28;
        local_8 = 0xfffffffe;
        SVar7 = VirtualQuery(local_28,(PMEMORY_BASIC_INFORMATION)local_4c,0x1c);
        if (SVar7 != 0) {
          if (local_34 == 0x1000000) {
            local_28 = (uint *)local_4c._4_4_;
            BVar4 = __ValidateImageBase(local_4c._4_4_);
            if (BVar4 != 0) {
              if (((((local_4c[20] & 0xcc) != 0) &&
                   ((p_Var6 = __FindPESection((PBYTE)local_28,(int)puVar9 - (int)local_28),
                    p_Var6 == (PIMAGE_SECTION_HEADER)0x0 ||
                    ((p_Var6->Characteristics & 0x80000000) != 0)))) ||
                  (pBVar10 = (PBYTE)local_28,
                  iVar11 = _ValidateScopeTableHandlers((PBYTE)local_28,(int)puVar9,uVar2),
                  iVar11 == 0)) ||
                 (p_Var6 = __FindPESection(pBVar10,param_1[1] - (int)pBVar10), iVar11 = DAT_10835d2c
                 , p_Var6 == (PIMAGE_SECTION_HEADER)0x0)) goto LAB_1002a5e4;
              DAT_10835d2c = 1;
              if (iVar11 == 0) {
                iVar11 = DAT_10835d28;
                if (0 < DAT_10835d28) {
                  puVar9 = (uint *)(&DAT_10835ca0 + DAT_10835d28 * 8);
                  do {
                    if (*puVar9 == uVar8) break;
                    iVar11 = iVar11 + -1;
                    puVar9 = puVar9 + -2;
                  } while (0 < iVar11);
                }
                if (iVar11 == 0) {
                  iVar11 = 0xf;
                  if (DAT_10835d28 < 0x10) {
                    iVar11 = DAT_10835d28;
                  }
                  if (-1 < iVar11) {
                    puVar9 = &DAT_10835ca8;
                    iVar11 = iVar11 + 1;
                    do {
                      uVar2 = *puVar9;
                      pBVar10 = (PBYTE)puVar9[1];
                      *puVar9 = uVar8;
                      puVar9[1] = (uint)local_4c._4_4_;
                      puVar9 = puVar9 + 2;
                      iVar11 = iVar11 + -1;
                      local_4c._4_4_ = pBVar10;
                      uVar8 = uVar2;
                    } while (iVar11 != 0);
                  }
                  if (DAT_10835d28 < 0x10) {
                    DAT_10835d28 = DAT_10835d28 + 1;
                  }
                }
                else {
                  *(PBYTE *)(&DAT_10835ca4 + iVar11 * 8) = local_4c._4_4_;
                }
                DAT_10835d2c = 0;
              }
              goto LAB_1002a8eb;
            }
          }
          *in_FS_OFFSET = local_14;
          return 0xffffffff;
        }
      }
LAB_1002a8eb:
      *in_FS_OFFSET = local_14;
      return 1;
    }
  }
LAB_1002a5e4:
  *in_FS_OFFSET = local_14;
  return 0;
  while (iVar5 = iVar11, (&DAT_10835ca8)[iVar11 * 2] != uVar8) {
joined_r0x1002a710:
    iVar11 = iVar5 + -1;
    if (iVar11 < 0) goto LAB_1002a721;
  }
  local_24 = (&DAT_10835ca8)[iVar11 * 2];
  pBVar10 = (PBYTE)(&DAT_10835cac)[iVar11 * 2];
LAB_1002a721:
  bVar12 = iVar11 < 0;
  if (bVar12) {
    if (DAT_10835d28 < 0x10) {
      DAT_10835d28 = DAT_10835d28 + 1;
    }
    iVar11 = DAT_10835d28 + -1;
LAB_1002a748:
    bVar12 = iVar11 < 0;
  }
  if ((iVar11 != 0 && !bVar12) && (-1 < iVar11)) {
    puVar9 = &DAT_10835ca8;
    iVar11 = iVar11 + 1;
    do {
      uVar8 = *puVar9;
      pBVar1 = (PBYTE)puVar9[1];
      *puVar9 = local_24;
      puVar9[1] = (uint)pBVar10;
      puVar9 = puVar9 + 2;
      iVar11 = iVar11 + -1;
      pBVar10 = pBVar1;
      local_24 = uVar8;
    } while (iVar11 != 0);
  }
  DAT_10835d2c = 0;
  goto LAB_1002a8eb;
}



undefined8 FUN_1002a910(void)

{
  undefined4 extraout_ECX;
  uint extraout_EDX;
  float10 in_ST0;
  undefined8 uVar1;
  double dVar2;
  
  dVar2 = (double)in_ST0;
  FUN_10032218(SUB84(dVar2,0),(uint)((ulonglong)dVar2 >> 0x20));
  uVar1 = FUN_1002a92d(extraout_ECX,extraout_EDX,SUB84(dVar2,0),(uint)((ulonglong)dVar2 >> 0x20));
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined8 __fastcall FUN_1002a92d(undefined4 param_1,uint param_2,int param_3,uint param_4)

{
  uint uVar1;
  uint uVar2;
  undefined4 uVar3;
  bool in_ZF;
  ushort in_FPUControlWord;
  ushort in_FPUStatusWord;
  undefined4 unaff_retaddr;
  uint uVar4;
  
  uVar4 = param_2 & 0xffff0000 | (uint)in_FPUControlWord;
  if (in_ZF) {
    if (((param_4 & 0xfffff) != 0) || (param_3 != 0)) {
      uVar1 = FUN_100321bc();
      goto LAB_1002a9ab;
    }
    uVar1 = param_4 & 0x80000000;
    if (uVar1 != 0) goto LAB_1002a99e;
  }
  else {
    uVar1 = param_4;
    if (in_FPUControlWord != 0x27f) {
      uVar1 = FUN_100321a5(uVar4);
    }
    if (((uVar1 & 0x80000000) != 0) &&
       ((((uVar1 & 0x7ff00000) != 0 || ((uVar1 & 0xfffff) != 0)) || (param_3 != 0)))) {
LAB_1002a99e:
      uVar1 = 1;
LAB_1002a9ab:
      if (_DAT_10835af0 == 0) {
        __startOneArgErrorHandling(&DAT_10047430,5,(ushort)uVar4,unaff_retaddr,param_3,param_4);
        return CONCAT44(uVar4,uVar1);
      }
      goto LAB_1003222e;
    }
  }
  if (_DAT_10835af0 == 0) {
    uVar2 = uVar1 & 0xffff0000 | uVar4 & 0xffff;
    if ((short)(uVar4 & 0xffff) != 0x27f) {
      if (((uVar4 & 0x20) != 0) &&
         (uVar2 = uVar1 & 0xffff0000 | (uint)in_FPUStatusWord, (in_FPUStatusWord & 0x20) != 0)) {
        uVar3 = 8;
        __startOneArgErrorHandling(&DAT_10047430,5,(ushort)uVar4,unaff_retaddr,param_3,param_4);
        return CONCAT44(uVar4,uVar3);
      }
      uVar2 = uVar2 & 0xffff0020;
    }
    return CONCAT44(uVar4,uVar2);
  }
LAB_1003222e:
  return CONCAT44(uVar4,uVar1);
}



bool FUN_1002a9ca(void)

{
  DAT_10835d30 = GetProcessHeap();
  return DAT_10835d30 != (HANDLE)0x0;
}



void FUN_1002a9df(void)

{
  DAT_10835d30 = 0;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __FF_MSGBANNER
// 
// Library: Visual Studio 2012 Release

void __cdecl __FF_MSGBANNER(void)

{
  int iVar1;
  
  iVar1 = __set_error_mode(3);
  if (iVar1 != 1) {
    iVar1 = __set_error_mode(3);
    if (iVar1 != 0) {
      return;
    }
    if (_DAT_10835d38 != 1) {
      return;
    }
  }
  FUN_1002aa44(0xfc);
  FUN_1002aa44(0xff);
  return;
}



// Library Function - Single Match
//  __GET_RTERRMSG
// 
// Library: Visual Studio 2012 Release

wchar_t * __cdecl __GET_RTERRMSG(int param_1)

{
  uint uVar1;
  
  uVar1 = 0;
  do {
    if (param_1 == (&DAT_10039cc0)[uVar1 * 2]) {
      return (wchar_t *)(&PTR_u_R6002___floating_point_support_n_10039cc4)[uVar1 * 2];
    }
    uVar1 = uVar1 + 1;
  } while (uVar1 < 0x17);
  return (wchar_t *)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_1002aa44(int param_1)

{
  code *pcVar1;
  wchar_t *_Src;
  int iVar2;
  errno_t eVar3;
  DWORD DVar4;
  size_t sVar5;
  HANDLE hFile;
  uint uVar6;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  undefined extraout_DL_02;
  undefined extraout_DL_03;
  undefined uVar7;
  LPDWORD lpNumberOfBytesWritten;
  LPOVERLAPPED lpOverlapped;
  undefined in_stack_fffffe00;
  char local_1fc [500];
  uint local_8;
  
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  _Src = __GET_RTERRMSG(param_1);
  uVar7 = extraout_DL;
  if (_Src != (wchar_t *)0x0) {
    iVar2 = __set_error_mode(3);
    if ((iVar2 == 1) || ((iVar2 = __set_error_mode(3), iVar2 == 0 && (_DAT_10835d38 == 1)))) {
      hFile = GetStdHandle(0xfffffff4);
      uVar7 = extraout_DL_02;
      if ((hFile != (HANDLE)0x0) && (hFile != (HANDLE)0xffffffff)) {
        uVar6 = 0;
        do {
          local_1fc[uVar6] = *(char *)(_Src + uVar6);
          if (_Src[uVar6] == L'\0') break;
          uVar6 = uVar6 + 1;
        } while (uVar6 < 500);
        lpOverlapped = (LPOVERLAPPED)0x0;
        lpNumberOfBytesWritten = (LPDWORD)&stack0xfffffe00;
        local_1fc[499] = 0;
        sVar5 = _strlen(local_1fc);
        WriteFile(hFile,local_1fc,sVar5,lpNumberOfBytesWritten,lpOverlapped);
        uVar7 = extraout_DL_03;
      }
    }
    else {
      uVar7 = extraout_DL_00;
      if (param_1 != 0xfc) {
        eVar3 = _wcscpy_s((wchar_t *)&DAT_10835d40,0x314,L"Runtime Error!\n\nProgram: ");
        if (eVar3 == 0) {
          _DAT_10835f7a = 0;
          DVar4 = GetModuleFileNameW((HMODULE)0x0,(LPWSTR)&DAT_10835d72,0x104);
          if ((DVar4 != 0) ||
             (eVar3 = _wcscpy_s((wchar_t *)&DAT_10835d72,0x2fb,L"<program name unknown>"),
             eVar3 == 0)) {
            sVar5 = _wcslen((wchar_t *)&DAT_10835d72);
            if (0x3c < sVar5 + 1) {
              sVar5 = _wcslen((wchar_t *)&DAT_10835d72);
              iVar2 = FUN_10031aa5((short *)(&DAT_10835cfc + sVar5 * 2),
                                   0x2fb - ((int)(sVar5 * 2 + -0x76) >> 1),(short *)&DAT_1003a6c4,3)
              ;
              if (iVar2 != 0) goto LAB_1002abf6;
            }
            eVar3 = _wcscat_s((wchar_t *)&DAT_10835d40,0x314,L"\n\n");
            if ((eVar3 == 0) && (eVar3 = _wcscat_s((wchar_t *)&DAT_10835d40,0x314,_Src), eVar3 == 0)
               ) {
              FUN_1003235c((LPCWSTR)&DAT_10835d40,L"Microsoft Visual C++ Runtime Library",0x12010);
              uVar7 = extraout_DL_01;
              goto LAB_1002abe6;
            }
          }
        }
LAB_1002abf6:
        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
        pcVar1 = (code *)swi(3);
        (*pcVar1)();
        return;
      }
    }
  }
LAB_1002abe6:
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,uVar7,in_stack_fffffe00);
  return;
}



uint __cdecl FUN_1002ac01(uint param_1,FILE *param_2)

{
  uint uVar1;
  WCHAR *pWVar2;
  FILE *_File;
  byte bVar3;
  WCHAR *pWVar4;
  int *piVar5;
  undefined **ppuVar6;
  undefined3 extraout_var;
  undefined *puVar7;
  FILE *pFVar8;
  longlong lVar9;
  
  _File = param_2;
  pWVar4 = (WCHAR *)__fileno(param_2);
  uVar1 = _File->_flag;
  if ((uVar1 & 0x82) == 0) {
    piVar5 = __errno();
    *piVar5 = 9;
LAB_1002ac25:
    _File->_flag = _File->_flag | 0x20;
    return 0xffffffff;
  }
  if ((uVar1 & 0x40) != 0) {
    piVar5 = __errno();
    *piVar5 = 0x22;
    goto LAB_1002ac25;
  }
  pFVar8 = (FILE *)0x0;
  if ((uVar1 & 1) != 0) {
    _File->_cnt = 0;
    if ((uVar1 & 0x10) == 0) {
      _File->_flag = uVar1 | 0x20;
      return 0xffffffff;
    }
    _File->_ptr = _File->_base;
    _File->_flag = uVar1 & 0xfffffffe;
  }
  uVar1 = _File->_flag;
  _File->_cnt = 0;
  _File->_flag = uVar1 & 0xffffffef | 2;
  if (((uVar1 & 0x10c) == 0) &&
     (((ppuVar6 = FUN_100245a8(), _File != (FILE *)(ppuVar6 + 8) &&
       (ppuVar6 = FUN_100245a8(), _File != (FILE *)(ppuVar6 + 0x10))) ||
      (bVar3 = FUN_1003180b((uint)pWVar4), CONCAT31(extraout_var,bVar3) == 0)))) {
    __getbuf(_File);
  }
  if ((_File->_flag & 0x108U) == 0) {
    param_2 = (FILE *)0x1;
    pFVar8 = (FILE *)FUN_1002e63e(pWVar4,(WCHAR *)&param_1,1);
  }
  else {
    pWVar2 = (WCHAR *)_File->_base;
    param_2 = (FILE *)(_File->_ptr + -(int)pWVar2);
    _File->_ptr = (char *)((int)pWVar2 + 1);
    _File->_cnt = _File->_bufsiz + -1;
    if ((int)param_2 < 1) {
      if ((pWVar4 == (WCHAR *)0xffffffff) || (pWVar4 == (WCHAR *)0xfffffffe)) {
        puVar7 = &DAT_100473a0;
      }
      else {
        puVar7 = (undefined *)(((uint)pWVar4 & 0x1f) * 0x40 + (&DAT_10835b98)[(int)pWVar4 >> 5]);
      }
      if (((puVar7[4] & 0x20) != 0) && (lVar9 = FUN_1002e4cf((uint)pWVar4,0,0,2), lVar9 == -1))
      goto LAB_1002ad3c;
    }
    else {
      pFVar8 = (FILE *)FUN_1002e63e(pWVar4,pWVar2,(uint)param_2);
    }
    *_File->_base = (char)param_1;
  }
  if (pFVar8 == param_2) {
    return param_1 & 0xff;
  }
LAB_1002ad3c:
  _File->_flag = _File->_flag | 0x20;
  return 0xffffffff;
}



void __cdecl FUN_1002ad50(FILE *param_1,byte *param_2,pthreadlocinfo *param_3,int **param_4)

{
  WCHAR WVar1;
  ushort uVar2;
  uint uVar3;
  byte *pbVar4;
  undefined2 extraout_var_00;
  int *piVar5;
  undefined3 extraout_var;
  code *pcVar6;
  char *pcVar7;
  byte *pbVar8;
  int iVar9;
  int *piVar10;
  int extraout_ECX;
  byte extraout_DL;
  byte bVar11;
  undefined *puVar12;
  uint uVar13;
  int *piVar14;
  char *pcVar15;
  bool bVar16;
  longlong lVar17;
  undefined4 uVar18;
  pthreadlocinfo *pptVar19;
  undefined uVar20;
  int *in_stack_fffffd7c;
  pthreadlocinfo local_274 [2];
  int local_26c;
  char local_268;
  int local_264;
  int *local_260;
  int *local_25c;
  int local_258;
  undefined4 local_254;
  uint local_250;
  int local_24c;
  int local_248;
  int *local_244;
  char *local_240;
  uint local_23c;
  int local_238;
  FILE *local_234;
  byte local_230;
  char local_22f;
  char *local_22c;
  int *local_228;
  int local_224;
  int **local_220;
  uint local_21c;
  byte local_215;
  byte *local_214;
  undefined local_210;
  undefined local_11 [9];
  uint local_8;
  
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  local_234 = param_1;
  local_214 = param_2;
  uVar13 = 0;
  local_220 = param_4;
  local_258 = 0;
  piVar14 = (int *)0x0;
  local_21c = 0;
  local_244 = (int *)0x0;
  local_228 = (int *)0x0;
  local_238 = 0;
  local_254 = 0;
  local_24c = 0;
  local_248 = 0;
  FUN_1001f92e(local_274,param_3);
  local_260 = __errno();
  uVar20 = SUB41(in_stack_fffffd7c,0);
  if (local_234 != (FILE *)0x0) {
    if ((*(byte *)&local_234->_flag & 0x40) == 0) {
      uVar3 = __fileno(local_234);
      uVar20 = SUB41(in_stack_fffffd7c,0);
      if ((uVar3 == 0xffffffff) || (uVar3 == 0xfffffffe)) {
        puVar12 = &DAT_100473a0;
      }
      else {
        puVar12 = (undefined *)((uVar3 & 0x1f) * 0x40 + (&DAT_10835b98)[(int)uVar3 >> 5]);
      }
      if ((puVar12[0x24] & 0x7f) == 0) {
        if ((uVar3 == 0xffffffff) || (uVar3 == 0xfffffffe)) {
          puVar12 = &DAT_100473a0;
        }
        else {
          puVar12 = (undefined *)((uVar3 & 0x1f) * 0x40 + (&DAT_10835b98)[(int)uVar3 >> 5]);
        }
        if ((puVar12[0x24] & 0x80) == 0) goto LAB_1002ae47;
      }
    }
    else {
LAB_1002ae47:
      uVar20 = SUB41(in_stack_fffffd7c,0);
      if (local_214 != (byte *)0x0) {
        local_215 = *local_214;
        local_22c = (char *)0x0;
        iVar9 = 0;
        local_224 = 0;
        local_23c = 0;
        local_25c = (int *)0x0;
        local_250 = local_250 & 0xffffff00 | (uint)local_215;
        pbVar4 = local_214;
        bVar11 = local_215;
        if (local_215 == 0) goto LAB_1002b8a7;
        do {
          uVar20 = SUB41(in_stack_fffffd7c,0);
          local_214 = pbVar4 + 1;
          if (iVar9 < 0) break;
          if ((byte)(local_215 - 0x20) < 0x59) {
            uVar3 = *(byte *)((int)L"Microsoft Visual C++ Runtime Library" + (char)local_215 + 0x30)
                    & 0xf;
          }
          else {
            uVar3 = 0;
          }
          local_23c = (uint)((byte)(&DAT_1003a728)[local_23c + uVar3 * 9] >> 4);
          pbVar8 = local_214;
          switch(local_23c) {
          case 0:
LAB_1002b0ef:
            local_248 = 0;
            uVar2 = FUN_10029715((uint)local_215,local_274);
            if (CONCAT22(extraout_var_00,uVar2) != 0) {
              _write_char((byte)local_250,local_234,&local_224);
              uVar20 = SUB41(in_stack_fffffd7c,0);
              bVar11 = *local_214;
              local_214 = local_214 + 1;
              local_250 = local_250 & 0xffffff00 | (uint)bVar11;
              if (bVar11 == 0) goto switchD_1002aeee_caseD_9;
            }
            _write_char((byte)local_250,local_234,&local_224);
            pbVar8 = local_214;
            iVar9 = local_224;
            break;
          case 1:
            local_228 = (int *)0xffffffff;
            uVar13 = 0;
            local_254 = 0;
            local_24c = 0;
            local_244 = (int *)0x0;
            local_238 = 0;
            local_21c = 0;
            local_248 = 0;
            break;
          case 2:
            if (local_215 == 0x20) {
              uVar13 = uVar13 | 2;
              local_21c = uVar13;
            }
            else if (local_215 == 0x23) {
              uVar13 = uVar13 | 0x80;
              local_21c = uVar13;
            }
            else if (local_215 == 0x2b) {
              uVar13 = uVar13 | 1;
              local_21c = uVar13;
            }
            else if (local_215 == 0x2d) {
              uVar13 = uVar13 | 4;
              local_21c = uVar13;
            }
            else if (local_215 == 0x30) {
              uVar13 = uVar13 | 8;
              local_21c = uVar13;
            }
            break;
          case 3:
            if (local_215 == 0x2a) {
              local_244 = *local_220;
              local_220 = local_220 + 1;
              if ((int)local_244 < 0) {
                uVar13 = uVar13 | 4;
                local_244 = (int *)-(int)local_244;
                local_21c = uVar13;
              }
            }
            else {
              local_244 = (int *)((int)(char)local_215 + (int)local_244 * 10 + -0x30);
              iVar9 = local_224;
            }
            break;
          case 4:
            local_228 = (int *)0x0;
            break;
          case 5:
            if (local_215 == 0x2a) {
              local_228 = *local_220;
              local_220 = local_220 + 1;
              if ((int)local_228 < 0) {
                local_228 = (int *)0xffffffff;
              }
            }
            else {
              local_228 = (int *)((int)(char)local_215 + (int)local_228 * 10 + -0x30);
              iVar9 = local_224;
            }
            break;
          case 6:
            if (local_215 == 0x49) {
              bVar11 = *local_214;
              if ((bVar11 == 0x36) && (pbVar4[2] == 0x34)) {
                uVar13 = uVar13 | 0x8000;
                pbVar8 = pbVar4 + 3;
                local_21c = uVar13;
              }
              else if ((bVar11 == 0x33) && (pbVar4[2] == 0x32)) {
                uVar13 = uVar13 & 0xffff7fff;
                pbVar8 = pbVar4 + 3;
                local_21c = uVar13;
              }
              else if (((((bVar11 != 100) && (bVar11 != 0x69)) && (bVar11 != 0x6f)) &&
                       ((bVar11 != 0x75 && (bVar11 != 0x78)))) && (bVar11 != 0x58)) {
                local_23c = 0;
                goto LAB_1002b0ef;
              }
            }
            else if (local_215 == 0x68) {
              uVar13 = uVar13 | 0x20;
              local_21c = uVar13;
            }
            else if (local_215 == 0x6c) {
              if (*local_214 == 0x6c) {
                uVar13 = uVar13 | 0x1000;
                pbVar8 = pbVar4 + 2;
                local_21c = uVar13;
              }
              else {
                uVar13 = uVar13 | 0x10;
                local_21c = uVar13;
              }
            }
            else if (local_215 == 0x77) {
              uVar13 = uVar13 | 0x800;
              local_21c = uVar13;
            }
            break;
          case 7:
            if ((char)local_215 < 'e') {
              if (local_215 == 100) {
LAB_1002b3c6:
                uVar13 = uVar13 | 0x40;
                local_21c = uVar13;
LAB_1002b3cf:
                local_22c = (char *)0xa;
LAB_1002b3d9:
                if (((uVar13 & 0x8000) == 0) && ((uVar13 & 0x1000) == 0)) {
                  if ((uVar13 & 0x20) == 0) {
                    if ((uVar13 & 0x40) == 0) {
                      piVar14 = *local_220;
                      piVar10 = (int *)0x0;
                      local_220 = local_220 + 1;
                      goto LAB_1002b5b0;
                    }
                    piVar14 = *local_220;
                  }
                  else if ((uVar13 & 0x40) == 0) {
                    piVar14 = (int *)(uint)*(ushort *)local_220;
                  }
                  else {
                    piVar14 = (int *)(int)*(short *)local_220;
                  }
                  piVar10 = (int *)((int)piVar14 >> 0x1f);
                  local_220 = local_220 + 1;
                }
                else {
                  piVar14 = *local_220;
                  piVar10 = local_220[1];
                  local_220 = local_220 + 2;
                }
LAB_1002b5b0:
                if ((((uVar13 & 0x40) != 0) && ((int)piVar10 < 1)) &&
                   (((int)piVar10 < 0 || (false)))) {
                  bVar16 = piVar14 != (int *)0x0;
                  piVar14 = (int *)-(int)piVar14;
                  piVar10 = (int *)-(int)((int)piVar10 + (uint)bVar16);
                  uVar13 = uVar13 | 0x100;
                  local_21c = uVar13;
                }
                if ((uVar13 & 0x9000) == 0) {
                  piVar10 = (int *)0x0;
                }
                lVar17 = CONCAT44(piVar10,piVar14);
                if ((int)local_228 < 0) {
                  local_228 = (int *)0x1;
                }
                else {
                  local_21c = uVar13 & 0xfffffff7;
                  if (0x200 < (int)local_228) {
                    local_228 = (int *)0x200;
                  }
                }
                if (((uint)piVar14 | (uint)piVar10) == 0) {
                  local_238 = 0;
                }
                piVar10 = (int *)local_11;
                while( true ) {
                  piVar5 = (int *)((int)local_228 + -1);
                  if (((int)local_228 < 1) && (lVar17 == 0)) break;
                  local_228 = piVar5;
                  lVar17 = __aulldvrm((uint)lVar17,(uint)((ulonglong)lVar17 >> 0x20),(uint)local_22c
                                      ,(int)local_22c >> 0x1f);
                  local_240 = (char *)lVar17;
                  iVar9 = extraout_ECX + 0x30;
                  if (0x39 < iVar9) {
                    iVar9 = iVar9 + local_258;
                  }
                  *(char *)piVar10 = (char)iVar9;
                  piVar10 = (int *)((int)piVar10 + -1);
                }
                local_22c = local_11 + -(int)piVar10;
                piVar14 = (int *)((int)piVar10 + 1);
                uVar13 = local_21c;
                local_228 = piVar5;
                if (((local_21c & 0x200) != 0) &&
                   ((local_22c == (char *)0x0 || (*(char *)piVar14 != '0')))) {
                  local_22c = local_11 + -(int)piVar10 + 1;
                  *(undefined *)piVar10 = 0x30;
                  piVar14 = piVar10;
                }
              }
              else if ((char)local_215 < 'T') {
                if (local_215 == 0x53) {
                  if ((uVar13 & 0x830) == 0) {
                    uVar13 = uVar13 | 0x800;
                    local_21c = uVar13;
                  }
                  goto LAB_1002b210;
                }
                if (local_215 == 0x41) {
LAB_1002b195:
                  local_215 = local_215 + 0x20;
                  local_254 = 1;
LAB_1002b1a8:
                  uVar3 = uVar13 | 0x40;
                  local_240 = (char *)0x200;
                  piVar5 = (int *)&local_210;
                  pcVar15 = local_240;
                  local_21c = uVar3;
                  if ((int)local_228 < 0) {
                    local_228 = (int *)0x6;
                  }
                  else if (local_228 == (int *)0x0) {
                    if (local_215 == 0x67) {
                      local_228 = (int *)0x1;
                    }
                  }
                  else {
                    if (0x200 < (int)local_228) {
                      local_228 = (int *)0x200;
                    }
                    if (0xa3 < (int)local_228) {
                      pcVar15 = (char *)((int)local_228 + 0x15d);
                      local_25c = (int *)FUN_10026f23((size_t)pcVar15);
                      piVar5 = local_25c;
                      if (local_25c == (int *)0x0) {
                        local_228 = (int *)0xa3;
                        piVar5 = (int *)&local_210;
                        pcVar15 = local_240;
                      }
                    }
                  }
                  local_240 = pcVar15;
                  in_stack_fffffd7c = *local_220;
                  local_220 = local_220 + 2;
                  pptVar19 = local_274;
                  iVar9 = (int)(char)local_215;
                  puVar12 = &stack0xfffffd7c;
                  piVar14 = piVar5;
                  pcVar15 = local_240;
                  piVar10 = local_228;
                  uVar18 = local_254;
                  pcVar6 = (code *)DecodePointer(PTR_FUN_10047404);
                  (*pcVar6)(puVar12,piVar14,pcVar15,iVar9,piVar10,uVar18,pptVar19);
                  if (((uVar13 & 0x80) != 0) && (local_228 == (int *)0x0)) {
                    pptVar19 = local_274;
                    piVar14 = piVar5;
                    pcVar6 = (code *)DecodePointer(PTR_FUN_10047410);
                    (*pcVar6)(piVar14,pptVar19);
                  }
                  if ((local_215 == 0x67) && ((uVar13 & 0x80) == 0)) {
                    pptVar19 = local_274;
                    piVar14 = piVar5;
                    pcVar6 = (code *)DecodePointer(PTR_FUN_1004740c);
                    (*pcVar6)(piVar14,pptVar19);
                  }
                  if (*(char *)piVar5 == '-') {
                    local_21c = uVar13 | 0x140;
                    uVar3 = local_21c;
                    piVar5 = (int *)((int)piVar5 + 1);
                  }
LAB_1002b330:
                  piVar14 = piVar5;
                  uVar13 = uVar3;
                  local_22c = (char *)_strlen((char *)piVar14);
                }
                else if (local_215 == 0x43) {
                  if ((uVar13 & 0x830) == 0) {
                    uVar13 = uVar13 | 0x800;
                    local_21c = uVar13;
                  }
LAB_1002b289:
                  if ((uVar13 & 0x810) == 0) {
                    local_210 = *(undefined *)local_220;
                    local_22c = (char *)0x1;
                    local_220 = local_220 + 1;
                  }
                  else {
                    WVar1 = *(WCHAR *)local_220;
                    local_220 = local_220 + 1;
                    iVar9 = FUN_10031983((int *)&local_22c,(uint *)&local_210,0x200,WVar1);
                    if (iVar9 != 0) {
                      local_24c = 1;
                    }
                  }
                  piVar14 = (int *)&local_210;
                }
                else if ((local_215 == 0x45) || (local_215 == 0x47)) goto LAB_1002b195;
              }
              else {
                if (local_215 == 0x58) goto LAB_1002b524;
                if (local_215 == 0x5a) {
                  piVar10 = *local_220;
                  local_220 = local_220 + 1;
                  uVar3 = uVar13;
                  piVar5 = (int *)PTR_s__null__100473e0;
                  if ((piVar10 == (int *)0x0) ||
                     (piVar14 = (int *)piVar10[1], piVar14 == (int *)0x0)) goto LAB_1002b330;
                  local_22c = (char *)(int)*(WCHAR *)piVar10;
                  if ((uVar13 & 0x800) == 0) {
                    local_248 = 0;
                  }
                  else {
                    local_248 = 1;
                    local_22c = (char *)((int)local_22c / 2);
                  }
                }
                else {
                  if (local_215 == 0x61) goto LAB_1002b1a8;
                  if (local_215 == 99) goto LAB_1002b289;
                }
              }
LAB_1002b6ad:
              if (local_24c == 0) {
                if ((uVar13 & 0x40) != 0) {
                  if ((uVar13 & 0x100) == 0) {
                    if ((uVar13 & 1) == 0) {
                      if ((uVar13 & 2) == 0) goto LAB_1002b6f4;
                      local_230 = 0x20;
                    }
                    else {
                      local_230 = 0x2b;
                    }
                  }
                  else {
                    local_230 = 0x2d;
                  }
                  local_238 = 1;
                }
LAB_1002b6f4:
                pcVar15 = (char *)((int)local_244 + (-local_238 - (int)local_22c));
                if ((uVar13 & 0xc) == 0) {
                  _write_multi_char(0x20,(int)pcVar15,local_234,&local_224);
                }
                FUN_1002969d(&local_230,local_238,local_234,&local_224,local_260);
                if (((uVar13 & 8) != 0) && ((uVar13 & 4) == 0)) {
                  _write_multi_char(0x30,(int)pcVar15,local_234,&local_224);
                }
                if ((local_248 == 0) || (pcVar7 = local_22c, piVar10 = piVar14, (int)local_22c < 1))
                {
                  FUN_1002969d((byte *)piVar14,(int)local_22c,local_234,&local_224,local_260);
                }
                else {
                  do {
                    local_240 = pcVar7 + -1;
                    iVar9 = FUN_10031983(&local_264,(uint *)(local_11 + 1),6,*(WCHAR *)piVar10);
                    if ((iVar9 != 0) || (local_264 == 0)) {
                      local_224 = -1;
                      break;
                    }
                    FUN_1002969d(local_11 + 1,local_264,local_234,&local_224,local_260);
                    pcVar7 = local_240;
                    piVar10 = (int *)((int)piVar10 + 2);
                  } while (local_240 != (char *)0x0);
                }
                if ((-1 < local_224) && ((uVar13 & 4) != 0)) {
                  _write_multi_char(0x20,(int)pcVar15,local_234,&local_224);
                }
              }
            }
            else {
              if ('p' < (char)local_215) {
                if (local_215 == 0x73) {
LAB_1002b210:
                  piVar10 = (int *)0x7fffffff;
                  if (local_228 != (int *)0xffffffff) {
                    piVar10 = local_228;
                  }
                  piVar5 = *local_220;
                  local_220 = local_220 + 1;
                  piVar14 = piVar5;
                  if ((uVar13 & 0x810) == 0) {
                    if (piVar5 == (int *)0x0) {
                      piVar5 = (int *)PTR_s__null__100473e0;
                      piVar14 = (int *)PTR_s__null__100473e0;
                    }
                    for (; (piVar10 != (int *)0x0 &&
                           (piVar10 = (int *)((int)piVar10 + -1), *(char *)piVar5 != '\0'));
                        piVar5 = (int *)((int)piVar5 + 1)) {
                    }
                    local_22c = (char *)((int)piVar5 - (int)piVar14);
                  }
                  else {
                    if (piVar5 == (int *)0x0) {
                      piVar14 = (int *)PTR_DAT_100473e4;
                    }
                    local_248 = 1;
                    for (piVar5 = piVar14;
                        (piVar10 != (int *)0x0 &&
                        (piVar10 = (int *)((int)piVar10 + -1), *(WCHAR *)piVar5 != L'\0'));
                        piVar5 = (int *)((int)piVar5 + 2)) {
                    }
                    local_22c = (char *)((int)piVar5 - (int)piVar14 >> 1);
                  }
                  goto LAB_1002b6ad;
                }
                if (local_215 == 0x75) goto LAB_1002b3cf;
                if (local_215 != 0x78) goto LAB_1002b6ad;
                local_258 = 0x27;
LAB_1002b544:
                local_22c = (char *)0x10;
                if ((char)uVar13 < '\0') {
                  local_22f = (char)local_258 + 'Q';
                  local_230 = 0x30;
                  local_238 = 2;
                }
                goto LAB_1002b3d9;
              }
              if (local_215 == 0x70) {
                local_228 = (int *)&DAT_00000008;
LAB_1002b524:
                local_258 = 7;
                goto LAB_1002b544;
              }
              if ((char)local_215 < 'e') goto LAB_1002b6ad;
              if ((char)local_215 < 'h') goto LAB_1002b1a8;
              if (local_215 == 0x69) goto LAB_1002b3c6;
              if (local_215 != 0x6e) {
                if (local_215 != 0x6f) goto LAB_1002b6ad;
                local_22c = (char *)0x8;
                if ((char)uVar13 < '\0') {
                  uVar13 = uVar13 | 0x200;
                  local_21c = uVar13;
                }
                goto LAB_1002b3d9;
              }
              piVar10 = *local_220;
              local_220 = local_220 + 1;
              bVar16 = FUN_10021026();
              uVar20 = SUB41(in_stack_fffffd7c,0);
              if (CONCAT31(extraout_var,bVar16) == 0) goto switchD_1002aeee_caseD_9;
              if ((uVar13 & 0x20) == 0) {
                *piVar10 = local_224;
              }
              else {
                *(WCHAR *)piVar10 = (WCHAR)local_224;
              }
              local_24c = 1;
            }
            pbVar8 = local_214;
            iVar9 = local_224;
            if (local_25c != (int *)0x0) {
              FID_conflict__free(local_25c);
              local_25c = (int *)0x0;
              pbVar8 = local_214;
              iVar9 = local_224;
            }
            break;
          default:
            goto switchD_1002aeee_caseD_9;
          case 0xbad1abe1:
            break;
          }
          uVar20 = SUB41(in_stack_fffffd7c,0);
          local_215 = *pbVar8;
          local_250 = local_250 & 0xffffff00 | (uint)local_215;
          pbVar4 = pbVar8;
        } while (local_215 != 0);
        bVar11 = local_215;
        if ((local_23c == 0) || (local_23c == 7)) goto LAB_1002b8a7;
      }
    }
  }
switchD_1002aeee_caseD_9:
  piVar14 = __errno();
  *piVar14 = 0x16;
  FUN_10025625();
  bVar11 = extraout_DL;
LAB_1002b8a7:
  if (local_268 != '\0') {
    *(uint *)(local_26c + 0x70) = *(uint *)(local_26c + 0x70) & 0xfffffffd;
  }
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,bVar11,uVar20);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint * __cdecl FUN_1002b8f0(uint *param_1,char param_2)

{
  int iVar1;
  char cVar2;
  uint uVar3;
  uint *puVar4;
  uint uVar5;
  uint uVar6;
  char *pcVar7;
  undefined auVar8 [16];
  char cVar10;
  char cVar11;
  char cVar12;
  char cVar13;
  char cVar14;
  char cVar15;
  char cVar16;
  undefined auVar9 [16];
  
  if (_DAT_10835b4c != 0) {
    auVar9 = pshuflw(ZEXT216(CONCAT11(param_2,param_2)),ZEXT216(CONCAT11(param_2,param_2)),0);
    uVar3 = -1 << (sbyte)((uint)param_1 & 0xf);
    pcVar7 = (char *)((int)param_1 - ((uint)param_1 & 0xf));
    while( true ) {
      cVar2 = SUB161(auVar9,0);
      cVar10 = SUB161(auVar9 >> 8,0);
      cVar11 = SUB161(auVar9 >> 0x10,0);
      cVar12 = SUB161(auVar9 >> 0x18,0);
      cVar13 = SUB161(auVar9 >> 0x20,0);
      cVar14 = SUB161(auVar9 >> 0x28,0);
      cVar15 = SUB161(auVar9 >> 0x30,0);
      cVar16 = SUB161(auVar9 >> 0x38,0);
      auVar8 = CONCAT115(-(pcVar7[0xf] == '\0'),
                         CONCAT114(-(pcVar7[0xe] == '\0'),
                                   CONCAT113(-(pcVar7[0xd] == '\0'),
                                             CONCAT112(-(pcVar7[0xc] == '\0'),
                                                       CONCAT111(-(pcVar7[0xb] == '\0'),
                                                                 CONCAT110(-(pcVar7[10] == '\0'),
                                                                           CONCAT19(-(pcVar7[9] ==
                                                                                     '\0'),CONCAT18(
                                                  -(pcVar7[8] == '\0'),
                                                  CONCAT17(-(pcVar7[7] == '\0'),
                                                           CONCAT16(-(pcVar7[6] == '\0'),
                                                                    CONCAT15(-(pcVar7[5] == '\0'),
                                                                             CONCAT14(-(pcVar7[4] ==
                                                                                       '\0'),
                                                  CONCAT13(-(pcVar7[3] == '\0'),
                                                           CONCAT12(-(pcVar7[2] == '\0'),
                                                                    CONCAT11(-(pcVar7[1] == '\0'),
                                                                             -(*pcVar7 == '\0'))))))
                                                  )))))))))) |
               CONCAT115(-(pcVar7[0xf] == cVar16),
                         CONCAT114(-(pcVar7[0xe] == cVar15),
                                   CONCAT113(-(pcVar7[0xd] == cVar14),
                                             CONCAT112(-(pcVar7[0xc] == cVar13),
                                                       CONCAT111(-(pcVar7[0xb] == cVar12),
                                                                 CONCAT110(-(pcVar7[10] == cVar11),
                                                                           CONCAT19(-(pcVar7[9] ==
                                                                                     cVar10),
                                                  CONCAT18(-(pcVar7[8] == cVar2),
                                                           CONCAT17(-(pcVar7[7] == cVar16),
                                                                    CONCAT16(-(pcVar7[6] == cVar15),
                                                                             CONCAT15(-(pcVar7[5] ==
                                                                                       cVar14),
                                                  CONCAT14(-(pcVar7[4] == cVar13),
                                                           CONCAT13(-(pcVar7[3] == cVar12),
                                                                    CONCAT12(-(pcVar7[2] == cVar11),
                                                                             CONCAT11(-(pcVar7[1] ==
                                                                                       cVar10),-(*
                                                  pcVar7 == cVar2))))))))))))))));
      uVar3 = (ushort)((ushort)(SUB161(auVar8 >> 7,0) & 1) |
                       (ushort)(SUB161(auVar8 >> 0xf,0) & 1) << 1 |
                       (ushort)(SUB161(auVar8 >> 0x17,0) & 1) << 2 |
                       (ushort)(SUB161(auVar8 >> 0x1f,0) & 1) << 3 |
                       (ushort)(SUB161(auVar8 >> 0x27,0) & 1) << 4 |
                       (ushort)(SUB161(auVar8 >> 0x2f,0) & 1) << 5 |
                       (ushort)(SUB161(auVar8 >> 0x37,0) & 1) << 6 |
                       (ushort)(SUB161(auVar8 >> 0x3f,0) & 1) << 7 |
                       (ushort)(SUB161(auVar8 >> 0x47,0) & 1) << 8 |
                       (ushort)(SUB161(auVar8 >> 0x4f,0) & 1) << 9 |
                       (ushort)(SUB161(auVar8 >> 0x57,0) & 1) << 10 |
                       (ushort)(SUB161(auVar8 >> 0x5f,0) & 1) << 0xb |
                       (ushort)(SUB161(auVar8 >> 0x67,0) & 1) << 0xc |
                       (ushort)(SUB161(auVar8 >> 0x6f,0) & 1) << 0xd |
                       (ushort)(SUB161(auVar8 >> 0x77,0) & 1) << 0xe |
                      (ushort)SUB161(auVar8 >> 0x7f,0) << 0xf) & uVar3;
      if (uVar3 != 0) break;
      uVar3 = 0xffffffff;
      pcVar7 = pcVar7 + 0x10;
    }
    iVar1 = 0;
    if (uVar3 != 0) {
      for (; (uVar3 >> iVar1 & 1) == 0; iVar1 = iVar1 + 1) {
      }
    }
    puVar4 = (uint *)(pcVar7 + iVar1);
    if (cVar2 != *(char *)puVar4) {
      puVar4 = (uint *)0x0;
    }
    return puVar4;
  }
  uVar3 = (uint)param_1 & 3;
  while (uVar3 != 0) {
    if (*(char *)param_1 == param_2) {
      return param_1;
    }
    if (*(char *)param_1 == '\0') {
      return (uint *)0x0;
    }
    uVar3 = (uint)(uint *)((int)param_1 + 1) & 3;
    param_1 = (uint *)((int)param_1 + 1);
  }
  while( true ) {
    while( true ) {
      uVar3 = *param_1;
      uVar6 = uVar3 ^ CONCAT22(CONCAT11(param_2,param_2),CONCAT11(param_2,param_2));
      uVar5 = uVar3 ^ 0xffffffff ^ uVar3 + 0x7efefeff;
      puVar4 = param_1 + 1;
      if (((uVar6 ^ 0xffffffff ^ uVar6 + 0x7efefeff) & 0x81010100) != 0) break;
      param_1 = puVar4;
      if ((uVar5 & 0x81010100) != 0) {
        if ((uVar5 & 0x1010100) != 0) {
          return (uint *)0x0;
        }
        if ((uVar3 + 0x7efefeff & 0x80000000) == 0) {
          return (uint *)0x0;
        }
      }
    }
    uVar3 = *param_1;
    if ((char)uVar3 == param_2) {
      return param_1;
    }
    if ((char)uVar3 == '\0') {
      return (uint *)0x0;
    }
    cVar2 = (char)(uVar3 >> 8);
    if (cVar2 == param_2) {
      return (uint *)((int)param_1 + 1);
    }
    if (cVar2 == '\0') break;
    cVar2 = (char)(uVar3 >> 0x10);
    if (cVar2 == param_2) {
      return (uint *)((int)param_1 + 2);
    }
    if (cVar2 == '\0') {
      return (uint *)0x0;
    }
    cVar2 = (char)(uVar3 >> 0x18);
    if (cVar2 == param_2) {
      return (uint *)((int)param_1 + 3);
    }
    param_1 = puVar4;
    if (cVar2 == '\0') {
      return (uint *)0x0;
    }
  }
  return (uint *)0x0;
}



// Library Function - Single Match
//  _strcpy_s
// 
// Library: Visual Studio 2012 Release

errno_t __cdecl _strcpy_s(char *_Dst,rsize_t _SizeInBytes,char *_Src)

{
  char cVar1;
  int *piVar2;
  int iVar3;
  
  if ((_Dst != (char *)0x0) && (_SizeInBytes != 0)) {
    if (_Src != (char *)0x0) {
      iVar3 = (int)_Dst - (int)_Src;
      do {
        cVar1 = *_Src;
        _Src[iVar3] = cVar1;
        _Src = _Src + 1;
        if (cVar1 == '\0') break;
        _SizeInBytes = _SizeInBytes - 1;
      } while (_SizeInBytes != 0);
      if (_SizeInBytes != 0) {
        return 0;
      }
      *_Dst = '\0';
      piVar2 = __errno();
      iVar3 = 0x22;
      goto LAB_1002ba3d;
    }
    *_Dst = '\0';
  }
  piVar2 = __errno();
  iVar3 = 0x16;
LAB_1002ba3d:
  *piVar2 = iVar3;
  FUN_10025625();
  return iVar3;
}



// Library Function - Single Match
//  _strnlen
// 
// Libraries: Visual Studio 2008 Release, Visual Studio 2010 Release, Visual Studio 2012 Release,
// Visual Studio 2019 Release

size_t __cdecl _strnlen(char *_Str,size_t _MaxCount)

{
  uint uVar1;
  
  uVar1 = 0;
  if (_MaxCount != 0) {
    do {
      if (*_Str == '\0') {
        return uVar1;
      }
      uVar1 = uVar1 + 1;
      _Str = _Str + 1;
    } while (uVar1 < _MaxCount);
  }
  return uVar1;
}



void FUN_1002ba8b(void)

{
  DecodePointer(DAT_10836374);
  return;
}



void __cdecl FUN_1002ba98(undefined4 param_1)

{
  DAT_1083636c = param_1;
  DAT_10836370 = param_1;
  DAT_10836374 = param_1;
  DAT_10836378 = param_1;
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

undefined4 __cdecl FUN_1002bab4(int param_1)

{
  bool bVar1;
  uint uVar2;
  int *piVar3;
  PVOID Ptr;
  code *pcVar4;
  code *pcVar5;
  int iVar6;
  _ptiddata p_Var7;
  int local_34;
  void *local_30;
  code **local_20;
  
  local_30 = (void *)0x0;
  local_34 = 0;
  bVar1 = false;
  p_Var7 = (_ptiddata)0x0;
  if (param_1 < 0xc) {
    if (param_1 != 0xb) {
      if (param_1 == 2) {
        local_20 = (code **)&DAT_1083636c;
        Ptr = DAT_1083636c;
        goto LAB_1002bb73;
      }
      if (param_1 != 4) {
        if (param_1 == 6) goto LAB_1002bb4b;
        if (param_1 != 8) goto LAB_1002bb39;
      }
    }
    p_Var7 = __getptd_noexit();
    if (p_Var7 == (_ptiddata)0x0) {
      return 0xffffffff;
    }
    uVar2 = FUN_1002bc6f(param_1,(uint)p_Var7->_pxcptacttab);
    local_20 = (code **)(uVar2 + 8);
    pcVar4 = *local_20;
  }
  else {
    if (param_1 == 0xf) {
      local_20 = (code **)&DAT_10836378;
      Ptr = DAT_10836378;
    }
    else if (param_1 == 0x15) {
      local_20 = (code **)&DAT_10836370;
      Ptr = DAT_10836370;
    }
    else {
      if (param_1 != 0x16) {
LAB_1002bb39:
        piVar3 = __errno();
        *piVar3 = 0x16;
        FUN_10025625();
        return 0xffffffff;
      }
LAB_1002bb4b:
      local_20 = (code **)&DAT_10836374;
      Ptr = DAT_10836374;
    }
LAB_1002bb73:
    bVar1 = true;
    pcVar4 = (code *)DecodePointer(Ptr);
  }
  if (pcVar4 == (code *)0x1) {
    return 0;
  }
  if (pcVar4 == (code *)0x0) {
    __exit(3);
  }
  if (bVar1) {
    __lock(0);
  }
  if (((param_1 == 8) || (param_1 == 0xb)) || (param_1 == 4)) {
    local_30 = p_Var7->_tpxcptinfoptrs;
    p_Var7->_tpxcptinfoptrs = (void *)0x0;
    if (param_1 == 8) {
      local_34 = p_Var7->_tfpecode;
      p_Var7->_tfpecode = 0x8c;
      goto LAB_1002bbd2;
    }
  }
  else {
LAB_1002bbd2:
    if (param_1 == 8) {
      for (iVar6 = 3; iVar6 < 0xc; iVar6 = iVar6 + 1) {
        *(undefined4 *)((int)p_Var7->_pxcptacttab + iVar6 * 0xc + 8) = 0;
      }
      goto LAB_1002bc11;
    }
  }
  pcVar5 = (code *)EncodePointer((PVOID)0x0);
  *local_20 = pcVar5;
LAB_1002bc11:
  FUN_1002bc35();
  if (param_1 == 8) {
    (*pcVar4)(8,p_Var7->_tfpecode);
  }
  else {
    (*pcVar4)(param_1);
    if ((param_1 != 0xb) && (param_1 != 4)) {
      return 0;
    }
  }
  p_Var7->_tpxcptinfoptrs = local_30;
  if (param_1 == 8) {
    p_Var7->_tfpecode = local_34;
  }
  return 0;
}



void FUN_1002bc35(void)

{
  int unaff_EBX;
  
  if (unaff_EBX != 0) {
    FUN_1002f199(0);
  }
  return;
}



uint __cdecl FUN_1002bc6f(int param_1,uint param_2)

{
  uint uVar1;
  
  uVar1 = param_2;
  do {
    if (*(int *)(uVar1 + 4) == param_1) break;
    uVar1 = uVar1 + 0xc;
  } while (uVar1 < param_2 + 0x90);
  if ((param_2 + 0x90 <= uVar1) || (*(int *)(uVar1 + 4) != param_1)) {
    uVar1 = 0;
  }
  return uVar1;
}



// Library Function - Single Match
//  __wrename
// 
// Library: Visual Studio 2012 Release

int __cdecl __wrename(wchar_t *_OldFilename,wchar_t *_NewFilename)

{
  BOOL BVar1;
  ulong uVar2;
  
  BVar1 = MoveFileExW(_OldFilename,_NewFilename,2);
  if (BVar1 == 0) {
    uVar2 = GetLastError();
  }
  else {
    uVar2 = 0;
  }
  if (uVar2 != 0) {
    FID_conflict___dosmaperr(uVar2);
    return -1;
  }
  return 0;
}



void __cdecl FUN_1002bcdc(undefined4 param_1)

{
  if ((code *)(DAT_10836b00 ^ DAT_10046c24) != (code *)0x0) {
    (*(code *)(DAT_10836b00 ^ DAT_10046c24))(param_1);
    return;
  }
                    // WARNING: Could not recover jumptable at 0x1002bcf4. Too many branches
                    // WARNING: Treating indirect jump as call
  TlsAlloc();
  return;
}



void __cdecl FUN_1002bcfa(DWORD param_1)

{
  if ((code *)(DAT_10836b04 ^ DAT_10046c24) != (code *)0x0) {
    (*(code *)(DAT_10836b04 ^ DAT_10046c24))();
    return;
  }
  TlsFree(param_1);
  return;
}



void __cdecl FUN_1002bd19(DWORD param_1)

{
  if ((code *)(DAT_10836b08 ^ DAT_10046c24) != (code *)0x0) {
    (*(code *)(DAT_10836b08 ^ DAT_10046c24))();
    return;
  }
  TlsGetValue(param_1);
  return;
}



void __cdecl FUN_1002bd38(DWORD param_1,LPVOID param_2)

{
  if ((code *)(DAT_10836b0c ^ DAT_10046c24) != (code *)0x0) {
    (*(code *)(DAT_10836b0c ^ DAT_10046c24))();
    return;
  }
  TlsSetValue(param_1,param_2);
  return;
}



undefined4 __cdecl FUN_1002bd5a(LPCRITICAL_SECTION param_1,DWORD param_2,undefined4 param_3)

{
  undefined4 uVar1;
  
  if ((code *)(DAT_10836b10 ^ DAT_10046c24) != (code *)0x0) {
    uVar1 = (*(code *)(DAT_10836b10 ^ DAT_10046c24))(param_1,param_2,param_3);
    return uVar1;
  }
  InitializeCriticalSectionAndSpinCount(param_1,param_2);
  return 1;
}



bool FUN_1002bd88(void)

{
  int iVar1;
  int iVar2;
  undefined4 local_8;
  
  iVar1 = DAT_10047440;
  if (DAT_10047440 < 0) {
    local_8 = 0;
    iVar1 = 0;
    if (((code *)(DAT_10836b74 ^ DAT_10046c24) != (code *)0x0) &&
       (iVar2 = (*(code *)(DAT_10836b74 ^ DAT_10046c24))(&local_8,0), iVar2 == 0x7a)) {
      iVar1 = 1;
    }
  }
  DAT_10047440 = iVar1;
  return 0 < DAT_10047440;
}



// public: static void __cdecl CThread::Sleep(unsigned int)

void __cdecl CThread::Sleep(uint param_1)

{
                    // 0x2c060  224  ?Sleep@CThread@@SAXI@Z
  ::Sleep(param_1);
  return;
}



// Library Function - Single Match
//  ___crtUnhandledException
// 
// Library: Visual Studio 2012 Release

LONG __cdecl ___crtUnhandledException(EXCEPTION_POINTERS *exceptionInfo)

{
  LONG LVar1;
  
  SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);
  LVar1 = UnhandledExceptionFilter(exceptionInfo);
  return LVar1;
}



undefined4 * FUN_1002c084(void)

{
  return &DAT_1004744c;
}



undefined4 * FUN_1002c08a(void)

{
  return &DAT_10047450;
}



undefined4 * FUN_1002c090(void)

{
  return &DAT_10047448;
}



undefined ** FUN_1002c096(void)

{
  return &PTR_DAT_100474d8;
}



undefined4 __cdecl FUN_1002c09c(undefined4 *param_1)

{
  int *piVar1;
  
  if (param_1 == (undefined4 *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    return 0x16;
  }
  *param_1 = DAT_1004744c;
  return 0;
}



undefined4 __cdecl FUN_1002c0c6(undefined4 *param_1)

{
  int *piVar1;
  
  if (param_1 == (undefined4 *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    return 0x16;
  }
  *param_1 = DAT_10047450;
  return 0;
}



undefined4 __cdecl FUN_1002c0f0(undefined4 *param_1)

{
  int *piVar1;
  
  if (param_1 == (undefined4 *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    return 0x16;
  }
  *param_1 = DAT_10047448;
  return 0;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___tzset
// 
// Library: Visual Studio 2012 Release

void __cdecl ___tzset(void)

{
  if (_DAT_10836384 == 0) {
    __lock(6);
    if (_DAT_10836384 == 0) {
      FUN_1002c398();
      _DAT_10836384 = _DAT_10836384 + 1;
    }
    FUN_1002c161();
  }
  return;
}



void FUN_1002c161(void)

{
  FUN_1002f199(6);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  __isindst
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release

int __cdecl __isindst(tm *_Time)

{
  uint uVar1;
  
  __lock(6);
  uVar1 = FUN_1002c1b4(&_Time->tm_sec);
  FUN_1002c1ab();
  return uVar1;
}



void FUN_1002c1ab(void)

{
  FUN_1002f199(6);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint __cdecl FUN_1002c1b4(int *param_1)

{
  code *pcVar1;
  int iVar2;
  uint uVar3;
  uint uVar4;
  uint uVar5;
  int iVar6;
  int iVar7;
  int iVar8;
  uint uVar9;
  int local_8;
  
  local_8 = 0;
  iVar2 = FUN_1002c09c(&local_8);
  if (iVar2 != 0) {
    __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    pcVar1 = (code *)swi(3);
    uVar5 = (*pcVar1)();
    return uVar5;
  }
  if (local_8 == 0) {
    return 0;
  }
  uVar5 = param_1[5];
  if ((uVar5 != _DAT_100474e0) || (uVar5 != _DAT_100474ec)) {
    if (_DAT_10836388 == 0) {
      iVar2 = 3;
      iVar7 = 2;
      iVar6 = 1;
      iVar8 = 0xb;
      if ((int)uVar5 < 0x6b) {
        iVar2 = 4;
        iVar8 = 10;
        iVar7 = 1;
        iVar6 = 5;
      }
      FUN_1002c6ca(1,1,uVar5,iVar2,iVar7,0,0,2,0,0,0);
      FUN_1002c6ca(0,1,param_1[5],iVar8,iVar6,0,0,2,0,0,0);
    }
    else {
      if (_DAT_10836428 != 0) {
        uVar9 = (uint)DAT_1083642e;
        uVar3 = 0;
        uVar4 = 0;
      }
      else {
        uVar3 = (uint)DAT_1083642c;
        uVar9 = 0;
        uVar4 = (uint)DAT_1083642e;
      }
      FUN_1002c6ca(1,(uint)(_DAT_10836428 == 0),uVar5,(uint)DAT_1083642a,uVar4,uVar3,uVar9,
                   (uint)DAT_10836430,(uint)DAT_10836432,(uint)DAT_10836434,(uint)DAT_10836436);
      if (_DAT_108363d4 != 0) {
        uVar9 = (uint)DAT_108363da;
        uVar3 = 0;
        uVar4 = 0;
        uVar5 = param_1[5];
      }
      else {
        uVar3 = (uint)DAT_108363d8;
        uVar9 = 0;
        uVar4 = (uint)DAT_108363da;
        uVar5 = param_1[5];
      }
      FUN_1002c6ca(0,(uint)(_DAT_108363d4 == 0),uVar5,(uint)DAT_108363d6,uVar4,uVar3,uVar9,
                   (uint)DAT_108363dc,(uint)DAT_108363de,(uint)DAT_108363e0,(uint)DAT_108363e2);
    }
  }
  iVar2 = param_1[7];
  if (DAT_100474e4 < DAT_100474f0) {
    if ((iVar2 < DAT_100474e4) || (DAT_100474f0 < iVar2)) {
      return 0;
    }
    if ((iVar2 <= DAT_100474e4) || (DAT_100474f0 <= iVar2)) {
LAB_1002c35f:
      iVar7 = ((param_1[2] * 0x3c + param_1[1]) * 0x3c + *param_1) * 1000;
      if (iVar2 != DAT_100474e4) {
        return (uint)(iVar7 < DAT_100474f4);
      }
      return (uint)(_DAT_100474e8 <= iVar7);
    }
  }
  else if ((DAT_100474f0 <= iVar2) && (iVar2 <= DAT_100474e4)) {
    if ((DAT_100474f0 < iVar2) && (iVar2 < DAT_100474e4)) {
      return 0;
    }
    goto LAB_1002c35f;
  }
  return 1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_1002c398(void)

{
  char cVar1;
  bool bVar2;
  undefined4 uVar3;
  LPSTR *ppCVar4;
  int iVar5;
  size_t sVar6;
  errno_t eVar7;
  DWORD DVar8;
  int *piVar9;
  undefined4 *puVar10;
  long lVar11;
  char *unaff_EDI;
  char *pcVar12;
  uint local_3c;
  int local_34;
  int local_30;
  int local_2c;
  undefined4 local_28;
  LPSTR *local_24;
  int local_20 [5];
  undefined4 uStack12;
  undefined *local_8;
  
  local_8 = &DAT_1003ff68;
  uStack12 = 0x1002c3a4;
  local_20[0] = 0;
  local_28 = 0;
  local_2c = 0;
  local_24 = (LPSTR *)0x0;
  local_30 = 0;
  bVar2 = false;
  __lock(7);
  local_8 = (undefined *)0x0;
  local_24 = FUN_1002c096();
  iVar5 = FUN_1002c0f0(local_20);
  if (iVar5 != 0) goto LAB_1002c4a2;
  iVar5 = FUN_1002c09c(&local_28);
  if (iVar5 != 0) goto LAB_1002c4a2;
  iVar5 = FUN_1002c0c6(&local_2c);
  if (iVar5 != 0) goto LAB_1002c4a2;
  local_3c = FUN_1003199e();
  _DAT_10836388 = 0;
  _DAT_100474ec = 0xffffffff;
  _DAT_100474e0 = 0xffffffff;
  unaff_EDI = __getenv_helper_nolock("TZ");
  if (unaff_EDI == (char *)0x0) goto LAB_1002c4ac;
  if (*unaff_EDI == '\0') goto LAB_1002c4ac;
  if (DAT_10836380 == (char *)0x0) {
LAB_1002c45e:
    sVar6 = _strlen(unaff_EDI);
    DAT_10836380 = (char *)FUN_10026f23(sVar6 + 1);
    if (DAT_10836380 != (char *)0x0) {
      pcVar12 = unaff_EDI;
      sVar6 = _strlen(unaff_EDI);
      eVar7 = _strcpy_s(DAT_10836380,sVar6 + 1,pcVar12);
      if (eVar7 != 0) goto LAB_1002c4a2;
      goto LAB_1002c59f;
    }
  }
  else {
    iVar5 = _strcmp(unaff_EDI,DAT_10836380);
    if (iVar5 != 0) {
      if (DAT_10836380 != (char *)0x0) {
        FID_conflict__free(DAT_10836380);
      }
      goto LAB_1002c45e;
    }
  }
  local_30 = 1;
LAB_1002c59f:
  do {
    iVar5 = local_20[0];
    piVar9 = FUN_1002c090();
    uVar3 = local_28;
    *piVar9 = iVar5;
    puVar10 = FUN_1002c084();
    iVar5 = local_2c;
    *puVar10 = uVar3;
    piVar9 = FUN_1002c08a();
    *piVar9 = iVar5;
    local_8 = (undefined *)0xfffffffe;
    FUN_1002c628();
    ppCVar4 = local_24;
    if (local_30 != 0) {
      return;
    }
    iVar5 = FUN_1002f8d8(*local_24,0x40,unaff_EDI,3);
    if (iVar5 == 0) {
      pcVar12 = unaff_EDI + 3;
      if (unaff_EDI[3] == '-') {
        bVar2 = true;
        pcVar12 = unaff_EDI + 4;
      }
      unaff_EDI = pcVar12;
      lVar11 = _atol(unaff_EDI);
      local_20[0] = lVar11 * 0xe10;
      for (; (cVar1 = *unaff_EDI, cVar1 == '+' || (('/' < cVar1 && (cVar1 < ':'))));
          unaff_EDI = unaff_EDI + 1) {
      }
      if (*unaff_EDI == ':') {
        unaff_EDI = unaff_EDI + 1;
        lVar11 = _atol(unaff_EDI);
        local_20[0] = local_20[0] + lVar11 * 0x3c;
        for (; ('/' < *unaff_EDI && (*unaff_EDI < ':')); unaff_EDI = unaff_EDI + 1) {
        }
        if (*unaff_EDI == ':') {
          unaff_EDI = unaff_EDI + 1;
          lVar11 = _atol(unaff_EDI);
          local_20[0] = local_20[0] + lVar11;
          for (; ('/' < *unaff_EDI && (*unaff_EDI < ':')); unaff_EDI = unaff_EDI + 1) {
          }
        }
      }
      if (bVar2) {
        local_20[0] = -local_20[0];
      }
      if (*unaff_EDI == '\0') {
        local_28 = 0;
        *ppCVar4[1] = '\0';
LAB_1002c6b0:
        iVar5 = local_20[0];
        piVar9 = FUN_1002c090();
        uVar3 = local_28;
        *piVar9 = iVar5;
        puVar10 = FUN_1002c084();
        *puVar10 = uVar3;
        return;
      }
      local_28 = 1;
      iVar5 = FUN_1002f8d8(ppCVar4[1],0x40,unaff_EDI,3);
      if (iVar5 == 0) goto LAB_1002c6b0;
    }
LAB_1002c4a2:
    __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
LAB_1002c4ac:
    if (DAT_10836380 != (char *)0x0) {
      FID_conflict__free(DAT_10836380);
      DAT_10836380 = (char *)0x0;
    }
    DVar8 = GetTimeZoneInformation((LPTIME_ZONE_INFORMATION)&DAT_10836390);
    if (DVar8 != 0xffffffff) {
      _DAT_10836388 = 1;
      local_20[0] = DAT_10836390 * 0x3c;
      if (DAT_108363d6 != 0) {
        local_20[0] = local_20[0] + DAT_108363e4 * 0x3c;
      }
      if ((DAT_1083642a == 0) || (DAT_10836438 == 0)) {
        local_28 = 0;
        local_2c = 0;
      }
      else {
        local_28 = 1;
        local_2c = (DAT_10836438 - DAT_108363e4) * 0x3c;
      }
      iVar5 = WideCharToMultiByte(local_3c,0,(LPCWSTR)&DAT_10836394,-1,*local_24,0x3f,(LPCSTR)0x0,
                                  &local_34);
      if ((iVar5 == 0) || (local_34 != 0)) {
        **local_24 = '\0';
      }
      else {
        (*local_24)[0x3f] = '\0';
      }
      iVar5 = WideCharToMultiByte(local_3c,0,(LPCWSTR)&DAT_108363e8,-1,local_24[1],0x3f,(LPCSTR)0x0,
                                  &local_34);
      if ((iVar5 == 0) || (local_34 != 0)) {
        *local_24[1] = '\0';
      }
      else {
        local_24[1][0x3f] = '\0';
      }
    }
    local_30 = 1;
  } while( true );
}



void FUN_1002c628(void)

{
  FUN_1002f199(7);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl
FUN_1002c6ca(int param_1,int param_2,uint param_3,int param_4,int param_5,int param_6,int param_7,
            int param_8,int param_9,int param_10,int param_11)

{
  code *pcVar1;
  uint uVar2;
  int iVar3;
  int iVar4;
  int iVar5;
  bool bVar6;
  int local_8;
  
  local_8 = 0;
  if (param_2 == 1) {
    uVar2 = param_3 & 0x80000003;
    if ((int)uVar2 < 0) {
      uVar2 = (uVar2 - 1 | 0xfffffffc) + 1;
    }
    if (((uVar2 == 0) && ((int)param_3 % 100 != 0)) || ((int)(param_3 + 0x76c) % 400 == 0)) {
      iVar5 = *(int *)(&DAT_10047530 + param_4 * 4);
    }
    else {
      iVar5 = *(int *)(&DAT_100474fc + param_4 * 4);
    }
    iVar4 = (int)(((int)((param_3 - 1) + ((int)(param_3 - 1) >> 0x1f & 3U)) >> 2) + iVar5 + 1 +
                  ((int)(param_3 + 299) / 400 - (int)(param_3 - 1) / 100) +
                 param_3 * 0x16d + -0x63db) % 7;
    iVar3 = param_5 * 7 - iVar4;
    if (iVar4 <= param_6) {
      iVar3 = iVar3 + -7;
    }
    iVar5 = iVar5 + 1 + iVar3 + param_6;
    if (param_5 == 5) {
      if (((uVar2 == 0) && ((int)param_3 % 100 != 0)) || ((int)(param_3 + 0x76c) % 400 == 0)) {
        iVar3 = *(int *)(&DAT_10047534 + param_4 * 4);
      }
      else {
        iVar3 = (&DAT_10047500)[param_4];
      }
      if (iVar3 < iVar5) {
        iVar5 = iVar5 + -7;
      }
    }
  }
  else {
    uVar2 = param_3 & 0x80000003;
    bVar6 = uVar2 == 0;
    if ((int)uVar2 < 0) {
      bVar6 = (uVar2 - 1 | 0xfffffffc) == 0xffffffff;
    }
    if (((bVar6) && ((int)param_3 % 100 != 0)) || ((int)(param_3 + 0x76c) % 400 == 0)) {
      iVar5 = *(int *)(&DAT_10047530 + param_4 * 4);
    }
    else {
      iVar5 = *(int *)(&DAT_100474fc + param_4 * 4);
    }
    iVar5 = iVar5 + param_7;
  }
  iVar3 = ((param_8 * 0x3c + param_9) * 0x3c + param_10) * 1000 + param_11;
  if (param_1 == 1) {
    _DAT_100474e0 = param_3;
    DAT_100474e4 = iVar5;
    _DAT_100474e8 = iVar3;
  }
  else {
    DAT_100474f0 = iVar5;
    DAT_100474f4 = iVar3;
    iVar5 = FUN_1002c0c6(&local_8);
    if (iVar5 != 0) {
      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      pcVar1 = (code *)swi(3);
      (*pcVar1)();
      return;
    }
    DAT_100474f4 = DAT_100474f4 + local_8 * 1000;
    _DAT_100474ec = param_3;
    if (DAT_100474f4 < 0) {
      DAT_100474f4 = DAT_100474f4 + 86400000;
      DAT_100474f0 = DAT_100474f0 + -1;
    }
    else if (86399999 < DAT_100474f4) {
      DAT_100474f4 = DAT_100474f4 + -86400000;
      DAT_100474f0 = DAT_100474f0 + 1;
    }
  }
  return;
}



void * FUN_1002c8ae(void)

{
  _ptiddata p_Var1;
  int *piVar2;
  void *pvVar3;
  
  p_Var1 = __getptd_noexit();
  if (p_Var1 == (_ptiddata)0x0) {
LAB_1002c8ba:
    piVar2 = __errno();
    *piVar2 = 0xc;
    return (void *)0x0;
  }
  if (p_Var1->_gmtimebuf == (void *)0x0) {
    pvVar3 = FUN_10026f23(0x24);
    p_Var1->_gmtimebuf = pvVar3;
    if (pvVar3 == (void *)0x0) goto LAB_1002c8ba;
  }
  return p_Var1->_gmtimebuf;
}



// Library Function - Single Match
//  __allrem
// 
// Library: Visual Studio

undefined8 __allrem(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  uint uVar4;
  int iVar5;
  int iVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  uint uVar10;
  uint uVar11;
  bool bVar12;
  bool bVar13;
  
  bVar13 = (int)param_2 < 0;
  if (bVar13) {
    bVar12 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(uint)bVar12 - param_2;
  }
  uVar11 = (uint)bVar13;
  if ((int)param_4 < 0) {
    bVar13 = param_3 != 0;
    param_3 = -param_3;
    param_4 = -(uint)bVar13 - param_4;
  }
  uVar3 = param_1;
  uVar4 = param_3;
  uVar8 = param_2;
  uVar9 = param_4;
  if (param_4 == 0) {
    iVar5 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) %
                 (ulonglong)param_3);
    iVar6 = 0;
    if ((int)(uVar11 - 1) < 0) goto LAB_1002c99d;
  }
  else {
    do {
      uVar10 = uVar9 >> 1;
      uVar4 = uVar4 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;
      uVar7 = uVar8 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar8 & 1) != 0) << 0x1f;
      uVar8 = uVar7;
      uVar9 = uVar10;
    } while (uVar10 != 0);
    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar4;
    uVar3 = (int)uVar1 * param_4;
    lVar2 = (uVar1 & 0xffffffff) * (ulonglong)param_3;
    uVar8 = (uint)((ulonglong)lVar2 >> 0x20);
    uVar4 = (uint)lVar2;
    uVar9 = uVar8 + uVar3;
    if (((CARRY4(uVar8,uVar3)) || (param_2 < uVar9)) || ((param_2 <= uVar9 && (param_1 < uVar4)))) {
      bVar13 = uVar4 < param_3;
      uVar4 = uVar4 - param_3;
      uVar9 = (uVar9 - param_4) - (uint)bVar13;
    }
    iVar5 = uVar4 - param_1;
    iVar6 = (uVar9 - param_2) - (uint)(uVar4 < param_1);
    if (-1 < (int)(uVar11 - 1)) goto LAB_1002c99d;
  }
  bVar13 = iVar5 != 0;
  iVar5 = -iVar5;
  iVar6 = -(uint)bVar13 - iVar6;
LAB_1002c99d:
  return CONCAT44(iVar6,iVar5);
}



// Library Function - Single Match
//  __aulldiv
// 
// Library: Visual Studio

undefined8 __aulldiv(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  
  uVar3 = param_1;
  uVar8 = param_4;
  uVar6 = param_2;
  uVar9 = param_3;
  if (param_4 == 0) {
    uVar3 = param_2 / param_3;
    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
                 (ulonglong)param_3);
  }
  else {
    do {
      uVar5 = uVar8 >> 1;
      uVar9 = uVar9 >> 1 | (uint)((uVar8 & 1) != 0) << 0x1f;
      uVar7 = uVar6 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
      uVar8 = uVar5;
      uVar6 = uVar7;
    } while (uVar5 != 0);
    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar9;
    iVar4 = (int)uVar1;
    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
    uVar8 = uVar3 + iVar4 * param_4;
    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar8)) ||
       ((param_2 <= uVar8 && (param_1 < (uint)lVar2)))) {
      iVar4 = iVar4 + -1;
    }
    uVar3 = 0;
  }
  return CONCAT44(uVar3,iVar4);
}



// Library Function - Single Match
//  __allmul
// 
// Library: Visual Studio

ulonglong __allmul(uint param_1,uint param_2,uint param_3,uint param_4)

{
  if ((param_4 | param_2) == 0) {
    return (ulonglong)param_1 * (ulonglong)param_3;
  }
  return (ulonglong)param_1 * (ulonglong)param_3 & 0xffffffff |
         (ulonglong)
         ((int)((ulonglong)param_1 * (ulonglong)param_3 >> 0x20) +
         param_2 * param_3 + param_1 * param_4) << 0x20;
}



LPVOID __cdecl FUN_1002ca54(uint param_1,uint param_2)

{
  LPVOID pvVar1;
  int *piVar2;
  int local_8;
  
  local_8 = 0;
  pvVar1 = __calloc_impl(param_1,param_2,&local_8);
  if ((pvVar1 == (LPVOID)0x0) && (local_8 != 0)) {
    piVar2 = __errno();
    if (piVar2 != (int *)0x0) {
      piVar2 = __errno();
      *piVar2 = local_8;
    }
  }
  return pvVar1;
}



void FUN_1002ca94(void)

{
  bool bVar1;
  DWORD DVar2;
  LPWSTR lpBuffer;
  int *piVar3;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  undefined uVar4;
  undefined extraout_DL_02;
  undefined extraout_DL_03;
  undefined uVar5;
  uint in_stack_fffffde4;
  WCHAR local_214 [262];
  uint local_8;
  
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  lpBuffer = local_214;
  bVar1 = false;
  DVar2 = GetCurrentDirectoryW(0x105,lpBuffer);
  uVar4 = extraout_DL;
  if ((int)DVar2 < 0x105) {
LAB_1002cb15:
    uVar5 = (undefined)in_stack_fffffde4;
    if (DVar2 != 0) goto LAB_1002cb40;
  }
  else {
    in_stack_fffffde4 = DVar2 + 1;
    lpBuffer = (LPWSTR)FUN_10026edb(in_stack_fffffde4,2);
    if (lpBuffer == (LPWSTR)0x0) {
      piVar3 = __errno();
      DVar2 = 0;
      *piVar3 = 0xc;
      uVar4 = extraout_DL_00;
      goto LAB_1002cb15;
    }
    bVar1 = true;
    if (DVar2 != 0) {
      DVar2 = GetCurrentDirectoryW(in_stack_fffffde4,lpBuffer);
      uVar4 = extraout_DL_01;
      goto LAB_1002cb15;
    }
  }
  uVar5 = (undefined)in_stack_fffffde4;
  piVar3 = __errno();
  *piVar3 = 0xc;
  uVar4 = extraout_DL_02;
LAB_1002cb40:
  if (bVar1) {
    FID_conflict__free(lpBuffer);
    uVar4 = extraout_DL_03;
  }
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,uVar4,uVar5);
  return;
}



// WARNING: Restarted to delay deadcode elimination for space: stack
// Library Function - Single Match
//  __CallSettingFrame@12
// 
// Library: Visual Studio 2012 Release

void __CallSettingFrame_12(undefined4 param_1,undefined4 param_2,int param_3)

{
  code *pcVar1;
  
  pcVar1 = (code *)__NLG_Notify1(param_3);
  (*pcVar1)();
  if (param_3 == 0x100) {
    param_3 = 2;
  }
  __NLG_Notify1(param_3);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// Library Function - Single Match
//  void __cdecl _inconsistency(void)
// 
// Library: Visual Studio 2012 Release

void __cdecl _inconsistency(void)

{
  code *pcVar1;
  
  pcVar1 = (code *)DecodePointer(DAT_1083643c);
  if (pcVar1 != (code *)0x0) {
    (*pcVar1)();
  }
  terminate();
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// Library Function - Single Match
//  void __cdecl terminate(void)
// 
// Library: Visual Studio 2012 Release

void __cdecl terminate(void)

{
  code *pcVar1;
  _ptiddata p_Var2;
  
  p_Var2 = __getptd();
  if ((code *)p_Var2->_terminate != (code *)0x0) {
    (*(code *)p_Var2->_terminate)();
  }
  _abort();
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void FUN_1002cc28(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd();
  if ((code *)p_Var1->_unexpected != (code *)0x0) {
    (*(code *)p_Var1->_unexpected)();
  }
  terminate();
  return;
}



void FUN_1002cc3b(void)

{
  DAT_1083643c = EncodePointer(terminate);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___DestructExceptionObject
// 
// Library: Visual Studio 2012 Release

void __cdecl ___DestructExceptionObject(int *param_1)

{
  byte *pbVar1;
  int *piVar2;
  
  if ((((param_1 != (int *)0x0) && (*param_1 == -0x1f928c9d)) && (param_1[4] == 3)) &&
     ((((param_1[5] == 0x19930520 || (param_1[5] == 0x19930521)) || (param_1[5] == 0x19930522)) &&
      (pbVar1 = (byte *)param_1[7], pbVar1 != (byte *)0x0)))) {
    if (*(undefined **)(pbVar1 + 4) == (undefined *)0x0) {
      if (((*pbVar1 & 0x10) != 0) && (piVar2 = *(int **)param_1[6], piVar2 != (int *)0x0)) {
        (**(code **)(*piVar2 + 8))(piVar2);
      }
    }
    else {
      FID_conflict__CallMemberFunction1(param_1[6],*(undefined **)(pbVar1 + 4));
    }
  }
  return;
}



undefined4 * __thiscall FUN_1002ccd7(void *this,exception *param_1)

{
  std::exception::exception((exception *)this,param_1);
  *(undefined ***)this = std::bad_exception::vftable;
  return (undefined4 *)this;
}



undefined4 * __thiscall FUN_1002ccfd(void *this,byte param_1)

{
  *(undefined ***)this = std::bad_exception::vftable;
  FUN_100253cb((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    FID_conflict__free(this);
  }
  return (undefined4 *)this;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  void * __cdecl CallCatchBlock(struct EHExceptionRecord *,struct EHRegistrationNode *,struct
// _CONTEXT *,struct _s_FuncInfo const *,void *,int,unsigned long)
// 
// Library: Visual Studio 2012 Release

void * __cdecl
CallCatchBlock(EHExceptionRecord *param_1,EHRegistrationNode *param_2,_CONTEXT *param_3,
              _s_FuncInfo *param_4,void *param_5,int param_6,ulong param_7)

{
  _ptiddata p_Var1;
  undefined4 local_44 [2];
  undefined4 local_3c;
  void *local_38;
  void *local_34;
  undefined4 *local_30;
  undefined4 local_2c;
  void *local_20;
  undefined4 uStack12;
  undefined *local_8;
  
  local_8 = &DAT_1003fff0;
  uStack12 = 0x1002cd2e;
  local_20 = param_5;
  local_3c = 0;
  local_2c = *(undefined4 *)(param_2 + -4);
  local_30 = __CreateFrameInfo(local_44,*(undefined4 *)(param_1 + 0x18));
  p_Var1 = __getptd();
  local_34 = p_Var1->_curexception;
  p_Var1 = __getptd();
  local_38 = p_Var1->_curcontext;
  p_Var1 = __getptd();
  p_Var1->_curexception = param_1;
  p_Var1 = __getptd();
  p_Var1->_curcontext = param_3;
  local_8 = (undefined *)0x1;
  local_20 = _CallCatchBlock2(param_2,param_4,param_5,param_6,param_7);
  local_8 = (undefined *)0xfffffffe;
  FUN_1002ce69();
  return param_2;
}



void FUN_1002ce69(void)

{
  _ptiddata p_Var1;
  int iVar2;
  int unaff_EBP;
  int *unaff_ESI;
  int unaff_EDI;
  
  *(undefined4 *)(unaff_EDI + -4) = *(undefined4 *)(unaff_EBP + -0x28);
  __FindAndUnlinkFrame(*(void **)(unaff_EBP + -0x2c));
  p_Var1 = __getptd();
  p_Var1->_curexception = *(void **)(unaff_EBP + -0x30);
  p_Var1 = __getptd();
  p_Var1->_curcontext = *(void **)(unaff_EBP + -0x34);
  if (((((*unaff_ESI == -0x1f928c9d) && (unaff_ESI[4] == 3)) &&
       ((unaff_ESI[5] == 0x19930520 ||
        ((unaff_ESI[5] == 0x19930521 || (unaff_ESI[5] == 0x19930522)))))) &&
      (*(int *)(unaff_EBP + -0x38) == 0)) &&
     ((*(int *)(unaff_EBP + -0x1c) != 0 &&
      (iVar2 = __IsExceptionObjectToBeDestroyed(unaff_ESI[6]), iVar2 != 0)))) {
    ___DestructExceptionObject(unaff_ESI);
  }
  return;
}



// WARNING: Function: __EH_prolog3_catch replaced with injection: EH_prolog3

void FUN_1002cee8(void *param_1)

{
  code *pcVar1;
  _ptiddata p_Var2;
  
  p_Var2 = __getptd();
  if (p_Var2->_curexcspec != (void *)0x0) {
    _inconsistency();
  }
  FUN_1002cc28();
  p_Var2 = __getptd();
  p_Var2->_curexcspec = param_1;
  FUN_1002364d((int *)0x0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void Catch_All_1002cf10(void)

{
  code *pcVar1;
  _ptiddata p_Var2;
  int unaff_EBP;
  
  p_Var2 = __getptd();
  p_Var2->_curexcspec = *(void **)(unaff_EBP + 8);
  FUN_1002364d((int *)0x0,(byte *)0x0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  void __cdecl CatchIt(struct EHExceptionRecord *,struct EHRegistrationNode *,struct _CONTEXT
// *,void *,struct _s_FuncInfo const *,struct _s_HandlerType const *,struct _s_CatchableType const
// *,struct _s_TryBlockMapEntry const *,int,struct EHRegistrationNode *,unsigned char)
// 
// Library: Visual Studio 2015 Release

void __cdecl
CatchIt(EHExceptionRecord *param_1,EHRegistrationNode *param_2,_CONTEXT *param_3,void *param_4,
       _s_FuncInfo *param_5,_s_HandlerType *param_6,_s_CatchableType *param_7,
       _s_TryBlockMapEntry *param_8,int param_9,EHRegistrationNode *param_10,uchar param_11)

{
  void *pvVar1;
  
  if (param_7 != (_s_CatchableType *)0x0) {
    ___BuildCatchObject((int)param_1,(int *)param_2,&param_6->adjectives,(byte *)param_7);
  }
  if (param_10 == (EHRegistrationNode *)0x0) {
    param_10 = param_2;
  }
  _UnwindNestedFrames(param_10,param_1);
  ___FrameUnwindToState((int)param_2,param_4,(int)param_5,param_8->tryLow);
  *(__ehstate_t *)(param_2 + 8) = param_8->tryHigh + 1;
  pvVar1 = CallCatchBlock(param_1,param_2,param_3,param_5,param_6->addressOfHandler,param_9,0x100);
  if (pvVar1 != (void *)0x0) {
    _JumpToContinuation(pvVar1,param_2);
  }
  return;
}



// Library Function - Single Match
//  int __cdecl ExFilterRethrow(struct _EXCEPTION_POINTERS *)
// 
// Library: Visual Studio 2012 Release

int __cdecl ExFilterRethrow(_EXCEPTION_POINTERS *param_1)

{
  PEXCEPTION_RECORD pEVar1;
  _ptiddata p_Var2;
  
  pEVar1 = param_1->ExceptionRecord;
  if ((((pEVar1->ExceptionCode == 0xe06d7363) && (pEVar1->NumberParameters == 3)) &&
      ((pEVar1->ExceptionInformation[0] == 0x19930520 ||
       ((pEVar1->ExceptionInformation[0] == 0x19930521 ||
        (pEVar1->ExceptionInformation[0] == 0x19930522)))))) &&
     (pEVar1->ExceptionInformation[2] == 0)) {
    p_Var2 = __getptd();
    p_Var2->_cxxReThrow = 1;
    return 1;
  }
  return 0;
}



// WARNING: Could not reconcile some variable overlaps

void __cdecl
FUN_1002cff0(_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4,char *param_5,
            char param_6,int param_7,undefined4 *param_8)

{
  code *pcVar1;
  char *pcVar2;
  byte bVar3;
  bool bVar4;
  _ptiddata p_Var5;
  undefined3 extraout_var;
  uint uVar6;
  _s_HandlerType *p_Var7;
  int iVar8;
  _s_HandlerType **pp_Var9;
  _s_HandlerType **pp_Var10;
  undefined4 *puVar11;
  _CONTEXT *p_Var12;
  undefined **local_40 [3];
  _s_CatchableType *local_34;
  _s_TryBlockMapEntry *local_30;
  uint local_2c;
  undefined4 local_28;
  _s_HandlerType *local_24;
  _s_CatchableType **local_20;
  _s_CatchableType *local_1c;
  _s_HandlerType **local_18;
  uint local_14;
  _s_HandlerType *local_10;
  _s_HandlerType *local_c;
  char local_5;
  
  pp_Var9 = (_s_HandlerType **)param_5;
  p_Var12 = param_1;
  iVar8 = 0;
  local_28 = local_28 & 0xffffff00;
  local_5 = '\0';
  if (*(int *)(param_5 + 4) < 0x81) {
    local_c = (_s_HandlerType *)(int)*(char *)(param_2 + 2);
  }
  else {
    local_c = (_s_HandlerType *)param_2[2];
  }
  if (((int)local_c < -1) || (*(int *)(param_5 + 4) <= (int)local_c)) {
    _inconsistency();
  }
  if (param_1->ContextFlags == 0xe06d7363) {
    if (((param_1->Dr3 == 3) &&
        (((param_1->Dr6 == 0x19930520 || (param_1->Dr6 == 0x19930521)) ||
         (param_1->Dr6 == 0x19930522)))) && ((param_1->FloatSave).ControlWord == 0)) {
      p_Var5 = __getptd();
      if (p_Var5->_curexception == (void *)0x0) {
        return;
      }
      p_Var5 = __getptd();
      p_Var12 = (_CONTEXT *)p_Var5->_curexception;
      p_Var5 = __getptd();
      local_28 = CONCAT31(local_28._1_3_,1);
      param_1 = (_CONTEXT *)p_Var5->_curcontext;
      bVar3 = FUN_100325c6((int)p_Var12);
      if (CONCAT31(extraout_var,bVar3) == 0) {
        _inconsistency();
      }
      if ((((p_Var12->ContextFlags == 0xe06d7363) && (p_Var12->Dr3 == 3)) &&
          ((p_Var12->Dr6 == 0x19930520 ||
           ((p_Var12->Dr6 == 0x19930521 || (p_Var12->Dr6 == 0x19930522)))))) &&
         ((p_Var12->FloatSave).ControlWord == 0)) {
        _inconsistency();
      }
      p_Var5 = __getptd();
      if (p_Var5->_curexcspec == (void *)0x0) goto LAB_1002d15c;
      p_Var5 = __getptd();
      local_18 = (_s_HandlerType **)p_Var5->_curexcspec;
      p_Var5 = __getptd();
      p_Var5->_curexcspec = (void *)0x0;
      uVar6 = FUN_1002d4a9((int)p_Var12,(int *)local_18);
      pp_Var10 = local_18;
      if ((char)uVar6 != '\0') goto LAB_1002d15c;
      if (0 < (int)*local_18) {
        param_5 = (char *)0x0;
        do {
          bVar4 = type_info::operator__
                            (*(type_info **)(param_5 + 4 + (int)pp_Var10[1]),
                             (type_info *)&class_std__bad_exception_RTTI_Type_Descriptor);
          if (bVar4) goto LAB_1002d339;
          iVar8 = iVar8 + 1;
          param_5 = param_5 + 0x10;
        } while (iVar8 < (int)*pp_Var10);
      }
      goto LAB_1002d334;
    }
    param_1 = param_3;
LAB_1002d15c:
    param_3 = param_1;
    if (((p_Var12->ContextFlags != 0xe06d7363) || (p_Var12->Dr3 != 3)) ||
       ((p_Var12->Dr6 != 0x19930520 &&
        ((p_Var12->Dr6 != 0x19930521 && (p_Var12->Dr6 != 0x19930522)))))) goto LAB_1002d2f7;
    if ((*(int *)((int)pp_Var9 + 0xc) != 0) &&
       (iVar8 = FUN_100238be((int)pp_Var9,param_7,(int)local_c,&local_14,&local_2c),
       local_14 < local_2c)) {
      local_18 = (_s_HandlerType **)(iVar8 + 0x10);
      p_Var7 = local_c;
      do {
        pcVar2 = param_5;
        local_30 = (_s_TryBlockMapEntry *)(local_18 + -4);
        if ((local_18[-4] == p_Var7 || (int)local_18[-4] < (int)p_Var7) &&
           ((int)p_Var7 <= (int)local_18[-3])) {
          local_10 = *local_18;
          for (local_24 = local_18[-1]; pp_Var9 = (_s_HandlerType **)pcVar2, 0 < (int)local_24;
              local_24 = (_s_HandlerType *)((int)&local_24[-1].addressOfHandler + 3)) {
            local_20 = *(_s_CatchableType ***)((p_Var12->FloatSave).ControlWord + 0xc);
            for (local_1c = *local_20; local_20 = local_20 + 1, 0 < (int)local_1c;
                local_1c = local_1c + -1) {
              local_34 = *local_20;
              iVar8 = FUN_1002d9ae((byte *)local_10,(byte *)local_34,
                                   (byte *)(p_Var12->FloatSave).ControlWord);
              if (iVar8 != 0) {
                local_5 = '\x01';
                CatchIt((EHExceptionRecord *)p_Var12,(EHRegistrationNode *)param_2,param_1,param_4,
                        (_s_FuncInfo *)pcVar2,local_10,local_34,local_30,param_7,
                        (EHRegistrationNode *)param_8,(uchar)local_28);
                p_Var7 = local_c;
                goto LAB_1002d277;
              }
            }
            local_10 = local_10 + 1;
            p_Var7 = local_c;
          }
        }
LAB_1002d277:
        local_14 = local_14 + 1;
        local_18 = local_18 + 5;
      } while (local_14 < local_2c);
    }
    if (param_6 != '\0') {
      ___DestructExceptionObject((int *)p_Var12);
    }
    if ((((local_5 != '\0') || (((uint)*pp_Var9 & 0x1fffffff) < 0x19930521)) ||
        (pp_Var9[7] == (_s_HandlerType *)0x0)) ||
       (uVar6 = FUN_1002d4a9((int)p_Var12,(int *)pp_Var9[7]), (char)uVar6 != '\0'))
    goto LAB_1002d31b;
    __getptd();
    __getptd();
    p_Var5 = __getptd();
    p_Var5->_curexception = p_Var12;
    p_Var5 = __getptd();
    p_Var5->_curcontext = param_1;
    puVar11 = param_2;
    if (param_8 == (undefined4 *)0x0) goto LAB_1002d36e;
  }
  else {
LAB_1002d2f7:
    if (*(int *)((int)pp_Var9 + 0xc) == 0) {
LAB_1002d31b:
      p_Var5 = __getptd();
      if (p_Var5->_curexcspec != (void *)0x0) {
        _inconsistency();
      }
      return;
    }
    pp_Var10 = pp_Var9;
    if (param_6 == '\0') {
      FUN_1002d38d((int *)p_Var12,param_2,param_3,param_4,(_s_FuncInfo *)pp_Var9,(int)local_c,
                   param_7,(EHRegistrationNode *)param_8);
      goto LAB_1002d31b;
    }
LAB_1002d334:
    terminate();
LAB_1002d339:
    ___DestructExceptionObject((int *)p_Var12);
    param_5 = "bad exception";
    std::exception::exception((exception *)local_40,&param_5);
    p_Var12 = (_CONTEXT *)&DAT_100400cc;
    local_40[0] = std::bad_exception::vftable;
    FUN_1002364d((int *)local_40,&DAT_100400cc);
    pp_Var9 = pp_Var10;
  }
  puVar11 = param_8;
LAB_1002d36e:
  _UnwindNestedFrames((EHRegistrationNode *)puVar11,(EHExceptionRecord *)p_Var12);
  ___FrameUnwindToState((int)param_2,param_4,(int)pp_Var9,-1);
  FUN_1002cee8(pp_Var9[7]);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void __cdecl
FUN_1002d38d(int *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4,_s_FuncInfo *param_5,
            int param_6,int param_7,EHRegistrationNode *param_8)

{
  _ptiddata p_Var1;
  PVOID pvVar2;
  int iVar3;
  _s_HandlerType *p_Var4;
  uint uVar5;
  int *piVar6;
  uint local_c;
  uint local_8;
  
  if (*param_1 != -0x7ffffffd) {
    p_Var1 = __getptd();
    if (p_Var1->_translator != (void *)0x0) {
      pvVar2 = EncodePointer((PVOID)0x0);
      p_Var1 = __getptd();
      if ((((p_Var1->_translator != pvVar2) && (*param_1 != -0x1fbcb0b3)) &&
          (*param_1 != -0x1fbcbcae)) &&
         (iVar3 = FUN_100237e7(param_1,param_2,param_3,param_4,param_5,param_7,param_8), iVar3 != 0)
         ) {
        return;
      }
    }
    if (param_5->nTryBlocks == 0) {
      _inconsistency();
    }
    iVar3 = FUN_100238be((int)param_5,param_7,param_6,&local_c,&local_8);
    if (local_c < local_8) {
      piVar6 = (int *)(iVar3 + 0xc);
      uVar5 = local_8;
      do {
        if ((((piVar6[-3] <= param_6) && (param_6 <= piVar6[-2])) &&
            ((iVar3 = *piVar6 * 0x10, *(int *)(piVar6[1] + -0xc + iVar3) == 0 ||
             (uVar5 = local_8, *(char *)(*(int *)(piVar6[1] + -0xc + iVar3) + 8) == '\0')))) &&
           (p_Var4 = (_s_HandlerType *)(iVar3 + piVar6[1] + -0x10),
           (*(byte *)&p_Var4->adjectives & 0x40) == 0)) {
          CatchIt((EHExceptionRecord *)param_1,(EHRegistrationNode *)param_2,param_3,param_4,param_5
                  ,p_Var4,(_s_CatchableType *)0x0,(_s_TryBlockMapEntry *)(piVar6 + -3),param_7,
                  param_8,'\x01');
          uVar5 = local_8;
        }
        local_c = local_c + 1;
        piVar6 = piVar6 + 5;
      } while (local_c < uVar5);
    }
  }
  return;
}



uint __cdecl FUN_1002d4a9(int param_1,int *param_2)

{
  code *pcVar1;
  int *piVar2;
  byte *in_EAX;
  byte *pbVar3;
  byte **ppbVar4;
  uint uVar5;
  int iVar6;
  
  piVar2 = param_2;
  if (param_2 == (int *)0x0) {
    _inconsistency();
    terminate();
    pcVar1 = (code *)swi(3);
    uVar5 = (*pcVar1)();
    return uVar5;
  }
  uVar5 = 0;
  iVar6 = 0;
  if (0 < *param_2) {
    param_2 = (int *)0x0;
    do {
      ppbVar4 = *(byte ***)(*(int *)(param_1 + 0x1c) + 0xc);
      for (pbVar3 = *ppbVar4; in_EAX = pbVar3, 0 < (int)pbVar3; pbVar3 = pbVar3 + -1) {
        ppbVar4 = ppbVar4 + 1;
        in_EAX = (byte *)FUN_1002d9ae((byte *)(piVar2[1] + (int)param_2),*ppbVar4,
                                      *(byte **)(param_1 + 0x1c));
        if (in_EAX != (byte *)0x0) {
          uVar5 = 1;
          break;
        }
      }
      iVar6 = iVar6 + 1;
      param_2 = param_2 + 4;
    } while (iVar6 < *piVar2);
  }
  return (uint)in_EAX & 0xffffff00 | uVar5;
}



// Library Function - Single Match
//  ___AdjustPointer
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl ___AdjustPointer(int param_1,int *param_2)

{
  int iVar1;
  int iVar2;
  
  iVar1 = param_2[1];
  iVar2 = *param_2 + param_1;
  if (-1 < iVar1) {
    iVar2 = iVar2 + *(int *)(*(int *)(iVar1 + param_1) + param_2[2]) + iVar1;
  }
  return iVar2;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___BuildCatchObject
// 
// Library: Visual Studio 2012 Release

void __cdecl ___BuildCatchObject(int param_1,int *param_2,uint *param_3,byte *param_4)

{
  char cVar1;
  undefined3 extraout_var;
  int *piVar2;
  
  piVar2 = param_2;
  if ((*param_3 & 0x80000000) == 0) {
    piVar2 = (int *)((int)param_2 + param_3[2] + 0xc);
  }
  cVar1 = FUN_1002d5e4(param_1,param_2,param_3,param_4);
  if (CONCAT31(extraout_var,cVar1) == 1) {
    ___AdjustPointer(*(int *)(param_1 + 0x18),(int *)(param_4 + 8));
    FID_conflict__CallMemberFunction1(piVar2,*(undefined **)(param_4 + 0x18));
  }
  else if (CONCAT31(extraout_var,cVar1) == 2) {
    ___AdjustPointer(*(int *)(param_1 + 0x18),(int *)(param_4 + 8));
    FID_conflict__CallMemberFunction1(piVar2,*(undefined **)(param_4 + 0x18));
  }
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

char __cdecl FUN_1002d5e4(int param_1,int *param_2,uint *param_3,byte *param_4)

{
  uint uVar1;
  byte bVar2;
  int iVar3;
  undefined3 extraout_var;
  undefined3 extraout_var_00;
  undefined3 extraout_var_01;
  undefined3 extraout_var_02;
  undefined3 extraout_var_03;
  undefined3 extraout_var_04;
  undefined3 extraout_var_05;
  undefined3 extraout_var_06;
  void *_Src;
  undefined3 extraout_var_07;
  undefined3 extraout_var_08;
  undefined3 extraout_var_09;
  size_t _Size;
  
  if (((param_3[1] == 0) || (*(char *)(param_3[1] + 8) == '\0')) ||
     ((param_3[2] == 0 && ((*param_3 & 0x80000000) == 0)))) {
    return '\0';
  }
  uVar1 = *param_3;
  if (-1 < (int)uVar1) {
    param_2 = (int *)((int)param_2 + param_3[2] + 0xc);
  }
  if ((((char)uVar1 < '\0') && ((*param_4 & 0x10) != 0)) && (DAT_10836440 != (code *)0x0)) {
    iVar3 = (*DAT_10836440)();
    bVar2 = FUN_100325c6(iVar3);
    if ((CONCAT31(extraout_var,bVar2) == 0) ||
       (bVar2 = FUN_100325c6((int)param_2), CONCAT31(extraout_var_00,bVar2) == 0))
    goto LAB_1002d782;
  }
  else {
    iVar3 = *(int *)(param_1 + 0x18);
    if ((uVar1 & 8) == 0) {
      if ((*param_4 & 1) == 0) {
        if (*(int *)(param_4 + 0x18) == 0) {
          bVar2 = FUN_100325c6(iVar3);
          if ((CONCAT31(extraout_var_05,bVar2) != 0) &&
             (bVar2 = FUN_100325c6((int)param_2), CONCAT31(extraout_var_06,bVar2) != 0)) {
            _Size = *(size_t *)(param_4 + 0x14);
            _Src = (void *)___AdjustPointer(*(int *)(param_1 + 0x18),(int *)(param_4 + 8));
            FID_conflict__memcpy(param_2,_Src,_Size);
            return '\0';
          }
        }
        else {
          bVar2 = FUN_100325c6(iVar3);
          if (((CONCAT31(extraout_var_07,bVar2) != 0) &&
              (bVar2 = FUN_100325c6((int)param_2), CONCAT31(extraout_var_08,bVar2) != 0)) &&
             (bVar2 = FUN_100325c6(*(int *)(param_4 + 0x18)), CONCAT31(extraout_var_09,bVar2) != 0))
          {
            return ((*param_4 & 4) != 0) + '\x01';
          }
        }
LAB_1002d782:
        _inconsistency();
        return '\0';
      }
      bVar2 = FUN_100325c6(iVar3);
      if ((CONCAT31(extraout_var_03,bVar2) == 0) ||
         (bVar2 = FUN_100325c6((int)param_2), CONCAT31(extraout_var_04,bVar2) == 0))
      goto LAB_1002d782;
      FID_conflict__memcpy(param_2,*(void **)(param_1 + 0x18),*(size_t *)(param_4 + 0x14));
      if (*(int *)(param_4 + 0x14) != 4) {
        return '\0';
      }
      if (*param_2 == 0) {
        return '\0';
      }
      iVar3 = *param_2;
      goto LAB_1002d675;
    }
    bVar2 = FUN_100325c6(iVar3);
    if ((CONCAT31(extraout_var_01,bVar2) == 0) ||
       (bVar2 = FUN_100325c6((int)param_2), CONCAT31(extraout_var_02,bVar2) == 0))
    goto LAB_1002d782;
    iVar3 = *(int *)(param_1 + 0x18);
  }
  *param_2 = iVar3;
LAB_1002d675:
  iVar3 = ___AdjustPointer(iVar3,(int *)(param_4 + 8));
  *param_2 = iVar3;
  return '\0';
}



// Library Function - Single Match
//  ___FrameUnwindFilter
// 
// Library: Visual Studio 2012 Release

_ptiddata __cdecl ___FrameUnwindFilter(int **param_1)

{
  int *piVar1;
  _ptiddata p_Var2;
  
  piVar1 = *param_1;
  if ((*piVar1 == -0x1fbcbcae) || (*piVar1 == -0x1fbcb0b3)) {
    p_Var2 = __getptd();
    if (0 < p_Var2->_ProcessingThrow) {
      p_Var2 = __getptd();
      p_Var2->_ProcessingThrow = p_Var2->_ProcessingThrow + -1;
    }
  }
  else if (*piVar1 == -0x1f928c9d) {
    p_Var2 = __getptd();
    p_Var2->_ProcessingThrow = 0;
    terminate();
    return p_Var2;
  }
  return (_ptiddata)0x0;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3
// Library Function - Single Match
//  ___FrameUnwindToState
// 
// Library: Visual Studio 2012 Release

void __cdecl ___FrameUnwindToState(int param_1,undefined4 param_2,int param_3,int param_4)

{
  _ptiddata p_Var1;
  int iVar2;
  int iVar3;
  
  if (*(int *)(param_3 + 4) < 0x81) {
    iVar2 = (int)*(char *)(param_1 + 8);
  }
  else {
    iVar2 = *(int *)(param_1 + 8);
  }
  p_Var1 = __getptd();
  p_Var1->_ProcessingThrow = p_Var1->_ProcessingThrow + 1;
  while (iVar3 = iVar2, iVar3 != param_4) {
    if ((iVar3 < 0) || (*(int *)(param_3 + 4) <= iVar3)) {
      _inconsistency();
    }
    iVar2 = *(int *)(*(int *)(param_3 + 8) + iVar3 * 8);
    if (*(int *)(*(int *)(param_3 + 8) + 4 + iVar3 * 8) != 0) {
      *(int *)(param_1 + 8) = iVar2;
      __CallSettingFrame_12(*(undefined4 *)(*(int *)(param_3 + 8) + 4 + iVar3 * 8),param_1,0x103);
    }
  }
  FUN_1002d8b3();
  if (iVar3 != param_4) {
    _inconsistency();
  }
  *(int *)(param_1 + 8) = iVar3;
  return;
}



void FUN_1002d8b3(void)

{
  _ptiddata p_Var1;
  
  p_Var1 = __getptd();
  if (0 < p_Var1->_ProcessingThrow) {
    p_Var1 = __getptd();
    p_Var1->_ProcessingThrow = p_Var1->_ProcessingThrow + -1;
  }
  return;
}



undefined4 __cdecl
FUN_1002d8cd(_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4,uint *param_5,
            int param_6,undefined4 *param_7,char param_8)

{
  code *pcVar1;
  _ptiddata p_Var2;
  undefined4 uVar3;
  
  p_Var2 = __getptd();
  if ((((p_Var2->_cxxReThrow != 0) || (param_1->ContextFlags == 0xe06d7363)) ||
      (param_1->ContextFlags == 0x80000026)) ||
     (((*param_5 & 0x1fffffff) < 0x19930522 || ((*(byte *)(param_5 + 8) & 1) == 0)))) {
    if ((*(byte *)&param_1->Dr0 & 0x66) == 0) {
      if ((param_5[3] != 0) || ((0x19930520 < (*param_5 & 0x1fffffff) && (param_5[7] != 0)))) {
        if ((param_1->ContextFlags == 0xe06d7363) &&
           (((2 < param_1->Dr3 && (0x19930522 < param_1->Dr6)) &&
            (pcVar1 = *(code **)((param_1->FloatSave).ControlWord + 8), pcVar1 != (code *)0x0)))) {
          uVar3 = (*pcVar1)(param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8);
          return uVar3;
        }
        FUN_1002cff0(param_1,param_2,param_3,param_4,(char *)param_5,param_8,param_6,param_7);
      }
    }
    else if ((param_5[1] != 0) && (param_6 == 0)) {
      ___FrameUnwindToState((int)param_2,param_4,(int)param_5,-1);
    }
  }
  return 1;
}



undefined4 __cdecl FUN_1002d9ae(byte *param_1,byte *param_2,byte *param_3)

{
  int iVar1;
  undefined4 uVar2;
  
  iVar1 = *(int *)(param_1 + 4);
  if (((iVar1 == 0) || (*(char *)(iVar1 + 8) == '\0')) ||
     (((*param_1 & 0x80) != 0 && ((*param_2 & 0x10) != 0)))) {
LAB_1002da0e:
    uVar2 = 1;
  }
  else {
    if (iVar1 == *(int *)(param_2 + 4)) {
LAB_1002d9ed:
      if ((((*param_2 & 2) == 0) || ((*param_1 & 8) != 0)) &&
         ((((*param_3 & 1) == 0 || ((*param_1 & 1) != 0)) &&
          (((*param_3 & 2) == 0 || ((*param_1 & 2) != 0)))))) goto LAB_1002da0e;
    }
    else {
      iVar1 = _strcmp((char *)(iVar1 + 8),(char *)(*(int *)(param_2 + 4) + 8));
      if (iVar1 == 0) goto LAB_1002d9ed;
    }
    uVar2 = 0;
  }
  return uVar2;
}



// Library Function - Single Match
//  _memcpy_s
// 
// Libraries: Visual Studio 2012, Visual Studio 2015, Visual Studio 2017, Visual Studio 2019

errno_t __cdecl _memcpy_s(void *_Dst,rsize_t _DstSize,void *_Src,rsize_t _MaxCount)

{
  errno_t eVar1;
  int *piVar2;
  
  if (_MaxCount == 0) {
    eVar1 = 0;
  }
  else if (_Dst == (void *)0x0) {
    piVar2 = __errno();
    eVar1 = 0x16;
    *piVar2 = 0x16;
    FUN_10025625();
  }
  else if ((_Src == (void *)0x0) || (_DstSize < _MaxCount)) {
    FUN_10021290((uint *)_Dst,0,_DstSize);
    if (_Src == (void *)0x0) {
      piVar2 = __errno();
      eVar1 = 0x16;
    }
    else {
      if (_MaxCount <= _DstSize) {
        return 0x16;
      }
      piVar2 = __errno();
      eVar1 = 0x22;
    }
    *piVar2 = eVar1;
    FUN_10025625();
  }
  else {
    FID_conflict__memcpy(_Dst,_Src,_MaxCount);
    eVar1 = 0;
  }
  return eVar1;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

uint __cdecl FUN_1002da94(uint param_1,LPWSTR param_2,uint param_3)

{
  ulong *puVar1;
  int *piVar2;
  uint uVar3;
  int iVar4;
  
  if (param_1 == 0xfffffffe) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    return 0xffffffff;
  }
  if (((int)param_1 < 0) || (DAT_10836b84 <= param_1)) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
  }
  else {
    iVar4 = (param_1 & 0x1f) * 0x40;
    if ((*(byte *)((&DAT_10835b98)[(int)param_1 >> 5] + 4 + iVar4) & 1) != 0) {
      if (param_3 < 0x80000000) {
        FUN_100248ff(param_1);
        if ((*(byte *)((&DAT_10835b98)[(int)param_1 >> 5] + 4 + iVar4) & 1) == 0) {
          piVar2 = __errno();
          *piVar2 = 9;
          puVar1 = ___doserrno();
          *puVar1 = 0;
          uVar3 = 0xffffffff;
        }
        else {
          uVar3 = FUN_1002dba8(param_1,param_2,param_3);
        }
        FUN_1002db80();
        return uVar3;
      }
      puVar1 = ___doserrno();
      *puVar1 = 0;
      piVar2 = __errno();
      *piVar2 = 0x16;
      goto LAB_1002db9a;
    }
    puVar1 = ___doserrno();
    *puVar1 = 0;
  }
  piVar2 = __errno();
  *piVar2 = 9;
LAB_1002db9a:
  FUN_10025625();
  return 0xffffffff;
}



void FUN_1002db80(void)

{
  uint unaff_ESI;
  
  FUN_10024dbb(unaff_ESI);
  return;
}



// WARNING: Could not reconcile some variable overlaps

uint __cdecl FUN_1002dba8(uint param_1,LPWSTR param_2,uint param_3)

{
  byte *pbVar1;
  char cVar2;
  undefined uVar3;
  char cVar4;
  byte bVar5;
  WCHAR WVar6;
  ulong *puVar7;
  int *piVar8;
  undefined3 extraout_var;
  BOOL BVar9;
  ulong uVar10;
  DWORD DVar11;
  int iVar12;
  int iVar13;
  uint uVar14;
  uint nNumberOfBytesToRead;
  LPWSTR pWVar15;
  LPWSTR pWVar16;
  uint uVar17;
  LPWSTR pWVar18;
  WCHAR *pWVar19;
  bool bVar20;
  undefined8 uVar21;
  WCHAR *local_24;
  LPWSTR local_20;
  uint local_1c;
  uint local_18;
  LPWSTR local_14;
  int local_10;
  undefined2 local_c;
  char local_5;
  
  uVar17 = 0;
  local_1c = 0xfffffffe;
  local_24 = (WCHAR *)0x0;
  if (param_1 == 0xfffffffe) {
    puVar7 = ___doserrno();
    *puVar7 = 0;
    piVar8 = __errno();
    *piVar8 = 9;
    return 0xffffffff;
  }
  if ((-1 < (int)param_1) && (param_1 < DAT_10836b84)) {
    local_10 = (int)param_1 >> 5;
    iVar13 = (param_1 & 0x1f) * 0x40;
    bVar5 = *(byte *)((&DAT_10835b98)[local_10] + 4 + iVar13);
    if ((bVar5 & 1) != 0) {
      if (param_3 < 0x80000000) {
        if ((param_3 == 0) || ((bVar5 & 2) != 0)) {
          return 0;
        }
        if (param_2 != (LPWSTR)0x0) {
          cVar4 = (char)(*(char *)((&DAT_10835b98)[local_10] + 0x24 + iVar13) * '\x02') >> 1;
          if (cVar4 == '\x01') {
            if ((~param_3 & 1) == 0) goto LAB_1002dc4e;
            uVar14 = param_3 >> 1;
            if (uVar14 < 4) {
              uVar14 = 4;
            }
            local_14 = (LPWSTR)FUN_10026f23(uVar14);
            if (local_14 == (LPWSTR)0x0) {
              piVar8 = __errno();
              *piVar8 = 0xc;
              puVar7 = ___doserrno();
              *puVar7 = 8;
              return 0xffffffff;
            }
            uVar21 = FUN_1002e5cb(param_1,0,0,1);
            iVar12 = (&DAT_10835b98)[local_10];
            *(int *)(iVar12 + 0x28 + iVar13) = (int)uVar21;
            *(int *)(iVar12 + 0x2c + iVar13) = (int)((ulonglong)uVar21 >> 0x20);
          }
          else {
            uVar14 = param_3;
            if (cVar4 == '\x02') {
              if ((~param_3 & 1) == 0) goto LAB_1002dc4e;
              uVar14 = param_3 & 0xfffffffe;
            }
            local_14 = param_2;
          }
          nNumberOfBytesToRead = uVar14;
          local_20 = local_14;
          if ((((*(byte *)((&DAT_10835b98)[local_10] + 4 + iVar13) & 0x48) != 0) &&
              (cVar2 = *(char *)((&DAT_10835b98)[local_10] + 5 + iVar13), cVar2 != '\n')) &&
             (uVar14 != 0)) {
            *(char *)local_14 = cVar2;
            local_20 = (LPWSTR)((int)local_14 + 1);
            uVar17 = 1;
            nNumberOfBytesToRead = uVar14 - 1;
            *(undefined *)((&DAT_10835b98)[local_10] + 5 + iVar13) = 10;
            if (((cVar4 != '\0') &&
                (cVar2 = *(char *)((&DAT_10835b98)[local_10] + 0x25 + iVar13), cVar2 != '\n')) &&
               (nNumberOfBytesToRead != 0)) {
              *(char *)local_20 = cVar2;
              local_20 = local_14 + 1;
              nNumberOfBytesToRead = uVar14 - 2;
              uVar17 = 2;
              *(undefined *)((&DAT_10835b98)[local_10] + 0x25 + iVar13) = 10;
              if (((cVar4 == '\x01') &&
                  (cVar2 = *(char *)((&DAT_10835b98)[local_10] + 0x26 + iVar13), cVar2 != '\n')) &&
                 (nNumberOfBytesToRead != 0)) {
                *(char *)local_20 = cVar2;
                local_20 = (LPWSTR)((int)local_14 + 3);
                nNumberOfBytesToRead = uVar14 - 3;
                uVar17 = 3;
                *(undefined *)((&DAT_10835b98)[local_10] + 0x26 + iVar13) = 10;
              }
            }
          }
          bVar5 = FUN_1003180b(param_1);
          if ((((CONCAT31(extraout_var,bVar5) == 0) ||
               ((*(byte *)((&DAT_10835b98)[local_10] + 4 + iVar13) & 0x80) == 0)) ||
              (local_24 = (WCHAR *)GetConsoleMode(*(HANDLE *)((&DAT_10835b98)[local_10] + iVar13),
                                                  (LPDWORD)&local_24), local_24 == (WCHAR *)0x0)) ||
             (cVar4 != '\x02')) {
            BVar9 = ReadFile(*(HANDLE *)((&DAT_10835b98)[local_10] + iVar13),local_20,
                             nNumberOfBytesToRead,&local_18,(LPOVERLAPPED)0x0);
            if (((BVar9 != 0) && (-1 < (int)local_18)) && (local_18 <= nNumberOfBytesToRead))
            goto LAB_1002de35;
            uVar10 = GetLastError();
            if (uVar10 != 5) {
              if (uVar10 == 0x6d) {
                uVar14 = 0;
                goto LAB_1002e0aa;
              }
              goto LAB_1002dde0;
            }
            piVar8 = __errno();
            *piVar8 = 9;
            puVar7 = ___doserrno();
            *puVar7 = 5;
          }
          else {
            BVar9 = ReadConsoleW(*(HANDLE *)((&DAT_10835b98)[local_10] + iVar13),local_20,
                                 nNumberOfBytesToRead >> 1,&local_18,
                                 (PCONSOLE_READCONSOLE_CONTROL)0x0);
            if (BVar9 != 0) {
              local_18 = local_18 * 2;
LAB_1002de35:
              uVar17 = uVar17 + local_18;
              iVar12 = (&DAT_10835b98)[local_10];
              bVar5 = *(byte *)(iVar12 + 4 + iVar13);
              uVar14 = local_1c;
              if (-1 < (char)bVar5) goto LAB_1002e0aa;
              if (cVar4 == '\x02') {
                if (local_24 == (WCHAR *)0x0) {
                  if ((local_18 == 0) || (*local_14 != L'\n')) {
                    bVar5 = bVar5 & 0xfb;
                  }
                  else {
                    bVar5 = bVar5 | 4;
                  }
                  *(byte *)(iVar12 + 4 + iVar13) = bVar5;
                  local_24 = (WCHAR *)((int)local_14 + uVar17);
                  iVar12 = local_10;
                  pWVar15 = local_14;
                  pWVar19 = local_14;
                  if (local_14 < local_24) {
                    do {
                      WVar6 = *pWVar19;
                      if (WVar6 == L'\x1a') {
                        bVar5 = *(byte *)((&DAT_10835b98)[iVar12] + 4 + iVar13);
                        if ((bVar5 & 0x40) == 0) {
                          *(byte *)((&DAT_10835b98)[iVar12] + 4 + iVar13) = bVar5 | 2;
                        }
                        else {
                          *pWVar15 = *pWVar19;
                          pWVar15 = pWVar15 + 1;
                        }
                        break;
                      }
                      if (WVar6 == L'\r') {
                        if (pWVar19 < local_24 + -1) {
                          if (pWVar19[1] != L'\n') {
                            *pWVar15 = L'\r';
                            iVar12 = local_10;
                            goto LAB_1002e1bf;
                          }
                          pWVar19 = pWVar19 + 2;
                          *pWVar15 = L'\n';
LAB_1002e2a1:
                          pWVar15 = pWVar15 + 1;
                          iVar12 = local_10;
                        }
                        else {
                          pWVar19 = pWVar19 + 1;
                          BVar9 = ReadFile(*(HANDLE *)((&DAT_10835b98)[iVar12] + iVar13),&local_c,2,
                                           &local_18,(LPOVERLAPPED)0x0);
                          if (((BVar9 == 0) && (DVar11 = GetLastError(), DVar11 != 0)) ||
                             (local_18 == 0)) {
                            *pWVar15 = L'\r';
                            pWVar15 = pWVar15 + 1;
                            iVar12 = local_10;
                          }
                          else {
                            iVar12 = local_10;
                            if ((*(byte *)((&DAT_10835b98)[local_10] + 4 + iVar13) & 0x48) == 0) {
                              if ((pWVar15 == local_14) && (local_c == 10)) {
                                *pWVar15 = L'\n';
                                pWVar15 = pWVar15 + 1;
                              }
                              else {
                                FUN_1002e5cb(param_1,0xfffffffe,0xffffffff,1);
                                iVar12 = local_10;
                                if (local_c != 10) {
                                  *pWVar15 = L'\r';
                                  goto LAB_1002e2a1;
                                }
                              }
                            }
                            else if (local_c == 10) {
                              *pWVar15 = L'\n';
                              pWVar15 = pWVar15 + 1;
                            }
                            else {
                              *pWVar15 = L'\r';
                              pWVar15 = pWVar15 + 1;
                              *(undefined *)((&DAT_10835b98)[local_10] + 5 + iVar13) =
                                   (undefined)local_c;
                              *(undefined *)((&DAT_10835b98)[local_10] + 0x25 + iVar13) =
                                   local_c._1_1_;
                              *(undefined *)((&DAT_10835b98)[local_10] + 0x26 + iVar13) = 10;
                            }
                          }
                        }
                      }
                      else {
                        *pWVar15 = WVar6;
LAB_1002e1bf:
                        pWVar15 = pWVar15 + 1;
                        pWVar19 = pWVar19 + 1;
                      }
                    } while (pWVar19 < local_24);
                  }
                  uVar17 = (int)pWVar15 - (int)local_14;
                  uVar14 = local_1c;
                }
                else {
                  pWVar15 = local_14;
                  pWVar19 = local_14;
                  while (pWVar15 < local_14 + (int)uVar17 / 2) {
                    WVar6 = *pWVar15;
                    if (WVar6 == L'\x1a') {
                      pbVar1 = (byte *)((&DAT_10835b98)[local_10] + 4 + iVar13);
                      *pbVar1 = *pbVar1 | 2;
                      break;
                    }
                    if (WVar6 == L'\r') {
                      if (pWVar15 < local_14 + (int)uVar17 / 2 + -1) {
                        pWVar15 = pWVar15 + 1;
                        WVar6 = L'\n';
                        if (*pWVar15 != L'\n') {
                          WVar6 = L'\r';
                        }
                        *pWVar19 = WVar6;
                        pWVar19 = pWVar19 + 1;
                      }
                    }
                    else {
                      *pWVar19 = WVar6;
                      pWVar19 = pWVar19 + 1;
                      pWVar15 = pWVar15 + 1;
                    }
                  }
                  uVar17 = (int)pWVar19 - (int)local_14 & 0xfffffffe;
                }
                goto LAB_1002e0aa;
              }
              if ((local_18 == 0) || (*(char *)local_14 != '\n')) {
                bVar5 = bVar5 & 0xfb;
              }
              else {
                bVar5 = bVar5 | 4;
              }
              *(byte *)(iVar12 + 4 + iVar13) = bVar5;
              local_24 = local_14;
              local_20 = (LPWSTR)((int)local_14 + uVar17);
              iVar12 = local_10;
              pWVar15 = local_14;
              pWVar16 = local_14;
              if (local_14 < local_20) {
                do {
                  cVar2 = *(char *)pWVar16;
                  if (cVar2 == '\x1a') {
                    bVar5 = *(byte *)((&DAT_10835b98)[iVar12] + 4 + iVar13);
                    if ((bVar5 & 0x40) == 0) {
                      *(byte *)((&DAT_10835b98)[iVar12] + 4 + iVar13) = bVar5 | 2;
                    }
                    else {
                      *(undefined *)pWVar15 = *(undefined *)pWVar16;
                      pWVar15 = (LPWSTR)((int)pWVar15 + 1);
                    }
                    break;
                  }
                  if (cVar2 == '\r') {
                    if (pWVar16 < (LPWSTR)((int)local_20 + -1)) {
                      pWVar18 = (LPWSTR)((int)pWVar16 + 1);
                      if (*(char *)pWVar18 == '\n') {
                        pWVar18 = pWVar16 + 1;
                        *(undefined *)pWVar15 = 10;
LAB_1002df67:
                        pWVar15 = (LPWSTR)((int)pWVar15 + 1);
                      }
                      else {
                        *(undefined *)pWVar15 = 0xd;
                        pWVar15 = (LPWSTR)((int)pWVar15 + 1);
                      }
                    }
                    else {
                      pWVar18 = (LPWSTR)((int)pWVar16 + 1);
                      BVar9 = ReadFile(*(HANDLE *)((&DAT_10835b98)[iVar12] + iVar13),&local_5,1,
                                       &local_18,(LPOVERLAPPED)0x0);
                      if (((BVar9 == 0) && (DVar11 = GetLastError(), DVar11 != 0)) ||
                         (local_18 == 0)) {
                        *(undefined *)pWVar15 = 0xd;
                        pWVar15 = (LPWSTR)((int)pWVar15 + 1);
                        iVar12 = local_10;
                      }
                      else {
                        iVar12 = local_10;
                        if ((*(byte *)((&DAT_10835b98)[local_10] + 4 + iVar13) & 0x48) == 0) {
                          if ((pWVar15 == local_14) && (local_5 == '\n')) {
                            *(undefined *)pWVar15 = 10;
                            pWVar15 = (LPWSTR)((int)pWVar15 + 1);
                          }
                          else {
                            FUN_1002e5cb(param_1,0xffffffff,0xffffffff,1);
                            iVar12 = local_10;
                            if (local_5 != '\n') {
                              *(undefined *)pWVar15 = 0xd;
                              goto LAB_1002df67;
                            }
                          }
                        }
                        else if (local_5 == '\n') {
                          *(undefined *)pWVar15 = 10;
                          pWVar15 = (LPWSTR)((int)pWVar15 + 1);
                        }
                        else {
                          *(undefined *)pWVar15 = 0xd;
                          pWVar15 = (LPWSTR)((int)pWVar15 + 1);
                          *(char *)((&DAT_10835b98)[local_10] + 5 + iVar13) = local_5;
                        }
                      }
                    }
                  }
                  else {
                    *(char *)pWVar15 = cVar2;
                    pWVar15 = (LPWSTR)((int)pWVar15 + 1);
                    pWVar18 = (LPWSTR)((int)pWVar16 + 1);
                  }
                  pWVar16 = pWVar18;
                } while (pWVar18 < local_20);
              }
              uVar17 = (int)pWVar15 - (int)local_14;
              uVar14 = local_1c;
              if ((cVar4 != '\x01') || (uVar17 == 0)) goto LAB_1002e0aa;
              bVar5 = *(byte *)(LPWSTR)((int)pWVar15 + -1);
              if ((char)bVar5 < '\0') {
                iVar12 = 1;
                cVar4 = (&DAT_10047570)[bVar5];
                pWVar15 = (LPWSTR)((int)pWVar15 + -1);
                while (((cVar4 == '\0' && (iVar12 < 5)) && (local_14 <= pWVar15))) {
                  pWVar15 = (LPWSTR)((int)pWVar15 + -1);
                  iVar12 = iVar12 + 1;
                  cVar4 = (&DAT_10047570)[*(byte *)pWVar15];
                }
                if ((char)(&DAT_10047570)[*(byte *)pWVar15] == 0) {
                  piVar8 = __errno();
                  *piVar8 = 0x2a;
                  goto LAB_1002dde7;
                }
                if ((char)(&DAT_10047570)[*(byte *)pWVar15] + 1 == iVar12) {
                  pWVar15 = (LPWSTR)((int)pWVar15 + iVar12);
                }
                else if ((*(byte *)((&DAT_10835b98)[local_10] + 4 + iVar13) & 0x48) == 0) {
                  FUN_1002e5cb(param_1,-iVar12,-iVar12 >> 0x1f,1);
                }
                else {
                  pWVar16 = (LPWSTR)((int)pWVar15 + 1);
                  *(undefined *)((&DAT_10835b98)[local_10] + 5 + iVar13) = *(undefined *)pWVar15;
                  if (1 < iVar12) {
                    uVar3 = *(undefined *)pWVar16;
                    pWVar16 = pWVar15 + 1;
                    *(undefined *)((&DAT_10835b98)[local_10] + 0x25 + iVar13) = uVar3;
                  }
                  if (iVar12 == 3) {
                    uVar3 = *(undefined *)pWVar16;
                    pWVar16 = (LPWSTR)((int)pWVar16 + 1);
                    *(undefined *)((&DAT_10835b98)[local_10] + 0x26 + iVar13) = uVar3;
                  }
                  pWVar15 = (LPWSTR)((int)pWVar16 - iVar12);
                }
              }
              uVar14 = (int)pWVar15 - (int)local_14;
              uVar17 = MultiByteToWideChar(0xfde9,0,(LPCSTR)local_14,uVar14,param_2,param_3 >> 1);
              if (uVar17 != 0) {
                bVar20 = uVar17 != uVar14;
                uVar17 = uVar17 * 2;
                *(uint *)((&DAT_10835b98)[local_10] + 0x30 + iVar13) = (uint)bVar20;
                uVar14 = local_1c;
                goto LAB_1002e0aa;
              }
            }
            uVar10 = GetLastError();
LAB_1002dde0:
            FID_conflict___dosmaperr(uVar10);
          }
LAB_1002dde7:
          uVar14 = 0xffffffff;
LAB_1002e0aa:
          if (local_14 != param_2) {
            FID_conflict__free(local_14);
          }
          if (uVar14 != 0xfffffffe) {
            return uVar14;
          }
          return uVar17;
        }
LAB_1002dc4e:
        puVar7 = ___doserrno();
        *puVar7 = 0;
      }
      else {
        puVar7 = ___doserrno();
        *puVar7 = 0;
      }
      piVar8 = __errno();
      *piVar8 = 0x16;
      goto LAB_1002e32a;
    }
  }
  puVar7 = ___doserrno();
  *puVar7 = 0;
  piVar8 = __errno();
  *piVar8 = 9;
LAB_1002e32a:
  FUN_10025625();
  return 0xffffffff;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

undefined4 __cdecl FUN_1002e339(uint param_1,int param_2,DWORD param_3)

{
  ulong *puVar1;
  int *piVar2;
  undefined4 uVar3;
  int iVar4;
  
  if (param_1 == 0xfffffffe) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if (((int)param_1 < 0) || (DAT_10836b84 <= param_1)) {
      puVar1 = ___doserrno();
      *puVar1 = 0;
    }
    else {
      iVar4 = (param_1 & 0x1f) * 0x40;
      if ((*(byte *)((&DAT_10835b98)[(int)param_1 >> 5] + 4 + iVar4) & 1) != 0) {
        FUN_100248ff(param_1);
        if ((*(byte *)((&DAT_10835b98)[(int)param_1 >> 5] + 4 + iVar4) & 1) == 0) {
          piVar2 = __errno();
          *piVar2 = 9;
          puVar1 = ___doserrno();
          *puVar1 = 0;
          uVar3 = 0xffffffff;
        }
        else {
          uVar3 = FUN_1002e428(param_1,param_2,param_3);
        }
        FUN_1002e400();
        return uVar3;
      }
      puVar1 = ___doserrno();
      *puVar1 = 0;
    }
    piVar2 = __errno();
    *piVar2 = 9;
    FUN_10025625();
  }
  return 0xffffffff;
}



void FUN_1002e400(void)

{
  uint unaff_ESI;
  
  FUN_10024dbb(unaff_ESI);
  return;
}



undefined4 __cdecl FUN_1002e428(uint param_1,int param_2,DWORD param_3)

{
  byte *pbVar1;
  HANDLE hFile;
  int *piVar2;
  BOOL BVar3;
  DWORD DVar4;
  undefined4 local_14;
  int local_10;
  undefined4 local_c;
  undefined4 local_8;
  
  hFile = (HANDLE)FUN_10024bbc(param_1);
  if (hFile == (HANDLE)0xffffffff) {
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    BVar3 = SetFilePointerEx(hFile,0,(PLARGE_INTEGER)&local_c,1);
    if ((BVar3 == 0) ||
       (BVar3 = SetFilePointerEx(hFile,(longlong)param_2,(PLARGE_INTEGER)&local_14,param_3),
       BVar3 == 0)) {
      DVar4 = GetLastError();
      FID_conflict___dosmaperr(DVar4);
    }
    else {
      if (local_10 == 0) {
        pbVar1 = (byte *)((&DAT_10835b98)[(int)param_1 >> 5] + 4 + (param_1 & 0x1f) * 0x40);
        *pbVar1 = *pbVar1 & 0xfd;
        return local_14;
      }
      SetFilePointerEx(hFile,CONCAT44(local_8,local_c),(PLARGE_INTEGER)0x0,0);
      piVar2 = __errno();
      *piVar2 = 0x16;
    }
  }
  return 0xffffffff;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

undefined8 __cdecl FUN_1002e4cf(uint param_1,undefined4 param_2,undefined4 param_3,DWORD param_4)

{
  ulong *puVar1;
  int *piVar2;
  int iVar3;
  undefined8 uVar4;
  
  if (param_1 == 0xfffffffe) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if ((-1 < (int)param_1) && (param_1 < DAT_10836b84)) {
      iVar3 = (param_1 & 0x1f) * 0x40;
      if ((*(byte *)((&DAT_10835b98)[(int)param_1 >> 5] + 4 + iVar3) & 1) != 0) {
        FUN_100248ff(param_1);
        if ((*(byte *)((&DAT_10835b98)[(int)param_1 >> 5] + 4 + iVar3) & 1) == 0) {
          piVar2 = __errno();
          *piVar2 = 9;
          puVar1 = ___doserrno();
          *puVar1 = 0;
          uVar4 = 0xffffffffffffffff;
        }
        else {
          uVar4 = FUN_1002e5cb(param_1,param_2,param_3,param_4);
        }
        FUN_1002e5a1();
        return uVar4;
      }
    }
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
    FUN_10025625();
  }
  return 0xffffffffffffffff;
}



void FUN_1002e5a1(void)

{
  uint unaff_EDI;
  
  FUN_10024dbb(unaff_EDI);
  return;
}



undefined8 __cdecl FUN_1002e5cb(uint param_1,undefined4 param_2,undefined4 param_3,DWORD param_4)

{
  byte *pbVar1;
  HANDLE hFile;
  int *piVar2;
  BOOL BVar3;
  DWORD DVar4;
  undefined4 local_c;
  undefined4 local_8;
  
  hFile = (HANDLE)FUN_10024bbc(param_1);
  if (hFile == (HANDLE)0xffffffff) {
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    BVar3 = SetFilePointerEx(hFile,CONCAT44(param_3,param_2),(PLARGE_INTEGER)&local_c,param_4);
    if (BVar3 != 0) {
      pbVar1 = (byte *)((&DAT_10835b98)[(int)param_1 >> 5] + 4 + (param_1 & 0x1f) * 0x40);
      *pbVar1 = *pbVar1 & 0xfd;
      goto LAB_1002e638;
    }
    DVar4 = GetLastError();
    FID_conflict___dosmaperr(DVar4);
  }
  local_c = 0xffffffff;
  local_8 = 0xffffffff;
LAB_1002e638:
  return CONCAT44(local_8,local_c);
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

undefined4 __cdecl FUN_1002e63e(WCHAR *param_1,WCHAR *param_2,uint param_3)

{
  ulong *puVar1;
  int *piVar2;
  undefined4 uVar3;
  int iVar4;
  
  if (param_1 == (WCHAR *)0xfffffffe) {
    puVar1 = ___doserrno();
    *puVar1 = 0;
    piVar2 = __errno();
    *piVar2 = 9;
  }
  else {
    if (((int)param_1 < 0) || (DAT_10836b84 <= param_1)) {
      puVar1 = ___doserrno();
      *puVar1 = 0;
    }
    else {
      iVar4 = ((uint)param_1 & 0x1f) * 0x40;
      if ((*(byte *)((&DAT_10835b98)[(int)param_1 >> 5] + 4 + iVar4) & 1) != 0) {
        FUN_100248ff((uint)param_1);
        if ((*(byte *)((&DAT_10835b98)[(int)param_1 >> 5] + 4 + iVar4) & 1) == 0) {
          piVar2 = __errno();
          *piVar2 = 9;
          puVar1 = ___doserrno();
          *puVar1 = 0;
          uVar3 = 0xffffffff;
        }
        else {
          uVar3 = FUN_1002e72d(param_1,param_2,param_3);
        }
        FUN_1002e705();
        return uVar3;
      }
      puVar1 = ___doserrno();
      *puVar1 = 0;
    }
    piVar2 = __errno();
    *piVar2 = 9;
    FUN_10025625();
  }
  return 0xffffffff;
}



void FUN_1002e705(void)

{
  uint unaff_ESI;
  
  FUN_10024dbb(unaff_ESI);
  return;
}



// WARNING: Function: __alloca_probe replaced with injection: alloca_probe

void __cdecl FUN_1002e72d(WCHAR *param_1,WCHAR *param_2,uint param_3)

{
  char cVar1;
  WCHAR WVar2;
  byte bVar3;
  wint_t wVar4;
  ulong *puVar5;
  int *piVar6;
  undefined3 extraout_var;
  _ptiddata p_Var7;
  BOOL BVar8;
  int iVar9;
  uint uVar10;
  DWORD DVar11;
  undefined in_DL;
  undefined extraout_DL;
  WCHAR *extraout_EDX;
  WCHAR *pWVar12;
  WCHAR *extraout_EDX_00;
  WCHAR *extraout_EDX_01;
  WCHAR *extraout_EDX_02;
  WCHAR *extraout_EDX_03;
  WCHAR *extraout_EDX_04;
  WCHAR *extraout_EDX_05;
  WCHAR *extraout_EDX_06;
  WCHAR *extraout_EDX_07;
  WCHAR *extraout_EDX_08;
  WCHAR *extraout_EDX_09;
  WCHAR *extraout_EDX_10;
  WCHAR *extraout_EDX_11;
  char cVar13;
  WCHAR *pWVar14;
  WCHAR *pWVar15;
  DWORD DVar16;
  WCHAR *pWVar17;
  undefined8 uVar18;
  uint uVar19;
  undefined uVar20;
  UINT in_stack_ffffe50c;
  uint local_1aec;
  char local_1ae5;
  WCHAR *local_1ae4;
  WCHAR *local_1ae0;
  int local_1adc;
  WCHAR *local_1ad8;
  WCHAR *local_1ad4;
  DWORD local_1ad0;
  WCHAR *local_1acc;
  WCHAR *local_1ac8;
  WCHAR *local_1ac4;
  int local_1ac0;
  WCHAR local_1abc [854];
  WCHAR local_1410 [852];
  CHAR local_d68 [3416];
  char local_10;
  char local_f;
  uint local_8;
  
  uVar20 = (undefined)in_stack_ffffe50c;
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  local_1ac0 = 0;
  pWVar15 = (WCHAR *)0x0;
  local_1acc = param_1;
  DVar16 = 0;
  local_1ad4 = param_2;
  local_1ac4 = (WCHAR *)0x0;
  if (param_3 == 0) goto LAB_1002ef82;
  if (param_2 == (WCHAR *)0x0) {
    puVar5 = ___doserrno();
    *puVar5 = 0;
    piVar6 = __errno();
    *piVar6 = 0x16;
    FUN_10025625();
    in_DL = extraout_DL;
    goto LAB_1002ef82;
  }
  local_1adc = (int)param_1 >> 5;
  local_1ae0 = (WCHAR *)(((uint)param_1 & 0x1f) * 0x40);
  cVar13 = (char)(*(char *)((int)local_1ae0 + (&DAT_10835b98)[local_1adc] + 0x24) * '\x02') >> 1;
  if (((cVar13 == '\x02') || (cVar13 == '\x01')) && ((~param_3 & 1) == 0)) {
    puVar5 = ___doserrno();
    *puVar5 = 0;
    piVar6 = __errno();
    *piVar6 = 0x16;
    FUN_10025625();
    pWVar12 = extraout_EDX;
  }
  else {
    if ((*(byte *)((int)local_1ae0 + (&DAT_10835b98)[local_1adc] + 4) & 0x20) != 0) {
      FUN_1002e5cb((uint)param_1,0,0,2);
    }
    bVar3 = FUN_1003180b((uint)local_1acc);
    if ((CONCAT31(extraout_var,bVar3) == 0) ||
       ((*(byte *)((int)local_1ae0 + (&DAT_10835b98)[local_1adc] + 4) & 0x80) == 0)) {
LAB_1002eb70:
      if ((*(byte *)((int)local_1ae0 + (&DAT_10835b98)[local_1adc] + 4) & 0x80) == 0) {
        BVar8 = WriteFile(*(HANDLE *)((int)local_1ae0 + (&DAT_10835b98)[local_1adc]),local_1ad4,
                          param_3,(LPDWORD)&local_1ae4,(LPOVERLAPPED)0x0);
        if (BVar8 == 0) {
LAB_1002eb63:
          DVar16 = GetLastError();
          pWVar12 = extraout_EDX_03;
        }
        else {
          pWVar12 = extraout_EDX_09;
          pWVar15 = local_1ae4;
          DVar16 = 0;
        }
        goto LAB_1002ec80;
      }
      local_1ad0 = 0;
      if (cVar13 == '\0') {
        local_1acc = local_1ad4;
        if (param_3 == 0) goto LAB_1002ef42;
        do {
          pWVar17 = local_1410;
          local_1ac8 = (WCHAR *)0x0;
          uVar19 = (int)local_1acc - (int)local_1ad4;
          do {
            if (param_3 <= uVar19) break;
            local_1ae5 = *(char *)local_1acc;
            local_1acc = (WCHAR *)((int)local_1acc + 1);
            uVar19 = uVar19 + 1;
            if (local_1ae5 == '\n') {
              local_1ac0 = local_1ac0 + 1;
              *(char *)pWVar17 = '\r';
              pWVar17 = (WCHAR *)((int)pWVar17 + 1);
              local_1ac8 = (WCHAR *)((int)local_1ac8 + 1);
            }
            *(char *)pWVar17 = local_1ae5;
            pWVar17 = (WCHAR *)((int)pWVar17 + 1);
            local_1ac8 = (WCHAR *)((int)local_1ac8 + 1);
          } while (local_1ac8 < (WCHAR *)0x13ff);
          BVar8 = WriteFile(*(HANDLE *)((int)local_1ae0 + (&DAT_10835b98)[local_1adc]),local_1410,
                            (int)pWVar17 - (int)local_1410,(LPDWORD)&local_1ae4,(LPOVERLAPPED)0x0);
          if (BVar8 == 0) goto LAB_1002eb63;
          pWVar15 = (WCHAR *)((int)pWVar15 + (int)local_1ae4);
          pWVar12 = extraout_EDX_04;
          DVar16 = local_1ad0;
        } while (((int)pWVar17 - (int)local_1410 <= (int)local_1ae4) &&
                (pWVar12 = local_1acc, (uint)((int)local_1acc - (int)local_1ad4) < param_3));
        goto LAB_1002ec80;
      }
      if (cVar13 == '\x02') {
        pWVar17 = local_1ad4;
        if (param_3 != 0) {
          do {
            local_1aec = 0;
            pWVar14 = local_1410;
            uVar10 = (int)pWVar17 - (int)local_1ad4;
            uVar19 = 0;
            do {
              if (param_3 <= uVar10) break;
              WVar2 = *pWVar17;
              uVar10 = uVar10 + 2;
              pWVar17 = pWVar17 + 1;
              if (WVar2 == L'\n') {
                local_1ac0 = local_1ac0 + 2;
                *pWVar14 = L'\r';
                pWVar14 = pWVar14 + 1;
                uVar19 = uVar19 + 2;
              }
              *pWVar14 = WVar2;
              uVar19 = uVar19 + 2;
              pWVar14 = pWVar14 + 1;
            } while (uVar19 < 0x13fe);
            local_1ac8 = pWVar17;
            BVar8 = WriteFile(*(HANDLE *)((int)local_1ae0 + (&DAT_10835b98)[local_1adc]),local_1410,
                              (int)pWVar14 - (int)local_1410,(LPDWORD)&local_1ae4,(LPOVERLAPPED)0x0)
            ;
            pWVar15 = local_1ac4;
            if (BVar8 == 0) goto LAB_1002eb63;
            pWVar15 = (WCHAR *)((int)local_1ac4 + (int)local_1ae4);
            pWVar12 = extraout_EDX_06;
            DVar16 = local_1ad0;
            local_1ac4 = pWVar15;
          } while (((int)pWVar14 - (int)local_1410 <= (int)local_1ae4) &&
                  (pWVar17 = local_1ac8, pWVar12 = local_1ad4,
                  (uint)((int)local_1ac8 - (int)local_1ad4) < param_3));
          goto LAB_1002ec80;
        }
      }
      else {
        local_1acc = local_1ad4;
        if (param_3 != 0) {
          do {
            local_1aec = 0;
            pWVar15 = local_1abc;
            uVar10 = (int)local_1acc - (int)local_1ad4;
            uVar19 = 0;
            do {
              if (param_3 <= uVar10) break;
              WVar2 = *local_1acc;
              uVar10 = uVar10 + 2;
              local_1acc = local_1acc + 1;
              if (WVar2 == L'\n') {
                *pWVar15 = L'\r';
                pWVar15 = pWVar15 + 1;
                uVar19 = uVar19 + 2;
              }
              *pWVar15 = WVar2;
              uVar19 = uVar19 + 2;
              pWVar15 = pWVar15 + 1;
            } while (uVar19 < 0x6a8);
            local_1ac8 = (WCHAR *)WideCharToMultiByte(0xfde9,0,local_1abc,
                                                      ((int)pWVar15 - (int)local_1abc) / 2,local_d68
                                                      ,0xd55,(LPCSTR)0x0,(LPBOOL)0x0);
            pWVar15 = local_1ac4;
            DVar16 = local_1ad0;
            if (local_1ac8 == (WCHAR *)0x0) goto LAB_1002eb63;
            local_1ac4 = (WCHAR *)0x0;
            do {
              BVar8 = WriteFile(*(HANDLE *)((int)local_1ae0 + (&DAT_10835b98)[local_1adc]),
                                local_d68 + (int)local_1ac4,(int)local_1ac8 - (int)local_1ac4,
                                (LPDWORD)&local_1ae4,(LPOVERLAPPED)0x0);
              if (BVar8 == 0) {
                DVar16 = GetLastError();
                pWVar12 = extraout_EDX_08;
                local_1ad0 = DVar16;
                break;
              }
              local_1ac4 = (WCHAR *)((int)local_1ac4 + (int)local_1ae4);
              pWVar12 = extraout_EDX_07;
            } while ((int)local_1ac4 < (int)local_1ac8);
          } while (((int)local_1ac8 <= (int)local_1ac4) &&
                  (pWVar15 = (WCHAR *)((int)local_1acc - (int)local_1ad4), pWVar12 = local_1ad4,
                  local_1ac4 = pWVar15, pWVar15 < param_3));
          goto LAB_1002ec80;
        }
      }
LAB_1002ef42:
      uVar20 = (undefined)in_stack_ffffe50c;
      if (((*(byte *)((int)local_1ae0 + (&DAT_10835b98)[local_1adc] + 4) & 0x40) == 0) ||
         (pWVar12 = local_1ad4, *(char *)local_1ad4 != '\x1a')) {
        piVar6 = __errno();
        *piVar6 = 0x1c;
        puVar5 = ___doserrno();
        *puVar5 = 0;
        pWVar12 = extraout_EDX_11;
      }
    }
    else {
      p_Var7 = __getptd();
      local_1ac8 = (WCHAR *)(uint)(p_Var7->ptlocinfo->locale_name[2] == (wchar_t *)0x0);
      BVar8 = GetConsoleMode(*(HANDLE *)((int)local_1ae0 + (&DAT_10835b98)[local_1adc]),&local_1aec)
      ;
      if ((BVar8 == 0) || ((local_1ac8 != (WCHAR *)0x0 && (cVar13 == '\0')))) goto LAB_1002eb70;
      in_stack_ffffe50c = GetConsoleCP();
      DVar11 = 0;
      local_1acc = (WCHAR *)0x0;
      local_1ad0 = 0;
      local_1ad8 = local_1ad4;
      if (param_3 == 0) goto LAB_1002ef42;
      pWVar12 = (WCHAR *)0x0;
      local_1ac4 = (WCHAR *)0x0;
      pWVar17 = local_1ad4;
      pWVar14 = pWVar15;
      do {
        local_1ac8 = (WCHAR *)0x0;
        pWVar15 = pWVar14;
        if (cVar13 == '\0') {
          cVar1 = *(char *)pWVar17;
          local_1aec = (uint)(cVar1 == '\n');
          local_1ac8 = (WCHAR *)(&DAT_10835b98)[local_1adc];
          if (*(int *)((int)(local_1ae0 + 0x1c) + (int)local_1ac8) == 0) {
            iVar9 = FUN_1002974f((int)cVar1);
            if (iVar9 == 0) {
              uVar19 = 1;
              pWVar12 = local_1ad8;
              goto LAB_1002e98c;
            }
            if ((char *)((int)local_1ad4 + (param_3 - (int)local_1ad8)) < (char *)0x2) {
              *(char *)((int)local_1ae0 + (&DAT_10835b98)[local_1adc] + 0x34) = *(char *)local_1ad8;
              *(undefined4 *)((int)local_1ae0 + (&DAT_10835b98)[local_1adc] + 0x38) = 1;
              pWVar12 = local_1ae0;
              pWVar15 = (WCHAR *)((int)pWVar14 + 1);
              break;
            }
            uVar18 = FUN_10032700((LPWSTR)&local_1ad0,(byte *)local_1ad8,2);
            pWVar12 = (WCHAR *)((ulonglong)uVar18 >> 0x20);
            if ((int)uVar18 == -1) break;
            local_1ad8 = (WCHAR *)((int)local_1ad8 + 1);
            local_1ac4 = (WCHAR *)((int)local_1ac4 + 1);
          }
          else {
            local_10 = *(char *)((int)(local_1ae0 + 0x1a) + (int)local_1ac8);
            uVar19 = 2;
            *(undefined4 *)((int)(local_1ae0 + 0x1c) + (int)local_1ac8) = 0;
            pWVar12 = (WCHAR *)&local_10;
            local_f = cVar1;
LAB_1002e98c:
            uVar18 = FUN_10032700((LPWSTR)&local_1ad0,(byte *)pWVar12,uVar19);
            pWVar12 = (WCHAR *)((ulonglong)uVar18 >> 0x20);
            if ((int)uVar18 == -1) break;
          }
          local_1ad8 = (WCHAR *)((int)local_1ad8 + 1);
          local_1ac4 = (WCHAR *)((int)local_1ac4 + 1);
          local_1ac8 = (WCHAR *)WideCharToMultiByte(in_stack_ffffe50c,0,(LPCWSTR)&local_1ad0,1,
                                                    &local_10,5,(LPCSTR)0x0,(LPBOOL)0x0);
          pWVar12 = extraout_EDX_00;
          if (local_1ac8 == (WCHAR *)0x0) break;
          BVar8 = WriteFile(*(HANDLE *)((int)local_1ae0 + (&DAT_10835b98)[local_1adc]),&local_10,
                            (DWORD)local_1ac8,(LPDWORD)&local_1acc,(LPOVERLAPPED)0x0);
          if (BVar8 == 0) goto LAB_1002eb63;
          pWVar15 = (WCHAR *)((int)local_1ac4 + local_1ac0);
          pWVar12 = extraout_EDX_01;
          if ((int)local_1acc < (int)local_1ac8) break;
          pWVar17 = local_1ad8;
          DVar11 = local_1ad0;
          pWVar12 = local_1ac4;
          if (local_1aec != 0) {
            local_10 = '\r';
            BVar8 = WriteFile(*(HANDLE *)((int)local_1ae0 + (&DAT_10835b98)[local_1adc]),&local_10,1
                              ,(LPDWORD)&local_1acc,(LPOVERLAPPED)0x0);
            if (BVar8 == 0) goto LAB_1002eb63;
            pWVar12 = extraout_EDX_02;
            if ((int)local_1acc < 1) break;
            local_1ac0 = local_1ac0 + 1;
            pWVar15 = (WCHAR *)((int)pWVar15 + 1);
            pWVar17 = local_1ad8;
            DVar11 = local_1ad0;
            pWVar12 = local_1ac4;
          }
        }
        else {
          if ((cVar13 == '\x01') || (cVar13 == '\x02')) {
            DVar11 = (DWORD)(ushort)*pWVar17;
            local_1ac8 = (WCHAR *)(uint)(*pWVar17 == L'\n');
            pWVar17 = pWVar17 + 1;
            pWVar12 = local_1ac4 + 1;
            local_1ad8 = pWVar17;
            local_1ad0 = DVar11;
            local_1ac4 = pWVar12;
          }
          if ((cVar13 == '\x01') || (cVar13 == '\x02')) {
            wVar4 = __putwch_nolock((wchar_t)DVar11);
            if (wVar4 != (wint_t)local_1ad0) goto LAB_1002eb63;
            pWVar15 = pWVar14 + 1;
            pWVar17 = local_1ad8;
            DVar11 = local_1ad0;
            pWVar12 = local_1ac4;
            if (local_1ac8 != (WCHAR *)0x0) {
              local_1ad0 = 0xd;
              wVar4 = __putwch_nolock(L'\r');
              if (wVar4 != (wint_t)local_1ad0) goto LAB_1002eb63;
              pWVar15 = (WCHAR *)((int)pWVar14 + 3);
              local_1ac0 = local_1ac0 + 1;
              pWVar17 = local_1ad8;
              DVar11 = local_1ad0;
              pWVar12 = local_1ac4;
            }
          }
        }
        pWVar14 = pWVar15;
      } while (pWVar12 < param_3);
LAB_1002ec80:
      uVar20 = (undefined)in_stack_ffffe50c;
      if (pWVar15 == (WCHAR *)0x0) {
        if (DVar16 == 0) goto LAB_1002ef42;
        if (DVar16 == 5) {
          piVar6 = __errno();
          *piVar6 = 9;
          puVar5 = ___doserrno();
          *puVar5 = 5;
          pWVar12 = extraout_EDX_05;
        }
        else {
          FID_conflict___dosmaperr(DVar16);
          pWVar12 = extraout_EDX_10;
        }
      }
    }
  }
  in_DL = SUB41(pWVar12,0);
LAB_1002ef82:
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,in_DL,uVar20);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

int FUN_1002ef92(void)

{
  FILE *_File;
  int iVar1;
  int iVar2;
  int iVar3;
  
  iVar3 = 0;
  __lock(1);
  for (iVar2 = 3; iVar2 < DAT_10837ba4; iVar2 = iVar2 + 1) {
    _File = *(FILE **)(DAT_10837ba0 + iVar2 * 4);
    if (_File != (FILE *)0x0) {
      if ((*(byte *)&_File->_flag & 0x83) != 0) {
        iVar1 = _fclose(_File);
        if (iVar1 != -1) {
          iVar3 = iVar3 + 1;
        }
      }
      if (0x13 < iVar2) {
        DeleteCriticalSection((LPCRITICAL_SECTION)(*(int *)(DAT_10837ba0 + iVar2 * 4) + 0x20));
        FID_conflict__free(*(void **)(DAT_10837ba0 + iVar2 * 4));
        *(undefined4 *)(DAT_10837ba0 + iVar2 * 4) = 0;
      }
    }
  }
  FUN_1002f026();
  return iVar3;
}



void FUN_1002f026(void)

{
  FUN_1002f199(1);
  return;
}



// Library Function - Single Match
//  __lock
// 
// Library: Visual Studio 2012 Release

void __cdecl __lock(int _File)

{
  int iVar1;
  
  if ((&DAT_10047670)[_File * 2] == 0) {
    iVar1 = FUN_1002f0b7(_File);
    if (iVar1 == 0) {
      __amsg_exit(0x11);
    }
  }
  EnterCriticalSection((LPCRITICAL_SECTION)(&DAT_10047670)[_File * 2]);
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

undefined4 __cdecl FUN_1002f0b7(int param_1)

{
  LPCRITICAL_SECTION _Memory;
  int *piVar1;
  
  if (DAT_10835d30 == 0) {
    __FF_MSGBANNER();
    FUN_1002aa44(0x1e);
    ___crtExitProcess(0xff);
  }
  if ((&DAT_10047670)[param_1 * 2] == 0) {
    _Memory = (LPCRITICAL_SECTION)FUN_10026f23(0x18);
    if (_Memory == (LPCRITICAL_SECTION)0x0) {
      piVar1 = __errno();
      *piVar1 = 0xc;
      return 0;
    }
    __lock(10);
    if ((&DAT_10047670)[param_1 * 2] == 0) {
      FUN_1002bd5a(_Memory,4000,0);
      (&DAT_10047670)[param_1 * 2] = _Memory;
    }
    else {
      FID_conflict__free(_Memory);
    }
    FUN_1002f157();
  }
  return 1;
}



void FUN_1002f157(void)

{
  FUN_1002f199(10);
  return;
}



undefined4 FUN_1002f160(void)

{
  LPCRITICAL_SECTION *pp_Var1;
  LPCRITICAL_SECTION p_Var2;
  
  pp_Var1 = (LPCRITICAL_SECTION *)&DAT_10047670;
  p_Var2 = (LPCRITICAL_SECTION)&DAT_10836448;
  do {
    if (pp_Var1[1] == (LPCRITICAL_SECTION)0x1) {
      *pp_Var1 = p_Var2;
      p_Var2 = p_Var2 + 1;
      FUN_1002bd5a(*pp_Var1,4000,0);
    }
    pp_Var1 = pp_Var1 + 2;
  } while ((int)pp_Var1 < 0x10047790);
  return 1;
}



void __cdecl FUN_1002f199(int param_1)

{
  LeaveCriticalSection((LPCRITICAL_SECTION)(&DAT_10047670)[param_1 * 2]);
  return;
}



_ptiddata __cdecl FUN_1002f1ae(int param_1,void *param_2)

{
  int *piVar1;
  code *pcVar2;
  void *pvVar3;
  _ptiddata p_Var4;
  int *piVar5;
  int iVar6;
  
  p_Var4 = __getptd_noexit();
  if (p_Var4 != (_ptiddata)0x0) {
    piVar1 = (int *)p_Var4->_pxcptacttab;
    piVar5 = piVar1;
    do {
      if (*piVar5 == param_1) break;
      piVar5 = piVar5 + 3;
    } while (piVar5 < piVar1 + 0x24);
    if ((piVar1 + 0x24 <= piVar5) || (*piVar5 != param_1)) {
      piVar5 = (int *)0x0;
    }
    if ((piVar5 == (int *)0x0) || (pcVar2 = (code *)piVar5[2], pcVar2 == (code *)0x0)) {
      p_Var4 = (_ptiddata)0x0;
    }
    else if (pcVar2 == (code *)0x5) {
      piVar5[2] = 0;
      p_Var4 = (_ptiddata)0x1;
    }
    else if (pcVar2 == (code *)0x1) {
      p_Var4 = (_ptiddata)0xffffffff;
    }
    else {
      pvVar3 = p_Var4->_tpxcptinfoptrs;
      p_Var4->_tpxcptinfoptrs = param_2;
      if (piVar5[1] == 8) {
        iVar6 = 0x24;
        do {
          *(undefined4 *)(iVar6 + 8 + (int)p_Var4->_pxcptacttab) = 0;
          iVar6 = iVar6 + 0xc;
        } while (iVar6 < 0x90);
        iVar6 = p_Var4->_tfpecode;
        if (*piVar5 == -0x3fffff72) {
          p_Var4->_tfpecode = 0x83;
        }
        else if (*piVar5 == -0x3fffff70) {
          p_Var4->_tfpecode = 0x81;
        }
        else if (*piVar5 == -0x3fffff6f) {
          p_Var4->_tfpecode = 0x84;
        }
        else if (*piVar5 == -0x3fffff6d) {
          p_Var4->_tfpecode = 0x85;
        }
        else if (*piVar5 == -0x3fffff73) {
          p_Var4->_tfpecode = 0x82;
        }
        else if (*piVar5 == -0x3fffff71) {
          p_Var4->_tfpecode = 0x86;
        }
        else if (*piVar5 == -0x3fffff6e) {
          p_Var4->_tfpecode = 0x8a;
        }
        else if (*piVar5 == -0x3ffffd4b) {
          p_Var4->_tfpecode = 0x8d;
        }
        else if (*piVar5 == -0x3ffffd4c) {
          p_Var4->_tfpecode = 0x8e;
        }
        (*pcVar2)(8,p_Var4->_tfpecode);
        p_Var4->_tfpecode = iVar6;
      }
      else {
        piVar5[2] = 0;
        (*pcVar2)(piVar5[1]);
      }
      p_Var4->_tpxcptinfoptrs = pvVar3;
      p_Var4 = (_ptiddata)0xffffffff;
    }
  }
  return p_Var4;
}



// Library Function - Single Match
//  ___CppXcptFilter
// 
// Library: Visual Studio 2012 Release

int __cdecl ___CppXcptFilter(ulong _ExceptionNum,_EXCEPTION_POINTERS *_ExceptionPtr)

{
  _ptiddata p_Var1;
  
  if (_ExceptionNum == 0xe06d7363) {
    p_Var1 = FUN_1002f1ae(-0x1f928c9d,_ExceptionPtr);
    return (int)p_Var1;
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_1002f327(void)

{
  uint uVar1;
  uint uVar2;
  byte **ppbVar3;
  byte *pbVar4;
  uint local_c;
  uint local_8;
  
  if (_DAT_10836b94 == 0) {
    FUN_100259ba();
  }
  DAT_108366a4 = 0;
  GetModuleFileNameA((HMODULE)0x0,&DAT_108365a0,0x104);
  _DAT_10835b74 = &DAT_108365a0;
  if ((DAT_10836b9c == (byte *)0x0) || (pbVar4 = DAT_10836b9c, *DAT_10836b9c == 0)) {
    pbVar4 = &DAT_108365a0;
  }
  FUN_1002f3da(pbVar4,(byte **)0x0,(byte *)0x0,(int *)&local_8,(int *)&local_c);
  uVar2 = local_8;
  if ((((local_8 < 0x3fffffff) && (local_c != 0xffffffff)) &&
      (uVar1 = local_c + local_8 * 4, local_c <= uVar1)) &&
     (ppbVar3 = (byte **)FUN_10026f23(uVar1), ppbVar3 != (byte **)0x0)) {
    FUN_1002f3da(pbVar4,ppbVar3,(byte *)(ppbVar3 + uVar2),(int *)&local_8,(int *)&local_c);
    _DAT_10835b60 = local_8 - 1;
    DAT_10835b64 = ppbVar3;
    return 0;
  }
  return 0xffffffff;
}



void __cdecl FUN_1002f3da(byte *param_1,byte **param_2,byte *param_3,int *param_4,int *param_5)

{
  bool bVar1;
  bool bVar2;
  byte bVar3;
  int iVar4;
  uint uVar5;
  byte *pbVar6;
  byte *pbVar7;
  
  *param_5 = 0;
  *param_4 = 1;
  if (param_2 != (byte **)0x0) {
    *param_2 = param_3;
    param_2 = param_2 + 1;
  }
  bVar2 = false;
  do {
    if (*param_1 == 0x22) {
      bVar2 = !bVar2;
      pbVar6 = param_1 + 1;
      bVar3 = 0x22;
    }
    else {
      *param_5 = *param_5 + 1;
      if (param_3 != (byte *)0x0) {
        *param_3 = *param_1;
        param_3 = param_3 + 1;
      }
      bVar3 = *param_1;
      pbVar6 = param_1 + 1;
      iVar4 = FUN_100327b5((uint)bVar3);
      if (iVar4 != 0) {
        *param_5 = *param_5 + 1;
        if (param_3 != (byte *)0x0) {
          *param_3 = *pbVar6;
          param_3 = param_3 + 1;
        }
        pbVar6 = param_1 + 2;
      }
      if (bVar3 == 0) {
        pbVar6 = pbVar6 + -1;
        goto LAB_1002f46b;
      }
    }
    param_1 = pbVar6;
  } while ((bVar2) || ((bVar3 != 0x20 && (bVar3 != 9))));
  if (param_3 != (byte *)0x0) {
    param_3[-1] = 0;
  }
LAB_1002f46b:
  bVar2 = false;
  while (pbVar7 = pbVar6, *pbVar6 != 0) {
    for (; (*pbVar7 == 0x20 || (*pbVar7 == 9)); pbVar7 = pbVar7 + 1) {
    }
    if (*pbVar7 == 0) break;
    if (param_2 != (byte **)0x0) {
      *param_2 = param_3;
      param_2 = param_2 + 1;
    }
    *param_4 = *param_4 + 1;
    while( true ) {
      bVar1 = true;
      uVar5 = 0;
      for (; *pbVar7 == 0x5c; pbVar7 = pbVar7 + 1) {
        uVar5 = uVar5 + 1;
      }
      pbVar6 = pbVar7;
      if (*pbVar7 == 0x22) {
        if (((uVar5 & 1) == 0) && ((!bVar2 || (pbVar6 = pbVar7 + 1, *pbVar6 != 0x22)))) {
          bVar1 = false;
          bVar2 = !bVar2;
          pbVar6 = pbVar7;
        }
        uVar5 = uVar5 >> 1;
      }
      while (uVar5 != 0) {
        uVar5 = uVar5 - 1;
        if (param_3 != (byte *)0x0) {
          *param_3 = 0x5c;
          param_3 = param_3 + 1;
        }
        *param_5 = *param_5 + 1;
      }
      bVar3 = *pbVar6;
      if ((bVar3 == 0) || ((!bVar2 && ((bVar3 == 0x20 || (bVar3 == 9)))))) break;
      if (bVar1) {
        iVar4 = FUN_100327b5((int)(char)bVar3);
        if (param_3 == (byte *)0x0) {
          if (iVar4 != 0) {
            pbVar6 = pbVar6 + 1;
            *param_5 = *param_5 + 1;
          }
        }
        else {
          if (iVar4 != 0) {
            *param_3 = *pbVar6;
            param_3 = param_3 + 1;
            pbVar6 = pbVar6 + 1;
            *param_5 = *param_5 + 1;
          }
          *param_3 = *pbVar6;
          param_3 = param_3 + 1;
        }
        *param_5 = *param_5 + 1;
      }
      pbVar7 = pbVar6 + 1;
    }
    if (param_3 != (byte *)0x0) {
      *param_3 = 0;
      param_3 = param_3 + 1;
    }
    *param_5 = *param_5 + 1;
  }
  if (param_2 != (byte **)0x0) {
    *param_2 = (byte *)0x0;
  }
  *param_4 = *param_4 + 1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 FUN_1002f556(void)

{
  uint _SizeInBytes;
  char cVar1;
  code *pcVar2;
  size_t sVar3;
  char *_Dst;
  errno_t eVar4;
  undefined4 uVar5;
  char *pcVar6;
  int iVar7;
  char **ppcVar8;
  
  if (_DAT_10836b94 == 0) {
    FUN_100259ba();
  }
  iVar7 = 0;
  pcVar6 = DAT_10835b1c;
  if (DAT_10835b1c != (char *)0x0) {
    for (; *pcVar6 != '\0'; pcVar6 = pcVar6 + sVar3 + 1) {
      if (*pcVar6 != '=') {
        iVar7 = iVar7 + 1;
      }
      sVar3 = _strlen(pcVar6);
    }
    DAT_10835b6c = (char **)FUN_10026edb(iVar7 + 1,4);
    if (DAT_10835b6c != (char **)0x0) {
      cVar1 = *DAT_10835b1c;
      ppcVar8 = DAT_10835b6c;
      pcVar6 = DAT_10835b1c;
      do {
        if (cVar1 == '\0') {
          FID_conflict__free(DAT_10835b1c);
          DAT_10835b1c = (char *)0x0;
          *ppcVar8 = (char *)0x0;
          _DAT_10836b98 = 1;
          return 0;
        }
        sVar3 = _strlen(pcVar6);
        _SizeInBytes = sVar3 + 1;
        if (*pcVar6 != '=') {
          _Dst = (char *)FUN_10026edb(_SizeInBytes,1);
          *ppcVar8 = _Dst;
          if (_Dst == (char *)0x0) {
            FID_conflict__free(DAT_10835b6c);
            DAT_10835b6c = (char **)0x0;
            return 0xffffffff;
          }
          eVar4 = _strcpy_s(_Dst,_SizeInBytes,pcVar6);
          if (eVar4 != 0) {
            __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
            pcVar2 = (code *)swi(3);
            uVar5 = (*pcVar2)();
            return uVar5;
          }
          ppcVar8 = ppcVar8 + 1;
        }
        pcVar6 = pcVar6 + _SizeInBytes;
        cVar1 = *pcVar6;
      } while( true );
    }
  }
  return 0xffffffff;
}



// Library Function - Single Match
//  ___security_init_cookie
// 
// Library: Visual Studio 2015 Release

void __cdecl ___security_init_cookie(void)

{
  DWORD DVar1;
  uint local_18;
  uint local_14;
  _FILETIME local_10;
  uint local_8;
  
  local_10.dwLowDateTime = 0;
  local_10.dwHighDateTime = 0;
  if ((DAT_10046c24 == 0xbb40e64e) || ((DAT_10046c24 & 0xffff0000) == 0)) {
    GetSystemTimeAsFileTime(&local_10);
    local_8 = local_10.dwHighDateTime ^ local_10.dwLowDateTime;
    DVar1 = GetCurrentThreadId();
    local_8 = local_8 ^ DVar1;
    DVar1 = GetCurrentProcessId();
    local_8 = local_8 ^ DVar1;
    QueryPerformanceCounter((LARGE_INTEGER *)&local_18);
    DAT_10046c24 = local_14 ^ local_18 ^ local_8 ^ (uint)&local_8;
    if (DAT_10046c24 == 0xbb40e64e) {
      DAT_10046c24 = 0xbb40e64f;
    }
    else if ((DAT_10046c24 & 0xffff0000) == 0) {
      DAT_10046c24 = DAT_10046c24 | (DAT_10046c24 | 0x4711) << 0x10;
    }
    DAT_10046c28 = ~DAT_10046c24;
  }
  else {
    DAT_10046c28 = ~DAT_10046c24;
  }
  return;
}



LPSTR FUN_1002f6d3(void)

{
  WCHAR WVar1;
  LPWCH lpWideCharStr;
  LPSTR lpMultiByteStr;
  size_t cbMultiByte;
  WCHAR *pWVar2;
  int iVar4;
  WCHAR *pWVar3;
  
  lpWideCharStr = GetEnvironmentStringsW();
  lpMultiByteStr = (LPSTR)0x0;
  if (lpWideCharStr != (LPWCH)0x0) {
    WVar1 = *lpWideCharStr;
    pWVar2 = lpWideCharStr;
    while (WVar1 != L'\0') {
      do {
        pWVar3 = pWVar2;
        pWVar2 = pWVar3 + 1;
      } while (*pWVar2 != L'\0');
      pWVar2 = pWVar3 + 2;
      WVar1 = *pWVar2;
    }
    iVar4 = ((int)pWVar2 - (int)lpWideCharStr >> 1) + 1;
    cbMultiByte = WideCharToMultiByte(0,0,lpWideCharStr,iVar4,(LPSTR)0x0,0,(LPCSTR)0x0,(LPBOOL)0x0);
    if ((cbMultiByte == 0) ||
       (lpMultiByteStr = (LPSTR)FUN_10026f23(cbMultiByte), lpMultiByteStr == (LPSTR)0x0)) {
      FreeEnvironmentStringsW(lpWideCharStr);
      lpMultiByteStr = (LPSTR)0x0;
    }
    else {
      iVar4 = WideCharToMultiByte(0,0,lpWideCharStr,iVar4,lpMultiByteStr,cbMultiByte,(LPCSTR)0x0,
                                  (LPBOOL)0x0);
      if (iVar4 == 0) {
        FID_conflict__free(lpMultiByteStr);
        lpMultiByteStr = (LPSTR)0x0;
      }
      FreeEnvironmentStringsW(lpWideCharStr);
    }
  }
  return lpMultiByteStr;
}



void FUN_1002f760(void)

{
  code **ppcVar1;
  
  for (ppcVar1 = (code **)&DAT_1003f518; ppcVar1 < &DAT_1003f518; ppcVar1 = ppcVar1 + 1) {
    if (*ppcVar1 != (code *)0x0) {
      (**ppcVar1)();
    }
  }
  return;
}



void FUN_1002f780(void)

{
  code **ppcVar1;
  
  for (ppcVar1 = (code **)&DAT_1003f520; ppcVar1 < &DAT_1003f520; ppcVar1 = ppcVar1 + 1) {
    if (*ppcVar1 != (code *)0x0) {
      (**ppcVar1)();
    }
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  ___raise_securityfailure
// 
// Library: Visual Studio 2012 Release

void __cdecl ___raise_securityfailure(EXCEPTION_POINTERS *param_1)

{
  _DAT_108369c4 = IsDebuggerPresent();
  FUN_1002fafa();
  ___crtUnhandledException(param_1);
  if (_DAT_108369c4 == 0) {
    FUN_1002fafa();
  }
  Plat_ExitProcess(0xc0000409);
  return;
}



int __cdecl FUN_1002f8d8(char *param_1,int param_2,char *param_3,int param_4)

{
  char cVar1;
  int *piVar2;
  int iVar3;
  char *pcVar4;
  int iVar5;
  
  if (param_4 == 0) {
    if (param_1 == (char *)0x0) {
      if (param_2 == 0) {
        return 0;
      }
    }
    else {
LAB_1002f8f7:
      if (param_2 != 0) {
        if (param_4 == 0) {
          *param_1 = '\0';
          return 0;
        }
        if (param_3 != (char *)0x0) {
          iVar5 = param_2;
          if (param_4 == -1) {
            iVar3 = (int)param_1 - (int)param_3;
            do {
              cVar1 = *param_3;
              param_3[iVar3] = cVar1;
              param_3 = param_3 + 1;
              if (cVar1 == '\0') break;
              iVar5 = iVar5 + -1;
            } while (iVar5 != 0);
          }
          else {
            pcVar4 = param_1;
            do {
              cVar1 = pcVar4[(int)param_3 - (int)param_1];
              *pcVar4 = cVar1;
              pcVar4 = pcVar4 + 1;
              if ((cVar1 == '\0') || (iVar5 = iVar5 + -1, iVar5 == 0)) break;
              param_4 = param_4 + -1;
            } while (param_4 != 0);
            if (param_4 == 0) {
              *pcVar4 = '\0';
            }
          }
          if (iVar5 != 0) {
            return 0;
          }
          if (param_4 == -1) {
            param_1[param_2 + -1] = '\0';
            return 0x50;
          }
          *param_1 = '\0';
          piVar2 = __errno();
          iVar5 = 0x22;
          goto LAB_1002f917;
        }
        *param_1 = '\0';
      }
    }
  }
  else if (param_1 != (char *)0x0) goto LAB_1002f8f7;
  piVar2 = __errno();
  iVar5 = 0x16;
LAB_1002f917:
  *piVar2 = iVar5;
  FUN_10025625();
  return iVar5;
}



// Library Function - Multiple Matches With Different Base Names
//  int __cdecl GetTableIndexFromLocaleName(wchar_t const *)
//  int __cdecl ATL::_AtlGetTableIndexFromLocaleName(wchar_t const *)
//  _GetTableIndexFromLocaleName
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined4 __cdecl FID_conflict_GetTableIndexFromLocaleName(wchar_t *param_1)

{
  int iVar1;
  int iVar2;
  int iVar3;
  int iVar4;
  
  iVar4 = 0;
  iVar2 = 0xe3;
  do {
    iVar3 = (iVar2 + iVar4) / 2;
    iVar1 = __wcsnicmp(param_1,*(wchar_t **)(&UNK_1003b270 + iVar3 * 8),0x55);
    if (iVar1 == 0) {
      return *(undefined4 *)(&UNK_1003b274 + iVar3 * 8);
    }
    if (iVar1 < 0) {
      iVar2 = iVar3 + -1;
    }
    else {
      iVar4 = iVar3 + 1;
    }
  } while (iVar4 <= iVar2);
  return 0xffffffff;
}



void __cdecl
FUN_1002f9ca(wchar_t *param_1,DWORD param_2,PCNZWCH param_3,int param_4,PCNZWCH param_5,int param_6)

{
  LCID Locale;
  
  if ((code *)(DAT_10836b54 ^ DAT_10046c24) != (code *)0x0) {
    (*(code *)(DAT_10836b54 ^ DAT_10046c24))(param_1,param_2,param_3,param_4,param_5,param_6,0,0,0);
    return;
  }
  Locale = FID_conflict__AtlDownlevelLocaleNameToLCID(param_1);
  CompareStringW(Locale,param_2,param_3,param_4,param_5,param_6);
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  unsigned long __cdecl ATL::_AtlDownlevelLocaleNameToLCID(wchar_t const *)
//  ___acrt_DownlevelLocaleNameToLCID
//  ___crtDownlevelLocaleNameToLCID
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

undefined4 __cdecl FID_conflict__AtlDownlevelLocaleNameToLCID(wchar_t *param_1)

{
  uint uVar1;
  
  if (param_1 != (wchar_t *)0x0) {
    uVar1 = FID_conflict_GetTableIndexFromLocaleName(param_1);
    if ((-1 < (int)uVar1) && (uVar1 < 0xe4)) {
      return *(undefined4 *)(&DAT_1003ab50 + uVar1 * 8);
    }
  }
  return 0;
}



void __cdecl
FUN_1002fa40(wchar_t *param_1,DWORD param_2,LPCWSTR param_3,int param_4,LPWSTR param_5,int param_6)

{
  LCID Locale;
  
  if ((code *)(DAT_10836b70 ^ DAT_10046c24) != (code *)0x0) {
    (*(code *)(DAT_10836b70 ^ DAT_10046c24))(param_1,param_2,param_3,param_4,param_5,param_6,0,0,0);
    return;
  }
  Locale = FID_conflict__AtlDownlevelLocaleNameToLCID(param_1);
  LCMapStringW(Locale,param_2,param_3,param_4,param_5,param_6);
  return;
}



// Library Function - Single Match
//  __wcsnicmp
// 
// Library: Visual Studio 2019 Release

int __cdecl __wcsnicmp(wchar_t *_Str1,wchar_t *_Str2,size_t _MaxCount)

{
  wchar_t wVar1;
  int iVar2;
  wchar_t wVar3;
  
  iVar2 = 0;
  if (_MaxCount != 0) {
    iVar2 = (int)_Str1 - (int)_Str2;
    do {
      wVar3 = *(wchar_t *)(iVar2 + (int)_Str2);
      if ((0x40 < (ushort)wVar3) && ((ushort)wVar3 < 0x5b)) {
        wVar3 = wVar3 + L' ';
      }
      wVar1 = *_Str2;
      if ((0x40 < (ushort)wVar1) && ((ushort)wVar1 < 0x5b)) {
        wVar1 = wVar1 + L' ';
      }
      _Str2 = _Str2 + 1;
      _MaxCount = _MaxCount - 1;
    } while (((_MaxCount != 0) && (wVar3 != L'\0')) && (wVar3 == wVar1));
    iVar2 = (uint)(ushort)wVar3 - (uint)(ushort)wVar1;
  }
  return iVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_1002fafa(void)

{
  _DAT_10836ae0 = 0;
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  ___acrt_locale_free_monetary
//  ___free_lconv_mon
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
// Visual Studio 2019 Release

void __cdecl FID_conflict____acrt_locale_free_monetary(int param_1)

{
  if (param_1 != 0) {
    if (*(undefined **)(param_1 + 0xc) != PTR_DAT_100477a4) {
      FID_conflict__free(*(undefined **)(param_1 + 0xc));
    }
    if (*(undefined **)(param_1 + 0x10) != PTR_DAT_100477a8) {
      FID_conflict__free(*(undefined **)(param_1 + 0x10));
    }
    if (*(undefined **)(param_1 + 0x14) != PTR_DAT_100477ac) {
      FID_conflict__free(*(undefined **)(param_1 + 0x14));
    }
    if (*(undefined **)(param_1 + 0x18) != PTR_DAT_100477b0) {
      FID_conflict__free(*(undefined **)(param_1 + 0x18));
    }
    if (*(undefined **)(param_1 + 0x1c) != PTR_DAT_100477b4) {
      FID_conflict__free(*(undefined **)(param_1 + 0x1c));
    }
    if (*(undefined **)(param_1 + 0x20) != PTR_DAT_100477b8) {
      FID_conflict__free(*(undefined **)(param_1 + 0x20));
    }
    if (*(undefined **)(param_1 + 0x24) != PTR_DAT_100477bc) {
      FID_conflict__free(*(undefined **)(param_1 + 0x24));
    }
    if (*(undefined **)(param_1 + 0x38) != PTR_DAT_100477d0) {
      FID_conflict__free(*(undefined **)(param_1 + 0x38));
    }
    if (*(undefined **)(param_1 + 0x3c) != PTR_DAT_100477d4) {
      FID_conflict__free(*(undefined **)(param_1 + 0x3c));
    }
    if (*(undefined **)(param_1 + 0x40) != PTR_DAT_100477d8) {
      FID_conflict__free(*(undefined **)(param_1 + 0x40));
    }
    if (*(undefined **)(param_1 + 0x44) != PTR_DAT_100477dc) {
      FID_conflict__free(*(undefined **)(param_1 + 0x44));
    }
    if (*(undefined **)(param_1 + 0x48) != PTR_DAT_100477e0) {
      FID_conflict__free(*(undefined **)(param_1 + 0x48));
    }
    if (*(undefined **)(param_1 + 0x4c) != PTR_DAT_100477e4) {
      FID_conflict__free(*(undefined **)(param_1 + 0x4c));
    }
  }
  return;
}



// Library Function - Multiple Matches With Different Base Names
//  ___acrt_locale_free_numeric
//  ___free_lconv_num
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2017 Release,
// Visual Studio 2019 Release

void __cdecl FID_conflict____free_lconv_num(void **param_1)

{
  if (param_1 != (void **)0x0) {
    if ((undefined *)*param_1 != PTR_DAT_10047798) {
      FID_conflict__free(*param_1);
    }
    if ((undefined *)param_1[1] != PTR_DAT_1004779c) {
      FID_conflict__free(param_1[1]);
    }
    if ((undefined *)param_1[2] != PTR_DAT_100477a0) {
      FID_conflict__free(param_1[2]);
    }
    if ((undefined *)param_1[0xc] != PTR_DAT_100477c8) {
      FID_conflict__free(param_1[0xc]);
    }
    if ((undefined *)param_1[0xd] != PTR_DAT_100477cc) {
      FID_conflict__free(param_1[0xd]);
    }
  }
  return;
}



// Library Function - Single Match
//  ___free_lc_time
// 
// Library: Visual Studio 2012 Release

void __cdecl ___free_lc_time(void **param_1)

{
  if (param_1 != (void **)0x0) {
    FID_conflict__free(param_1[1]);
    FID_conflict__free(param_1[2]);
    FID_conflict__free(param_1[3]);
    FID_conflict__free(param_1[4]);
    FID_conflict__free(param_1[5]);
    FID_conflict__free(param_1[6]);
    FID_conflict__free(*param_1);
    FID_conflict__free(param_1[8]);
    FID_conflict__free(param_1[9]);
    FID_conflict__free(param_1[10]);
    FID_conflict__free(param_1[0xb]);
    FID_conflict__free(param_1[0xc]);
    FID_conflict__free(param_1[0xd]);
    FID_conflict__free(param_1[7]);
    FID_conflict__free(param_1[0xe]);
    FID_conflict__free(param_1[0xf]);
    FID_conflict__free(param_1[0x10]);
    FID_conflict__free(param_1[0x11]);
    FID_conflict__free(param_1[0x12]);
    FID_conflict__free(param_1[0x13]);
    FID_conflict__free(param_1[0x14]);
    FID_conflict__free(param_1[0x15]);
    FID_conflict__free(param_1[0x16]);
    FID_conflict__free(param_1[0x17]);
    FID_conflict__free(param_1[0x18]);
    FID_conflict__free(param_1[0x19]);
    FID_conflict__free(param_1[0x1a]);
    FID_conflict__free(param_1[0x1b]);
    FID_conflict__free(param_1[0x1c]);
    FID_conflict__free(param_1[0x1d]);
    FID_conflict__free(param_1[0x1e]);
    FID_conflict__free(param_1[0x1f]);
    FID_conflict__free(param_1[0x20]);
    FID_conflict__free(param_1[0x21]);
    FID_conflict__free(param_1[0x22]);
    FID_conflict__free(param_1[0x23]);
    FID_conflict__free(param_1[0x24]);
    FID_conflict__free(param_1[0x25]);
    FID_conflict__free(param_1[0x26]);
    FID_conflict__free(param_1[0x27]);
    FID_conflict__free(param_1[0x28]);
    FID_conflict__free(param_1[0x29]);
    FID_conflict__free(param_1[0x2a]);
    FID_conflict__free(param_1[0x2e]);
    FID_conflict__free(param_1[0x2f]);
    FID_conflict__free(param_1[0x30]);
    FID_conflict__free(param_1[0x31]);
    FID_conflict__free(param_1[0x32]);
    FID_conflict__free(param_1[0x33]);
    FID_conflict__free(param_1[0x2d]);
    FID_conflict__free(param_1[0x35]);
    FID_conflict__free(param_1[0x36]);
    FID_conflict__free(param_1[0x37]);
    FID_conflict__free(param_1[0x38]);
    FID_conflict__free(param_1[0x39]);
    FID_conflict__free(param_1[0x3a]);
    FID_conflict__free(param_1[0x34]);
    FID_conflict__free(param_1[0x3b]);
    FID_conflict__free(param_1[0x3c]);
    FID_conflict__free(param_1[0x3d]);
    FID_conflict__free(param_1[0x3e]);
    FID_conflict__free(param_1[0x3f]);
    FID_conflict__free(param_1[0x40]);
    FID_conflict__free(param_1[0x41]);
    FID_conflict__free(param_1[0x42]);
    FID_conflict__free(param_1[0x43]);
    FID_conflict__free(param_1[0x44]);
    FID_conflict__free(param_1[0x45]);
    FID_conflict__free(param_1[0x46]);
    FID_conflict__free(param_1[0x47]);
    FID_conflict__free(param_1[0x48]);
    FID_conflict__free(param_1[0x49]);
    FID_conflict__free(param_1[0x4a]);
    FID_conflict__free(param_1[0x4b]);
    FID_conflict__free(param_1[0x4c]);
    FID_conflict__free(param_1[0x4d]);
    FID_conflict__free(param_1[0x4e]);
    FID_conflict__free(param_1[0x4f]);
    FID_conflict__free(param_1[0x50]);
    FID_conflict__free(param_1[0x51]);
    FID_conflict__free(param_1[0x52]);
    FID_conflict__free(param_1[0x53]);
    FID_conflict__free(param_1[0x54]);
    FID_conflict__free(param_1[0x55]);
    FID_conflict__free(param_1[0x56]);
    FID_conflict__free(param_1[0x57]);
    FID_conflict__free(param_1[0x58]);
  }
  return;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe

void __cdecl
FUN_1002ffe5(int *param_1,DWORD param_2,LPCSTR param_3,int param_4,LPWORD param_5,UINT param_6,
            int param_7)

{
  uint _Size;
  uint uVar1;
  uint cchWideChar;
  undefined4 *puVar2;
  int cchSrc;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar3;
  undefined extraout_DL_01;
  uint *lpWideCharStr;
  
  uVar1 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  if (param_6 == 0) {
    param_6 = *(UINT *)(*param_1 + 4);
  }
  cchWideChar = MultiByteToWideChar(param_6,(uint)(param_7 != 0) * 8 + 1,param_3,param_4,(LPWSTR)0x0
                                    ,0);
  uVar3 = extraout_DL;
  if (cchWideChar == 0) goto LAB_100300c9;
  if ((((int)cchWideChar < 1) || (0x7ffffff0 < cchWideChar)) ||
     (cchWideChar * 2 + 8 <= cchWideChar * 2)) {
    lpWideCharStr = (uint *)0x0;
  }
  else {
    _Size = cchWideChar * 2 + 8;
    if (_Size < 0x401) {
      puVar2 = (undefined4 *)&stack0xffffffec;
      if (&stack0x00000000 == (undefined *)0x14) goto LAB_100300c9;
    }
    else {
      puVar2 = (undefined4 *)_malloc(_Size);
      uVar3 = extraout_DL_00;
      if (puVar2 == (undefined4 *)0x0) goto LAB_100300c9;
      *puVar2 = 0xdddd;
    }
    lpWideCharStr = puVar2 + 2;
  }
  if (lpWideCharStr != (uint *)0x0) {
    FUN_10021290(lpWideCharStr,0,cchWideChar * 2);
    cchSrc = MultiByteToWideChar(param_6,1,param_3,param_4,(LPWSTR)lpWideCharStr,cchWideChar);
    if (cchSrc != 0) {
      GetStringTypeW(param_2,(LPCWSTR)lpWideCharStr,cchSrc,param_5);
    }
    FUN_10021ea8((int)lpWideCharStr);
    uVar3 = extraout_DL_01;
  }
LAB_100300c9:
  FUN_1002534c(uVar1 ^ (uint)&stack0xfffffffc,uVar3,(char)uVar1);
  return;
}



void __cdecl
FUN_100300dd(pthreadlocinfo *param_1,DWORD param_2,LPCSTR param_3,int param_4,LPWORD param_5,
            UINT param_6,int param_7)

{
  int local_14 [2];
  int local_c;
  char local_8;
  
  FUN_1001f92e(local_14,param_1);
  FUN_1002ffe5(local_14,param_2,param_3,param_4,param_5,param_6,param_7);
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return;
}



// Library Function - Single Match
//  __FindPESection
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

PIMAGE_SECTION_HEADER __cdecl __FindPESection(PBYTE pImageBase,DWORD_PTR rva)

{
  int iVar1;
  PIMAGE_SECTION_HEADER p_Var2;
  uint uVar3;
  
  uVar3 = 0;
  iVar1 = *(int *)(pImageBase + 0x3c);
  p_Var2 = (PIMAGE_SECTION_HEADER)
           (pImageBase + *(ushort *)(pImageBase + iVar1 + 0x14) + 0x18 + iVar1);
  if (*(ushort *)(pImageBase + iVar1 + 6) != 0) {
    do {
      if ((p_Var2->VirtualAddress <= rva) && (rva < p_Var2->Misc + p_Var2->VirtualAddress)) {
        return p_Var2;
      }
      uVar3 = uVar3 + 1;
      p_Var2 = p_Var2 + 1;
    } while (uVar3 < *(ushort *)(pImageBase + iVar1 + 6));
  }
  return (PIMAGE_SECTION_HEADER)0x0;
}



// Library Function - Single Match
//  __IsNonwritableInCurrentImage
// 
// Libraries: Visual Studio 2015 Release, Visual Studio 2019 Release

BOOL __cdecl __IsNonwritableInCurrentImage(PBYTE pTarget)

{
  uint uVar1;
  BOOL BVar2;
  PIMAGE_SECTION_HEADER p_Var3;
  int **in_FS_OFFSET;
  int *local_14;
  code *pcStack16;
  uint local_c;
  undefined4 local_8;
  
  pcStack16 = FUN_10027070;
  local_14 = *in_FS_OFFSET;
  local_c = DAT_10046c24 ^ 0x100401c8;
  *in_FS_OFFSET = (int *)&local_14;
  local_8 = 0;
  BVar2 = __ValidateImageBase((PBYTE)&IMAGE_DOS_HEADER_10000000);
  if (BVar2 != 0) {
    p_Var3 = __FindPESection((PBYTE)&IMAGE_DOS_HEADER_10000000,(DWORD_PTR)(pTarget + -0x10000000));
    if (p_Var3 != (PIMAGE_SECTION_HEADER)0x0) {
      uVar1 = p_Var3->Characteristics;
      *in_FS_OFFSET = local_14;
      return ~(uVar1 >> 0x1f) & 1;
    }
  }
  *in_FS_OFFSET = local_14;
  return 0;
}



// Library Function - Single Match
//  __ValidateImageBase
// 
// Library: Visual Studio 2012 Release

BOOL __cdecl __ValidateImageBase(PBYTE pImageBase)

{
  uint uVar1;
  
  if (*(short *)pImageBase != 0x5a4d) {
    return 0;
  }
  uVar1 = 0;
  if (*(int *)(pImageBase + *(int *)(pImageBase + 0x3c)) == 0x4550) {
    uVar1 = (uint)(*(short *)((int)(pImageBase + *(int *)(pImageBase + 0x3c)) + 0x18) == 0x10b);
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_10030261(undefined4 param_1)

{
  _DAT_10836a10 = param_1;
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _realloc
// 
// Library: Visual Studio 2012 Release

void * __cdecl _realloc(void *_Memory,size_t _NewSize)

{
  void *pvVar1;
  LPVOID pvVar2;
  int iVar3;
  int *piVar4;
  DWORD DVar5;
  
  if (_Memory == (void *)0x0) {
    pvVar1 = _malloc(_NewSize);
    return pvVar1;
  }
  if (_NewSize == 0) {
    FID_conflict__free(_Memory);
  }
  else {
    do {
      if (0xffffffe0 < _NewSize) {
        __callnewh(_NewSize);
        piVar4 = __errno();
        *piVar4 = 0xc;
        return (void *)0x0;
      }
      if (_NewSize == 0) {
        _NewSize = 1;
      }
      pvVar2 = HeapReAlloc(DAT_10835d30,0,_Memory,_NewSize);
      if (pvVar2 != (LPVOID)0x0) {
        return pvVar2;
      }
      if (_DAT_10836368 == 0) {
        piVar4 = __errno();
        DVar5 = GetLastError();
        iVar3 = __get_errno_from_oserr(DVar5);
        *piVar4 = iVar3;
        return (void *)0x0;
      }
      iVar3 = __callnewh(_NewSize);
    } while (iVar3 != 0);
    piVar4 = __errno();
    DVar5 = GetLastError();
    iVar3 = __get_errno_from_oserr(DVar5);
    *piVar4 = iVar3;
  }
  return (void *)0x0;
}



void * __cdecl FUN_10030319(LPCVOID param_1,uint param_2,uint param_3)

{
  int *piVar1;
  void *pvVar2;
  uint _NewSize;
  SIZE_T SVar3;
  
  SVar3 = 0;
  if ((param_2 == 0) || (param_3 <= 0xffffffe0 / param_2)) {
    _NewSize = param_2 * param_3;
    if (param_1 != (LPCVOID)0x0) {
      SVar3 = FUN_10026eaa(param_1);
    }
    pvVar2 = _realloc(param_1,_NewSize);
    if ((pvVar2 != (void *)0x0) && (SVar3 < _NewSize)) {
      FUN_10021290((uint *)(SVar3 + (int)pvVar2),0,_NewSize - SVar3);
    }
  }
  else {
    piVar1 = __errno();
    *piVar1 = 0xc;
    pvVar2 = (void *)0x0;
  }
  return pvVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __calloc_impl
// 
// Library: Visual Studio 2012 Release

LPVOID __cdecl __calloc_impl(uint param_1,uint param_2,int *param_3)

{
  int iVar1;
  LPVOID pvVar2;
  uint dwBytes;
  
  if ((param_1 == 0) || (param_2 <= 0xffffffe0 / param_1)) {
    dwBytes = param_1 * param_2;
    if (dwBytes == 0) {
      dwBytes = 1;
    }
    do {
      pvVar2 = (LPVOID)0x0;
      if ((dwBytes < 0xffffffe1) &&
         (pvVar2 = HeapAlloc(DAT_10835d30,8,dwBytes), pvVar2 != (LPVOID)0x0)) {
        return pvVar2;
      }
      if (_DAT_10836368 == 0) {
        if (param_3 != (int *)0x0) {
          *param_3 = 0xc;
          return pvVar2;
        }
        return pvVar2;
      }
      iVar1 = __callnewh(dwBytes);
    } while (iVar1 != 0);
    if (param_3 == (int *)0x0) {
      return (LPVOID)0x0;
    }
  }
  else {
    param_3 = __errno();
  }
  *param_3 = 0xc;
  return (LPVOID)0x0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_100303fc(ushort *param_1,uint *param_2)

{
  ushort uVar1;
  ushort uVar2;
  byte bVar3;
  bool bVar4;
  bool bVar5;
  int iVar6;
  uint uVar7;
  byte bVar8;
  uint uVar9;
  uint *puVar10;
  uint uVar11;
  uint *puVar12;
  int iVar13;
  int iVar14;
  int iVar15;
  uint uVar16;
  uint uVar17;
  int local_38;
  uint local_24;
  uint local_14 [4];
  
  local_14[3] = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  uVar1 = param_1[5];
  iVar14 = 0;
  uVar11 = uVar1 & 0x7fff;
  uVar16 = *(uint *)(param_1 + 3);
  puVar12 = (uint *)(uVar11 - 0x3fff);
  local_14[0] = uVar16;
  uVar17 = *(uint *)(param_1 + 1);
  local_14[1] = uVar17;
  uVar2 = *param_1;
  local_14[2] = (uint)uVar2 << 0x10;
  bVar3 = (byte)DAT_10047800;
  if (puVar12 == (uint *)0xffffc001) {
    iVar15 = 0;
    iVar14 = 0;
    do {
      if (local_14[iVar14] != 0) {
        local_14[0] = 0;
        local_14[1] = 0;
        local_14[2] = 0;
        goto LAB_10030471;
      }
      iVar14 = iVar14 + 1;
    } while (iVar14 < 3);
  }
  else {
    iVar6 = DAT_100477fc + -1;
    bVar5 = false;
    iVar15 = (int)((DAT_100477fc >> 0x1f & 0x1fU) + DAT_100477fc) >> 5;
    bVar8 = 0x1f - ((byte)DAT_100477fc & 0x1f);
    if ((local_14[iVar15] & 1 << (bVar8 & 0x1f)) != 0) {
      uVar7 = local_14[iVar15] & ~(-1 << (bVar8 & 0x1f));
      iVar13 = iVar15;
      while (uVar7 == 0) {
        iVar13 = iVar13 + 1;
        if (2 < iVar13) goto LAB_10030571;
        uVar7 = local_14[iVar13];
      }
      iVar13 = (int)((iVar6 >> 0x1f & 0x1fU) + iVar6) >> 5;
      bVar5 = false;
      uVar7 = 1 << (0x1f - ((byte)iVar6 & 0x1f) & 0x1f);
      uVar9 = uVar7 + local_14[iVar13];
      bVar4 = false;
      if ((uVar9 < local_14[iVar13]) || (uVar9 < uVar7)) {
        bVar4 = true;
        bVar5 = true;
      }
      local_14[iVar13] = uVar9;
      while ((iVar13 = iVar13 + -1, -1 < iVar13 && (bVar4))) {
        bVar4 = false;
        bVar5 = false;
        uVar7 = local_14[iVar13] + 1;
        if ((uVar7 < local_14[iVar13]) || (uVar7 == 0)) {
          bVar4 = true;
          bVar5 = true;
        }
        local_14[iVar13] = uVar7;
      }
    }
LAB_10030571:
    local_14[iVar15] = local_14[iVar15] & -1 << (bVar8 & 0x1f);
    iVar15 = iVar15 + 1;
    if (iVar15 < 3) {
      puVar10 = local_14 + iVar15;
      for (iVar13 = 3 - iVar15; iVar13 != 0; iVar13 = iVar13 + -1) {
        *puVar10 = 0;
        puVar10 = puVar10 + 1;
      }
    }
    puVar10 = puVar12;
    if (bVar5) {
      puVar10 = (uint *)(uVar11 - 0x3ffe);
    }
    if ((int)puVar10 < (int)DAT_100477f8 - DAT_100477fc) {
      local_14[0] = 0;
      local_14[1] = 0;
      local_14[2] = 0;
      puVar12 = DAT_100477f8;
    }
    else {
      if ((int)DAT_100477f8 < (int)puVar10) {
        if ((int)puVar10 < _DAT_100477f4) {
          local_14[0] = local_14[0] & 0x7fffffff;
          iVar15 = DAT_10047808 + (int)puVar10;
          iVar14 = (int)(DAT_10047800 + (DAT_10047800 >> 0x1f & 0x1fU)) >> 5;
          bVar8 = bVar3 & 0x1f;
          local_24 = 0;
          iVar6 = 0;
          do {
            uVar16 = local_14[iVar6] >> bVar8 | local_24;
            local_24 = (local_14[iVar6] & ~(-1 << bVar8)) << (0x20 - bVar8 & 0x1f);
            local_14[iVar6] = uVar16;
            iVar6 = iVar6 + 1;
          } while (iVar6 < 3);
          puVar12 = local_14 + (2 - iVar14);
          iVar6 = 2;
          do {
            if (iVar6 < iVar14) {
              local_14[iVar6] = 0;
            }
            else {
              local_14[iVar6] = *puVar12;
            }
            puVar12 = puVar12 + -1;
            iVar6 = iVar6 + -1;
          } while (-1 < iVar6);
        }
        else {
          local_14[1] = 0;
          local_14[2] = 0;
          local_14[0] = 0x80000000;
          iVar15 = (int)(DAT_10047800 + (DAT_10047800 >> 0x1f & 0x1fU)) >> 5;
          bVar8 = bVar3 & 0x1f;
          local_24 = 0;
          do {
            uVar16 = local_14[iVar14] >> bVar8 | local_24;
            local_24 = (local_14[iVar14] & ~(-1 << bVar8)) << (0x20 - bVar8 & 0x1f);
            local_14[iVar14] = uVar16;
            iVar14 = iVar14 + 1;
          } while (iVar14 < 3);
          puVar12 = local_14 + (2 - iVar15);
          iVar14 = 2;
          do {
            if (iVar14 < iVar15) {
              local_14[iVar14] = 0;
            }
            else {
              local_14[iVar14] = *puVar12;
            }
            puVar12 = puVar12 + -1;
            iVar14 = iVar14 + -1;
          } while (-1 < iVar14);
          iVar15 = DAT_10047808 + _DAT_100477f4;
        }
        goto LAB_10030922;
      }
      iVar13 = (int)DAT_100477f8 - (int)puVar12;
      local_14[0] = uVar16;
      iVar15 = (int)(iVar13 + (iVar13 >> 0x1f & 0x1fU)) >> 5;
      local_14[1] = uVar17;
      local_14[2] = (uint)uVar2 << 0x10;
      bVar8 = (byte)iVar13 & 0x1f;
      local_24 = 0;
      do {
        uVar16 = local_14[iVar14] >> bVar8 | local_24;
        local_24 = (local_14[iVar14] & ~(-1 << bVar8)) << (0x20 - bVar8 & 0x1f);
        local_14[iVar14] = uVar16;
        iVar14 = iVar14 + 1;
      } while (iVar14 < 3);
      puVar12 = local_14 + (2 - iVar15);
      iVar14 = 2;
      do {
        if (iVar14 < iVar15) {
          local_14[iVar14] = 0;
        }
        else {
          local_14[iVar14] = *puVar12;
        }
        puVar12 = puVar12 + -1;
        iVar14 = iVar14 + -1;
      } while (-1 < iVar14);
      iVar14 = (int)((DAT_100477fc >> 0x1f & 0x1fU) + DAT_100477fc) >> 5;
      bVar8 = 0x1f - ((byte)DAT_100477fc & 0x1f);
      if ((local_14[iVar14] & 1 << (bVar8 & 0x1f)) != 0) {
        uVar16 = local_14[iVar14] & ~(-1 << (bVar8 & 0x1f));
        iVar15 = iVar14;
        while (uVar16 == 0) {
          iVar15 = iVar15 + 1;
          if (2 < iVar15) goto LAB_1003072c;
          uVar16 = local_14[iVar15];
        }
        iVar15 = (int)((iVar6 >> 0x1f & 0x1fU) + iVar6) >> 5;
        uVar16 = 1 << (0x1f - ((byte)iVar6 & 0x1f) & 0x1f);
        bVar5 = false;
        uVar17 = uVar16 + local_14[iVar15];
        if ((uVar17 < local_14[iVar15]) || (uVar17 < uVar16)) {
          bVar5 = true;
        }
        local_14[iVar15] = uVar17;
        while ((iVar15 = iVar15 + -1, -1 < iVar15 && (bVar5))) {
          bVar5 = false;
          uVar16 = local_14[iVar15] + 1;
          if ((uVar16 < local_14[iVar15]) || (uVar16 == 0)) {
            bVar5 = true;
          }
          local_14[iVar15] = uVar16;
        }
      }
LAB_1003072c:
      local_14[iVar14] = local_14[iVar14] & -1 << (bVar8 & 0x1f);
      iVar14 = iVar14 + 1;
      if (iVar14 < 3) {
        puVar12 = local_14 + iVar14;
        for (iVar15 = 3 - iVar14; iVar15 != 0; iVar15 = iVar15 + -1) {
          *puVar12 = 0;
          puVar12 = puVar12 + 1;
        }
      }
      iVar15 = DAT_10047800 + 1;
      iVar14 = (int)(iVar15 + (iVar15 >> 0x1f & 0x1fU)) >> 5;
      bVar8 = (byte)iVar15 & 0x1f;
      local_24 = 0;
      local_38 = 0;
      do {
        uVar16 = local_14[local_38];
        local_14[local_38] = uVar16 >> bVar8 | local_24;
        local_24 = (uVar16 & ~(-1 << bVar8)) << (0x20 - bVar8 & 0x1f);
        local_38 = local_38 + 1;
      } while (local_38 < 3);
      puVar12 = local_14 + (2 - iVar14);
      iVar15 = 2;
      do {
        if (iVar15 < iVar14) {
          local_14[iVar15] = 0;
        }
        else {
          local_14[iVar15] = *puVar12;
        }
        puVar12 = puVar12 + -1;
        iVar15 = iVar15 + -1;
      } while (-1 < iVar15);
    }
LAB_10030471:
    iVar15 = 0;
  }
LAB_10030922:
  uVar16 = iVar15 << (0x1f - bVar3 & 0x1f) | -(uint)((uVar1 & 0x8000) != 0) & 0x80000000 |
           local_14[0];
  if (DAT_10047804 == 0x40) {
    param_2[1] = uVar16;
    *param_2 = local_14[1];
  }
  else if (DAT_10047804 == 0x20) {
    *param_2 = uVar16;
  }
  FUN_1002534c(local_14[3] ^ (uint)&stack0xfffffffc,(char)puVar12,0);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void __cdecl FUN_1003096e(ushort *param_1,uint *param_2)

{
  ushort uVar1;
  ushort uVar2;
  byte bVar3;
  bool bVar4;
  bool bVar5;
  int iVar6;
  uint uVar7;
  byte bVar8;
  uint uVar9;
  uint *puVar10;
  uint uVar11;
  uint *puVar12;
  int iVar13;
  int iVar14;
  int iVar15;
  uint uVar16;
  uint uVar17;
  int local_38;
  uint local_24;
  uint local_14 [4];
  
  local_14[3] = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  uVar1 = param_1[5];
  iVar14 = 0;
  uVar11 = uVar1 & 0x7fff;
  uVar16 = *(uint *)(param_1 + 3);
  puVar12 = (uint *)(uVar11 - 0x3fff);
  local_14[0] = uVar16;
  uVar17 = *(uint *)(param_1 + 1);
  local_14[1] = uVar17;
  uVar2 = *param_1;
  local_14[2] = (uint)uVar2 << 0x10;
  bVar3 = (byte)DAT_10047818;
  if (puVar12 == (uint *)0xffffc001) {
    iVar15 = 0;
    iVar14 = 0;
    do {
      if (local_14[iVar14] != 0) {
        local_14[0] = 0;
        local_14[1] = 0;
        local_14[2] = 0;
        goto LAB_100309e3;
      }
      iVar14 = iVar14 + 1;
    } while (iVar14 < 3);
  }
  else {
    iVar6 = DAT_10047814 + -1;
    bVar5 = false;
    iVar15 = (int)((DAT_10047814 >> 0x1f & 0x1fU) + DAT_10047814) >> 5;
    bVar8 = 0x1f - ((byte)DAT_10047814 & 0x1f);
    if ((local_14[iVar15] & 1 << (bVar8 & 0x1f)) != 0) {
      uVar7 = local_14[iVar15] & ~(-1 << (bVar8 & 0x1f));
      iVar13 = iVar15;
      while (uVar7 == 0) {
        iVar13 = iVar13 + 1;
        if (2 < iVar13) goto LAB_10030ae3;
        uVar7 = local_14[iVar13];
      }
      iVar13 = (int)((iVar6 >> 0x1f & 0x1fU) + iVar6) >> 5;
      bVar5 = false;
      uVar7 = 1 << (0x1f - ((byte)iVar6 & 0x1f) & 0x1f);
      uVar9 = uVar7 + local_14[iVar13];
      bVar4 = false;
      if ((uVar9 < local_14[iVar13]) || (uVar9 < uVar7)) {
        bVar4 = true;
        bVar5 = true;
      }
      local_14[iVar13] = uVar9;
      while ((iVar13 = iVar13 + -1, -1 < iVar13 && (bVar4))) {
        bVar4 = false;
        bVar5 = false;
        uVar7 = local_14[iVar13] + 1;
        if ((uVar7 < local_14[iVar13]) || (uVar7 == 0)) {
          bVar4 = true;
          bVar5 = true;
        }
        local_14[iVar13] = uVar7;
      }
    }
LAB_10030ae3:
    local_14[iVar15] = local_14[iVar15] & -1 << (bVar8 & 0x1f);
    iVar15 = iVar15 + 1;
    if (iVar15 < 3) {
      puVar10 = local_14 + iVar15;
      for (iVar13 = 3 - iVar15; iVar13 != 0; iVar13 = iVar13 + -1) {
        *puVar10 = 0;
        puVar10 = puVar10 + 1;
      }
    }
    puVar10 = puVar12;
    if (bVar5) {
      puVar10 = (uint *)(uVar11 - 0x3ffe);
    }
    if ((int)puVar10 < (int)DAT_10047810 - DAT_10047814) {
      local_14[0] = 0;
      local_14[1] = 0;
      local_14[2] = 0;
      puVar12 = DAT_10047810;
    }
    else {
      if ((int)DAT_10047810 < (int)puVar10) {
        if ((int)puVar10 < _DAT_1004780c) {
          local_14[0] = local_14[0] & 0x7fffffff;
          iVar15 = DAT_10047820 + (int)puVar10;
          iVar14 = (int)(DAT_10047818 + (DAT_10047818 >> 0x1f & 0x1fU)) >> 5;
          bVar8 = bVar3 & 0x1f;
          local_24 = 0;
          iVar6 = 0;
          do {
            uVar16 = local_14[iVar6] >> bVar8 | local_24;
            local_24 = (local_14[iVar6] & ~(-1 << bVar8)) << (0x20 - bVar8 & 0x1f);
            local_14[iVar6] = uVar16;
            iVar6 = iVar6 + 1;
          } while (iVar6 < 3);
          puVar12 = local_14 + (2 - iVar14);
          iVar6 = 2;
          do {
            if (iVar6 < iVar14) {
              local_14[iVar6] = 0;
            }
            else {
              local_14[iVar6] = *puVar12;
            }
            puVar12 = puVar12 + -1;
            iVar6 = iVar6 + -1;
          } while (-1 < iVar6);
        }
        else {
          local_14[1] = 0;
          local_14[2] = 0;
          local_14[0] = 0x80000000;
          iVar15 = (int)(DAT_10047818 + (DAT_10047818 >> 0x1f & 0x1fU)) >> 5;
          bVar8 = bVar3 & 0x1f;
          local_24 = 0;
          do {
            uVar16 = local_14[iVar14] >> bVar8 | local_24;
            local_24 = (local_14[iVar14] & ~(-1 << bVar8)) << (0x20 - bVar8 & 0x1f);
            local_14[iVar14] = uVar16;
            iVar14 = iVar14 + 1;
          } while (iVar14 < 3);
          puVar12 = local_14 + (2 - iVar15);
          iVar14 = 2;
          do {
            if (iVar14 < iVar15) {
              local_14[iVar14] = 0;
            }
            else {
              local_14[iVar14] = *puVar12;
            }
            puVar12 = puVar12 + -1;
            iVar14 = iVar14 + -1;
          } while (-1 < iVar14);
          iVar15 = DAT_10047820 + _DAT_1004780c;
        }
        goto LAB_10030e94;
      }
      iVar13 = (int)DAT_10047810 - (int)puVar12;
      local_14[0] = uVar16;
      iVar15 = (int)(iVar13 + (iVar13 >> 0x1f & 0x1fU)) >> 5;
      local_14[1] = uVar17;
      local_14[2] = (uint)uVar2 << 0x10;
      bVar8 = (byte)iVar13 & 0x1f;
      local_24 = 0;
      do {
        uVar16 = local_14[iVar14] >> bVar8 | local_24;
        local_24 = (local_14[iVar14] & ~(-1 << bVar8)) << (0x20 - bVar8 & 0x1f);
        local_14[iVar14] = uVar16;
        iVar14 = iVar14 + 1;
      } while (iVar14 < 3);
      puVar12 = local_14 + (2 - iVar15);
      iVar14 = 2;
      do {
        if (iVar14 < iVar15) {
          local_14[iVar14] = 0;
        }
        else {
          local_14[iVar14] = *puVar12;
        }
        puVar12 = puVar12 + -1;
        iVar14 = iVar14 + -1;
      } while (-1 < iVar14);
      iVar14 = (int)((DAT_10047814 >> 0x1f & 0x1fU) + DAT_10047814) >> 5;
      bVar8 = 0x1f - ((byte)DAT_10047814 & 0x1f);
      if ((local_14[iVar14] & 1 << (bVar8 & 0x1f)) != 0) {
        uVar16 = local_14[iVar14] & ~(-1 << (bVar8 & 0x1f));
        iVar15 = iVar14;
        while (uVar16 == 0) {
          iVar15 = iVar15 + 1;
          if (2 < iVar15) goto LAB_10030c9e;
          uVar16 = local_14[iVar15];
        }
        iVar15 = (int)((iVar6 >> 0x1f & 0x1fU) + iVar6) >> 5;
        uVar16 = 1 << (0x1f - ((byte)iVar6 & 0x1f) & 0x1f);
        bVar5 = false;
        uVar17 = uVar16 + local_14[iVar15];
        if ((uVar17 < local_14[iVar15]) || (uVar17 < uVar16)) {
          bVar5 = true;
        }
        local_14[iVar15] = uVar17;
        while ((iVar15 = iVar15 + -1, -1 < iVar15 && (bVar5))) {
          bVar5 = false;
          uVar16 = local_14[iVar15] + 1;
          if ((uVar16 < local_14[iVar15]) || (uVar16 == 0)) {
            bVar5 = true;
          }
          local_14[iVar15] = uVar16;
        }
      }
LAB_10030c9e:
      local_14[iVar14] = local_14[iVar14] & -1 << (bVar8 & 0x1f);
      iVar14 = iVar14 + 1;
      if (iVar14 < 3) {
        puVar12 = local_14 + iVar14;
        for (iVar15 = 3 - iVar14; iVar15 != 0; iVar15 = iVar15 + -1) {
          *puVar12 = 0;
          puVar12 = puVar12 + 1;
        }
      }
      iVar15 = DAT_10047818 + 1;
      iVar14 = (int)(iVar15 + (iVar15 >> 0x1f & 0x1fU)) >> 5;
      bVar8 = (byte)iVar15 & 0x1f;
      local_24 = 0;
      local_38 = 0;
      do {
        uVar16 = local_14[local_38];
        local_14[local_38] = uVar16 >> bVar8 | local_24;
        local_24 = (uVar16 & ~(-1 << bVar8)) << (0x20 - bVar8 & 0x1f);
        local_38 = local_38 + 1;
      } while (local_38 < 3);
      puVar12 = local_14 + (2 - iVar14);
      iVar15 = 2;
      do {
        if (iVar15 < iVar14) {
          local_14[iVar15] = 0;
        }
        else {
          local_14[iVar15] = *puVar12;
        }
        puVar12 = puVar12 + -1;
        iVar15 = iVar15 + -1;
      } while (-1 < iVar15);
    }
LAB_100309e3:
    iVar15 = 0;
  }
LAB_10030e94:
  uVar16 = iVar15 << (0x1f - bVar3 & 0x1f) | -(uint)((uVar1 & 0x8000) != 0) & 0x80000000 |
           local_14[0];
  if (DAT_1004781c == 0x40) {
    param_2[1] = uVar16;
    *param_2 = local_14[1];
  }
  else if (DAT_1004781c == 0x20) {
    *param_2 = uVar16;
  }
  FUN_1002534c(local_14[3] ^ (uint)&stack0xfffffffc,(char)puVar12,0);
  return;
}



void __cdecl FUN_10030ee0(char *param_1,int param_2,uint *param_3)

{
  uint uVar1;
  bool bVar2;
  uint *puVar3;
  short sVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint *puVar9;
  uint uVar10;
  uint uVar11;
  uint local_10;
  uint local_c;
  
  puVar3 = param_3;
  *param_3 = 0;
  param_3[1] = 0;
  param_3[2] = 0;
  if (param_2 != 0) {
    param_3 = (uint *)0x0;
    local_10 = 0;
    local_c = 0;
    do {
      uVar7 = *puVar3;
      uVar6 = puVar3[1];
      uVar10 = puVar3[2];
      uVar1 = local_10 * 4;
      uVar8 = ((int)param_3 * 2 | local_10 >> 0x1f) * 2 | local_10 * 2 >> 0x1f;
      *puVar3 = uVar1;
      uVar11 = (local_c * 2 | (uint)param_3 >> 0x1f) * 2 | (uint)((int)param_3 * 2) >> 0x1f;
      puVar3[1] = uVar8;
      uVar5 = uVar7 + uVar1;
      puVar3[2] = uVar11;
      bVar2 = false;
      if ((uVar5 < uVar1) || (uVar5 < uVar7)) {
        bVar2 = true;
      }
      *puVar3 = uVar5;
      uVar7 = uVar8;
      if (bVar2) {
        bVar2 = false;
        uVar7 = uVar8 + 1;
        if ((uVar7 < uVar8) || (uVar7 == 0)) {
          bVar2 = true;
        }
        puVar3[1] = uVar7;
        if (bVar2) {
          uVar11 = uVar11 + 1;
          puVar3[2] = uVar11;
        }
      }
      bVar2 = false;
      uVar1 = uVar7 + uVar6;
      if ((uVar1 < uVar7) || (uVar1 < uVar6)) {
        bVar2 = true;
      }
      puVar3[1] = uVar1;
      if (bVar2) {
        uVar11 = uVar11 + 1;
        puVar3[2] = uVar11;
      }
      uVar7 = uVar5 * 2;
      puVar9 = (uint *)(uVar1 * 2 | uVar5 >> 0x1f);
      local_c = (uVar11 + uVar10) * 2 | uVar1 >> 0x1f;
      *puVar3 = uVar7;
      puVar3[1] = (uint)puVar9;
      puVar3[2] = local_c;
      local_10 = uVar7 + (int)*param_1;
      if ((local_10 < uVar7) || (local_10 < (uint)(int)*param_1)) {
        bVar2 = true;
      }
      else {
        bVar2 = false;
      }
      *puVar3 = local_10;
      param_3 = puVar9;
      if (bVar2) {
        bVar2 = false;
        param_3 = (uint *)((int)puVar9 + 1);
        if ((param_3 < puVar9) || (param_3 == (uint *)0x0)) {
          bVar2 = true;
        }
        puVar3[1] = (uint)param_3;
        if (bVar2) {
          local_c = local_c + 1;
          puVar3[2] = local_c;
        }
      }
      param_2 = param_2 + -1;
      puVar3[1] = (uint)param_3;
      param_1 = param_1 + 1;
      puVar3[2] = local_c;
    } while (param_2 != 0);
  }
  sVar4 = 0x404e;
  if (puVar3[2] == 0) {
    uVar7 = puVar3[1];
    sVar4 = 0x404e;
    do {
      uVar6 = uVar7 << 0x10 | *puVar3 >> 0x10;
      uVar10 = uVar7 >> 0x10;
      sVar4 = sVar4 + -0x10;
      *puVar3 = *puVar3 << 0x10;
      uVar7 = uVar6;
    } while (uVar10 == 0);
    puVar3[1] = uVar6;
    puVar3[2] = uVar10;
  }
  uVar7 = puVar3[2];
  if ((uVar7 & 0x8000) == 0) {
    uVar6 = *puVar3;
    uVar10 = puVar3[1];
    do {
      uVar5 = uVar10 * 2 | uVar6 >> 0x1f;
      uVar1 = uVar7 * 2;
      uVar7 = uVar1 | uVar10 >> 0x1f;
      sVar4 = sVar4 + -1;
      uVar6 = uVar6 * 2;
      uVar10 = uVar5;
    } while ((uVar1 & 0x8000) == 0);
    *puVar3 = uVar6;
    puVar3[1] = uVar5;
    puVar3[2] = uVar7;
  }
  *(short *)((int)puVar3 + 10) = sVar4;
  return;
}



void __cdecl FUN_100310c0(uint *param_1,char *param_2,pthreadlocinfo *param_3,char **param_4)

{
  undefined extraout_DL;
  undefined in_stack_ffffffd0;
  int local_28;
  char local_24;
  char *local_1c;
  uint *local_18;
  ushort local_14 [6];
  uint local_8;
  
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  local_18 = param_1;
  FUN_1001f92e(&stack0xffffffd0,param_3);
  FUN_100272ab(local_14,&local_1c,param_2,0,0,0,0,(int *)&stack0xffffffd0);
  if (param_4 != (char **)0x0) {
    *param_4 = local_1c;
  }
  FUN_1003096e(local_14,local_18);
  if (local_24 != '\0') {
    *(uint *)(local_28 + 0x70) = *(uint *)(local_28 + 0x70) & 0xfffffffd;
  }
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,extraout_DL,in_stack_ffffffd0);
  return;
}



void __cdecl FUN_10031164(uint *param_1,char *param_2,pthreadlocinfo *param_3)

{
  undefined extraout_DL;
  undefined in_stack_ffffffd4;
  int local_24;
  char local_20;
  char *local_1c;
  undefined4 local_18;
  ushort local_14 [6];
  uint local_8;
  
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  FUN_1001f92e(&stack0xffffffd4,param_3);
  local_18 = FUN_100272ab(local_14,&local_1c,param_2,0,0,0,0,(int *)&stack0xffffffd4);
  FUN_100303fc(local_14,param_1);
  if (local_20 != '\0') {
    *(uint *)(local_24 + 0x70) = *(uint *)(local_24 + 0x70) & 0xfffffffd;
  }
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,extraout_DL,in_stack_ffffffd4);
  return;
}



void __cdecl FUN_100311f2(uint *param_1,char *param_2,pthreadlocinfo *param_3)

{
  FUN_100310c0(param_1,param_2,param_3,(char **)0x0);
  return;
}



// Library Function - Single Match
//  __aulldvrm
// 
// Library: Visual Studio

undefined8 __aulldvrm(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  uint uVar9;
  
  uVar3 = param_1;
  uVar8 = param_4;
  uVar6 = param_2;
  uVar9 = param_3;
  if (param_4 == 0) {
    uVar3 = param_2 / param_3;
    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
                 (ulonglong)param_3);
  }
  else {
    do {
      uVar5 = uVar8 >> 1;
      uVar9 = uVar9 >> 1 | (uint)((uVar8 & 1) != 0) << 0x1f;
      uVar7 = uVar6 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
      uVar8 = uVar5;
      uVar6 = uVar7;
    } while (uVar5 != 0);
    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar9;
    iVar4 = (int)uVar1;
    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
    uVar8 = uVar3 + iVar4 * param_4;
    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar8)) ||
       ((param_2 <= uVar8 && (param_1 < (uint)lVar2)))) {
      iVar4 = iVar4 + -1;
    }
    uVar3 = 0;
  }
  return CONCAT44(uVar3,iVar4);
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

DWORD __cdecl FUN_100312a5(uint param_1)

{
  int *piVar1;
  HANDLE hFile;
  BOOL BVar2;
  ulong *puVar3;
  int iVar4;
  DWORD DVar5;
  
  DVar5 = 0;
  if (param_1 == 0xfffffffe) {
    piVar1 = __errno();
    *piVar1 = 9;
  }
  else {
    if ((-1 < (int)param_1) && (param_1 < DAT_10836b84)) {
      iVar4 = (param_1 & 0x1f) * 0x40;
      if ((*(byte *)(iVar4 + 4 + (&DAT_10835b98)[(int)param_1 >> 5]) & 1) != 0) {
        FUN_100248ff(param_1);
        if ((*(byte *)(iVar4 + 4 + (&DAT_10835b98)[(int)param_1 >> 5]) & 1) != 0) {
          hFile = (HANDLE)FUN_10024bbc(param_1);
          BVar2 = FlushFileBuffers(hFile);
          if (BVar2 == 0) {
            DVar5 = GetLastError();
          }
          if (DVar5 == 0) goto LAB_10031357;
          puVar3 = ___doserrno();
          *puVar3 = DVar5;
        }
        piVar1 = __errno();
        *piVar1 = 9;
        DVar5 = 0xffffffff;
LAB_10031357:
        FUN_1003136d();
        return DVar5;
      }
    }
    piVar1 = __errno();
    *piVar1 = 9;
    FUN_10025625();
  }
  return 0xffffffff;
}



void FUN_1003136d(void)

{
  uint unaff_EDI;
  
  FUN_10024dbb(unaff_EDI);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __getbuf
// 
// Library: Visual Studio 2012 Release

void __cdecl __getbuf(FILE *_File)

{
  char *pcVar1;
  
  _DAT_10835b14 = _DAT_10835b14 + 1;
  pcVar1 = (char *)FUN_10026f23(0x1000);
  _File->_base = pcVar1;
  if (pcVar1 == (char *)0x0) {
    _File->_flag = _File->_flag | 4;
    _File->_base = (char *)&_File->_charbuf;
    _File->_bufsiz = 2;
  }
  else {
    _File->_flag = _File->_flag | 8;
    _File->_bufsiz = 0x1000;
  }
  _File->_cnt = 0;
  _File->_ptr = _File->_base;
  return;
}



// WARNING: Function: __SEH_prolog4 replaced with injection: SEH_prolog4
// WARNING: Function: __SEH_epilog4 replaced with injection: EH_epilog3

int __cdecl
FUN_100313d4(LPCSTR param_1,uint param_2,int param_3,uint param_4,WCHAR **param_5,int param_6)

{
  int *piVar1;
  int iVar2;
  undefined4 local_24;
  int local_20;
  undefined4 uStack12;
  undefined *local_8;
  
  local_8 = &DAT_10040208;
  uStack12 = 0x100313e0;
  local_20 = 0;
  local_24 = 0;
  if (((param_5 == (WCHAR **)0x0) || (*param_5 = (WCHAR *)0xffffffff, param_1 == (LPCSTR)0x0)) ||
     ((param_6 != 0 && ((param_4 & 0xfffffe7f) != 0)))) {
    piVar1 = __errno();
    iVar2 = 0x16;
    *piVar1 = 0x16;
    FUN_10025625();
  }
  else {
    local_8 = (undefined *)0x0;
    iVar2 = FUN_1003149d(&local_24,param_5,param_1,param_2,param_3,(byte)param_4);
    local_8 = (undefined *)0xfffffffe;
    local_20 = iVar2;
    FUN_10031471();
    if (iVar2 != 0) {
      *param_5 = (WCHAR *)0xffffffff;
    }
  }
  return iVar2;
}



void FUN_10031471(void)

{
  byte *pbVar1;
  int unaff_EBP;
  uint *unaff_ESI;
  int unaff_EDI;
  
  if (*(int *)(unaff_EBP + -0x20) != 0) {
    if (unaff_EDI != 0) {
      pbVar1 = (byte *)((&DAT_10835b98)[(int)*unaff_ESI >> 5] + 4 + (*unaff_ESI & 0x1f) * 0x40);
      *pbVar1 = *pbVar1 & 0xfe;
    }
    FUN_10024dbb(*unaff_ESI);
  }
  return;
}



int __cdecl
FUN_1003149d(undefined4 *param_1,WCHAR **param_2,LPCSTR param_3,uint param_4,int param_5,
            byte param_6)

{
  int iVar1;
  LPCWSTR local_8;
  
  local_8 = (LPCWSTR)0x0;
  iVar1 = FUN_10026a0d(param_3,&local_8);
  if (iVar1 == 0) {
    iVar1 = -1;
  }
  else {
    iVar1 = FUN_10032858(param_1,param_2,local_8,param_4,param_5,param_6);
    FID_conflict__free(local_8);
  }
  return iVar1;
}



void __cdecl FUN_100314eb(WCHAR **param_1,LPCSTR param_2,uint param_3,int param_4,uint param_5)

{
  FUN_100313d4(param_2,param_3,param_4,param_5,param_1,1);
  return;
}



void __cdecl FUN_10031509(byte *param_1,byte *param_2,size_t param_3)

{
  FUN_10031521(param_1,param_2,param_3,(pthreadlocinfo *)0x0);
  return;
}



uint __cdecl FUN_10031521(byte *param_1,byte *param_2,size_t param_3,pthreadlocinfo *param_4)

{
  byte bVar1;
  byte bVar2;
  uint uVar3;
  int *piVar4;
  ushort uVar5;
  uint uVar6;
  size_t sVar7;
  byte *pbVar8;
  undefined local_18 [4];
  int local_14;
  int local_10;
  char local_c;
  byte *local_8;
  
  if (param_3 == 0) {
    uVar3 = 0;
  }
  else {
    FUN_1001f92e(local_18,param_4);
    if (*(int *)(local_14 + 8) == 0) {
      uVar3 = _strncmp((char *)param_1,(char *)param_2,param_3);
    }
    else {
      if ((param_1 != (byte *)0x0) && (param_2 != (byte *)0x0)) {
        do {
          bVar2 = *param_1;
          sVar7 = param_3 - 1;
          local_8 = param_1 + 1;
          uVar3 = 0;
          uVar6 = (uint)bVar2;
          if ((*(byte *)(bVar2 + 0x19 + local_14) & 4) == 0) {
LAB_100315d6:
            uVar5 = (ushort)uVar6;
            bVar2 = *param_2;
            pbVar8 = param_2 + 1;
            uVar6 = (uint)bVar2;
            if (((*(byte *)(bVar2 + 0x19 + local_14) & 4) != 0) && (uVar6 = 0, sVar7 != 0)) {
              bVar1 = *pbVar8;
              sVar7 = param_3 - 2;
              if (bVar1 != 0) {
                pbVar8 = param_2 + 2;
                uVar6 = (uint)CONCAT11(bVar2,bVar1);
              }
            }
          }
          else {
            if (sVar7 != 0) {
              bVar1 = *local_8;
              uVar6 = uVar3;
              if (bVar1 != 0) {
                local_8 = param_1 + 2;
                uVar6 = (uint)CONCAT11(bVar2,bVar1);
              }
              goto LAB_100315d6;
            }
            uVar5 = 0;
            if ((*(byte *)(*param_2 + 0x19 + local_14) & 4) != 0) goto LAB_10031622;
            uVar6 = (uint)*param_2;
            pbVar8 = param_2;
          }
          uVar3 = 0;
          if ((ushort)uVar6 != uVar5) {
            uVar3 = (-(uint)((ushort)uVar6 < uVar5) & 2) - 1;
            goto LAB_10031622;
          }
          if ((uVar5 == 0) || (param_1 = local_8, param_3 = sVar7, param_2 = pbVar8, sVar7 == 0))
          goto LAB_10031622;
        } while( true );
      }
      piVar4 = __errno();
      *piVar4 = 0x16;
      FUN_10025625();
      uVar3 = 0x7fffffff;
    }
LAB_10031622:
    if (local_c != '\0') {
      *(uint *)(local_10 + 0x70) = *(uint *)(local_10 + 0x70) & 0xfffffffd;
    }
  }
  return uVar3;
}



void __cdecl FUN_10031638(byte *param_1,byte *param_2,size_t param_3)

{
  FUN_10031650(param_1,param_2,param_3,(pthreadlocinfo *)0x0);
  return;
}



// WARNING: Could not reconcile some variable overlaps

int __cdecl FUN_10031650(byte *param_1,byte *param_2,size_t param_3,pthreadlocinfo *param_4)

{
  byte bVar1;
  ushort uVar2;
  byte *pbVar3;
  int *piVar4;
  int iVar5;
  byte *pbVar6;
  uint uVar7;
  size_t sVar8;
  undefined local_1c [4];
  int local_18;
  int local_14;
  char local_10;
  byte *local_c;
  size_t local_8;
  
  FUN_1001f92e(local_1c,param_4);
  iVar5 = 0;
  if (param_3 != 0) {
    if (*(int *)(local_18 + 8) == 0) {
      iVar5 = __strnicmp((char *)param_1,(char *)param_2,param_3);
    }
    else {
      local_c = param_1;
      if ((param_1 != (byte *)0x0) && (param_2 != (byte *)0x0)) {
        do {
          iVar5 = 0;
          bVar1 = *local_c;
          uVar7 = (uint)bVar1;
          sVar8 = param_3 - 1;
          pbVar3 = local_c + 1;
          if ((*(byte *)(uVar7 + 0x19 + local_18) & 4) == 0) {
            local_8._0_2_ = (ushort)bVar1;
            local_c = pbVar3;
            if ((*(byte *)(uVar7 + 0x19 + local_18) & 0x10) != 0) {
              local_8._0_2_ = (ushort)*(byte *)(uVar7 + 0x119 + local_18);
            }
LAB_10031755:
            local_8 = (size_t)*param_2;
            pbVar6 = param_2 + 1;
            if ((*(byte *)(local_8 + 0x19 + local_18) & 4) == 0) {
              if ((*(byte *)(local_8 + 0x19 + local_18) & 0x10) != 0) {
                bVar1 = *(byte *)(local_8 + 0x119 + local_18);
                goto LAB_100317d1;
              }
            }
            else {
              if (sVar8 != 0) {
                sVar8 = param_3 - 2;
                if (*pbVar6 != 0) {
                  uVar2 = CONCAT11(*param_2,*pbVar6);
                  local_8 = (size_t)uVar2;
                  pbVar6 = param_2 + 2;
                  if ((uVar2 < *(ushort *)(local_18 + 0xc)) ||
                     (*(ushort *)(local_18 + 0xe) <= uVar2 && uVar2 != *(ushort *)(local_18 + 0xe)))
                  {
                    if ((*(ushort *)(local_18 + 0x12) <= uVar2) &&
                       (uVar2 < *(ushort *)(local_18 + 0x14) ||
                        uVar2 == *(ushort *)(local_18 + 0x14))) {
                      local_8 = (size_t)(ushort)(uVar2 + *(short *)(local_18 + 0x16));
                    }
                  }
                  else {
                    local_8 = (size_t)(ushort)(uVar2 + *(short *)(local_18 + 0x10));
                  }
                  goto LAB_100317d8;
                }
              }
              param_3 = 0;
              local_8 = param_3;
            }
          }
          else {
            if (sVar8 != 0) {
              if (*pbVar3 == 0) {
                local_8._0_2_ = 0;
                local_c = pbVar3;
              }
              else {
                local_8._0_2_ = CONCAT11(bVar1,*pbVar3);
                local_c = local_c + 2;
                if (((ushort)local_8 < *(ushort *)(local_18 + 0xc)) ||
                   (*(ushort *)(local_18 + 0xe) <= (ushort)local_8 &&
                    (ushort)local_8 != *(ushort *)(local_18 + 0xe))) {
                  if ((*(ushort *)(local_18 + 0x12) <= (ushort)local_8) &&
                     ((ushort)local_8 < *(ushort *)(local_18 + 0x14) ||
                      (ushort)local_8 == *(ushort *)(local_18 + 0x14))) {
                    local_8._0_2_ = (ushort)local_8 + *(short *)(local_18 + 0x16);
                  }
                }
                else {
                  local_8._0_2_ = (ushort)local_8 + *(short *)(local_18 + 0x10);
                }
              }
              goto LAB_10031755;
            }
            if ((*(byte *)(*param_2 + 0x19 + local_18) & 4) != 0) goto LAB_100317f6;
            bVar1 = *param_2;
            local_8._0_2_ = 0;
            pbVar6 = param_2;
            local_c = pbVar3;
LAB_100317d1:
            local_8 = (size_t)bVar1;
          }
LAB_100317d8:
          iVar5 = 0;
          if ((ushort)local_8 != (ushort)local_8) {
            iVar5 = (-(uint)((ushort)local_8 < (ushort)local_8) & 2) - 1;
            goto LAB_100317f6;
          }
          if (((ushort)local_8 == 0) || (param_2 = pbVar6, param_3 = sVar8, sVar8 == 0))
          goto LAB_100317f6;
        } while( true );
      }
      piVar4 = __errno();
      *piVar4 = 0x16;
      FUN_10025625();
      iVar5 = 0x7fffffff;
    }
  }
LAB_100317f6:
  if (local_10 != '\0') {
    *(uint *)(local_14 + 0x70) = *(uint *)(local_14 + 0x70) & 0xfffffffd;
  }
  return iVar5;
}



byte __cdecl FUN_1003180b(uint param_1)

{
  int *piVar1;
  
  if (param_1 == 0xfffffffe) {
    piVar1 = __errno();
    *piVar1 = 9;
  }
  else {
    if ((-1 < (int)param_1) && (param_1 < DAT_10836b84)) {
      return *(byte *)((&DAT_10835b98)[(int)param_1 >> 5] + 4 + (param_1 & 0x1f) * 0x40) & 0x40;
    }
    piVar1 = __errno();
    *piVar1 = 9;
    FUN_10025625();
  }
  return 0;
}



int __cdecl
FUN_1003185f(int *param_1,uint *param_2,uint param_3,WCHAR param_4,pthreadlocinfo *param_5)

{
  uint *lpMultiByteStr;
  uint cbMultiByte;
  int *piVar1;
  int iVar2;
  DWORD DVar3;
  int iVar4;
  int local_14 [2];
  int local_c;
  char local_8;
  
  cbMultiByte = param_3;
  lpMultiByteStr = param_2;
  if ((param_2 == (uint *)0x0) && (param_3 != 0)) {
    if (param_1 != (int *)0x0) {
      *param_1 = 0;
    }
    return 0;
  }
  if (param_1 != (int *)0x0) {
    *param_1 = -1;
  }
  if (0x7fffffff < param_3) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    return 0x16;
  }
  FUN_1001f92e(local_14,param_5);
  iVar4 = 0;
  if (*(int *)(local_14[0] + 0xa8) == 0) {
    if ((ushort)param_4 < 0x100) {
      if (lpMultiByteStr != (uint *)0x0) {
        if (cbMultiByte == 0) goto LAB_1003196f;
        *(char *)lpMultiByteStr = (char)param_4;
      }
      if (param_1 != (int *)0x0) {
        *param_1 = 1;
      }
      goto LAB_100318f2;
    }
    if ((lpMultiByteStr != (uint *)0x0) && (cbMultiByte != 0)) {
      FUN_10021290(lpMultiByteStr,0,cbMultiByte);
    }
  }
  else {
    param_2 = (uint *)0x0;
    iVar2 = WideCharToMultiByte(*(UINT *)(local_14[0] + 4),0,&param_4,1,(LPSTR)lpMultiByteStr,
                                cbMultiByte,(LPCSTR)0x0,(LPBOOL)&param_2);
    if (iVar2 == 0) {
      DVar3 = GetLastError();
      if (DVar3 == 0x7a) {
        if ((lpMultiByteStr != (uint *)0x0) && (cbMultiByte != 0)) {
          FUN_10021290(lpMultiByteStr,0,cbMultiByte);
        }
LAB_1003196f:
        piVar1 = __errno();
        iVar4 = 0x22;
        *piVar1 = 0x22;
        FUN_10025625();
        goto LAB_100318f2;
      }
    }
    else if (param_2 == (uint *)0x0) {
      if (param_1 != (int *)0x0) {
        *param_1 = iVar2;
      }
      goto LAB_100318f2;
    }
  }
  piVar1 = __errno();
  *piVar1 = 0x2a;
  piVar1 = __errno();
  iVar4 = *piVar1;
LAB_100318f2:
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return iVar4;
}



void __cdecl FUN_10031983(int *param_1,uint *param_2,uint param_3,WCHAR param_4)

{
  FUN_1003185f(param_1,param_2,param_3,param_4,(pthreadlocinfo *)0x0);
  return;
}



uint FUN_1003199e(void)

{
  _ptiddata p_Var1;
  pthreadlocinfo ptVar2;
  
  p_Var1 = __getptd();
  ptVar2 = p_Var1->ptlocinfo;
  if ((ptVar2 != (pthreadlocinfo)PTR_DAT_100472c4) && ((p_Var1->_ownlocale & DAT_10047388) == 0)) {
    ptVar2 = FUN_100258ef();
  }
  return ptVar2->lc_codepage;
}



// Library Function - Single Match
//  _wcscat_s
// 
// Library: Visual Studio 2012 Release

errno_t __cdecl _wcscat_s(wchar_t *_Dst,rsize_t _SizeInWords,wchar_t *_Src)

{
  wchar_t wVar1;
  int *piVar2;
  wchar_t *pwVar3;
  int iVar4;
  int iStack16;
  
  if ((_Dst != (wchar_t *)0x0) && (_SizeInWords != 0)) {
    pwVar3 = _Dst;
    if (_Src != (wchar_t *)0x0) {
      do {
        if (*pwVar3 == L'\0') break;
        pwVar3 = pwVar3 + 1;
        _SizeInWords = _SizeInWords - 1;
      } while (_SizeInWords != 0);
      if (_SizeInWords != 0) {
        iVar4 = (int)pwVar3 - (int)_Src;
        do {
          wVar1 = *_Src;
          *(wchar_t *)(iVar4 + (int)_Src) = wVar1;
          _Src = _Src + 1;
          if (wVar1 == L'\0') break;
          _SizeInWords = _SizeInWords - 1;
        } while (_SizeInWords != 0);
        if (_SizeInWords != 0) {
          return 0;
        }
        *_Dst = L'\0';
        piVar2 = __errno();
        iStack16 = 0x22;
        goto LAB_100319ea;
      }
    }
    *_Dst = L'\0';
  }
  piVar2 = __errno();
  iStack16 = 0x16;
LAB_100319ea:
  *piVar2 = iStack16;
  FUN_10025625();
  return iStack16;
}



// Library Function - Single Match
//  _wcscpy_s
// 
// Library: Visual Studio 2012 Release

errno_t __cdecl _wcscpy_s(wchar_t *_Dst,rsize_t _SizeInWords,wchar_t *_Src)

{
  wchar_t wVar1;
  int *piVar2;
  int iVar3;
  
  if ((_Dst != (wchar_t *)0x0) && (_SizeInWords != 0)) {
    if (_Src != (wchar_t *)0x0) {
      iVar3 = (int)_Dst - (int)_Src;
      do {
        wVar1 = *_Src;
        *(wchar_t *)(iVar3 + (int)_Src) = wVar1;
        _Src = _Src + 1;
        if (wVar1 == L'\0') break;
        _SizeInWords = _SizeInWords - 1;
      } while (_SizeInWords != 0);
      if (_SizeInWords != 0) {
        return 0;
      }
      *_Dst = L'\0';
      piVar2 = __errno();
      iVar3 = 0x22;
      goto LAB_10031a55;
    }
    *_Dst = L'\0';
  }
  piVar2 = __errno();
  iVar3 = 0x16;
LAB_10031a55:
  *piVar2 = iVar3;
  FUN_10025625();
  return iVar3;
}



// Library Function - Single Match
//  _wcslen
// 
// Libraries: Visual Studio 2010 Release, Visual Studio 2012 Release, Visual Studio 2015 Release,
// Visual Studio 2019 Release

size_t __cdecl _wcslen(wchar_t *_Str)

{
  wchar_t wVar1;
  wchar_t *pwVar2;
  
  pwVar2 = _Str;
  do {
    wVar1 = *pwVar2;
    pwVar2 = pwVar2 + 1;
  } while (wVar1 != L'\0');
  return ((int)pwVar2 - (int)_Str >> 1) - 1;
}



int __cdecl FUN_10031aa5(short *param_1,int param_2,short *param_3,int param_4)

{
  short sVar1;
  int *piVar2;
  int iVar3;
  short *psVar4;
  int iVar5;
  
  if (param_4 == 0) {
    if (param_1 == (short *)0x0) {
      if (param_2 == 0) {
        return 0;
      }
    }
    else {
LAB_10031ac4:
      if (param_2 != 0) {
        if (param_4 == 0) {
          *param_1 = 0;
          return 0;
        }
        if (param_3 != (short *)0x0) {
          iVar5 = param_2;
          if (param_4 == -1) {
            iVar3 = (int)param_1 - (int)param_3;
            do {
              sVar1 = *param_3;
              *(short *)(iVar3 + (int)param_3) = sVar1;
              param_3 = param_3 + 1;
              if (sVar1 == 0) break;
              iVar5 = iVar5 + -1;
            } while (iVar5 != 0);
          }
          else {
            psVar4 = param_1;
            do {
              sVar1 = *(short *)(((int)param_3 - (int)param_1) + (int)psVar4);
              *psVar4 = sVar1;
              psVar4 = psVar4 + 1;
              if ((sVar1 == 0) || (iVar5 = iVar5 + -1, iVar5 == 0)) break;
              param_4 = param_4 + -1;
            } while (param_4 != 0);
            if (param_4 == 0) {
              *psVar4 = 0;
            }
          }
          if (iVar5 != 0) {
            return 0;
          }
          if (param_4 == -1) {
            param_1[param_2 + -1] = 0;
            return 0x50;
          }
          *param_1 = 0;
          piVar2 = __errno();
          iVar5 = 0x22;
          goto LAB_10031ae9;
        }
        *param_1 = 0;
      }
    }
  }
  else if (param_1 != (short *)0x0) goto LAB_10031ac4;
  piVar2 = __errno();
  iVar5 = 0x16;
LAB_10031ae9:
  *piVar2 = iVar5;
  FUN_10025625();
  return iVar5;
}



ushort __cdecl FUN_10031b63(int param_1,pthreadlocinfo *param_2)

{
  ushort uVar1;
  pthreadlocinfo local_14 [2];
  int local_c;
  char local_8;
  
  FUN_1001f92e(local_14,param_2);
  if (local_14[0]->mb_cur_max < 2) {
    uVar1 = local_14[0]->pctype[param_1] & 4;
  }
  else {
    uVar1 = FUN_10027a53(param_1,4,local_14);
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  _isdigit
// 
// Library: Visual Studio 2012 Release

int __cdecl _isdigit(int _C)

{
  ushort uVar1;
  undefined2 extraout_var;
  
  if (_DAT_10835ca0 == 0) {
    return *(ushort *)(PTR_DAT_10047358 + _C * 2) & 4;
  }
  uVar1 = FUN_10031b63(_C,(pthreadlocinfo *)0x0);
  return CONCAT22(extraout_var,uVar1);
}



int __cdecl FUN_10031be0(char *param_1,uint param_2,int param_3,int param_4)

{
  char *_Str;
  int *piVar1;
  char *pcVar2;
  size_t sVar3;
  char cVar4;
  char *pcVar5;
  int iVar6;
  
  pcVar5 = *(char **)(param_4 + 0xc);
  if ((param_1 == (char *)0x0) || (param_2 == 0)) {
    piVar1 = __errno();
    iVar6 = 0x16;
  }
  else {
    *param_1 = '\0';
    iVar6 = param_3;
    if (param_3 < 1) {
      iVar6 = 0;
    }
    if (iVar6 + 1U < param_2) {
      *param_1 = '0';
      _Str = param_1 + 1;
      pcVar2 = _Str;
      if (0 < param_3) {
        do {
          cVar4 = *pcVar5;
          if (cVar4 == '\0') {
            cVar4 = '0';
          }
          else {
            pcVar5 = pcVar5 + 1;
          }
          *pcVar2 = cVar4;
          pcVar2 = pcVar2 + 1;
          param_3 = param_3 + -1;
        } while (0 < param_3);
      }
      *pcVar2 = '\0';
      if ((-1 < param_3) && ('4' < *pcVar5)) {
        while (pcVar2 = pcVar2 + -1, *pcVar2 == '9') {
          *pcVar2 = '0';
        }
        *pcVar2 = *pcVar2 + '\x01';
      }
      if (*param_1 == '1') {
        *(int *)(param_4 + 4) = *(int *)(param_4 + 4) + 1;
      }
      else {
        sVar3 = _strlen(_Str);
        FID_conflict__memcpy(param_1,_Str,sVar3 + 1);
      }
      return 0;
    }
    piVar1 = __errno();
    iVar6 = 0x22;
  }
  *piVar1 = iVar6;
  FUN_10025625();
  return iVar6;
}



void __cdecl FUN_10031c90(uint *param_1,uint *param_2)

{
  uint uVar1;
  ushort uVar2;
  ushort uVar3;
  uint uVar4;
  uint uVar5;
  ushort uVar6;
  
  uVar4 = 0x80000000;
  uVar1 = *param_2;
  uVar6 = *(ushort *)((int)param_2 + 6) & 0x8000;
  uVar2 = *(ushort *)((int)param_2 + 6) >> 4;
  uVar3 = uVar2 & 0x7ff;
  if ((uVar2 & 0x7ff) == 0) {
    if (((param_2[1] & 0xfffff) == 0) && (uVar1 == 0)) {
      param_1[1] = 0;
      *param_1 = 0;
      *(ushort *)(param_1 + 2) = uVar6;
      return;
    }
    uVar3 = uVar3 + 0x3c01;
    uVar4 = 0;
  }
  else if (uVar3 == 0x7ff) {
    uVar3 = 0x7fff;
  }
  else {
    uVar3 = uVar3 + 0x3c00;
  }
  uVar5 = uVar1 >> 0x15 | (param_2[1] & 0xfffff) << 0xb | uVar4;
  param_1[1] = uVar5;
  *param_1 = uVar1 << 0xb;
  if (uVar4 == 0) {
    do {
      uVar3 = uVar3 - 1;
      uVar5 = uVar5 * 2 | *param_1 >> 0x1f;
      *param_1 = *param_1 * 2;
    } while (-1 < (int)uVar5);
    param_1[1] = uVar5;
  }
  *(ushort *)(param_1 + 2) = uVar6 | uVar3;
  return;
}



void __cdecl
FUN_10031d58(uint param_1,undefined4 param_2,int *param_3,char *param_4,rsize_t param_5)

{
  code *pcVar1;
  int *piVar2;
  char *_Dst;
  int iVar3;
  errno_t eVar4;
  undefined extraout_DL;
  undefined uVar5;
  uint in_stack_ffffffcc;
  uint uStack48;
  ushort uStack44;
  short local_24;
  char local_22;
  char local_20 [24];
  uint local_8;
  
  _Dst = param_4;
  piVar2 = param_3;
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  FUN_10031c90((uint *)&stack0xffffffcc,&param_1);
  iVar3 = FUN_10033144(in_stack_ffffffcc,uStack48,uStack44,0x11,0,&local_24);
  uVar5 = (undefined)in_stack_ffffffcc;
  piVar2[2] = iVar3;
  *piVar2 = (int)local_22;
  piVar2[1] = (int)local_24;
  eVar4 = _strcpy_s(_Dst,param_5,local_20);
  if (eVar4 == 0) {
    piVar2[3] = (int)_Dst;
    FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,extraout_DL,uVar5);
    return;
  }
  __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



// Library Function - Single Match
//  __alldvrm
// 
// Library: Visual Studio

undefined8 __alldvrm(uint param_1,uint param_2,uint param_3,uint param_4)

{
  ulonglong uVar1;
  longlong lVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  uint uVar6;
  uint uVar7;
  uint uVar8;
  bool bVar10;
  char cVar11;
  uint uVar9;
  
  cVar11 = (int)param_2 < 0;
  if ((bool)cVar11) {
    bVar10 = param_1 != 0;
    param_1 = -param_1;
    param_2 = -(uint)bVar10 - param_2;
  }
  if ((int)param_4 < 0) {
    cVar11 = cVar11 + '\x01';
    bVar10 = param_3 != 0;
    param_3 = -param_3;
    param_4 = -(uint)bVar10 - param_4;
  }
  uVar3 = param_1;
  uVar5 = param_3;
  uVar6 = param_2;
  uVar9 = param_4;
  if (param_4 == 0) {
    uVar3 = param_2 / param_3;
    iVar4 = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) /
                 (ulonglong)param_3);
  }
  else {
    do {
      uVar8 = uVar9 >> 1;
      uVar5 = uVar5 >> 1 | (uint)((uVar9 & 1) != 0) << 0x1f;
      uVar7 = uVar6 >> 1;
      uVar3 = uVar3 >> 1 | (uint)((uVar6 & 1) != 0) << 0x1f;
      uVar6 = uVar7;
      uVar9 = uVar8;
    } while (uVar8 != 0);
    uVar1 = CONCAT44(uVar7,uVar3) / (ulonglong)uVar5;
    iVar4 = (int)uVar1;
    lVar2 = (ulonglong)param_3 * (uVar1 & 0xffffffff);
    uVar3 = (uint)((ulonglong)lVar2 >> 0x20);
    uVar5 = uVar3 + iVar4 * param_4;
    if (((CARRY4(uVar3,iVar4 * param_4)) || (param_2 < uVar5)) ||
       ((param_2 <= uVar5 && (param_1 < (uint)lVar2)))) {
      iVar4 = iVar4 + -1;
    }
    uVar3 = 0;
  }
  if (cVar11 == '\x01') {
    bVar10 = iVar4 != 0;
    iVar4 = -iVar4;
    uVar3 = -(uint)bVar10 - uVar3;
  }
  return CONCAT44(uVar3,iVar4);
}



// Library Function - Single Match
//  __aullshr
// 
// Library: Visual Studio

ulonglong __fastcall __aullshr(byte param_1,uint param_2)

{
  uint in_EAX;
  
  if (0x3f < param_1) {
    return 0;
  }
  if (param_1 < 0x20) {
    return CONCAT44(param_2 >> (param_1 & 0x1f),
                    in_EAX >> (param_1 & 0x1f) | param_2 << 0x20 - (param_1 & 0x1f));
  }
  return (ulonglong)(param_2 >> (param_1 & 0x1f));
}



// Library Function - Single Match
//  __controlfp_s
// 
// Library: Visual Studio 2012 Release

errno_t __cdecl __controlfp_s(uint *_CurrentState,uint _NewValue,uint _Mask)

{
  int *piVar1;
  uint uVar2;
  errno_t eVar3;
  
  uVar2 = _Mask & 0xfff7ffff;
  if ((_NewValue & uVar2 & 0xfcf0fce0) == 0) {
    if (_CurrentState == (uint *)0x0) {
      FUN_10033bc1(_NewValue,uVar2);
    }
    else {
      uVar2 = FUN_10033bc1(_NewValue,uVar2);
      *_CurrentState = uVar2;
    }
    eVar3 = 0;
  }
  else {
    if (_CurrentState != (uint *)0x0) {
      uVar2 = FUN_10033bc1(0,0);
      *_CurrentState = uVar2;
    }
    piVar1 = __errno();
    eVar3 = 0x16;
    *piVar1 = 0x16;
    FUN_10025625();
  }
  return eVar3;
}



void FUN_10031f4c(void)

{
  __amsg_exit(2);
  return;
}



float10 __fastcall
FUN_10032130(undefined4 param_1,int param_2,ushort param_3,undefined4 param_4,undefined4 param_5,
            undefined4 param_6,undefined4 param_7,undefined4 param_8)

{
  float10 in_ST0;
  int local_24;
  undefined4 uStack32;
  undefined4 uStack28;
  undefined4 uStack24;
  undefined4 local_14;
  undefined4 local_10;
  double dStack12;
  
  local_14 = param_7;
  local_10 = param_8;
  dStack12 = (double)in_ST0;
  uStack28 = param_5;
  uStack24 = param_6;
  uStack32 = param_1;
  __87except(param_2,&local_24,&param_3);
  return (float10)dStack12;
}



// Library Function - Single Match
//  __startOneArgErrorHandling
// 
// Library: Visual Studio 2019 Release

float10 __fastcall
__startOneArgErrorHandling
          (undefined4 param_1,int param_2,ushort param_3,undefined4 param_4,undefined4 param_5,
          undefined4 param_6)

{
  float10 in_ST0;
  int local_24;
  undefined4 local_20;
  undefined4 local_1c;
  undefined4 local_18;
  double local_c;
  
  local_c = (double)in_ST0;
  local_1c = param_5;
  local_18 = param_6;
  local_20 = param_1;
  __87except(param_2,&local_24,&param_3);
  return (float10)local_c;
}



void FUN_100321a5(undefined4 param_1)

{
  return;
}



undefined4 FUN_100321bc(void)

{
  uint in_EAX;
  
  if ((in_EAX & 0x80000) != 0) {
    return 7;
  }
  return 1;
}



uint __cdecl FUN_10032218(undefined4 param_1,uint param_2)

{
  if ((param_2 & 0x7ff00000) != 0x7ff00000) {
    return param_2 & 0x7ff00000;
  }
  return param_2;
}



// Library Function - Single Match
//  __set_error_mode
// 
// Library: Visual Studio 2012 Release

int __cdecl __set_error_mode(int _Mode)

{
  int iVar1;
  int *piVar2;
  
  iVar1 = DAT_10836a18;
  if (_Mode < 0) {
LAB_10032347:
    piVar2 = __errno();
    *piVar2 = 0x16;
    FUN_10025625();
    return -1;
  }
  if (_Mode < 3) {
    DAT_10836a18 = _Mode;
  }
  else if (_Mode != 3) goto LAB_10032347;
  return iVar1;
}



void __cdecl FUN_1003235c(LPCWSTR param_1,undefined4 param_2,uint param_3)

{
  bool bVar1;
  PVOID pvVar2;
  undefined3 extraout_var;
  HMODULE hModule;
  DWORD DVar3;
  FARPROC pFVar4;
  BOOL BVar5;
  code *pcVar6;
  code *pcVar7;
  int iVar8;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined extraout_DL_01;
  undefined extraout_DL_02;
  undefined extraout_DL_03;
  undefined extraout_DL_04;
  undefined extraout_DL_05;
  undefined extraout_DL_06;
  undefined uVar9;
  int iVar10;
  undefined in_stack_ffffffd8;
  undefined local_14 [8];
  byte local_c;
  uint local_8;
  
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  iVar10 = 0;
  pvVar2 = EncodePointer((PVOID)0x0);
  bVar1 = FUN_1002bd88();
  if (DAT_10836a1c == (PVOID)0x0) {
    hModule = LoadLibraryExW(L"USER32.DLL",(HANDLE)0x0,0x800);
    if (((hModule == (HMODULE)0x0) &&
        ((DVar3 = GetLastError(), uVar9 = extraout_DL, DVar3 != 0x57 ||
         (hModule = LoadLibraryExW(L"USER32.DLL",(HANDLE)0x0,0), uVar9 = extraout_DL_00,
         hModule == (HMODULE)0x0)))) ||
       (pFVar4 = GetProcAddress(hModule,"MessageBoxW"), uVar9 = extraout_DL_01,
       pFVar4 == (FARPROC)0x0)) goto LAB_10032531;
    DAT_10836a1c = EncodePointer(pFVar4);
    pFVar4 = GetProcAddress(hModule,"GetActiveWindow");
    DAT_10836a20 = EncodePointer(pFVar4);
    pFVar4 = GetProcAddress(hModule,"GetLastActivePopup");
    DAT_10836a24 = EncodePointer(pFVar4);
    pFVar4 = GetProcAddress(hModule,"GetUserObjectInformationW");
    DAT_10836a2c = EncodePointer(pFVar4);
    if (DAT_10836a2c != (PVOID)0x0) {
      pFVar4 = GetProcAddress(hModule,"GetProcessWindowStation");
      DAT_10836a28 = EncodePointer(pFVar4);
    }
  }
  BVar5 = IsDebuggerPresent();
  if (BVar5 == 0) {
    if (CONCAT31(extraout_var,bVar1) != 0) {
      DecodePointer(DAT_10836a1c);
      uVar9 = extraout_DL_04;
      goto LAB_10032531;
    }
  }
  else {
    uVar9 = extraout_DL_02;
    if (param_1 != (LPCWSTR)0x0) {
      OutputDebugStringW(param_1);
      uVar9 = extraout_DL_03;
    }
    if (CONCAT31(extraout_var,bVar1) != 0) goto LAB_10032531;
  }
  if ((DAT_10836a28 == pvVar2) || (DAT_10836a2c == pvVar2)) {
LAB_100324e7:
    if ((((DAT_10836a20 != pvVar2) &&
         (pcVar6 = (code *)DecodePointer(DAT_10836a20), pcVar6 != (code *)0x0)) &&
        (iVar10 = (*pcVar6)(), iVar10 != 0)) &&
       ((DAT_10836a24 != pvVar2 &&
        (pcVar6 = (code *)DecodePointer(DAT_10836a24), pcVar6 != (code *)0x0)))) {
      iVar10 = (*pcVar6)(iVar10);
    }
  }
  else {
    pcVar6 = (code *)DecodePointer(DAT_10836a28);
    pcVar7 = (code *)DecodePointer(DAT_10836a2c);
    if (((pcVar6 == (code *)0x0) || (pcVar7 == (code *)0x0)) ||
       (((iVar8 = (*pcVar6)(), iVar8 != 0 &&
         (iVar8 = (*pcVar7)(iVar8,1,local_14,0xc,&stack0xffffffd8), iVar8 != 0)) &&
        ((local_c & 1) != 0)))) goto LAB_100324e7;
    param_3 = param_3 | 0x200000;
  }
  pcVar6 = (code *)DecodePointer(DAT_10836a1c);
  uVar9 = extraout_DL_05;
  if (pcVar6 != (code *)0x0) {
    (*pcVar6)(iVar10,param_1,param_2,param_3);
    uVar9 = extraout_DL_06;
  }
LAB_10032531:
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,uVar9,in_stack_ffffffd8);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __getenv_helper_nolock
// 
// Library: Visual Studio 2012 Release

char * __cdecl __getenv_helper_nolock(char *param_1)

{
  int iVar1;
  size_t _MaxCount;
  size_t sVar2;
  uchar **ppuVar3;
  
  if (((_DAT_10836b98 != 0) &&
      ((DAT_10835b6c != (uchar **)0x0 ||
       (((DAT_10835b70 != 0 && (iVar1 = FUN_10034063(), iVar1 == 0)) &&
        (DAT_10835b6c != (uchar **)0x0)))))) && (ppuVar3 = DAT_10835b6c, param_1 != (char *)0x0)) {
    _MaxCount = _strlen(param_1);
    for (; *ppuVar3 != (uchar *)0x0; ppuVar3 = ppuVar3 + 1) {
      sVar2 = _strlen((char *)*ppuVar3);
      if (((_MaxCount < sVar2) && ((*ppuVar3)[_MaxCount] == '=')) &&
         (iVar1 = __mbsnbicoll(*ppuVar3,(uchar *)param_1,_MaxCount), iVar1 == 0)) {
        return (char *)(*ppuVar3 + _MaxCount + 1);
      }
    }
  }
  return (char *)0x0;
}



byte __cdecl FUN_100325c6(int param_1)

{
  return -(param_1 != 0) & 1;
}



// WARNING: This is an inlined function
// WARNING: Unable to track spacebase fully for stack
// WARNING: Variable defined which should be unmapped: param_1
// Library Function - Single Match
//  __EH_prolog3_catch
// 
// Libraries: Visual Studio 2005, Visual Studio 2008, Visual Studio 2010, Visual Studio 2012

void __cdecl __EH_prolog3_catch(int param_1)

{
  int iVar1;
  undefined4 unaff_EBX;
  undefined4 unaff_ESI;
  undefined4 unaff_EDI;
  int *in_FS_OFFSET;
  undefined4 unaff_retaddr;
  uint auStack28 [5];
  undefined local_8 [8];
  
  iVar1 = -param_1;
  *(undefined4 *)((int)auStack28 + iVar1 + 0x10) = unaff_EBX;
  *(undefined4 *)((int)auStack28 + iVar1 + 0xc) = unaff_ESI;
  *(undefined4 *)((int)auStack28 + iVar1 + 8) = unaff_EDI;
  *(uint *)((int)auStack28 + iVar1 + 4) = DAT_10046c24 ^ (uint)&param_1;
  *(undefined4 *)((int)auStack28 + iVar1) = unaff_retaddr;
  *in_FS_OFFSET = (int)local_8;
  return;
}



undefined4 __cdecl FUN_1003260b(LPWSTR param_1,byte *param_2,uint param_3,pthreadlocinfo *param_4)

{
  uint uVar1;
  ushort uVar2;
  undefined2 extraout_var;
  int iVar3;
  int *piVar4;
  int iVar5;
  pthreadlocinfo local_14 [2];
  int local_c;
  char local_8;
  
  if ((param_2 == (byte *)0x0) || (param_3 == 0)) {
    return 0;
  }
  if (*param_2 == 0) {
    if (param_1 == (LPWSTR)0x0) {
      return 0;
    }
    *param_1 = L'\0';
    return 0;
  }
  FUN_1001f92e(local_14,param_4);
  if (local_14[0]->locale_name[2] == (wchar_t *)0x0) {
    if (param_1 != (LPWSTR)0x0) {
      *param_1 = (ushort)*param_2;
    }
    iVar5 = 1;
    goto LAB_100326eb;
  }
  uVar2 = FUN_10029715((uint)*param_2,local_14);
  if (CONCAT22(extraout_var,uVar2) == 0) {
    iVar5 = 1;
    iVar3 = MultiByteToWideChar(local_14[0]->lc_codepage,9,(LPCSTR)param_2,1,param_1,
                                (uint)(param_1 != (LPWSTR)0x0));
    if (iVar3 != 0) goto LAB_100326eb;
LAB_100326dd:
    piVar4 = __errno();
    iVar5 = -1;
    *piVar4 = 0x2a;
  }
  else {
    if (local_14[0]->mb_cur_max < 2) {
LAB_100326aa:
      uVar1 = local_14[0]->mb_cur_max;
LAB_100326ad:
      if ((param_3 < uVar1) || (param_2[1] == 0)) goto LAB_100326dd;
    }
    else {
      uVar1 = local_14[0]->mb_cur_max;
      if ((int)param_3 < local_14[0]->mb_cur_max) goto LAB_100326ad;
      iVar5 = MultiByteToWideChar(local_14[0]->lc_codepage,9,(LPCSTR)param_2,local_14[0]->mb_cur_max
                                  ,param_1,(uint)(param_1 != (LPWSTR)0x0));
      if (iVar5 == 0) goto LAB_100326aa;
    }
    iVar5 = local_14[0]->mb_cur_max;
  }
LAB_100326eb:
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
    return iVar5;
  }
  return iVar5;
}



void __cdecl FUN_10032700(LPWSTR param_1,byte *param_2,uint param_3)

{
  FUN_1003260b(param_1,param_2,param_3,(pthreadlocinfo *)0x0);
  return;
}



// Library Function - Single Match
//  __putwch_nolock
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

wint_t __cdecl __putwch_nolock(wchar_t _WCh)

{
  BOOL BVar1;
  DWORD local_8;
  
  if (DAT_10047b00 == (HANDLE)0xfffffffe) {
    ___dcrt_lowio_initialize_console_output();
  }
  if ((DAT_10047b00 == (HANDLE)0xffffffff) ||
     (BVar1 = WriteConsoleW(DAT_10047b00,&_WCh,1,&local_8,(LPVOID)0x0), BVar1 == 0)) {
    _WCh = L'\xffff';
  }
  return _WCh;
}



undefined4 __cdecl FUN_1003275b(pthreadlocinfo *param_1,uint param_2,uint param_3,byte param_4)

{
  uint uVar1;
  undefined4 uVar2;
  int local_14;
  int local_10;
  int local_c;
  char local_8;
  
  FUN_1001f92e(&local_14,param_1);
  if ((*(byte *)(local_10 + 0x19 + (param_2 & 0xff)) & param_4) == 0) {
    uVar2 = 0;
    if (param_3 == 0) {
      uVar1 = 0;
    }
    else {
      uVar1 = *(ushort *)(*(int *)(local_14 + 0x90) + (param_2 & 0xff) * 2) & param_3;
    }
    if (uVar1 == 0) goto LAB_100327a1;
  }
  uVar2 = 1;
LAB_100327a1:
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return uVar2;
}



void __cdecl FUN_100327b5(uint param_1)

{
  FUN_1003275b((pthreadlocinfo *)0x0,param_1,0,4);
  return;
}



HANDLE __cdecl
FUN_100327d0(LPCWSTR param_1,DWORD param_2,DWORD param_3,LPSECURITY_ATTRIBUTES param_4,DWORD param_5
            ,uint param_6,uint param_7)

{
  bool bVar1;
  undefined3 extraout_var;
  HMODULE hModule;
  FARPROC pFVar2;
  HANDLE pvVar3;
  char *lpProcName;
  undefined4 local_1c;
  uint local_18;
  uint local_14;
  undefined4 local_10;
  LPSECURITY_ATTRIBUTES local_c;
  undefined4 local_8;
  
  bVar1 = FUN_1002bd88();
  if (CONCAT31(extraout_var,bVar1) == 0) {
    pvVar3 = CreateFileW(param_1,param_2,param_3,param_4,param_5,param_6 | param_7,(HANDLE)0x0);
  }
  else {
    lpProcName = "CreateFile2";
    hModule = GetModuleHandleW(L"kernel32.dll");
    pFVar2 = GetProcAddress(hModule,lpProcName);
    if (pFVar2 == (FARPROC)0x0) {
      pvVar3 = (HANDLE)0xffffffff;
    }
    else {
      local_10 = 0;
      local_8 = 0;
      local_18 = param_6;
      local_14 = param_7;
      local_c = param_4;
      local_1c = 0x18;
      pvVar3 = (HANDLE)(*pFVar2)(param_1,param_2,param_3,param_5,&local_1c);
    }
  }
  return pvVar3;
}



// WARNING: Could not reconcile some variable overlaps

int __cdecl
FUN_10032858(undefined4 *param_1,WCHAR **param_2,LPCWSTR param_3,uint param_4,int param_5,
            byte param_6)

{
  byte *pbVar1;
  code *pcVar2;
  ulonglong uVar3;
  ulonglong uVar4;
  ulonglong uVar5;
  ulonglong uVar6;
  int iVar7;
  uint uVar8;
  ulong *puVar9;
  int *piVar10;
  uint uVar11;
  uint uVar12;
  WCHAR *pWVar13;
  DWORD DVar14;
  int iVar15;
  HANDLE pvVar16;
  byte bVar17;
  bool bVar18;
  ulonglong uVar19;
  longlong lVar20;
  _SECURITY_ATTRIBUTES local_3c;
  uint local_30;
  int local_2c;
  undefined4 local_28;
  uint local_24;
  HANDLE local_20;
  uint local_1c;
  uint local_18;
  uint local_14;
  uint local_10;
  uint local_c;
  byte local_7;
  byte local_6;
  byte local_5;
  
  local_3c.nLength = 0xc;
  bVar18 = (param_4 & 0x80) == 0;
  local_24 = 0;
  local_6 = 0;
  local_3c.lpSecurityDescriptor = (LPVOID)0x0;
  if (bVar18) {
    local_5 = 0;
  }
  else {
    local_5 = 0x10;
  }
  local_3c.bInheritHandle = (BOOL)bVar18;
  iVar7 = FUN_100343ac(&local_24);
  if (iVar7 != 0) {
    __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
    pcVar2 = (code *)swi(3);
    iVar7 = (*pcVar2)();
    return iVar7;
  }
  if (((param_4 & 0x8000) == 0) && (((param_4 & 0x74000) != 0 || (local_24 != 0x8000)))) {
    local_5 = local_5 | 0x80;
  }
  uVar8 = param_4 & 3;
  if (uVar8 == 0) {
    local_c = 0x80000000;
  }
  else if (uVar8 == 1) {
    if (((param_4 & 8) == 0) || ((param_4 & 0x70000) == 0)) {
      local_c = 0x40000000;
    }
    else {
      local_c = 0xc0000000;
    }
  }
  else {
    if (uVar8 != 2) {
      puVar9 = ___doserrno();
      *puVar9 = 0;
      *param_2 = (WCHAR *)0xffffffff;
      piVar10 = __errno();
      *piVar10 = 0x16;
      FUN_10025625();
      return 0x16;
    }
    local_c = 0xc0000000;
  }
  uVar8 = 2;
  local_2c = 2;
  if (param_5 == 0x10) {
    local_10 = 0;
  }
  else if (param_5 == 0x20) {
    local_10 = 1;
  }
  else if (param_5 == 0x30) {
    local_10 = 2;
  }
  else if (param_5 == 0x40) {
    local_10 = 3;
  }
  else {
    if (param_5 != 0x80) goto LAB_100329af;
    local_10 = (uint)(local_c == 0x80000000);
  }
  uVar11 = param_4 & 0x700;
  if (uVar11 < 0x401) {
    if ((uVar11 == 0x400) || (uVar11 == 0)) {
      uVar8 = 3;
    }
    else if (uVar11 == 0x100) {
      uVar8 = 4;
    }
    else {
      if (uVar11 == 0x200) goto LAB_100329d0;
      if (uVar11 != 0x300) goto LAB_100329af;
    }
  }
  else {
    if (uVar11 != 0x500) {
      if (uVar11 == 0x600) {
LAB_100329d0:
        uVar8 = 5;
        goto LAB_100329d7;
      }
      if (uVar11 != 0x700) {
LAB_100329af:
        puVar9 = ___doserrno();
        *puVar9 = 0;
        *param_2 = (WCHAR *)0xffffffff;
        piVar10 = __errno();
        *piVar10 = 0x16;
        FUN_10025625();
        return 0x16;
      }
    }
    uVar8 = 1;
  }
LAB_100329d7:
  uVar11 = 0x80;
  local_1c = 0x80;
  local_14 = 0;
  if (((param_4 & 0x100) != 0) && (-1 < (char)(~(byte)DAT_10835b7c & param_6))) {
    uVar11 = 1;
    local_1c = 1;
  }
  uVar12 = 0;
  if ((param_4 & 0x40) != 0) {
    local_c = local_c | 0x10000;
    uVar12 = 0x4000000;
    local_10 = local_10 | 4;
    local_14 = 0x4000000;
  }
  if ((param_4 & 0x1000) != 0) {
    local_1c = uVar11 | 0x100;
  }
  if ((param_4 & 0x2000) != 0) {
    uVar12 = uVar12 | 0x2000000;
    local_14 = uVar12;
  }
  if ((param_4 & 0x20) == 0) {
    if ((param_4 & 0x10) != 0) {
      local_14 = uVar12 | 0x10000000;
    }
  }
  else {
    local_14 = uVar12 | 0x8000000;
  }
  pWVar13 = (WCHAR *)FUN_1002498d();
  *param_2 = pWVar13;
  if (pWVar13 == (WCHAR *)0xffffffff) {
    puVar9 = ___doserrno();
    *puVar9 = 0;
    *param_2 = (WCHAR *)0xffffffff;
    piVar10 = __errno();
    *piVar10 = 0x18;
    piVar10 = __errno();
    return *piVar10;
  }
  *param_1 = 1;
  local_20 = FUN_100327d0(param_3,local_c,local_10,&local_3c,uVar8,local_1c,local_14);
  if (local_20 == (HANDLE)0xffffffff) {
    if (((local_c & 0xc0000000) == 0xc0000000) && ((param_4 & 1) != 0)) {
      local_c = local_c & 0x7fffffff;
      local_20 = FUN_100327d0(param_3,local_c,local_10,&local_3c,uVar8,local_1c,local_14);
      if (local_20 != (HANDLE)0xffffffff) goto LAB_10032b28;
    }
    pbVar1 = (byte *)((&DAT_10835b98)[(int)*param_2 >> 5] + 4 + ((uint)*param_2 & 0x1f) * 0x40);
    *pbVar1 = *pbVar1 & 0xfe;
    DVar14 = GetLastError();
    FID_conflict___dosmaperr(DVar14);
    uVar19 = CONCAT44(local_18,local_30);
    goto LAB_10032b1c;
  }
LAB_10032b28:
  DVar14 = GetFileType(local_20);
  if (DVar14 == 0) {
    pbVar1 = (byte *)((&DAT_10835b98)[(int)*param_2 >> 5] + 4 + ((uint)*param_2 & 0x1f) * 0x40);
    *pbVar1 = *pbVar1 & 0xfe;
    DVar14 = GetLastError();
    FID_conflict___dosmaperr(DVar14);
    CloseHandle(local_20);
    uVar19 = CONCAT44(local_18,local_30);
    if (DVar14 == 0) {
      piVar10 = __errno();
      uVar19 = CONCAT44(local_18,local_30);
      *piVar10 = 0xd;
    }
    goto LAB_10032b1c;
  }
  if (DVar14 == 2) {
    local_5 = local_5 | 0x40;
  }
  else if (DVar14 == 3) {
    local_5 = local_5 | 8;
  }
  FUN_10024d39((uint)*param_2,local_20);
  bVar17 = local_5 | 1;
  *(byte *)((&DAT_10835b98)[(int)*param_2 >> 5] + 4 + ((uint)*param_2 & 0x1f) * 0x40) = bVar17;
  pbVar1 = (byte *)((&DAT_10835b98)[(int)*param_2 >> 5] + 0x24 + ((uint)*param_2 & 0x1f) * 0x40);
  *pbVar1 = *pbVar1 & 0x80;
  local_7 = local_5 & 0x48;
  local_5 = bVar17;
  uVar19 = CONCAT44(local_18,local_30);
  if (local_7 == 0) {
    uVar19 = CONCAT44(local_18,local_30);
    if (-1 < (char)bVar17) goto LAB_10032e99;
    if ((param_4 & 2) == 0) goto LAB_10032c75;
    uVar19 = FUN_1002e5cb((uint)*param_2,0xffffffff,0xffffffff,2);
    if (uVar19 == 0xffffffffffffffff) {
      puVar9 = ___doserrno();
      local_18 = (uint)(uVar19 >> 0x20);
      local_30 = (uint)uVar19;
      if (*puVar9 == 0x83) goto LAB_10032c75;
    }
    else {
      local_28 = 0;
      uVar11 = FUN_1002dba8((uint)*param_2,(LPWSTR)&local_28,1);
      local_18 = (uint)(uVar19 >> 0x20);
      local_30 = (uint)uVar19;
      if ((uVar11 == 0) && ((short)local_28 == 0x1a)) {
        iVar7 = FUN_100341f6(*param_2,local_30,local_18);
        local_18 = (uint)(uVar19 >> 0x20);
        local_30 = (uint)uVar19;
        if (iVar7 == -1) goto LAB_10032c1c;
      }
      lVar20 = FUN_1002e5cb((uint)*param_2,0,0,0);
      local_18 = (uint)(uVar19 >> 0x20);
      local_30 = (uint)uVar19;
      if (lVar20 != -1) goto LAB_10032c75;
    }
LAB_10032c1c:
    FUN_10027e53((uint)*param_2);
    local_18 = (uint)(uVar19 >> 0x20);
    local_30 = (uint)uVar19;
  }
  else {
LAB_10032c75:
    local_30 = (uint)uVar19;
    if ((char)local_5 < '\0') {
      if ((param_4 & 0x74000) == 0) {
        if ((local_24 & 0x74000) == 0) {
          param_4 = param_4 | 0x4000;
        }
        else {
          param_4 = param_4 | local_24 & 0x74000;
        }
      }
      uVar11 = param_4 & 0x74000;
      if (uVar11 == 0x4000) {
        local_6 = 0;
      }
      else if ((uVar11 == 0x10000) || (uVar11 == 0x14000)) {
        if ((param_4 & 0x301) == 0x301) goto LAB_10032ce8;
      }
      else if ((uVar11 == 0x20000) || (uVar11 == 0x24000)) {
LAB_10032ce8:
        local_6 = 2;
      }
      else if ((uVar11 == 0x40000) || (uVar11 == 0x44000)) {
        local_6 = 1;
      }
      if ((param_4 & 0x70000) != 0) {
        local_18 = 0;
        uVar6 = uVar19 & 0xffffffff;
        uVar5 = uVar19 & 0xffffffff;
        uVar4 = uVar19 & 0xffffffff;
        uVar3 = uVar19 & 0xffffffff;
        uVar19 = uVar19 & 0xffffffff;
        if ((local_5 & 0x40) == 0) {
          uVar11 = local_c & 0xc0000000;
          if (uVar11 == 0x40000000) {
            uVar19 = uVar6;
            if (uVar8 != 0) {
              if (2 < uVar8) {
                if (uVar8 < 5) {
                  lVar20 = FUN_1002e5cb((uint)*param_2,0,0,2);
                  if (lVar20 != 0) goto LAB_10032e34;
                }
                else {
LAB_10032d45:
                  uVar19 = uVar5;
                  if (uVar8 != 5) goto LAB_10032e99;
                }
              }
LAB_10032e50:
              iVar7 = 0;
              if (local_6 == 1) {
                iVar15 = 3;
                local_18 = 0xbfbbef;
                local_2c = 3;
              }
              else {
                uVar19 = CONCAT44(local_18,local_30);
                if (local_6 != 2) goto LAB_10032e99;
                local_18 = 0xfeff;
                iVar15 = 2;
              }
              do {
                iVar15 = FUN_1002e63e(*param_2,(WCHAR *)((int)&local_18 + iVar7),iVar15 - iVar7);
                uVar19 = CONCAT44(local_18,local_30);
                if (iVar15 == -1) goto LAB_10032c1c;
                iVar7 = iVar7 + iVar15;
                iVar15 = local_2c;
              } while (iVar7 < local_2c);
            }
          }
          else if (uVar11 == 0x80000000) {
LAB_10032d80:
            uVar8 = FUN_1002dba8((uint)*param_2,(LPWSTR)&local_18,3);
            uVar19 = CONCAT44(local_18,local_30);
            if (uVar8 == 0xffffffff) goto LAB_10032c1c;
            if (uVar8 == 2) {
LAB_10032dbd:
              if ((local_18 & 0xffff) == 0xfffe) {
                FUN_10027e53((uint)*param_2);
                piVar10 = __errno();
                *piVar10 = 0x16;
                return 0x16;
              }
              if ((local_18 & 0xffff) == 0xfeff) {
                lVar20 = FUN_1002e5cb((uint)*param_2,2,0,0);
                uVar19 = CONCAT44(local_18,local_30);
                if (lVar20 == -1) goto LAB_10032c1c;
                local_6 = 2;
                goto LAB_10032e99;
              }
            }
            else if (uVar8 == 3) {
              if (local_18 == 0xbfbbef) {
                local_6 = 1;
                goto LAB_10032e99;
              }
              goto LAB_10032dbd;
            }
LAB_10032e34:
            lVar20 = FUN_1002e5cb((uint)*param_2,0,0,0);
            uVar19 = CONCAT44(local_18,local_30);
            if (lVar20 == -1) goto LAB_10032c1c;
          }
          else {
            uVar19 = uVar3;
            if ((uVar11 == 0xc0000000) && (uVar19 = uVar4, uVar8 != 0)) {
              if (2 < uVar8) {
                if (4 < uVar8) goto LAB_10032d45;
                lVar20 = FUN_1002e5cb((uint)*param_2,0,0,2);
                if (lVar20 != 0) {
                  lVar20 = FUN_1002e5cb((uint)*param_2,0,0,0);
                  uVar19 = CONCAT44(local_18,local_30);
                  if (lVar20 == -1) goto LAB_10032c1c;
                  goto LAB_10032d80;
                }
              }
              goto LAB_10032e50;
            }
          }
        }
      }
    }
LAB_10032e99:
    uVar8 = local_c;
    iVar7 = ((uint)*param_2 & 0x1f) * 0x40;
    pbVar1 = (byte *)((&DAT_10835b98)[(int)*param_2 >> 5] + 0x24 + iVar7);
    *pbVar1 = *pbVar1 ^ (*(byte *)((&DAT_10835b98)[(int)*param_2 >> 5] + 0x24 + iVar7) ^ local_6) &
                        0x7f;
    iVar7 = ((uint)*param_2 & 0x1f) * 0x40;
    *(byte *)((&DAT_10835b98)[(int)*param_2 >> 5] + 0x24 + iVar7) =
         (char)(param_4 >> 0x10) << 7 |
         *(byte *)((&DAT_10835b98)[(int)*param_2 >> 5] + 0x24 + iVar7) & 0x7f;
    if ((local_7 == 0) && ((param_4 & 8) != 0)) {
      pbVar1 = (byte *)((&DAT_10835b98)[(int)*param_2 >> 5] + 4 + ((uint)*param_2 & 0x1f) * 0x40);
      *pbVar1 = *pbVar1 | 0x20;
    }
    if ((local_c & 0xc0000000) != 0xc0000000) {
      return 0;
    }
    if ((param_4 & 1) == 0) {
      return 0;
    }
    CloseHandle(local_20);
    local_18 = (uint)(uVar19 >> 0x20);
    local_30 = (uint)uVar19;
    pvVar16 = FUN_100327d0(param_3,uVar8 & 0x7fffffff,local_10,&local_3c,3,local_1c,local_14);
    local_18 = (uint)(uVar19 >> 0x20);
    local_30 = (uint)uVar19;
    if (pvVar16 != (HANDLE)0xffffffff) {
      *(HANDLE *)(((uint)*param_2 & 0x1f) * 0x40 + (&DAT_10835b98)[(int)*param_2 >> 5]) = pvVar16;
      return 0;
    }
    DVar14 = GetLastError();
    local_18 = (uint)(uVar19 >> 0x20);
    local_30 = (uint)uVar19;
    FID_conflict___dosmaperr(DVar14);
    local_18 = (uint)(uVar19 >> 0x20);
    local_30 = (uint)uVar19;
    pbVar1 = (byte *)((&DAT_10835b98)[(int)*param_2 >> 5] + 4 + ((uint)*param_2 & 0x1f) * 0x40);
    *pbVar1 = *pbVar1 & 0xfe;
    FUN_10024b36((uint)*param_2);
    local_18 = (uint)(uVar19 >> 0x20);
    local_30 = (uint)uVar19;
  }
LAB_10032b1c:
  piVar10 = __errno();
  local_18 = (uint)(uVar19 >> 0x20);
  local_30 = (uint)uVar19;
  return *piVar10;
}



// Library Function - Single Match
//  _strncmp
// 
// Libraries: Visual Studio 2012 Debug, Visual Studio 2012 Release

int __cdecl _strncmp(char *_Str1,char *_Str2,size_t _MaxCount)

{
  byte bVar1;
  int iVar2;
  uint uVar3;
  bool bVar4;
  
  if (_MaxCount != 0) {
    iVar2 = (int)_Str1 - (int)_Str2;
    uVar3 = (uint)_Str2 & 3;
    while( true ) {
      if (uVar3 == 0) {
        while ((((int)_Str2 + iVar2 & 0xfffU) < 0xffd &&
               (uVar3 = *(uint *)((int)_Str2 + iVar2), uVar3 == *(uint *)_Str2))) {
          bVar4 = _MaxCount < 4;
          _MaxCount = _MaxCount - 4;
          if (bVar4 || _MaxCount == 0) {
            return 0;
          }
          _Str2 = (char *)((int)_Str2 + 4);
          if ((~uVar3 & uVar3 + 0xfefefeff & 0x80808080) != 0) {
            return 0;
          }
        }
      }
      bVar1 = *(byte *)((int)_Str2 + iVar2);
      if (bVar1 != *_Str2) {
        return -(uint)(bVar1 < (byte)*_Str2) | 1;
      }
      uVar3 = _MaxCount;
      if (bVar1 == 0) {
        uVar3 = (uint)bVar1;
      }
      _Str2 = (char *)((int)_Str2 + 1);
      _MaxCount = uVar3 - 1;
      if (uVar3 == 0 || _MaxCount == 0) break;
      uVar3 = (uint)_Str2 & 3;
    }
  }
  return 0;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __strnicmp
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl __strnicmp(char *_Str1,char *_Str2,size_t _MaxCount)

{
  int *piVar1;
  int iVar2;
  
  if (_DAT_10835ca0 == 0) {
    if ((_Str1 == (char *)0x0) || (_Str2 == (char *)0x0)) {
      piVar1 = __errno();
      *piVar1 = 0x16;
      FUN_10025625();
      iVar2 = 0x7fffffff;
    }
    else {
      if (_MaxCount < 0x80000000) {
        iVar2 = ___ascii_strnicmp(_Str1,_Str2,_MaxCount);
        return iVar2;
      }
      piVar1 = __errno();
      *piVar1 = 0x16;
      FUN_10025625();
      iVar2 = 0x7fffffff;
    }
  }
  else {
    iVar2 = FUN_10033093(_Str1,(byte *)_Str2,_MaxCount,(pthreadlocinfo *)0x0);
  }
  return iVar2;
}



int __cdecl FUN_10033093(char *param_1,byte *param_2,uint param_3,pthreadlocinfo *param_4)

{
  int *piVar1;
  uint uVar2;
  uint uVar3;
  int iVar4;
  pthreadlocinfo local_14 [2];
  int local_c;
  char local_8;
  
  if (param_3 == 0) {
    iVar4 = 0;
  }
  else {
    FUN_1001f92e(local_14,param_4);
    iVar4 = 0x7fffffff;
    if (((param_1 == (char *)0x0) || (param_2 == (byte *)0x0)) || (0x7fffffff < param_3)) {
      piVar1 = __errno();
      *piVar1 = 0x16;
      FUN_10025625();
    }
    else if (local_14[0]->locale_name[2] == (wchar_t *)0x0) {
      iVar4 = ___ascii_strnicmp(param_1,(char *)param_2,param_3);
    }
    else {
      iVar4 = (int)param_1 - (int)param_2;
      do {
        uVar2 = FUN_100210ea((uint)param_2[iVar4],local_14);
        uVar3 = FUN_100210ea((uint)*param_2,local_14);
        param_2 = param_2 + 1;
        param_3 = param_3 - 1;
        if ((param_3 == 0) || (uVar2 == 0)) break;
      } while (uVar2 == uVar3);
      iVar4 = uVar2 - uVar3;
    }
    if (local_8 != '\0') {
      *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
    }
  }
  return iVar4;
}



// WARNING: Could not reconcile some variable overlaps

void __cdecl
FUN_10033144(int param_1,uint param_2,ushort param_3,int param_4,byte param_5,short *param_6)

{
  short *psVar1;
  code *pcVar2;
  ushort uVar3;
  errno_t eVar4;
  ushort *puVar5;
  uint uVar6;
  char cVar7;
  ushort uVar8;
  undefined **ppuVar9;
  int iVar10;
  undefined **ppuVar11;
  uint uVar12;
  ushort *puVar13;
  short *psVar14;
  short sVar15;
  uint uVar16;
  uint extraout_EDX;
  uint extraout_EDX_00;
  uint uVar17;
  int iVar18;
  uint uVar19;
  ushort uVar20;
  ushort uVar21;
  undefined **ppuVar22;
  ushort *puVar23;
  int iVar24;
  int iVar25;
  uint uVar26;
  bool bVar27;
  char *pcVar28;
  undefined uVar29;
  ushort *in_stack_ffffff74;
  int local_7c;
  short *local_5c;
  int local_58;
  uint local_54;
  int local_50;
  int local_4c;
  uint local_48;
  uint local_44;
  ushort local_40;
  undefined2 uStack62;
  undefined2 uStack60;
  undefined2 uStack58;
  undefined *local_38;
  undefined4 local_34;
  undefined4 local_30;
  ushort local_2c;
  undefined2 uStack42;
  ushort local_24;
  undefined4 uStack34;
  undefined4 uStack30;
  undefined local_1a;
  byte bStack25;
  byte local_14;
  undefined uStack19;
  ushort uStack18;
  ushort local_10 [4];
  uint local_8;
  
  uVar29 = SUB41(in_stack_ffffff74,0);
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  uVar16 = param_3 & 0x8000;
  local_34 = 0xcccccccc;
  uVar21 = param_3 & 0x7fff;
  local_30 = 0xcccccccc;
  local_2c = 0xcccc;
  uStack42 = 0x3ffb;
  sVar15 = (short)uVar16;
  if (sVar15 == 0) {
    *(undefined *)(param_6 + 1) = 0x20;
  }
  else {
    *(undefined *)(param_6 + 1) = 0x2d;
  }
  if (uVar21 == 0) {
    if ((param_2 == 0) && (param_1 == 0)) {
      *(undefined *)((int)param_6 + 3) = 1;
      *param_6 = 0;
      *(byte *)(param_6 + 1) = ((sVar15 != -0x8000) - 1U & 0xd) + 0x20;
      param_6[2] = 0x30;
      param_1 = CONCAT22(uStack34._2_2_,(ushort)uStack34);
      goto LAB_10033ac1;
    }
  }
  else if (uVar21 == 0x7fff) {
    *param_6 = 1;
    if (((param_2 == 0x80000000) && (param_1 == 0)) || ((param_2 & 0x40000000) != 0)) {
      if ((sVar15 == 0) || (param_2 != 0xc0000000)) {
        if ((param_2 != 0x80000000) || (param_1 != 0)) goto LAB_10033254;
        pcVar28 = "1#INF";
      }
      else {
        if (param_1 != 0) {
LAB_10033254:
          pcVar28 = "1#QNAN";
          goto LAB_10033259;
        }
        pcVar28 = "1#IND";
      }
      eVar4 = _strcpy_s((char *)(param_6 + 2),0x16,pcVar28);
      if (eVar4 != 0) goto LAB_10033b0b;
      *(undefined *)((int)param_6 + 3) = 5;
      uVar16 = extraout_EDX;
    }
    else {
      pcVar28 = "1#SNAN";
LAB_10033259:
      eVar4 = _strcpy_s((char *)(param_6 + 2),0x16,pcVar28);
      if (eVar4 != 0) {
LAB_10033b0b:
        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
        pcVar2 = (code *)swi(3);
        (*pcVar2)();
        return;
      }
      *(undefined *)((int)param_6 + 3) = 6;
      uVar16 = extraout_EDX_00;
    }
    param_1 = CONCAT22(uStack34._2_2_,(ushort)uStack34);
    goto LAB_10033ac1;
  }
  uStack30._0_2_ = (undefined2)param_2;
  uStack30._2_2_ = (ushort)(param_2 >> 0x10);
  ppuVar22 = &PTR_DAT_100477c8;
  local_1a = (undefined)uVar21;
  bStack25 = (byte)(uVar21 >> 8);
  local_5c = (short *)0x5;
  local_4c._0_2_ =
       (short)((uint)uVar21 * 0x4d10 + -0x134312f4 +
               ((uint)(uVar21 >> 8) + (param_2 >> 0x18) * 2) * 0x4d >> 0x10);
  uStack34._0_2_ = (ushort)param_1;
  uStack34._2_2_ = (ushort)((uint)param_1 >> 0x10);
  local_24 = 0;
  uVar16 = (uint)(short)local_4c;
  bVar27 = -uVar16 == 0;
  if (bVar27) {
LAB_10033614:
    uVar16 = CONCAT22((undefined2)uStack30,uStack34._2_2_);
    uVar19 = param_1 << 0x10;
  }
  else {
    local_48 = -uVar16;
    if (0 < (int)uVar16) {
      ppuVar22 = (undefined **)0x10047928;
      bVar27 = uVar16 == 0;
      local_48 = uVar16;
    }
    if (bVar27) goto LAB_10033614;
    uVar19 = param_1 << 0x10;
    uVar16 = CONCAT22((undefined2)uStack30,uStack34._2_2_);
    local_44 = uVar19;
    do {
      uStack30._2_2_ = (ushort)(param_2 >> 0x10);
      iVar24 = 0;
      uVar12 = (int)local_48 >> 3;
      ppuVar22 = ppuVar22 + 0x15;
      if ((local_48 & 7) != 0) {
        ppuVar11 = ppuVar22 + (local_48 & 7) * 3;
        ppuVar9 = ppuVar11;
        if (0x7fff < *(ushort *)ppuVar11) {
          ppuVar9 = (undefined **)&local_40;
          local_40 = (ushort)*ppuVar11;
          uStack62 = (undefined2)((uint)*ppuVar11 >> 0x10);
          uStack60 = SUB42(ppuVar11[1],0);
          uStack58 = (undefined2)((uint)ppuVar11[1] >> 0x10);
          local_38 = ppuVar11[2];
          iVar25 = CONCAT22(uStack60,uStack62) + -1;
          uStack62 = (undefined2)iVar25;
          uStack60 = (undefined2)((uint)iVar25 >> 0x10);
        }
        uVar20 = *(ushort *)((int)ppuVar9 + 10) & 0x7fff;
        uVar3 = CONCAT11(bStack25,local_1a) & 0x7fff;
        uVar21 = (*(ushort *)((int)ppuVar9 + 10) ^ CONCAT11(bStack25,local_1a)) & 0x8000;
        uVar8 = uVar3 + uVar20;
        local_14 = 0;
        uStack19 = 0;
        uStack18 = 0;
        local_10[0] = 0;
        local_10[1] = uStack18;
        local_10[2] = local_10[0];
        local_10[3] = uStack18;
        if (((uVar3 < 0x7fff) && (uVar20 < 0x7fff)) && (uVar8 < 0xbffe)) {
          if (uVar8 < 0x3fc0) {
LAB_100333a7:
            local_1a = 0;
            bStack25 = 0;
            uStack30._2_2_ = local_10[0];
            goto LAB_100335f4;
          }
          if (((uVar3 == 0) &&
              (uVar8 = uVar8 + 1,
              (CONCAT13(bStack25,CONCAT12(local_1a,uStack30._2_2_)) & 0x7fffffff) == 0)) &&
             ((uVar16 == 0 && (local_44 == 0)))) {
            local_1a = 0;
            bStack25 = 0;
            uVar19 = local_44;
            goto LAB_10033604;
          }
          if (((uVar20 == 0) && (uVar8 = uVar8 + 1, ((uint)ppuVar9[2] & 0x7fffffff) == 0)) &&
             ((ppuVar9[1] == (undefined *)0x0 && (*ppuVar9 == (undefined *)0x0))))
          goto LAB_100333a7;
          puVar13 = local_10;
          local_54 = 5;
          iVar25 = iVar24;
          do {
            if (0 < (int)local_54) {
              in_stack_ffffff74 = &local_24 + iVar25;
              ppuVar11 = ppuVar9 + 2;
              iVar18 = local_54;
              do {
                uVar16 = *(uint *)(puVar13 + -2) +
                         (uint)*in_stack_ffffff74 * (uint)*(ushort *)ppuVar11;
                if ((uVar16 < *(uint *)(puVar13 + -2)) ||
                   (iVar10 = iVar24, uVar16 < (uint)*in_stack_ffffff74 * (uint)*(ushort *)ppuVar11))
                {
                  iVar10 = 1;
                }
                *(uint *)(puVar13 + -2) = uVar16;
                if (iVar10 != 0) {
                  *puVar13 = *puVar13 + 1;
                }
                in_stack_ffffff74 = in_stack_ffffff74 + 1;
                ppuVar11 = (undefined **)((int)ppuVar11 + -2);
                iVar18 = iVar18 + -1;
              } while (0 < iVar18);
            }
            puVar13 = puVar13 + 1;
            iVar25 = iVar25 + 1;
            local_54 = local_54 + -1;
          } while (0 < (int)local_54);
          local_44 = CONCAT22(local_10[3],local_10[2]);
          uVar8 = uVar8 + 0xc002;
          uVar16 = CONCAT22(uStack18,CONCAT11(uStack19,local_14));
          if ((short)uVar8 < 1) {
LAB_100334e3:
            uVar8 = uVar8 - 1;
            if (-1 < (short)uVar8) goto LAB_10033554;
            local_54 = (uint)(ushort)-uVar8;
            uVar8 = 0;
            uVar19 = local_44;
            do {
              if ((local_14 & 1) != 0) {
                iVar24 = iVar24 + 1;
              }
              uVar26 = CONCAT22(local_10[1],local_10[0]);
              local_10[1] = local_10[1] >> 1 | (ushort)((uVar19 << 0x1f) >> 0x10);
              uVar17 = uVar16 >> 1;
              local_44 = uVar19 >> 1;
              uVar16 = uVar17 | uVar26 << 0x1f;
              local_54 = local_54 - 1;
              local_10[2] = (ushort)local_44;
              local_10[3] = (ushort)(uVar19 >> 0x11);
              local_10[0] = (ushort)(uVar26 >> 1);
              local_14 = (byte)uVar17;
              uStack19 = (undefined)(uVar17 >> 8);
              uStack18 = (ushort)(uVar16 >> 0x10);
              uVar19 = local_44;
            } while (local_54 != 0);
            if (iVar24 == 0) goto LAB_10033554;
            uVar3 = (ushort)uVar17 | 1;
            local_14 = (byte)uVar3;
            uVar16 = uVar17 | 1;
          }
          else {
            do {
              if ((int)local_44 < 0) break;
              iVar25 = CONCAT22(local_10[1],local_10[0]) * 2;
              uVar3 = local_10[1] >> 0xf;
              local_10[0] = (ushort)iVar25 | (ushort)(uVar16 >> 0x1f);
              uVar16 = uVar16 * 2;
              local_10[1] = (ushort)((uint)iVar25 >> 0x10);
              uVar19 = local_44 * 2;
              local_14 = (byte)uVar16;
              uStack19 = (undefined)(uVar16 >> 8);
              uStack18 = (ushort)(uVar16 >> 0x10);
              local_44 = uVar19 | uVar3;
              uVar8 = uVar8 - 1;
              local_10[2] = (ushort)local_44;
              local_10[3] = (ushort)(uVar19 >> 0x10);
            } while (0 < (short)uVar8);
            if ((short)uVar8 < 1) goto LAB_100334e3;
LAB_10033554:
            uVar3 = CONCAT11(uStack19,local_14);
          }
          if ((0x8000 < uVar3) || ((uVar16 & 0x1ffff) == 0x18000)) {
            if (CONCAT22(local_10[0],uStack18) == -1) {
              uStack18 = 0;
              local_10[0] = 0;
              if (CONCAT22(local_10[2],local_10[1]) == -1) {
                local_10[1] = 0;
                local_10[2] = 0;
                if (local_10[3] == 0xffff) {
                  local_10[3] = 0x8000;
                  uVar8 = uVar8 + 1;
                }
                else {
                  local_10[3] = local_10[3] + 1;
                }
              }
              else {
                iVar24 = CONCAT22(local_10[2],local_10[1]) + 1;
                local_10[1] = (ushort)iVar24;
                local_10[2] = (ushort)((uint)iVar24 >> 0x10);
              }
              local_44 = CONCAT22(local_10[3],local_10[2]);
            }
            else {
              iVar24 = CONCAT22(local_10[0],uStack18) + 1;
              uStack18 = (ushort)iVar24;
              local_10[0] = (ushort)((uint)iVar24 >> 0x10);
            }
          }
          if (0x7ffe < uVar8) goto LAB_100335dd;
          bStack25 = (byte)(uVar8 >> 8) | (byte)(uVar21 >> 8);
          local_24 = uStack18;
          uStack34._0_2_ = local_10[0];
          uStack34._2_2_ = local_10[1];
          uVar19 = CONCAT22(local_10[0],uStack18);
          uStack30._0_2_ = (undefined2)local_44;
          uStack30._2_2_ = (ushort)(local_44 >> 0x10);
          uVar16 = CONCAT22((undefined2)uStack30,local_10[1]);
          local_1a = (undefined)uVar8;
        }
        else {
LAB_100335dd:
          iVar24 = ((uVar21 == 0) - 1 & 0x80000000) + 0x7fff8000;
          uStack30._2_2_ = (ushort)iVar24;
          local_1a = (undefined)((uint)iVar24 >> 0x10);
          bStack25 = (byte)((uint)iVar24 >> 0x18);
LAB_100335f4:
          uVar16 = 0;
          local_24 = 0;
          uStack34._0_2_ = 0;
          uStack34._2_2_ = 0;
          uStack30._0_2_ = 0;
          uVar19 = uVar16;
        }
        param_2 = CONCAT22(uStack30._2_2_,(undefined2)uStack30);
        param_1 = CONCAT22(uStack34._2_2_,(ushort)uStack34);
        local_44 = uVar19;
      }
LAB_10033604:
      uVar29 = SUB41(in_stack_ffffff74,0);
      local_48 = uVar12;
    } while (uVar12 != 0);
  }
  uStack30._2_2_ = (ushort)(param_2 >> 0x10);
  uVar12 = CONCAT13(bStack25,CONCAT12(local_1a,uStack30._2_2_));
  uStack30 = param_2;
  if (0x3ffe < (ushort)(uVar12 >> 0x10)) {
    local_4c._0_2_ = (short)local_4c + 1;
    local_7c = 0;
    local_14 = 0;
    uStack19 = 0;
    uStack18 = 0;
    local_10[0] = 0;
    local_10[1] = 0;
    local_10[2] = 0;
    local_10[3] = 0;
    uVar12 = uVar12 >> 0x10 & 0x7fff;
    local_50 = uVar12 + 0x3ffb;
    if (((0x7ffe < (ushort)uVar12) || (false)) || (0xbffd < (ushort)local_50)) {
LAB_100338b2:
      iVar24 = (((bStack25 & 0x80) == 0) - 1 & 0x80000000) + 0x7fff8000;
      uStack30._2_2_ = (ushort)iVar24;
      local_1a = (undefined)((uint)iVar24 >> 0x10);
      bStack25 = (byte)((uint)iVar24 >> 0x18);
    }
    else {
      if (0x3fbf < (ushort)local_50) {
        if ((((ushort)uVar12 == 0) &&
            (local_50 = uVar12 + 0x3ffc,
            (CONCAT13(bStack25,CONCAT12(local_1a,uStack30._2_2_)) & 0x7fffffff) == 0)) &&
           ((uVar16 == 0 && (uVar19 == 0)))) {
          local_1a = 0;
          bStack25 = 0;
          goto LAB_100338cd;
        }
        if (((false) && (local_50 = local_50 + 1, false)) && ((false && (false))))
        goto LAB_1003368f;
        puVar13 = local_10;
        local_54 = 0;
        do {
          if (0 < (int)local_5c) {
            puVar5 = &local_2c;
            puVar23 = &local_24 + local_54;
            iVar24 = (int)local_5c;
            do {
              uVar16 = *(uint *)(puVar13 + -2) + (uint)*puVar5 * (uint)*puVar23;
              if ((uVar16 < *(uint *)(puVar13 + -2)) || (uVar16 < (uint)*puVar5 * (uint)*puVar23)) {
                bVar27 = true;
              }
              else {
                bVar27 = false;
              }
              *(uint *)(puVar13 + -2) = uVar16;
              if (bVar27) {
                *puVar13 = *puVar13 + 1;
              }
              puVar23 = puVar23 + 1;
              puVar5 = puVar5 + -1;
              iVar24 = iVar24 + -1;
            } while (0 < iVar24);
          }
          puVar13 = puVar13 + 1;
          local_54 = local_54 + 1;
          local_5c = (short *)((int)local_5c + -1);
        } while (0 < (int)local_5c);
        uStack30 = CONCAT22(local_10[3],local_10[2]);
        local_50 = local_50 + 0xc002;
        if ((short)local_50 < 1) {
          uVar16 = CONCAT22(uStack18,CONCAT11(uStack19,local_14));
LAB_10033806:
          uVar21 = (ushort)(local_50 + 0xffff);
          if (-1 < (short)uVar21) goto LAB_100337ab;
          local_5c = (short *)(-(local_50 + 0xffff) & 0xffff);
          uVar21 = uVar21 + (short)local_5c;
          do {
            uVar19 = uStack30;
            if ((local_14 & 1) != 0) {
              local_7c = local_7c + 1;
            }
            uVar12 = CONCAT22(local_10[1],local_10[0]);
            uVar26 = uVar16 >> 1;
            local_10[1] = local_10[1] >> 1 | (ushort)((uVar19 << 0x1f) >> 0x10);
            uVar16 = uVar26 | uVar12 << 0x1f;
            uStack30 = uVar19 >> 1;
            local_5c = (short *)((int)local_5c - 1);
            local_10[0] = (ushort)(uVar12 >> 1);
            local_14 = (byte)uVar26;
            uStack19 = (undefined)(uVar26 >> 8);
            uStack18 = (ushort)(uVar16 >> 0x10);
          } while (local_5c != (short *)0x0);
          local_10[2] = (ushort)uStack30;
          local_10[3] = (ushort)(uVar19 >> 0x11);
          if (local_7c == 0) goto LAB_100337ab;
          uVar8 = (ushort)uVar26 | 1;
          local_14 = (byte)uVar8;
          uVar16 = uVar26 | 1;
        }
        else {
          uVar16 = CONCAT22(uStack18,CONCAT11(uStack19,local_14));
          do {
            if ((int)uStack30 < 0) break;
            iVar24 = CONCAT22(local_10[1],local_10[0]) * 2;
            uVar21 = local_10[1] >> 0xf;
            local_10[0] = (ushort)iVar24 | (ushort)(uVar16 >> 0x1f);
            uVar19 = uStack30 * 2;
            local_10[1] = (ushort)((uint)iVar24 >> 0x10);
            uVar16 = uVar16 * 2;
            local_14 = (byte)uVar16;
            uStack19 = (undefined)(uVar16 >> 8);
            uStack18 = (ushort)(uVar16 >> 0x10);
            uStack30 = uVar19 | uVar21;
            local_50 = local_50 + 0xffff;
            local_10[2] = (ushort)uStack30;
            local_10[3] = (ushort)(uVar19 >> 0x10);
          } while (0 < (short)local_50);
          uVar21 = (ushort)local_50;
          if ((short)uVar21 < 1) goto LAB_10033806;
LAB_100337ab:
          uVar8 = CONCAT11(uStack19,local_14);
        }
        if ((0x8000 < uVar8) || ((uVar16 & 0x1ffff) == 0x18000)) {
          if (CONCAT22(local_10[0],uStack18) == -1) {
            uStack18 = 0;
            local_10[0] = 0;
            if (CONCAT22(local_10[2],local_10[1]) == -1) {
              local_10[1] = uStack18;
              local_10[2] = local_10[0];
              if (local_10[3] == 0xffff) {
                uVar21 = uVar21 + 1;
                local_10[3] = 0x8000;
              }
              else {
                local_10[3] = local_10[3] + 1;
              }
            }
            else {
              iVar24 = CONCAT22(local_10[2],local_10[1]) + 1;
              local_10[1] = (ushort)iVar24;
              local_10[2] = (ushort)((uint)iVar24 >> 0x10);
            }
            uStack30 = CONCAT22(local_10[3],local_10[2]);
          }
          else {
            iVar24 = CONCAT22(local_10[0],uStack18) + 1;
            uStack18 = (ushort)iVar24;
            local_10[0] = (ushort)((uint)iVar24 >> 0x10);
          }
        }
        if (uVar21 < 0x7fff) {
          bStack25 = (byte)(uVar21 >> 8) | bStack25 & 0x80;
          local_24 = uStack18;
          param_1 = CONCAT22(local_10[1],local_10[0]);
          uVar16 = CONCAT22((undefined2)uStack30,local_10[1]);
          uVar19 = CONCAT22(local_10[0],uStack18);
          local_1a = (undefined)uVar21;
          goto LAB_100338cd;
        }
        goto LAB_100338b2;
      }
LAB_1003368f:
      uStack30._2_2_ = 0;
      local_1a = 0;
      bStack25 = 0;
    }
    uVar16 = 0;
    uVar19 = uVar16;
    uStack30 = param_2 & 0xffff | (uint)uStack30._2_2_ << 0x10;
  }
LAB_100338cd:
  uStack30._2_2_ = (ushort)(uStack30 >> 0x10);
  *param_6 = (short)local_4c;
  if ((param_5 & 1) == 0) {
    local_4c = param_4;
LAB_10033918:
    if (0x15 < local_4c) {
      local_4c = 0x15;
    }
    iVar24 = (CONCAT13(bStack25,CONCAT12(local_1a,uStack30._2_2_)) >> 0x10) - 0x3ffe;
    uVar12 = (uint)uStack30._2_2_;
    iVar25 = 8;
    do {
      uVar6 = uVar19 >> 0x1f;
      uVar26 = uVar16 * 2;
      uVar17 = uVar12 * 2;
      uVar19 = uVar19 * 2;
      uVar12 = uVar17 | uVar16 >> 0x1f;
      uVar16 = uVar26 | uVar6;
      local_24 = (ushort)uVar19;
      uStack34._0_2_ = (ushort)(uVar19 >> 0x10);
      uStack30._2_2_ = (ushort)uVar12;
      local_1a = (undefined)(uVar17 >> 0x10);
      bStack25 = (byte)(uVar17 >> 0x18);
      iVar25 = iVar25 + -1;
    } while (iVar25 != 0);
    uStack34._2_2_ = (ushort)uVar16;
    uStack30._0_2_ = (undefined2)(uVar26 >> 0x10);
    local_48 = uVar12;
    local_44 = uVar19;
    if ((iVar24 < 0) && (uVar26 = -iVar24 & 0xff, uVar26 != 0)) {
      do {
        uVar6 = uVar19 >> 1;
        uVar19 = uVar6 | uVar16 << 0x1f;
        uVar17 = uVar16 >> 1;
        local_48 = uVar12 >> 1;
        uVar16 = uVar17 | uVar12 << 0x1f;
        uVar26 = uVar26 - 1;
        uStack30._2_2_ = (ushort)local_48;
        local_1a = (undefined)(local_48 >> 0x10);
        bStack25 = (byte)(uVar12 >> 0x19);
        local_24 = (ushort)uVar6;
        uStack34._0_2_ = (ushort)(uVar19 >> 0x10);
        uVar12 = local_48;
      } while (0 < (int)uVar26);
      uStack34._2_2_ = (ushort)uVar17;
      uStack30._0_2_ = (undefined2)(uVar16 >> 0x10);
      local_44 = uVar19;
    }
    local_58 = local_4c + 1;
    psVar1 = param_6 + 2;
    local_5c = psVar1;
    if (0 < local_58) {
      while( true ) {
        local_40 = local_24;
        uStack62 = (ushort)uStack34;
        uStack60 = uStack34._2_2_;
        uStack58 = (undefined2)uStack30;
        local_38 = (undefined *)CONCAT13(bStack25,CONCAT12(local_1a,uStack30._2_2_));
        uVar19 = (uVar16 * 2 | local_44 >> 0x1f) * 2 | local_44 * 2 >> 0x1f;
        uVar12 = (local_48 * 2 | uVar16 >> 0x1f) * 2 | uVar16 * 2 >> 0x1f;
        uVar16 = CONCAT22((ushort)uStack34,local_24) + local_44 * 4;
        if ((uVar16 < local_44 * 4) ||
           (uVar26 = uVar19, uVar16 < CONCAT22((ushort)uStack34,local_24))) {
          uVar26 = uVar19 + 1;
          if ((uVar26 < uVar19) || (bVar27 = false, uVar26 == 0)) {
            bVar27 = true;
          }
          if (bVar27) {
            uVar12 = uVar12 + 1;
          }
        }
        uVar19 = CONCAT22((undefined2)uStack30,uStack34._2_2_) + uVar26;
        if ((uVar19 < uVar26) || (uVar19 < CONCAT22((undefined2)uStack30,uStack34._2_2_))) {
          uVar12 = uVar12 + 1;
        }
        local_44 = uVar16 * 2;
        local_24 = (ushort)local_44;
        uStack34._0_2_ = (ushort)(local_44 >> 0x10);
        uVar16 = uVar19 * 2 | uVar16 >> 0x1f;
        uVar12 = (int)(local_38 + uVar12) * 2;
        uStack34._2_2_ = (ushort)uVar16;
        uStack30._0_2_ = (undefined2)(uVar19 * 2 >> 0x10);
        uStack30._2_2_ = (ushort)uVar12 | (ushort)(uVar19 >> 0x1f);
        local_1a = (undefined)(uVar12 >> 0x10);
        *(char *)local_5c = (char)(uVar12 >> 0x18) + '0';
        local_5c = (short *)((int)local_5c + 1);
        local_58 = local_58 + -1;
        bStack25 = 0;
        if (local_58 < 1) break;
        local_48 = uVar12 & 0xffffff | uVar19 >> 0x1f;
      }
    }
    param_1 = CONCAT22(uStack34._2_2_,(ushort)uStack34);
    psVar14 = local_5c + -1;
    if (*(char *)((int)local_5c + -1) < '5') {
      for (; (psVar1 <= psVar14 && (*(char *)psVar14 == '0'));
          psVar14 = (short *)((int)psVar14 + -1)) {
      }
      if (psVar14 < psVar1) {
        *param_6 = 0;
        *(byte *)(param_6 + 1) = ((sVar15 != -0x8000) - 1U & 0xd) + 0x20;
        *(undefined *)((int)param_6 + 3) = 1;
        *(char *)psVar1 = '0';
        goto LAB_1003390d;
      }
    }
    else {
      for (; (psVar1 <= psVar14 && (*(char *)psVar14 == '9'));
          psVar14 = (short *)((int)psVar14 + -1)) {
        *(char *)psVar14 = '0';
      }
      if (psVar14 < psVar1) {
        psVar14 = (short *)((int)psVar14 + 1);
        *param_6 = *param_6 + 1;
      }
      *(char *)psVar14 = *(char *)psVar14 + '\x01';
    }
    cVar7 = ((char)psVar14 - (char)param_6) + -3;
    *(char *)((int)param_6 + 3) = cVar7;
    *(undefined *)(cVar7 + 4 + (int)param_6) = 0;
  }
  else {
    local_4c = param_4 + (short)local_4c;
    if (0 < local_4c) goto LAB_10033918;
    *param_6 = 0;
    *(byte *)(param_6 + 1) = ((sVar15 != -0x8000) - 1U & 0xd) + 0x20;
    *(undefined *)((int)param_6 + 3) = 1;
    *(undefined *)(param_6 + 2) = 0x30;
LAB_1003390d:
    *(undefined *)((int)param_6 + 5) = 0;
  }
LAB_10033ac1:
  uStack34 = param_1;
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,(char)uVar16,uVar29);
  return;
}



// Library Function - Single Match
//  ___hw_cw_sse2
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2019 Release

uint __cdecl ___hw_cw_sse2(uint param_1)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = 0;
  if ((param_1 & 0x10) != 0) {
    uVar1 = 0x80;
  }
  if ((param_1 & 8) != 0) {
    uVar1 = uVar1 | 0x200;
  }
  if ((param_1 & 4) != 0) {
    uVar1 = uVar1 | 0x400;
  }
  if ((param_1 & 2) != 0) {
    uVar1 = uVar1 | 0x800;
  }
  if ((param_1 & 1) != 0) {
    uVar1 = uVar1 | 0x1000;
  }
  if ((param_1 & 0x80000) != 0) {
    uVar1 = uVar1 | 0x100;
  }
  uVar2 = param_1 & 0x300;
  if (uVar2 != 0) {
    if (uVar2 == 0x100) {
      uVar1 = uVar1 | 0x2000;
    }
    else if (uVar2 == 0x200) {
      uVar1 = uVar1 | 0x4000;
    }
    else if (uVar2 == 0x300) {
      uVar1 = uVar1 | 0x6000;
    }
  }
  uVar2 = param_1 & 0x3000000;
  if (uVar2 == 0x1000000) {
    uVar1 = uVar1 | 0x8040;
  }
  else {
    if (uVar2 == 0x2000000) {
      return uVar1 | 0x40;
    }
    if (uVar2 == 0x3000000) {
      return uVar1 | 0x8000;
    }
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

uint __cdecl FUN_10033bc1(uint param_1,uint param_2)

{
  uint uVar1;
  uint uVar2;
  ushort uVar3;
  uint uVar4;
  uint in_MXCSR;
  ushort in_FPUControlWord;
  
  uVar1 = 0;
  if ((in_FPUControlWord & 1) != 0) {
    uVar1 = 0x10;
  }
  if ((in_FPUControlWord & 4) != 0) {
    uVar1 = uVar1 | 8;
  }
  if ((in_FPUControlWord & 8) != 0) {
    uVar1 = uVar1 | 4;
  }
  if ((in_FPUControlWord & 0x10) != 0) {
    uVar1 = uVar1 | 2;
  }
  if ((in_FPUControlWord & 0x20) != 0) {
    uVar1 = uVar1 | 1;
  }
  if ((in_FPUControlWord & 2) != 0) {
    uVar1 = uVar1 | 0x80000;
  }
  uVar3 = in_FPUControlWord & 0xc00;
  if ((in_FPUControlWord & 0xc00) != 0) {
    if (uVar3 == 0x400) {
      uVar1 = uVar1 | 0x100;
    }
    else if (uVar3 == 0x800) {
      uVar1 = uVar1 | 0x200;
    }
    else if (uVar3 == 0xc00) {
      uVar1 = uVar1 | 0x300;
    }
  }
  if ((in_FPUControlWord & 0x300) == 0) {
    uVar1 = uVar1 | 0x20000;
  }
  else if ((in_FPUControlWord & 0x300) == 0x200) {
    uVar1 = uVar1 | 0x10000;
  }
  if ((in_FPUControlWord & 0x1000) != 0) {
    uVar1 = uVar1 | 0x40000;
  }
  uVar4 = ~param_2 & uVar1 | param_1 & param_2;
  if (uVar4 != uVar1) {
    uVar1 = __hw_cw(uVar4);
    uVar4 = 0;
    if ((uVar1 & 1) != 0) {
      uVar4 = 0x10;
    }
    if ((uVar1 & 4) != 0) {
      uVar4 = uVar4 | 8;
    }
    if ((uVar1 & 8) != 0) {
      uVar4 = uVar4 | 4;
    }
    if ((uVar1 & 0x10) != 0) {
      uVar4 = uVar4 | 2;
    }
    if ((uVar1 & 0x20) != 0) {
      uVar4 = uVar4 | 1;
    }
    if ((uVar1 & 2) != 0) {
      uVar4 = uVar4 | 0x80000;
    }
    uVar2 = uVar1 & 0xc00;
    if (uVar2 != 0) {
      if (uVar2 == 0x400) {
        uVar4 = uVar4 | 0x100;
      }
      else if (uVar2 == 0x800) {
        uVar4 = uVar4 | 0x200;
      }
      else if (uVar2 == 0xc00) {
        uVar4 = uVar4 | 0x300;
      }
    }
    if ((uVar1 & 0x300) == 0) {
      uVar4 = uVar4 | 0x20000;
    }
    else if ((uVar1 & 0x300) == 0x200) {
      uVar4 = uVar4 | 0x10000;
    }
    if ((uVar1 & 0x1000) != 0) {
      uVar4 = uVar4 | 0x40000;
    }
  }
  uVar1 = uVar4;
  if (0 < _DAT_10835b4c) {
    uVar2 = 0;
    if ((char)in_MXCSR < '\0') {
      uVar2 = 0x10;
    }
    if ((in_MXCSR & 0x200) != 0) {
      uVar2 = uVar2 | 8;
    }
    if ((in_MXCSR & 0x400) != 0) {
      uVar2 = uVar2 | 4;
    }
    if ((in_MXCSR & 0x800) != 0) {
      uVar2 = uVar2 | 2;
    }
    if ((in_MXCSR & 0x1000) != 0) {
      uVar2 = uVar2 | 1;
    }
    if ((in_MXCSR & 0x100) != 0) {
      uVar2 = uVar2 | 0x80000;
    }
    uVar1 = in_MXCSR & 0x6000;
    if (uVar1 != 0) {
      if (uVar1 == 0x2000) {
        uVar2 = uVar2 | 0x100;
      }
      else if (uVar1 == 0x4000) {
        uVar2 = uVar2 | 0x200;
      }
      else if (uVar1 == 0x6000) {
        uVar2 = uVar2 | 0x300;
      }
    }
    uVar1 = in_MXCSR & 0x8040;
    if (uVar1 == 0x40) {
      uVar2 = uVar2 | 0x2000000;
    }
    else if (uVar1 == 0x8000) {
      uVar2 = uVar2 | 0x3000000;
    }
    else if (uVar1 == 0x8040) {
      uVar2 = uVar2 | 0x1000000;
    }
    uVar1 = ~(param_2 & 0x308031f) & uVar2 | param_2 & 0x308031f & param_1;
    if (uVar1 != uVar2) {
      uVar1 = ___hw_cw_sse2(uVar1);
      ___set_fpsr_sse2(uVar1);
      uVar2 = 0;
      if ((char)in_MXCSR < '\0') {
        uVar2 = 0x10;
      }
      if ((in_MXCSR & 0x200) != 0) {
        uVar2 = uVar2 | 8;
      }
      if ((in_MXCSR & 0x400) != 0) {
        uVar2 = uVar2 | 4;
      }
      if ((in_MXCSR & 0x800) != 0) {
        uVar2 = uVar2 | 2;
      }
      if ((in_MXCSR & 0x1000) != 0) {
        uVar2 = uVar2 | 1;
      }
      if ((in_MXCSR & 0x100) != 0) {
        uVar2 = uVar2 | 0x80000;
      }
      uVar1 = in_MXCSR & 0x6000;
      if (uVar1 != 0) {
        if (uVar1 == 0x2000) {
          uVar2 = uVar2 | 0x100;
        }
        else if (uVar1 == 0x4000) {
          uVar2 = uVar2 | 0x200;
        }
        else if (uVar1 == 0x6000) {
          uVar2 = uVar2 | 0x300;
        }
      }
      uVar1 = in_MXCSR & 0x8040;
      if (uVar1 == 0x40) {
        uVar2 = uVar2 | 0x2000000;
      }
      else if (uVar1 == 0x8000) {
        uVar2 = uVar2 | 0x3000000;
      }
      else if (uVar1 == 0x8040) {
        uVar2 = uVar2 | 0x1000000;
      }
    }
    uVar1 = uVar2 | uVar4;
    if (((uVar2 ^ uVar4) & 0x8031f) != 0) {
      uVar1 = uVar1 | 0x80000000;
    }
  }
  return uVar1;
}



// Library Function - Single Match
//  __hw_cw
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2015 Release, Visual Studio 2019 Release

uint __cdecl __hw_cw(uint param_1)

{
  uint uVar1;
  uint uVar2;
  
  uVar1 = (uint)((param_1 & 0x10) != 0);
  if ((param_1 & 8) != 0) {
    uVar1 = uVar1 | 4;
  }
  if ((param_1 & 4) != 0) {
    uVar1 = uVar1 | 8;
  }
  if ((param_1 & 2) != 0) {
    uVar1 = uVar1 | 0x10;
  }
  if ((param_1 & 1) != 0) {
    uVar1 = uVar1 | 0x20;
  }
  if ((param_1 & 0x80000) != 0) {
    uVar1 = uVar1 | 2;
  }
  uVar2 = param_1 & 0x300;
  if (uVar2 != 0) {
    if (uVar2 == 0x100) {
      uVar1 = uVar1 | 0x400;
    }
    else if (uVar2 == 0x200) {
      uVar1 = uVar1 | 0x800;
    }
    else if (uVar2 == 0x300) {
      uVar1 = uVar1 | 0xc00;
    }
  }
  if ((param_1 & 0x30000) == 0) {
    uVar1 = uVar1 | 0x300;
  }
  else if ((param_1 & 0x30000) == 0x10000) {
    uVar1 = uVar1 | 0x200;
  }
  if ((param_1 & 0x40000) != 0) {
    uVar1 = uVar1 | 0x1000;
  }
  return uVar1;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address
// Library Function - Single Match
//  __87except
// 
// Library: Visual Studio 2019 Release

void __cdecl __87except(int param_1,int *param_2,ushort *param_3)

{
  bool bVar1;
  undefined3 extraout_var;
  int iVar2;
  undefined extraout_DL;
  undefined extraout_DL_00;
  undefined uVar3;
  uint uVar4;
  CVProfNode *this;
  undefined in_stack_ffffff68;
  uint local_94;
  uint local_90 [12];
  undefined8 local_60;
  uint local_50;
  uint local_14;
  
  local_14 = DAT_10046c24 ^ (uint)&stack0xfffffff0;
  local_94 = (uint)*param_3;
  iVar2 = *param_2;
  if (iVar2 == 1) {
LAB_10033fc0:
    uVar4 = 8;
  }
  else if (iVar2 == 2) {
    uVar4 = 4;
  }
  else if (iVar2 == 3) {
    uVar4 = 0x11;
  }
  else if (iVar2 == 4) {
    uVar4 = 0x12;
  }
  else {
    if (iVar2 == 5) goto LAB_10033fc0;
    if (iVar2 == 7) {
      *param_2 = 1;
      goto LAB_10034022;
    }
    if (iVar2 != 8) goto LAB_10034022;
    uVar4 = 0x10;
  }
  bVar1 = __handle_exc(uVar4,(double *)(param_2 + 6),local_94);
  if (CONCAT31(extraout_var,bVar1) == 0) {
    if (((param_1 == 0x10) || (param_1 == 0x16)) || (param_1 == 0x1d)) {
      local_60 = *(undefined8 *)(param_2 + 4);
      local_50 = local_50 & 0xffffffe3 | 3;
    }
    else {
      local_50 = local_50 & 0xfffffffe;
    }
    __raise_exc(local_90,&local_94,uVar4,param_1,(undefined8 *)(param_2 + 2),
                (undefined8 *)(param_2 + 6));
  }
LAB_10034022:
  this = (CVProfNode *)0xffff;
  __ctrlfp(local_94,0xffff);
  if (((*param_2 == 8) || (_DAT_10046c20 != 0)) ||
     (iVar2 = CVProfNode::GetPrevLoadHitStoreLessChildren(this), uVar3 = extraout_DL, iVar2 == 0)) {
    __set_errno_from_matherr(*param_2);
    uVar3 = extraout_DL_00;
  }
  FUN_1002534c(local_14 ^ (uint)&stack0xfffffff0,uVar3,in_stack_ffffff68);
  return;
}



undefined4 FUN_10034063(void)

{
  uint cbMultiByte;
  int iVar1;
  LPCWSTR *ppWVar2;
  uint *local_8;
  
  local_8 = (uint *)0x0;
  ppWVar2 = DAT_10835b70;
  while( true ) {
    if (*ppWVar2 == (LPCWSTR)0x0) {
      return 0;
    }
    cbMultiByte = WideCharToMultiByte(0,0,*ppWVar2,-1,(LPSTR)0x0,0,(LPCSTR)0x0,(LPBOOL)0x0);
    if ((cbMultiByte == 0) ||
       (local_8 = (uint *)FUN_10026edb(cbMultiByte,1), local_8 == (uint *)0x0)) break;
    iVar1 = WideCharToMultiByte(0,0,*ppWVar2,-1,(LPSTR)local_8,cbMultiByte,(LPCSTR)0x0,(LPBOOL)0x0);
    if (iVar1 == 0) {
      FID_conflict__free(local_8);
      return 0xffffffff;
    }
    iVar1 = FUN_10034511(&local_8,0);
    if ((iVar1 < 0) && (local_8 != (uint *)0x0)) {
      FID_conflict__free(local_8);
      local_8 = (uint *)0x0;
    }
    ppWVar2 = ppWVar2 + 1;
  }
  return 0xffffffff;
}



// Library Function - Single Match
//  __mbsnbicoll
// 
// Library: Visual Studio 2012 Release

int __cdecl __mbsnbicoll(uchar *_Str1,uchar *_Str2,size_t _MaxCount)

{
  int iVar1;
  
  iVar1 = FUN_1003410a(_Str1,_Str2,_MaxCount,(pthreadlocinfo *)0x0);
  return iVar1;
}



int __cdecl FUN_1003410a(byte *param_1,byte *param_2,uint param_3,pthreadlocinfo *param_4)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  pthreadlocinfo local_14;
  int local_10;
  int local_c;
  char local_8;
  
  FUN_1001f92e(&local_14,param_4);
  if (param_3 == 0) {
    iVar3 = 0;
  }
  else if ((param_1 == (byte *)0x0) || (param_2 == (byte *)0x0)) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    iVar3 = 0x7fffffff;
  }
  else {
    iVar3 = 0x7fffffff;
    if (param_3 < 0x80000000) {
      if (*(int *)(local_10 + 8) == 0) {
        iVar3 = FUN_10034814(param_1,param_2,param_3,param_4);
      }
      else {
        iVar2 = FUN_10034b7d(&local_14,*(wchar_t **)(local_10 + 0x21c),0x1001,param_1,param_3,
                             param_2,param_3,*(UINT *)(local_10 + 4));
        if (iVar2 != 0) {
          iVar3 = iVar2 + -2;
        }
      }
    }
    else {
      piVar1 = __errno();
      *piVar1 = 0x16;
      FUN_10025625();
    }
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return iVar3;
}



void FUN_100341c0(void)

{
  if ((DAT_10047b00 != (HANDLE)0xffffffff) && (DAT_10047b00 != (HANDLE)0xfffffffe)) {
    CloseHandle(DAT_10047b00);
  }
  return;
}



// Library Function - Single Match
//  ___dcrt_lowio_initialize_console_output
// 
// Libraries: Visual Studio 2015 Debug, Visual Studio 2015 Release

void ___dcrt_lowio_initialize_console_output(void)

{
  DAT_10047b00 = CreateFileW(L"CONOUT$",0x40000000,3,(LPSECURITY_ATTRIBUTES)0x0,3,0,(HANDLE)0x0);
  return;
}



int __cdecl FUN_100341f6(WCHAR *param_1,uint param_2,int param_3)

{
  int iVar1;
  HANDLE pvVar2;
  WCHAR *lpMem;
  int *piVar3;
  int iVar4;
  uint uVar5;
  ulong *puVar6;
  BOOL BVar7;
  uint uVar8;
  uint uVar9;
  bool bVar10;
  bool bVar11;
  longlong lVar12;
  longlong lVar13;
  DWORD DVar14;
  SIZE_T dwBytes;
  undefined4 local_1c;
  undefined4 local_18;
  uint local_c;
  int local_8;
  
  uVar8 = 0;
  local_c = 0;
  lVar12 = FUN_1002e5cb((uint)param_1,0,0,1);
  if (lVar12 == -1) goto LAB_1003427e;
  lVar13 = FUN_1002e5cb((uint)param_1,0,0,2);
  iVar4 = (int)((ulonglong)lVar13 >> 0x20);
  if (lVar13 == -1) goto LAB_1003427e;
  uVar9 = param_2 - (uint)lVar13;
  uVar5 = (uint)(param_2 < (uint)lVar13);
  iVar1 = param_3 - iVar4;
  local_8 = iVar1 - uVar5;
  if ((local_8 < 0) ||
     ((local_8 == 0 || (SBORROW4(param_3,iVar4) != SBORROW4(iVar1,uVar5)) != local_8 < 0 &&
      (uVar9 == 0)))) {
    if ((local_8 < 1) && ((local_8 < 0 || (false)))) {
      lVar13 = FUN_1002e5cb((uint)param_1,param_2,param_3,0);
      if (lVar13 == -1) goto LAB_1003427e;
      pvVar2 = (HANDLE)FUN_10024bbc((uint)param_1);
      BVar7 = SetEndOfFile(pvVar2);
      uVar8 = (BVar7 != 0) - 1;
      local_c = (int)uVar8 >> 0x1f;
      if ((uVar8 & local_c) == 0xffffffff) {
        piVar3 = __errno();
        *piVar3 = 0xd;
        puVar6 = ___doserrno();
        DVar14 = GetLastError();
        *puVar6 = DVar14;
        goto LAB_1003437d;
      }
    }
  }
  else {
    dwBytes = 0x1000;
    DVar14 = 8;
    pvVar2 = GetProcessHeap();
    lpMem = (WCHAR *)HeapAlloc(pvVar2,DVar14,dwBytes);
    if (lpMem == (WCHAR *)0x0) {
      piVar3 = __errno();
      *piVar3 = 0xc;
      goto LAB_1003427e;
    }
    iVar4 = __setmode_nolock((int)param_1,0x8000);
    while( true ) {
      uVar5 = uVar9;
      if ((-1 < local_8) && ((0 < local_8 || (0xfff < uVar9)))) {
        uVar5 = 0x1000;
      }
      uVar5 = FUN_1002e72d(param_1,lpMem,uVar5);
      if (uVar5 == 0xffffffff) break;
      bVar10 = uVar9 < uVar5;
      uVar9 = uVar9 - uVar5;
      bVar11 = SBORROW4(local_8,(int)uVar5 >> 0x1f);
      iVar1 = local_8 - ((int)uVar5 >> 0x1f);
      local_8 = iVar1 - (uint)bVar10;
      if ((local_8 < 0) ||
         ((local_8 == 0 || (bVar11 != SBORROW4(iVar1,(uint)bVar10)) != local_8 < 0 && (uVar9 == 0)))
         ) goto LAB_100342f8;
    }
    puVar6 = ___doserrno();
    if (*puVar6 == 5) {
      piVar3 = __errno();
      *piVar3 = 0xd;
    }
    uVar8 = 0xffffffff;
    local_c = 0xffffffff;
LAB_100342f8:
    __setmode_nolock((int)param_1,iVar4);
    DVar14 = 0;
    pvVar2 = GetProcessHeap();
    HeapFree(pvVar2,DVar14,lpMem);
LAB_1003437d:
    if ((uVar8 & local_c) == 0xffffffff) goto LAB_1003427e;
  }
  local_18 = (undefined4)((ulonglong)lVar12 >> 0x20);
  local_1c = (undefined4)lVar12;
  lVar12 = FUN_1002e5cb((uint)param_1,local_1c,local_18,0);
  if (lVar12 != -1) {
    return 0;
  }
LAB_1003427e:
  piVar3 = __errno();
  return *piVar3;
}



undefined4 __cdecl FUN_100343ac(undefined4 *param_1)

{
  int *piVar1;
  
  if (param_1 == (undefined4 *)0x0) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    return 0x16;
  }
  *param_1 = DAT_10836a30;
  return 0;
}



// Library Function - Single Match
//  __setmode_nolock
// 
// Library: Visual Studio 2012 Release

int __cdecl __setmode_nolock(int _FileHandle,int _Mode)

{
  byte *pbVar1;
  byte bVar2;
  char cVar3;
  byte bVar4;
  int iVar5;
  int iVar6;
  int iVar7;
  
  iVar6 = _FileHandle >> 5;
  iVar7 = (_FileHandle & 0x1fU) * 0x40;
  iVar5 = (&DAT_10835b98)[iVar6];
  bVar2 = *(byte *)(iVar5 + 4 + iVar7);
  cVar3 = *(char *)(iVar5 + 0x24 + iVar7);
  if (_Mode == 0x4000) {
    *(byte *)(iVar5 + 4 + iVar7) = bVar2 | 0x80;
    pbVar1 = (byte *)((&DAT_10835b98)[iVar6] + 0x24 + iVar7);
    *pbVar1 = *pbVar1 & 0x80;
  }
  else if (_Mode == 0x8000) {
    *(byte *)(iVar5 + 4 + iVar7) = bVar2 & 0x7f;
  }
  else {
    if ((_Mode == 0x10000) || (_Mode == 0x20000)) {
      *(byte *)(iVar5 + 4 + iVar7) = bVar2 | 0x80;
      iVar5 = (&DAT_10835b98)[iVar6];
      bVar4 = *(byte *)(iVar5 + 0x24 + iVar7) & 0x82 | 2;
    }
    else {
      if (_Mode != 0x40000) goto LAB_10034481;
      *(byte *)(iVar5 + 4 + iVar7) = bVar2 | 0x80;
      iVar5 = (&DAT_10835b98)[iVar6];
      bVar4 = *(byte *)(iVar5 + 0x24 + iVar7) & 0x81 | 1;
    }
    *(byte *)(iVar5 + 0x24 + iVar7) = bVar4;
  }
LAB_10034481:
  if ((bVar2 & 0x80) == 0) {
    return 0x8000;
  }
  return (-(uint)((char)(cVar3 * '\x02') >> 1 != '\0') & 0xc000) + 0x4000;
}



// Library Function - Single Match
//  ___ascii_strnicmp
// 
// Libraries: Visual Studio 2012 Release, Visual Studio 2017 Release, Visual Studio 2019 Release

int __cdecl ___ascii_strnicmp(char *_Str1,char *_Str2,size_t _MaxCount)

{
  byte bVar1;
  byte bVar2;
  bool bVar3;
  
  if (_MaxCount != 0) {
    do {
      bVar2 = *_Str1;
      bVar1 = *_Str2;
      if ((bVar2 == 0) || (bVar1 == 0)) break;
      _Str1 = (char *)((byte *)_Str1 + 1);
      _Str2 = (char *)((byte *)_Str2 + 1);
      if ((0x40 < bVar2) && (bVar2 < 0x5b)) {
        bVar2 = bVar2 + 0x20;
      }
      if ((0x40 < bVar1) && (bVar1 < 0x5b)) {
        bVar1 = bVar1 + 0x20;
      }
      bVar3 = bVar2 < bVar1;
      if (bVar2 != bVar1) goto LAB_10034501;
      _MaxCount = _MaxCount - 1;
    } while (_MaxCount != 0);
    _MaxCount = 0;
    bVar3 = bVar2 < bVar1;
    if (bVar2 != bVar1) {
LAB_10034501:
      _MaxCount = 0xffffffff;
      if (!bVar3) {
        _MaxCount = 1;
      }
    }
  }
  return _MaxCount;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

undefined4 __cdecl FUN_10034511(uint **param_1,int param_2)

{
  uint uVar1;
  uint *_Str;
  code *pcVar2;
  int *piVar3;
  uint *puVar4;
  int iVar5;
  uint uVar6;
  char **ppcVar7;
  size_t sVar8;
  char *_Dst;
  errno_t eVar9;
  BOOL BVar10;
  undefined4 uVar11;
  undefined *puVar12;
  bool bVar13;
  uint *_Src;
  undefined4 local_c;
  
  local_c = 0;
  if (param_1 == (uint **)0x0) {
    piVar3 = __errno();
    *piVar3 = 0x16;
    FUN_10025625();
    return 0xffffffff;
  }
  _Str = *param_1;
  if (((_Str == (uint *)0x0) || (puVar4 = (uint *)FUN_10034c10(_Str,0x3d), puVar4 == (uint *)0x0))
     || (_Str == puVar4)) {
LAB_1003459c:
    piVar3 = __errno();
    *piVar3 = 0x16;
    return 0xffffffff;
  }
  bVar13 = *(char *)((int)puVar4 + 1) == '\0';
  if (DAT_10835b6c == _DAT_10835b8c) {
    DAT_10835b6c = FUN_10034759(DAT_10835b6c);
  }
  if (DAT_10835b6c == (char **)0x0) {
    if ((param_2 == 0) || (DAT_10835b70 == (undefined4 *)0x0)) {
      if (bVar13) {
        return 0;
      }
      DAT_10835b6c = (char **)FUN_10026f23(4);
      if (DAT_10835b6c == (char **)0x0) {
        return 0xffffffff;
      }
      *DAT_10835b6c = (char *)0x0;
      if (DAT_10835b70 == (undefined4 *)0x0) {
        DAT_10835b70 = (undefined4 *)FUN_10026f23(4);
        if (DAT_10835b70 == (undefined4 *)0x0) {
          return 0xffffffff;
        }
        *DAT_10835b70 = 0;
      }
    }
    else {
      iVar5 = FUN_10034063();
      if (iVar5 != 0) goto LAB_1003459c;
    }
    if (DAT_10835b6c == (char **)0x0) {
      return 0xffffffff;
    }
  }
  ppcVar7 = DAT_10835b6c;
  uVar6 = _findenv((uchar *)_Str,(int)puVar4 - (int)_Str);
  if (((int)uVar6 < 0) || (*ppcVar7 == (char *)0x0)) {
    if (bVar13) {
      FID_conflict__free(_Str);
      *param_1 = (uint *)0x0;
      return 0;
    }
    if ((int)uVar6 < 0) {
      uVar6 = -uVar6;
    }
    uVar1 = uVar6 + 2;
    if ((int)uVar1 < (int)uVar6) {
      return 0xffffffff;
    }
    if (0x3ffffffe < uVar1) {
      return 0xffffffff;
    }
    ppcVar7 = (char **)FUN_10026fb4(DAT_10835b6c,4,uVar1);
    if (ppcVar7 == (char **)0x0) {
      return 0xffffffff;
    }
    ppcVar7[uVar6 + 1] = (char *)0x0;
    ppcVar7[uVar6] = (char *)_Str;
    *param_1 = (uint *)0x0;
  }
  else {
    FID_conflict__free(ppcVar7[uVar6]);
    if (!bVar13) {
      ppcVar7[uVar6] = (char *)_Str;
      *param_1 = (uint *)0x0;
      goto LAB_100346b0;
    }
    for (; ppcVar7[uVar6] != (char *)0x0; uVar6 = uVar6 + 1) {
      ppcVar7[uVar6] = ppcVar7[uVar6 + 1];
    }
    if ((0x3ffffffe < uVar6) ||
       (ppcVar7 = (char **)FUN_10026fb4(DAT_10835b6c,uVar6,4), ppcVar7 == (char **)0x0))
    goto LAB_100346b0;
  }
  DAT_10835b6c = ppcVar7;
LAB_100346b0:
  if (param_2 != 0) {
    uVar6 = 1;
    sVar8 = _strlen((char *)_Str);
    _Dst = (char *)FUN_10026edb(sVar8 + 2,uVar6);
    if (_Dst != (char *)0x0) {
      _Src = _Str;
      sVar8 = _strlen((char *)_Str);
      eVar9 = _strcpy_s(_Dst,sVar8 + 2,(char *)_Src);
      if (eVar9 != 0) {
        __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
        pcVar2 = (code *)swi(3);
        uVar11 = (*pcVar2)();
        return uVar11;
      }
      puVar12 = (undefined *)(((int)_Dst - (int)_Str) + (int)puVar4);
      *puVar12 = 0;
      BVar10 = SetEnvironmentVariableA(_Dst,(LPCSTR)(~-(uint)bVar13 & (uint)(puVar12 + 1)));
      if (BVar10 == 0) {
        local_c = 0xffffffff;
        piVar3 = __errno();
        *piVar3 = 0x2a;
      }
      FID_conflict__free(_Dst);
    }
  }
  if (bVar13) {
    FID_conflict__free(_Str);
    *param_1 = (uint *)0x0;
    return local_c;
  }
  return local_c;
}



char ** __cdecl FUN_10034759(char **param_1)

{
  char **ppcVar1;
  char *pcVar2;
  int iVar3;
  char **ppcVar4;
  
  iVar3 = 0;
  ppcVar1 = param_1;
  if (param_1 != (char **)0x0) {
    pcVar2 = *param_1;
    while (pcVar2 != (char *)0x0) {
      ppcVar1 = ppcVar1 + 1;
      iVar3 = iVar3 + 1;
      pcVar2 = *ppcVar1;
    }
    ppcVar1 = (char **)FUN_10026edb(iVar3 + 1,4);
    if (ppcVar1 == (char **)0x0) {
      __amsg_exit(9);
    }
    pcVar2 = *param_1;
    ppcVar4 = ppcVar1;
    if (pcVar2 != (char *)0x0) {
      do {
        pcVar2 = __strdup(pcVar2);
        *ppcVar4 = pcVar2;
        ppcVar4 = ppcVar4 + 1;
        pcVar2 = *(char **)(((int)param_1 - (int)ppcVar1) + (int)ppcVar4);
      } while (pcVar2 != (char *)0x0);
    }
    *ppcVar4 = (char *)0x0;
  }
  return ppcVar1;
}



// Library Function - Single Match
//  _findenv
// 
// Library: Visual Studio 2012 Release

int __cdecl _findenv(uchar *param_1,size_t param_2)

{
  uchar *_Str2;
  int iVar1;
  uchar **ppuVar2;
  
  _Str2 = *DAT_10835b6c;
  ppuVar2 = DAT_10835b6c;
  while( true ) {
    if (_Str2 == (uchar *)0x0) {
      return -((int)ppuVar2 - (int)DAT_10835b6c >> 2);
    }
    iVar1 = __mbsnbicoll(param_1,_Str2,param_2);
    if ((iVar1 == 0) && (((*ppuVar2)[param_2] == '=' || ((*ppuVar2)[param_2] == '\0')))) break;
    ppuVar2 = ppuVar2 + 1;
    _Str2 = *ppuVar2;
  }
  return (int)ppuVar2 - (int)DAT_10835b6c >> 2;
}



int __cdecl FUN_10034814(byte *param_1,byte *param_2,uint param_3,pthreadlocinfo *param_4)

{
  int *piVar1;
  int iVar2;
  int iVar3;
  pthreadlocinfo local_14 [2];
  int local_c;
  char local_8;
  
  FUN_1001f92e(local_14,param_4);
  if (param_3 == 0) {
    iVar3 = 0;
  }
  else if ((param_1 == (byte *)0x0) || (param_2 == (byte *)0x0)) {
    piVar1 = __errno();
    *piVar1 = 0x16;
    FUN_10025625();
    iVar3 = 0x7fffffff;
  }
  else {
    iVar3 = 0x7fffffff;
    if (param_3 < 0x80000000) {
      if (local_14[0]->locale_name[1] == (wchar_t *)0x0) {
        iVar3 = FUN_10033093((char *)param_1,param_2,param_3,local_14);
      }
      else {
        iVar2 = FUN_10034b7d(local_14,local_14[0]->locale_name[1],0x1001,param_1,param_3,param_2,
                             param_3,local_14[0]->lc_collate_cp);
        if (iVar2 == 0) {
          piVar1 = __errno();
          *piVar1 = 0x16;
        }
        else {
          iVar3 = iVar2 + -2;
        }
      }
    }
    else {
      piVar1 = __errno();
      *piVar1 = 0x16;
      FUN_10025625();
    }
  }
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return iVar3;
}



// WARNING: Function: __alloca_probe_16 replaced with injection: alloca_probe

void __cdecl
FUN_100348d9(int *param_1,wchar_t *param_2,DWORD param_3,byte *param_4,int param_5,byte *param_6,
            int param_7,UINT param_8)

{
  uint _Size;
  BOOL BVar1;
  BYTE *pBVar2;
  uint uVar3;
  int iVar4;
  uint uVar5;
  undefined4 *puVar6;
  byte in_DL;
  byte extraout_DL;
  byte extraout_DL_00;
  byte extraout_DL_01;
  byte extraout_DL_02;
  byte extraout_DL_03;
  uint extraout_EDX;
  undefined4 *lpWideCharStr;
  undefined4 *puVar7;
  undefined uVar8;
  _cpinfo local_1c;
  uint local_8;
  
  local_8 = DAT_10046c24 ^ (uint)&stack0xfffffffc;
  if (param_5 < 1) {
    if (-2 < param_5) goto LAB_10034919;
  }
  else {
    param_5 = ___strncnt((char *)param_4,param_5);
    in_DL = extraout_DL;
LAB_10034919:
    if (param_7 < 1) {
      if (param_7 < -1) goto LAB_10034932;
    }
    else {
      param_7 = ___strncnt((char *)param_6,param_7);
      in_DL = extraout_DL_00;
    }
    lpWideCharStr = (undefined4 *)0x0;
    if (param_8 == 0) {
      param_8 = *(UINT *)(*param_1 + 4);
    }
    if ((param_5 == 0) || (param_7 == 0)) {
      if (param_5 == param_7) {
LAB_10034965:
        uVar8 = SUB41(param_2,0);
        goto LAB_10034b49;
      }
      if (param_7 < 2) {
        if (param_5 < 2) {
          BVar1 = GetCPInfo(param_8,&local_1c);
          in_DL = (byte)extraout_EDX;
          if (BVar1 == 0) goto LAB_10034932;
          if (param_5 < 1) {
            if (param_7 < 1) goto LAB_100349f7;
            if (1 < local_1c.MaxCharSize) {
              pBVar2 = local_1c.LeadByte;
              uVar3 = extraout_EDX;
              while (local_1c.LeadByte[0] != 0) {
                in_DL = (byte)uVar3;
                if (pBVar2[1] == 0) break;
                in_DL = *param_6;
                uVar3 = (uint)in_DL;
                if ((*pBVar2 <= in_DL) && (in_DL <= pBVar2[1])) goto LAB_10034965;
                pBVar2 = pBVar2 + 2;
                local_1c.LeadByte[0] = *pBVar2;
              }
            }
            goto LAB_10034972;
          }
          if (1 < local_1c.MaxCharSize) {
            pBVar2 = local_1c.LeadByte;
            uVar3 = extraout_EDX;
            while (local_1c.LeadByte[0] != 0) {
              in_DL = (byte)uVar3;
              if (pBVar2[1] == 0) break;
              in_DL = *param_4;
              uVar3 = (uint)in_DL;
              if ((*pBVar2 <= in_DL) && (in_DL <= pBVar2[1])) goto LAB_10034965;
              pBVar2 = pBVar2 + 2;
              local_1c.LeadByte[0] = *pBVar2;
            }
          }
        }
        uVar8 = SUB41(param_2,0);
      }
      else {
LAB_10034972:
        uVar8 = SUB41(param_2,0);
      }
      goto LAB_10034b49;
    }
LAB_100349f7:
    uVar3 = MultiByteToWideChar(param_8,9,(LPCSTR)param_4,param_5,(LPWSTR)0x0,0);
    in_DL = extraout_DL_01;
    if (uVar3 != 0) {
      if (((0 < (int)uVar3) && (in_DL = (byte)(0xffffffe0 % uVar3), 1 < 0xffffffe0 / uVar3)) &&
         (uVar3 * 2 < uVar3 * 2 + 8)) {
        uVar5 = uVar3 * 2 + 8;
        if (uVar5 < 0x401) {
          puVar6 = (undefined4 *)&stack0xffffffc4;
          lpWideCharStr = (undefined4 *)&stack0xffffffc4;
          if (&stack0x00000000 != (undefined *)0x3c) {
LAB_10034a63:
            lpWideCharStr = puVar6 + 2;
          }
        }
        else {
          puVar6 = (undefined4 *)_malloc(uVar5);
          lpWideCharStr = puVar6;
          in_DL = extraout_DL_02;
          if (puVar6 != (undefined4 *)0x0) {
            *puVar6 = 0xdddd;
            goto LAB_10034a63;
          }
        }
      }
      if (lpWideCharStr != (undefined4 *)0x0) {
        iVar4 = MultiByteToWideChar(param_8,1,(LPCSTR)param_4,param_5,(LPWSTR)lpWideCharStr,uVar3);
        if ((iVar4 != 0) &&
           (uVar5 = MultiByteToWideChar(param_8,9,(LPCSTR)param_6,param_7,(LPWSTR)0x0,0), uVar5 != 0
           )) {
          if (((int)uVar5 < 1) || ((0xffffffe0 / uVar5 < 2 || (uVar5 * 2 + 8 <= uVar5 * 2)))) {
            puVar6 = (undefined4 *)0x0;
          }
          else {
            _Size = uVar5 * 2 + 8;
            if (_Size < 0x401) {
              puVar7 = (undefined4 *)&stack0xffffffc4;
              puVar6 = (undefined4 *)&stack0xffffffc4;
              if (&stack0x00000000 != (undefined *)0x3c) {
LAB_10034af7:
                puVar6 = puVar7 + 2;
              }
            }
            else {
              puVar6 = (undefined4 *)_malloc(_Size);
              if (puVar6 != (undefined4 *)0x0) {
                *puVar6 = 0xdddd;
                puVar7 = puVar6;
                goto LAB_10034af7;
              }
            }
          }
          if (puVar6 != (undefined4 *)0x0) {
            iVar4 = MultiByteToWideChar(param_8,1,(LPCSTR)param_6,param_7,(LPWSTR)puVar6,uVar5);
            if (iVar4 != 0) {
              FUN_1002f9ca(param_2,param_3,(PCNZWCH)lpWideCharStr,uVar3,(PCNZWCH)puVar6,uVar5);
            }
            FUN_10021ea8((int)puVar6);
          }
        }
        uVar8 = SUB41(param_2,0);
        FUN_10021ea8((int)lpWideCharStr);
        in_DL = extraout_DL_03;
        goto LAB_10034b49;
      }
    }
  }
LAB_10034932:
  uVar8 = SUB41(param_2,0);
LAB_10034b49:
  FUN_1002534c(local_8 ^ (uint)&stack0xfffffffc,in_DL,uVar8);
  return;
}



// Library Function - Single Match
//  ___strncnt
// 
// Library: Visual Studio 2019 Release

int __cdecl ___strncnt(char *param_1,int param_2)

{
  int iVar1;
  
  iVar1 = param_2;
  if (param_2 != 0) {
    do {
      iVar1 = iVar1 + -1;
      if (*param_1 == '\0') goto LAB_10034b78;
      param_1 = param_1 + 1;
    } while (iVar1 != 0);
  }
  iVar1 = iVar1 + -1;
LAB_10034b78:
  return (param_2 - iVar1) + -1;
}



void __cdecl
FUN_10034b7d(pthreadlocinfo *param_1,wchar_t *param_2,DWORD param_3,byte *param_4,int param_5,
            byte *param_6,int param_7,UINT param_8)

{
  int local_14 [2];
  int local_c;
  char local_8;
  
  FUN_1001f92e(local_14,param_1);
  FUN_100348d9(local_14,param_2,param_3,param_4,param_5,param_6,param_7,param_8);
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return;
}



// Library Function - Single Match
//  __strdup
// 
// Library: Visual Studio 2012 Release

char * __cdecl __strdup(char *_Src)

{
  code *pcVar1;
  size_t sVar2;
  char *pcVar3;
  errno_t eVar4;
  
  if (_Src == (char *)0x0) {
    return (char *)0x0;
  }
  sVar2 = _strlen(_Src);
  pcVar3 = (char *)_malloc(sVar2 + 1);
  if (pcVar3 == (char *)0x0) {
    pcVar3 = (char *)0x0;
  }
  else {
    eVar4 = _strcpy_s(pcVar3,sVar2 + 1,_Src);
    if (eVar4 != 0) {
      __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);
      pcVar1 = (code *)swi(3);
      pcVar3 = (char *)(*pcVar1)();
      return pcVar3;
    }
  }
  return pcVar3;
}



void __cdecl FUN_10034c10(uint *param_1,uint param_2)

{
  FUN_10034c25(param_1,param_2,(pthreadlocinfo *)0x0);
  return;
}



uint * __cdecl FUN_10034c25(uint *param_1,uint param_2,pthreadlocinfo *param_3)

{
  byte bVar1;
  byte bVar2;
  int *piVar3;
  uint *puVar4;
  uint uVar5;
  uint *puVar6;
  undefined local_14 [4];
  int local_10;
  int local_c;
  char local_8;
  
  FUN_1001f92e(local_14,param_3);
  if (param_1 == (uint *)0x0) {
    piVar3 = __errno();
    *piVar3 = 0x16;
    FUN_10025625();
    puVar4 = (uint *)0x0;
  }
  else if (*(int *)(local_10 + 8) == 0) {
    puVar4 = FUN_1002b8f0(param_1,(char)param_2);
  }
  else {
    while( true ) {
      bVar2 = *(byte *)param_1;
      uVar5 = (uint)bVar2;
      puVar4 = (uint *)0x0;
      if (bVar2 == 0) break;
      if ((*(byte *)(uVar5 + 0x19 + local_10) & 4) == 0) {
        puVar6 = param_1;
        if (param_2 == uVar5) break;
      }
      else {
        bVar1 = *(byte *)(uint *)((int)param_1 + 1);
        if ((bVar1 == 0) ||
           (puVar6 = (uint *)((int)param_1 + 1), puVar4 = param_1, param_2 == CONCAT11(bVar2,bVar1))
           ) goto LAB_10034cad;
      }
      param_1 = (uint *)((int)puVar6 + 1);
    }
    if (param_2 == uVar5) {
      puVar4 = param_1;
    }
  }
LAB_10034cad:
  if (local_8 != '\0') {
    *(uint *)(local_c + 0x70) = *(uint *)(local_c + 0x70) & 0xfffffffd;
  }
  return puVar4;
}



undefined4 * __thiscall FUN_10034cc2(void *this,exception *param_1)

{
  std::exception::exception((exception *)this,param_1);
  *(undefined ***)this = std::length_error::vftable;
  return (undefined4 *)this;
}



undefined4 * __thiscall FUN_10034cdd(void *this,exception *param_1)

{
  std::exception::exception((exception *)this,param_1);
  *(undefined ***)this = std::logic_error::vftable;
  return (undefined4 *)this;
}



undefined4 * __thiscall FUN_10034cf8(void *this,exception *param_1)

{
  std::exception::exception((exception *)this,param_1);
  *(undefined ***)this = std::out_of_range::vftable;
  return (undefined4 *)this;
}



undefined4 * __thiscall FUN_10034d18(void *this,byte param_1)

{
  FUN_100253cb((undefined4 *)this);
  if ((param_1 & 1) != 0) {
    FID_conflict__free(this);
  }
  return (undefined4 *)this;
}



void FUN_10034d37(void)

{
  code *pcVar1;
  undefined **local_14 [3];
  char *local_8;
  
  local_8 = "bad allocation";
  FUN_1002538d(local_14,&local_8);
  local_14[0] = std::bad_alloc::vftable;
  FUN_1002364d((int *)local_14,&DAT_1003fa94);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void FUN_10034d68(char *param_1)

{
  code *pcVar1;
  undefined **local_10 [3];
  
  std::exception::exception((exception *)local_10,&param_1);
  local_10[0] = std::length_error::vftable;
  FUN_1002364d((int *)local_10,&DAT_10040240);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



void FUN_10034d96(char *param_1)

{
  code *pcVar1;
  undefined **local_10 [3];
  
  std::exception::exception((exception *)local_10,&param_1);
  local_10[0] = std::out_of_range::vftable;
  FUN_1002364d((int *)local_10,&DAT_1004027c);
  pcVar1 = (code *)swi(3);
  (*pcVar1)();
  return;
}



int __cdecl FUN_10034dc4(int param_1)

{
  int *piVar1;
  int *piVar2;
  
  piVar2 = &DAT_1003ded8;
  if (true) {
    do {
      if (*piVar2 == param_1) {
        return piVar2[1];
      }
      piVar1 = piVar2 + 3;
      piVar2 = piVar2 + 2;
    } while (*piVar1 != 0);
  }
  return 0;
}



int __cdecl FUN_10034dee(int param_1)

{
  int *piVar1;
  int *piVar2;
  
  piVar2 = &DAT_1003dc80;
  if (true) {
    do {
      if (*piVar2 == param_1) {
        return piVar2[1];
      }
      piVar1 = piVar2 + 3;
      piVar2 = piVar2 + 2;
    } while (*piVar1 != 0);
  }
  return 0;
}



undefined4 __fastcall FUN_10034e18(undefined4 param_1)

{
  LPCRITICAL_SECTION p_Var1;
  
  LOCK();
  DAT_10047b10 = DAT_10047b10 + 1;
  if (DAT_10047b10 == 0) {
    p_Var1 = (LPCRITICAL_SECTION)&DAT_10836a48;
    do {
      FUN_10034ed3(p_Var1);
      p_Var1 = p_Var1 + 1;
    } while ((int)p_Var1 < 0x10836aa8);
  }
  return param_1;
}



// Library Function - Single Match
//  public: __thiscall std::_Lockit::_Lockit(int)
// 
// Library: Visual Studio 2012 Release

_Lockit * __thiscall std::_Lockit::_Lockit(_Lockit *this,int param_1)

{
  *(int *)this = param_1;
  if (param_1 == 0) {
    __lock(0xc);
  }
  else if (param_1 < 4) {
    __Mtxlock((_Rmtx *)(&DAT_10836a48 + param_1 * 0x18));
  }
  return this;
}



int FUN_10034e79(void)

{
  int iVar1;
  int iVar2;
  LPCRITICAL_SECTION p_Var3;
  
  LOCK();
  iVar1 = DAT_10047b10 + -1;
  iVar2 = DAT_10047b10;
  DAT_10047b10 = iVar1;
  if (iVar1 < 0) {
    p_Var3 = (LPCRITICAL_SECTION)&DAT_10836a48;
    do {
      iVar2 = FUN_10034ec5(p_Var3);
      p_Var3 = p_Var3 + 1;
    } while ((int)p_Var3 < 0x10836aa8);
  }
  return iVar2;
}



// Library Function - Single Match
//  public: __thiscall std::_Lockit::~_Lockit(void)
// 
// Library: Visual Studio 2012 Release

void __thiscall std::_Lockit::__Lockit(_Lockit *this)

{
  int iVar1;
  
  iVar1 = *(int *)this;
  if (iVar1 == 0) {
    FUN_1002f199(0xc);
    return;
  }
  if (iVar1 < 4) {
    __Mtxunlock((_Rmtx *)(&DAT_10836a48 + iVar1 * 0x18));
  }
  return;
}



void __cdecl FUN_10034ec5(LPCRITICAL_SECTION param_1)

{
  DeleteCriticalSection(param_1);
  return;
}



void __cdecl FUN_10034ed3(LPCRITICAL_SECTION param_1)

{
  FUN_1002bd5a(param_1,4000,0);
  return;
}



// Library Function - Single Match
//  __Mtxlock
// 
// Library: Visual Studio 2012 Release

void __cdecl __Mtxlock(_Rmtx *param_1)

{
  EnterCriticalSection(param_1);
  return;
}



// Library Function - Single Match
//  __Mtxunlock
// 
// Library: Visual Studio 2012 Release

void __cdecl __Mtxunlock(_Rmtx *param_1)

{
  LeaveCriticalSection(param_1);
  return;
}



void CallNtPowerInformation(void)

{
                    // WARNING: Could not recover jumptable at 0x10034f06. Too many branches
                    // WARNING: Treating indirect jump as call
  CallNtPowerInformation();
  return;
}



BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)

{
  BOOL BVar1;
  
                    // WARNING: Could not recover jumptable at 0x10034f0c. Too many branches
                    // WARNING: Treating indirect jump as call
  BVar1 = IsProcessorFeaturePresent(ProcessorFeature);
  return BVar1;
}



void RtlUnwind(PVOID TargetFrame,PVOID TargetIp,PEXCEPTION_RECORD ExceptionRecord,PVOID ReturnValue)

{
                    // WARNING: Could not recover jumptable at 0x10034f12. Too many branches
                    // WARNING: Treating indirect jump as call
  RtlUnwind(TargetFrame,TargetIp,ExceptionRecord,ReturnValue);
  return;
}



undefined4 __cdecl FUN_10034f18(LPCSTR param_1)

{
  int iVar1;
  undefined4 uVar2;
  LPCWSTR local_8;
  
  local_8 = (LPCWSTR)0x0;
  if ((param_1 == (LPCSTR)0x0) || (iVar1 = FUN_10026a0d(param_1,&local_8), iVar1 != 0)) {
    uVar2 = FUN_10034f63(local_8);
    FID_conflict__free(local_8);
  }
  else {
    uVar2 = 0xffffffff;
  }
  return uVar2;
}



undefined4 __cdecl FUN_10034f63(LPCWSTR param_1)

{
  BOOL BVar1;
  ulong uVar2;
  
  BVar1 = DeleteFileW(param_1);
  if (BVar1 == 0) {
    uVar2 = GetLastError();
  }
  else {
    uVar2 = 0;
  }
  if (uVar2 != 0) {
    FID_conflict___dosmaperr(uVar2);
    return 0xffffffff;
  }
  return 0;
}



void __cdecl FUN_10034fa0(_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4)

{
  FID_conflict____CxxFrameHandler3(param_1,param_2,param_3,param_4);
  return;
}



void __cdecl FUN_10034fb0(_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4)

{
  FID_conflict____CxxFrameHandler3(param_1,param_2,param_3,param_4);
  return;
}



void __cdecl FUN_10034fc0(_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4)

{
  FID_conflict____CxxFrameHandler3(param_1,param_2,param_3,param_4);
  return;
}



void __cdecl FUN_10034fd0(_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4)

{
  FID_conflict____CxxFrameHandler3(param_1,param_2,param_3,param_4);
  return;
}



void __cdecl FUN_10034fe0(_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4)

{
  FID_conflict____CxxFrameHandler3(param_1,param_2,param_3,param_4);
  return;
}



void __cdecl FUN_10034ff0(_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4)

{
  FID_conflict____CxxFrameHandler3(param_1,param_2,param_3,param_4);
  return;
}



void __cdecl FUN_10035000(_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4)

{
  FID_conflict____CxxFrameHandler3(param_1,param_2,param_3,param_4);
  return;
}



void __cdecl FUN_10035010(_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4)

{
  FID_conflict____CxxFrameHandler3(param_1,param_2,param_3,param_4);
  return;
}



void __cdecl FUN_10035020(_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4)

{
  FID_conflict____CxxFrameHandler3(param_1,param_2,param_3,param_4);
  return;
}



void __cdecl FUN_10035030(_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4)

{
  FID_conflict____CxxFrameHandler3(param_1,param_2,param_3,param_4);
  return;
}



void __cdecl FUN_10035040(_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4)

{
  FID_conflict____CxxFrameHandler3(param_1,param_2,param_3,param_4);
  return;
}



void __cdecl FUN_10035050(_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4)

{
  FID_conflict____CxxFrameHandler3(param_1,param_2,param_3,param_4);
  return;
}



void __cdecl FUN_10035060(_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4)

{
  FID_conflict____CxxFrameHandler3(param_1,param_2,param_3,param_4);
  return;
}



void __cdecl FUN_1003506a(_CONTEXT *param_1,undefined4 *param_2,_CONTEXT *param_3,void *param_4)

{
  undefined1 unaff_retaddr;
  
  FUN_1002534c(param_2[-5] ^ (uint)(param_2 + 3),(char)param_2,unaff_retaddr);
  FID_conflict____CxxFrameHandler3(param_1,param_2,param_3,param_4);
  return;
}



void FUN_10035090(void)

{
  FUN_10002730(&PTR_vftable_10046010);
  return;
}



void FUN_100350a0(void)

{
  CThreadMutex::_CThreadMutex((CThreadMutex *)&DAT_100480e0);
  return;
}



void __fastcall FUN_100350b0(CThreadSyncObject *param_1)

{
  void **_Memory;
  
  _Memory = DAT_10048208;
  if (DAT_10048208 != (void **)0x0) {
    CThreadSyncObject::AssertUseable(param_1);
    FreeLibrary((HMODULE)_Memory[2]);
    FID_conflict__free(*_Memory);
    if (_Memory[1] != (void *)0x0) {
      FUN_10007050(_Memory[1],1);
    }
    FID_conflict__free(_Memory);
  }
  return;
}



void FUN_10035100(void)

{
  FUN_10007c20(&DAT_100482f0);
  FUN_10007c20(&DAT_100482b8);
  FUN_10007c20(&DAT_10048210);
  FUN_10007c20(&DAT_10048280);
  FUN_10007c20(&DAT_10048248);
  return;
}



void FUN_10035140(void)

{
  GenericThreadLocals::CThreadLocalBase::_CThreadLocalBase((CThreadLocalBase *)&DAT_100483c8);
  return;
}



void FUN_10035150(void)

{
  DAT_100483b8 = 0;
  FID_conflict__free(DAT_1004f7ec);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_10035170(void)

{
  _DAT_1004fd80 = IMemAlloc::vftable;
  return;
}



ulonglong __fastcall FUN_10035180(undefined4 param_1,uint param_2)

{
  longlong *plVar1;
  int iVar2;
  ulonglong uVar3;
  
  iVar2 = 0x1bfff;
  plVar1 = (longlong *)&DAT_10592dc0;
  do {
    plVar1 = plVar1 + -3;
    uVar3 = FUN_1000c560(plVar1,param_2);
    param_2 = (uint)(uVar3 >> 0x20);
    iVar2 = iVar2 + -1;
  } while (-1 < iVar2);
  uVar3 = FUN_1000c560((longlong *)&DAT_102f2d90,param_2);
  return uVar3;
}



ulonglong __fastcall FUN_100351b0(undefined4 param_1,uint param_2)

{
  longlong *plVar1;
  int iVar2;
  ulonglong uVar3;
  
  iVar2 = 0x1bfff;
  plVar1 = (longlong *)&DAT_102f2d98;
  do {
    plVar1 = plVar1 + -3;
    uVar3 = FUN_1000c560(plVar1,param_2);
    param_2 = (uint)(uVar3 >> 0x20);
    iVar2 = iVar2 + -1;
  } while (-1 < iVar2);
  uVar3 = FUN_1000c560((longlong *)&DAT_10052d68,param_2);
  return uVar3;
}



ulonglong __fastcall FUN_100351e0(undefined4 param_1,uint param_2)

{
  longlong *plVar1;
  int iVar2;
  ulonglong uVar3;
  
  iVar2 = 0x1bfff;
  plVar1 = (longlong *)&DAT_10832de8;
  do {
    plVar1 = plVar1 + -3;
    uVar3 = FUN_1000c560(plVar1,param_2);
    param_2 = (uint)(uVar3 >> 0x20);
    iVar2 = iVar2 + -1;
  } while (-1 < iVar2);
  uVar3 = FUN_1000c560((longlong *)&DAT_10592db8,param_2);
  return uVar3;
}



void __fastcall FUN_10035210(undefined4 param_1,uint param_2)

{
  FUN_1000ad90(&DAT_10050148,param_2);
  return;
}



void FUN_10035220(void)

{
  CThreadMutex::_CThreadMutex((CThreadMutex *)&DAT_10052d30);
  return;
}



void FUN_10035230(void)

{
  CThreadSyncObject::AssertUseable((CThreadSyncObject *)&DAT_10833b60);
  return;
}



void FUN_10035240(void)

{
  GenericThreadLocals::CThreadLocalBase::_CThreadLocalBase((CThreadLocalBase *)&DAT_10833b5c);
  return;
}



void FUN_10035250(void)

{
  PTR_vftable_10046660 = (undefined *)std::error_category::vftable;
  return;
}



void FUN_10035260(void)

{
  PTR_vftable_10046664 = (undefined *)std::error_category::vftable;
  return;
}



void FUN_10035270(void)

{
  PTR_vftable_10046668 = (undefined *)std::error_category::vftable;
  return;
}



void FUN_10035280(void)

{
  GenericThreadLocals::CThreadLocalBase::_CThreadLocalBase((CThreadLocalBase *)&DAT_10833d10);
  return;
}



void FUN_10035290(void)

{
  (*(code *)PTR_FUN_1004668c)(DAT_10046674);
  if (DAT_10046678 != (HMODULE)0x0) {
    FreeLibrary(DAT_10046678);
  }
  if (DAT_1004667c != (void *)0x0) {
    FID_conflict__free(DAT_1004667c);
  }
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_100352c0(void)

{
  if (DAT_10833d24 != '\0') {
    if ((DAT_10833d25 != '\0') && (DAT_10833d20 != (HMODULE)0x0)) {
      FreeLibrary(DAT_10833d20);
    }
    DAT_10833d18 = 0;
    DAT_10833d20 = (HMODULE)0x0;
    DAT_10833d1c = 0;
    _DAT_10833d24 = 0;
  }
  return;
}



void FUN_10035310(void)

{
  DeleteCriticalSection((LPCRITICAL_SECTION)&DAT_10833d50);
  return;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_10035320(void)

{
  if (_g_nThreadID != 0xffffffff) {
    TlsFree(_g_nThreadID);
  }
  _g_nThreadID = 0xffffffff;
  return;
}



void FUN_10035340(void)

{
  if (DAT_10833d3c != 0xffffffff) {
    TlsFree(DAT_10833d3c);
  }
  DAT_10833d3c = 0xffffffff;
  return;
}



ulonglong __fastcall FUN_10035360(undefined4 param_1,uint param_2)

{
  ulonglong uVar1;
  
  uVar1 = FUN_1000c560((longlong *)&DAT_10833e30,param_2);
  return uVar1;
}



ulonglong __fastcall FUN_10035370(undefined4 param_1,uint param_2)

{
  int iVar1;
  undefined4 extraout_EDX;
  ulonglong uVar2;
  
  uVar2 = FUN_1000c560((longlong *)&DAT_10833e28,param_2);
  iVar1 = (int)uVar2;
  while( true ) {
    if (iVar1 == 0) break;
    iVar1 = *(int *)uVar2;
    (**(code **)(*(int *)g_pMemAlloc + 0x14))
              (*(undefined4 *)(((uint)(int *)uVar2 & 0xfffffffc) - 4));
    uVar2 = CONCAT44(extraout_EDX,iVar1);
  }
  uVar2 = FUN_1000c560((longlong *)&DAT_10833e28,(uint)(uVar2 >> 0x20));
  return uVar2;
}



ulonglong FUN_100353b0(void)

{
  uint extraout_EDX;
  uint uVar1;
  ulonglong uVar2;
  
  FUN_10016940((longlong *)&DAT_10833e48);
  uVar1 = DAT_10833e48;
  if (DAT_10833e48 != 0) {
    (**(code **)(*(int *)g_pMemAlloc + 0x14))(*(undefined4 *)((DAT_10833e48 & 0xfffffffc) - 4));
    uVar1 = extraout_EDX;
  }
  uVar2 = FUN_1000c560((longlong *)&DAT_10833e60,uVar1);
  return uVar2;
}



// WARNING: Globals starting with '_' overlap smaller symbols at the same address

void FUN_100353e0(void)

{
  undefined local_5;
  
  if (DAT_10833ef0 != (void *)0x0) {
    FUN_1000a3b0();
    FUN_10019190(&local_5);
    FID_conflict__free(DAT_10833ef0);
    DAT_10833ef0 = (void *)0x0;
    DAT_10833ef4 = 0;
    _DAT_10833ef8 = 0;
  }
  return;
}



void FUN_10035440(void)

{
  int **_Memory;
  bool bVar1;
  int *local_c;
  CThreadFullMutex local_5;
  
  FUN_1001b6d0(&DAT_10833ee8,&local_c,(int **)*DAT_10833ee8,DAT_10833ee8);
  _Memory = DAT_10833ee8;
  FUN_10019190(&local_5);
  bVar1 = SUB41(_Memory,0);
  CThreadFullMutex::SetTrace(&local_5,bVar1);
  FUN_10019190(&local_5);
  CThreadFullMutex::SetTrace(&local_5,(bool)(bVar1 + '\x04'));
  FUN_10019190(&local_5);
  CThreadFullMutex::SetTrace(&local_5,(bool)(bVar1 + '\b'));
  FUN_10019190(&local_5);
  FID_conflict__free(_Memory);
  return;
}



void FUN_100354c0(void)

{
  int **_Memory;
  bool bVar1;
  int *local_c;
  CThreadFullMutex local_5;
  
  FUN_1001b6d0(&DAT_108358d0,&local_c,(int **)*DAT_108358d0,DAT_108358d0);
  _Memory = DAT_108358d0;
  FUN_10019190(&local_5);
  bVar1 = SUB41(_Memory,0);
  CThreadFullMutex::SetTrace(&local_5,bVar1);
  FUN_10019190(&local_5);
  CThreadFullMutex::SetTrace(&local_5,(bool)(bVar1 + '\x04'));
  FUN_10019190(&local_5);
  CThreadFullMutex::SetTrace(&local_5,(bool)(bVar1 + '\b'));
  FUN_10019190(&local_5);
  FID_conflict__free(_Memory);
  return;
}



void FUN_10035540(void)

{
  CVProfile::Term((CVProfile *)&g_VProfCurrentProfile);
  FUN_10011330((int)&DAT_10834f38);
  return;
}



void FUN_10035554(void)

{
  FUN_10034e79();
  return;
}


